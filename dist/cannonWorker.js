(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
/* global AFRAME, THREE, CANNON */
if (typeof window !== "undefined")
  return

const cmd = require("./libs/cmdCodec")

global.CANNON = require("./libs/cannon")
global.world = new CANNON.World()
global.bodies = []
global.movingBodies = []
global.joints = []

let vec = new CANNON.Vec3()
let quat = new CANNON.Quaternion()
let cyloff = new CANNON.Quaternion()
let lastStep = 0

function init() {
  cyloff.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2)
  addEventListener("message", onMessage)
}

function onMessage(e) {
  if (typeof e.data === "string") {
    let command = cmd.parse(e.data)
    switch (command.shift()) {
      case "log":
        console.log(...command)
        break
      case "world":
        worldCommand(command)
        break
    }
  }
  else if (e.data instanceof Float64Array) {
    let buffer = e.data
    let now = Date.now()
    for (let mid = 0; mid < movingBodies.length; mid++) {
      let body = movingBodies[mid]
      let p = mid * 8
      if (!body) continue
      if (body.type === CANNON.Body.KINEMATIC) {
        vec.set(buffer[p++], buffer[p++], buffer[p++])
        body.position.copy(vec)
        buffer[p++] = body.sleepState === CANNON.Body.SLEEPING
        quat.set(buffer[p++], buffer[p++], buffer[p++], buffer[p++])
        body.quaternion.copy(quat)
      }
    }
    if (now - lastStep < 128) {
      world.step((now - lastStep) / 1000)
    }
    for (let mid = 0; mid < movingBodies.length; mid++) {
      let body = movingBodies[mid]
      let p = mid * 8
      if (!body) continue
      if (body.type !== CANNON.Body.KINEMATIC) {
        buffer[p++] = body.position.x
        buffer[p++] = body.position.y
        buffer[p++] = body.position.z
        buffer[p++] = body.sleepState === CANNON.Body.SLEEPING
        buffer[p++] = body.quaternion.x
        buffer[p++] = body.quaternion.y
        buffer[p++] = body.quaternion.z
        buffer[p++] = body.quaternion.w
      }
    }
    postMessage(buffer, [buffer.buffer])
    lastStep = now
  }
}

function worldCommand(params) {
  if (typeof params[0] === "number") {
    params.shift()
  }
  switch (params.shift()) {
    case "body":
      bodyCommand(params)
      break
    case "joint":
      jointCommand(params)
      break
    case "gravity":
      world.gravity.copy(params[0])
      break
    case "eval":
      eval(params[0])
      break
  }
}

function bodyCommand(params) {
  let id = params.shift()
  let body = bodies[id]
  if (!body && params[0] !== "create") return
  switch (params.shift()) {
    case "shape":
      shapeCommand(body, params)
      break
    case "create":
      if (body) {
        world.removeBody(body)
        if (body._mid_ !== null)
          movingBodies[body._mid_] = null
      }
      body = new CANNON.Body({
        type: params[0].type === "dynamic" ? CANNON.Body.DYNAMIC : params[0].type === "kinematic" ? CANNON.Body.KINEMATIC : CANNON.Body.STATIC,
        sleepSpeedLimit: 1,
        position: new CANNON.Vec3().copy(params[0].position),
        quaternion: new CANNON.Quaternion().copy(params[0].quaternion),
      })
      body._id_ = id
      body._mid_ = params[0].mid
      if (body._mid_ !== null)
        movingBodies[body._mid_] = body
      body._shapes_ = []
      world.addBody(bodies[id] = body)
      break
    case "remove":
      world.removeBody(body)
      bodies[id] = null
      if (body._mid_ !== null)
        movingBodies[body._mid_] = null
      break
    case "position":
      body.position.copy(params[0])
      break
    case "quaternion":
      body.quaternion.copy(params[0])
      break
    case "type":
      body.type = params[0] === "dynamic" ? CANNON.Body.DYNAMIC : params[0] === "kinematic" ? CANNON.Body.KINEMATIC : CANNON.Body.STATIC
      break
    case "mass":
      body.mass = body.type === CANNON.Body.STATIC ? 0 : params[0]
      body.updateMassProperties()
      break
    case "belongsTo":
      body.collisionFilterGroup = params[0]
      break
    case "collidesWith":
      body.collisionFilterMask = params[0]
      break
    case "emitsWith":
      if (params[0] && !body._emitsWith_) {
        body.addEventListener("collide", onCollide)
      }
      if (body._emitsWith_ && !params[0]) {
        body.removeEventListener("collide", onCollide)
      }
      body._emitsWith_ = params[0]
      break
    case "sleeping":
      if (params[0]) body.sleep()
      else body.wakeUp()
      break
    case "eval":
      eval("const body = bodies[" + id + "];" + params[0])
      break
  }
}

function jointCommand(params) {
  let id = params.shift()
  let joint = joints[id]
  if (!joint && params[0] !== "create") return
  switch (params.shift()) {
    case "create":
      if (joint) {
        world.removeConstraint(joint)
      }
      switch (params[0].type) {
        case "hinge":
          joint = new CANNON.HingeConstraint(
            bodies[params[0].body1],
            bodies[params[0].body2],
            {
              pivotA: new CANNON.Vec3().copy(params[0].pivot1),
              pivotB: new CANNON.Vec3().copy(params[0].pivot2),
              axisA: new CANNON.Vec3().copy(params[0].axis1),
              axisB: new CANNON.Vec3().copy(params[0].axis2)
            }
          )
          break
        case "distance":
          joint = new CANNON.DistanceConstraint(
            bodies[params[0].body1],
            bodies[params[0].body2]
          )
          break
        case "lock":
          joint = new CANNON.LockConstraint(
            bodies[params[0].body1],
            bodies[params[0].body2]
          )
          break
        default:
          joint = new CANNON.PointToPointConstraint(
            bodies[params[0].body1],
            new CANNON.Vec3().copy(params[0].pivot1),
            bodies[params[0].body2],
            new CANNON.Vec3().copy(params[0].pivot2)
          )
          break
      }
      joint.collideConnected = params[0].collision
      joint._id_ = id
      world.addConstraint(joints[id] = joint)
      break
    case "remove":
      world.removeConstraint(joint)
      joints[id] = null
      break
    case "eval":
      eval("const joint = joints[" + id + "];" + params[0])
      break
  }
}

function shapeCommand(body, params) {
  if (!body) return
  let id = params.shift()
  let shape = body._shapes_[id]
  if (!shape && params[0] !== "create") return
  switch (params.shift()) {
    case "create":
      if (shape)
        body.removeShape(shape)
      let quat = (new CANNON.Quaternion()).copy(params[0].quaternion)
      switch (params[0].type) {
        case "sphere": shape = new CANNON.Sphere(params[0].size.x / 2); break
        case "cylinder": shape = new CANNON.Cylinder(params[0].size.x / 2, params[0].size.x / 2, params[0].size.y, 16); quat.mult(cyloff, quat); break
        default: shape = new CANNON.Box(new CANNON.Vec3().copy(params[0].size).scale(0.5))
      }
      shape._id_ = id
      body.addShape(body._shapes_[id] = shape, (new CANNON.Vec3()).copy(params[0].position), quat)
      body.updateMassProperties()
      break
    case "remove":
      // body.removeShape(shape)
      let i = body.shapes.indexOf(shape)
      if (i >= 0) body.shapes.splice(i, 1)
      body._shapes_[id] = null
      body.updateMassProperties()
      break
    case "eval":
      eval("const body = bodies[" + body._id_ + "],shape = body._shapes_[" + id + "];" + params[0])
      break
  }
}




function onCollide(e) {
  let b1 = e.contact.bi
  let b2 = e.contact.bj
  if (this === b1 && (b1._emitsWith_ & b2.collisionFilterGroup)) {
    postMessage("world body " + b1._id_ + " emits " + cmd.stringifyParam({
      event: "collision",
      body1: b1._id_,
      body2: b2._id_,
      shape1: e.contact.si._id_,
      shape2: e.contact.sj._id_
    }))
  }
  if (this === b2 && (b2._emitsWith_ & b1.collisionFilterGroup)) {
    postMessage("world body " + b2._id_ + " emits " + cmd.stringifyParam({
      event: "collision",
      body1: b2._id_,
      body2: b1._id_,
      shape1: e.contact.sj._id_,
      shape2: e.contact.si._id_
    }))
  }
}
init()
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./libs/cannon":2,"./libs/cmdCodec":3}],2:[function(require,module,exports){
(function (global){(function (){
/*
 * Copyright (c) 2015 cannon.js Authors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

!function (e) { if ("object" == typeof exports && "undefined" != typeof module) module.exports = e(); else if ("function" == typeof define && false) define([], e); else { var f; "undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self), f.CANNON = e() } }(function () {
    var define, module, exports; return (function e(t, n, r) { function s(o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require == "function" && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); throw new Error("Cannot find module '" + o + "'") } var f = n[o] = { exports: {} }; t[o][0].call(f.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, f, f.exports, e, t, n, r) } return n[o].exports } var i = typeof require == "function" && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({
        1: [function (_dereq_, module, exports) {
            module.exports = {
                "name": "cannon",
                "version": "0.6.2",
                "description": "A lightweight 3D physics engine written in JavaScript.",
                "homepage": "https://github.com/schteppe/cannon.js",
                "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                "keywords": [
                    "cannon.js",
                    "cannon",
                    "physics",
                    "engine",
                    "3d"
                ],
                "main": "./build/cannon.js",
                "engines": {
                    "node": "*"
                },
                "repository": {
                    "type": "git",
                    "url": "https://github.com/schteppe/cannon.js.git"
                },
                "bugs": {
                    "url": "https://github.com/schteppe/cannon.js/issues"
                },
                "licenses": [
                    {
                        "type": "MIT"
                    }
                ],
                "devDependencies": {
                    "jshint": "latest",
                    "uglify-js": "latest",
                    "nodeunit": "^0.9.0",
                    "grunt": "~0.4.0",
                    "grunt-contrib-jshint": "~0.1.1",
                    "grunt-contrib-nodeunit": "^0.4.1",
                    "grunt-contrib-concat": "~0.1.3",
                    "grunt-contrib-uglify": "^0.5.1",
                    "grunt-browserify": "^2.1.4",
                    "grunt-contrib-yuidoc": "^0.5.2",
                    "browserify": "*"
                },
                "dependencies": {}
            }

        }, {}], 2: [function (_dereq_, module, exports) {
            // Export classes
            module.exports = {
                version: _dereq_('../package.json').version,

                AABB: _dereq_('./collision/AABB'),
                ArrayCollisionMatrix: _dereq_('./collision/ArrayCollisionMatrix'),
                Body: _dereq_('./objects/Body'),
                Box: _dereq_('./shapes/Box'),
                Broadphase: _dereq_('./collision/Broadphase'),
                Constraint: _dereq_('./constraints/Constraint'),
                ContactEquation: _dereq_('./equations/ContactEquation'),
                Narrowphase: _dereq_('./world/Narrowphase'),
                ConeTwistConstraint: _dereq_('./constraints/ConeTwistConstraint'),
                ContactMaterial: _dereq_('./material/ContactMaterial'),
                ConvexPolyhedron: _dereq_('./shapes/ConvexPolyhedron'),
                Cylinder: _dereq_('./shapes/Cylinder'),
                DistanceConstraint: _dereq_('./constraints/DistanceConstraint'),
                Equation: _dereq_('./equations/Equation'),
                EventTarget: _dereq_('./utils/EventTarget'),
                FrictionEquation: _dereq_('./equations/FrictionEquation'),
                GSSolver: _dereq_('./solver/GSSolver'),
                GridBroadphase: _dereq_('./collision/GridBroadphase'),
                Heightfield: _dereq_('./shapes/Heightfield'),
                HingeConstraint: _dereq_('./constraints/HingeConstraint'),
                LockConstraint: _dereq_('./constraints/LockConstraint'),
                Mat3: _dereq_('./math/Mat3'),
                Material: _dereq_('./material/Material'),
                NaiveBroadphase: _dereq_('./collision/NaiveBroadphase'),
                ObjectCollisionMatrix: _dereq_('./collision/ObjectCollisionMatrix'),
                Pool: _dereq_('./utils/Pool'),
                Particle: _dereq_('./shapes/Particle'),
                Plane: _dereq_('./shapes/Plane'),
                PointToPointConstraint: _dereq_('./constraints/PointToPointConstraint'),
                Quaternion: _dereq_('./math/Quaternion'),
                Ray: _dereq_('./collision/Ray'),
                RaycastVehicle: _dereq_('./objects/RaycastVehicle'),
                RaycastResult: _dereq_('./collision/RaycastResult'),
                RigidVehicle: _dereq_('./objects/RigidVehicle'),
                RotationalEquation: _dereq_('./equations/RotationalEquation'),
                RotationalMotorEquation: _dereq_('./equations/RotationalMotorEquation'),
                SAPBroadphase: _dereq_('./collision/SAPBroadphase'),
                SPHSystem: _dereq_('./objects/SPHSystem'),
                Shape: _dereq_('./shapes/Shape'),
                Solver: _dereq_('./solver/Solver'),
                Sphere: _dereq_('./shapes/Sphere'),
                SplitSolver: _dereq_('./solver/SplitSolver'),
                Spring: _dereq_('./objects/Spring'),
                Trimesh: _dereq_('./shapes/Trimesh'),
                Vec3: _dereq_('./math/Vec3'),
                Vec3Pool: _dereq_('./utils/Vec3Pool'),
                World: _dereq_('./world/World'),
            };

        }, { "../package.json": 1, "./collision/AABB": 3, "./collision/ArrayCollisionMatrix": 4, "./collision/Broadphase": 5, "./collision/GridBroadphase": 6, "./collision/NaiveBroadphase": 7, "./collision/ObjectCollisionMatrix": 8, "./collision/Ray": 9, "./collision/RaycastResult": 10, "./collision/SAPBroadphase": 11, "./constraints/ConeTwistConstraint": 12, "./constraints/Constraint": 13, "./constraints/DistanceConstraint": 14, "./constraints/HingeConstraint": 15, "./constraints/LockConstraint": 16, "./constraints/PointToPointConstraint": 17, "./equations/ContactEquation": 19, "./equations/Equation": 20, "./equations/FrictionEquation": 21, "./equations/RotationalEquation": 22, "./equations/RotationalMotorEquation": 23, "./material/ContactMaterial": 24, "./material/Material": 25, "./math/Mat3": 27, "./math/Quaternion": 28, "./math/Vec3": 30, "./objects/Body": 31, "./objects/RaycastVehicle": 32, "./objects/RigidVehicle": 33, "./objects/SPHSystem": 34, "./objects/Spring": 35, "./shapes/Box": 37, "./shapes/ConvexPolyhedron": 38, "./shapes/Cylinder": 39, "./shapes/Heightfield": 40, "./shapes/Particle": 41, "./shapes/Plane": 42, "./shapes/Shape": 43, "./shapes/Sphere": 44, "./shapes/Trimesh": 45, "./solver/GSSolver": 46, "./solver/Solver": 47, "./solver/SplitSolver": 48, "./utils/EventTarget": 49, "./utils/Pool": 51, "./utils/Vec3Pool": 54, "./world/Narrowphase": 55, "./world/World": 56 }], 3: [function (_dereq_, module, exports) {
            var Vec3 = _dereq_('../math/Vec3');
            var Utils = _dereq_('../utils/Utils');

            module.exports = AABB;

            /**
             * Axis aligned bounding box class.
             * @class AABB
             * @constructor
             * @param {Object} [options]
             * @param {Vec3}   [options.upperBound]
             * @param {Vec3}   [options.lowerBound]
             */
            function AABB(options) {
                options = options || {};

                /**
                 * The lower bound of the bounding box.
                 * @property lowerBound
                 * @type {Vec3}
                 */
                this.lowerBound = new Vec3();
                if (options.lowerBound) {
                    this.lowerBound.copy(options.lowerBound);
                }

                /**
                 * The upper bound of the bounding box.
                 * @property upperBound
                 * @type {Vec3}
                 */
                this.upperBound = new Vec3();
                if (options.upperBound) {
                    this.upperBound.copy(options.upperBound);
                }
            }

            var tmp = new Vec3();

            /**
             * Set the AABB bounds from a set of points.
             * @method setFromPoints
             * @param {Array} points An array of Vec3's.
             * @param {Vec3} position
             * @param {Quaternion} quaternion
             * @param {number} skinSize
             * @return {AABB} The self object
             */
            AABB.prototype.setFromPoints = function (points, position, quaternion, skinSize) {
                var l = this.lowerBound,
                    u = this.upperBound,
                    q = quaternion;

                // Set to the first point
                l.copy(points[0]);
                if (q) {
                    q.vmult(l, l);
                }
                u.copy(l);

                for (var i = 1; i < points.length; i++) {
                    var p = points[i];

                    if (q) {
                        q.vmult(p, tmp);
                        p = tmp;
                    }

                    if (p.x > u.x) { u.x = p.x; }
                    if (p.x < l.x) { l.x = p.x; }
                    if (p.y > u.y) { u.y = p.y; }
                    if (p.y < l.y) { l.y = p.y; }
                    if (p.z > u.z) { u.z = p.z; }
                    if (p.z < l.z) { l.z = p.z; }
                }

                // Add offset
                if (position) {
                    position.vadd(l, l);
                    position.vadd(u, u);
                }

                if (skinSize) {
                    l.x -= skinSize;
                    l.y -= skinSize;
                    l.z -= skinSize;
                    u.x += skinSize;
                    u.y += skinSize;
                    u.z += skinSize;
                }

                return this;
            };

            /**
             * Copy bounds from an AABB to this AABB
             * @method copy
             * @param  {AABB} aabb Source to copy from
             * @return {AABB} The this object, for chainability
             */
            AABB.prototype.copy = function (aabb) {
                this.lowerBound.copy(aabb.lowerBound);
                this.upperBound.copy(aabb.upperBound);
                return this;
            };

            /**
             * Clone an AABB
             * @method clone
             */
            AABB.prototype.clone = function () {
                return new AABB().copy(this);
            };

            /**
             * Extend this AABB so that it covers the given AABB too.
             * @method extend
             * @param  {AABB} aabb
             */
            AABB.prototype.extend = function (aabb) {
                // Extend lower bound
                var l = aabb.lowerBound.x;
                if (this.lowerBound.x > l) {
                    this.lowerBound.x = l;
                }

                // Upper
                var u = aabb.upperBound.x;
                if (this.upperBound.x < u) {
                    this.upperBound.x = u;
                }

                // Extend lower bound
                var l = aabb.lowerBound.y;
                if (this.lowerBound.y > l) {
                    this.lowerBound.y = l;
                }

                // Upper
                var u = aabb.upperBound.y;
                if (this.upperBound.y < u) {
                    this.upperBound.y = u;
                }

                // Extend lower bound
                var l = aabb.lowerBound.z;
                if (this.lowerBound.z > l) {
                    this.lowerBound.z = l;
                }

                // Upper
                var u = aabb.upperBound.z;
                if (this.upperBound.z < u) {
                    this.upperBound.z = u;
                }
            };

            /**
             * Returns true if the given AABB overlaps this AABB.
             * @method overlaps
             * @param  {AABB} aabb
             * @return {Boolean}
             */
            AABB.prototype.overlaps = function (aabb) {
                var l1 = this.lowerBound,
                    u1 = this.upperBound,
                    l2 = aabb.lowerBound,
                    u2 = aabb.upperBound;

                //      l2        u2
                //      |---------|
                // |--------|
                // l1       u1

                return ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x)) &&
                    ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y)) &&
                    ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));
            };

            /**
             * Returns true if the given AABB is fully contained in this AABB.
             * @method contains
             * @param {AABB} aabb
             * @return {Boolean}
             */
            AABB.prototype.contains = function (aabb) {
                var l1 = this.lowerBound,
                    u1 = this.upperBound,
                    l2 = aabb.lowerBound,
                    u2 = aabb.upperBound;

                //      l2        u2
                //      |---------|
                // |---------------|
                // l1              u1

                return (
                    (l1.x <= l2.x && u1.x >= u2.x) &&
                    (l1.y <= l2.y && u1.y >= u2.y) &&
                    (l1.z <= l2.z && u1.z >= u2.z)
                );
            };

            /**
             * @method getCorners
             * @param {Vec3} a
             * @param {Vec3} b
             * @param {Vec3} c
             * @param {Vec3} d
             * @param {Vec3} e
             * @param {Vec3} f
             * @param {Vec3} g
             * @param {Vec3} h
             */
            AABB.prototype.getCorners = function (a, b, c, d, e, f, g, h) {
                var l = this.lowerBound,
                    u = this.upperBound;

                a.copy(l);
                b.set(u.x, l.y, l.z);
                c.set(u.x, u.y, l.z);
                d.set(l.x, u.y, u.z);
                e.set(u.x, l.y, l.z);
                f.set(l.x, u.y, l.z);
                g.set(l.x, l.y, u.z);
                h.copy(u);
            };

            var transformIntoFrame_corners = [
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3()
            ];

            /**
             * Get the representation of an AABB in another frame.
             * @method toLocalFrame
             * @param  {Transform} frame
             * @param  {AABB} target
             * @return {AABB} The "target" AABB object.
             */
            AABB.prototype.toLocalFrame = function (frame, target) {

                var corners = transformIntoFrame_corners;
                var a = corners[0];
                var b = corners[1];
                var c = corners[2];
                var d = corners[3];
                var e = corners[4];
                var f = corners[5];
                var g = corners[6];
                var h = corners[7];

                // Get corners in current frame
                this.getCorners(a, b, c, d, e, f, g, h);

                // Transform them to new local frame
                for (var i = 0; i !== 8; i++) {
                    var corner = corners[i];
                    frame.pointToLocal(corner, corner);
                }

                return target.setFromPoints(corners);
            };

            /**
             * Get the representation of an AABB in the global frame.
             * @method toWorldFrame
             * @param  {Transform} frame
             * @param  {AABB} target
             * @return {AABB} The "target" AABB object.
             */
            AABB.prototype.toWorldFrame = function (frame, target) {

                var corners = transformIntoFrame_corners;
                var a = corners[0];
                var b = corners[1];
                var c = corners[2];
                var d = corners[3];
                var e = corners[4];
                var f = corners[5];
                var g = corners[6];
                var h = corners[7];

                // Get corners in current frame
                this.getCorners(a, b, c, d, e, f, g, h);

                // Transform them to new local frame
                for (var i = 0; i !== 8; i++) {
                    var corner = corners[i];
                    frame.pointToWorld(corner, corner);
                }

                return target.setFromPoints(corners);
            };

        }, { "../math/Vec3": 30, "../utils/Utils": 53 }], 4: [function (_dereq_, module, exports) {
            module.exports = ArrayCollisionMatrix;

            /**
             * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
             * @class ArrayCollisionMatrix
             * @constructor
             */
            function ArrayCollisionMatrix() {

                /**
                 * The matrix storage
                 * @property matrix
                 * @type {Array}
                 */
                this.matrix = [];
            }

            /**
             * Get an element
             * @method get
             * @param  {Number} i
             * @param  {Number} j
             * @return {Number}
             */
            ArrayCollisionMatrix.prototype.get = function (i, j) {
                i = i.index;
                j = j.index;
                if (j > i) {
                    var temp = j;
                    j = i;
                    i = temp;
                }
                return this.matrix[(i * (i + 1) >> 1) + j - 1];
            };

            /**
             * Set an element
             * @method set
             * @param {Number} i
             * @param {Number} j
             * @param {Number} value
             */
            ArrayCollisionMatrix.prototype.set = function (i, j, value) {
                i = i.index;
                j = j.index;
                if (j > i) {
                    var temp = j;
                    j = i;
                    i = temp;
                }
                this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
            };

            /**
             * Sets all elements to zero
             * @method reset
             */
            ArrayCollisionMatrix.prototype.reset = function () {
                for (var i = 0, l = this.matrix.length; i !== l; i++) {
                    this.matrix[i] = 0;
                }
            };

            /**
             * Sets the max number of objects
             * @method setNumObjects
             * @param {Number} n
             */
            ArrayCollisionMatrix.prototype.setNumObjects = function (n) {
                this.matrix.length = n * (n - 1) >> 1;
            };

        }, {}], 5: [function (_dereq_, module, exports) {
            var Body = _dereq_('../objects/Body');
            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Shape = _dereq_('../shapes/Shape');
            var Plane = _dereq_('../shapes/Plane');

            module.exports = Broadphase;

            /**
             * Base class for broadphase implementations
             * @class Broadphase
             * @constructor
             * @author schteppe
             */
            function Broadphase() {
                /**
                * The world to search for collisions in.
                * @property world
                * @type {World}
                */
                this.world = null;

                /**
                 * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
                 * @property useBoundingBoxes
                 * @type {Boolean}
                 */
                this.useBoundingBoxes = false;

                /**
                 * Set to true if the objects in the world moved.
                 * @property {Boolean} dirty
                 */
                this.dirty = true;
            }

            /**
             * Get the collision pairs from the world
             * @method collisionPairs
             * @param {World} world The world to search in
             * @param {Array} p1 Empty array to be filled with body objects
             * @param {Array} p2 Empty array to be filled with body objects
             */
            Broadphase.prototype.collisionPairs = function (world, p1, p2) {
                throw new Error("collisionPairs not implemented for this BroadPhase class!");
            };

            /**
             * Check if a body pair needs to be intersection tested at all.
             * @method needBroadphaseCollision
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @return {bool}
             */
            var Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;
            Broadphase.prototype.needBroadphaseCollision = function (bodyA, bodyB) {

                // Check collision filter masks
                if ((bodyA.collisionFilterGroup & bodyB.collisionFilterMask) === 0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask) === 0) {
                    return false;
                }

                // Check types
                if (((bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC) !== 0 || bodyA.sleepState === Body.SLEEPING) &&
                    ((bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC) !== 0 || bodyB.sleepState === Body.SLEEPING)) {
                    // Both bodies are static, kinematic or sleeping. Skip.
                    return false;
                }

                return true;
            };

            /**
             * Check if the bounding volumes of two bodies intersect.
             * @method intersectionTest
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {array} pairs1
             * @param {array} pairs2
              */
            Broadphase.prototype.intersectionTest = function (bodyA, bodyB, pairs1, pairs2) {
                if (this.useBoundingBoxes) {
                    this.doBoundingBoxBroadphase(bodyA, bodyB, pairs1, pairs2);
                } else {
                    this.doBoundingSphereBroadphase(bodyA, bodyB, pairs1, pairs2);
                }
            };

            /**
             * Check if the bounding spheres of two bodies are intersecting.
             * @method doBoundingSphereBroadphase
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {Array} pairs1 bodyA is appended to this array if intersection
             * @param {Array} pairs2 bodyB is appended to this array if intersection
             */
            var Broadphase_collisionPairs_r = new Vec3(), // Temp objects
                Broadphase_collisionPairs_normal = new Vec3(),
                Broadphase_collisionPairs_quat = new Quaternion(),
                Broadphase_collisionPairs_relpos = new Vec3();
            Broadphase.prototype.doBoundingSphereBroadphase = function (bodyA, bodyB, pairs1, pairs2) {
                var r = Broadphase_collisionPairs_r;
                bodyB.position.vsub(bodyA.position, r);
                var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
                var norm2 = r.norm2();
                if (norm2 < boundingRadiusSum2) {
                    pairs1.push(bodyA);
                    pairs2.push(bodyB);
                }
            };

            /**
             * Check if the bounding boxes of two bodies are intersecting.
             * @method doBoundingBoxBroadphase
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {Array} pairs1
             * @param {Array} pairs2
             */
            Broadphase.prototype.doBoundingBoxBroadphase = function (bodyA, bodyB, pairs1, pairs2) {
                if (bodyA.aabbNeedsUpdate) {
                    bodyA.computeAABB();
                }
                if (bodyB.aabbNeedsUpdate) {
                    bodyB.computeAABB();
                }

                // Check AABB / AABB
                if (bodyA.aabb.overlaps(bodyB.aabb)) {
                    pairs1.push(bodyA);
                    pairs2.push(bodyB);
                }
            };

            /**
             * Removes duplicate pairs from the pair arrays.
             * @method makePairsUnique
             * @param {Array} pairs1
             * @param {Array} pairs2
             */
            var Broadphase_makePairsUnique_temp = { keys: [] },
                Broadphase_makePairsUnique_p1 = [],
                Broadphase_makePairsUnique_p2 = [];
            Broadphase.prototype.makePairsUnique = function (pairs1, pairs2) {
                var t = Broadphase_makePairsUnique_temp,
                    p1 = Broadphase_makePairsUnique_p1,
                    p2 = Broadphase_makePairsUnique_p2,
                    N = pairs1.length;

                for (var i = 0; i !== N; i++) {
                    p1[i] = pairs1[i];
                    p2[i] = pairs2[i];
                }

                pairs1.length = 0;
                pairs2.length = 0;

                for (var i = 0; i !== N; i++) {
                    var id1 = p1[i].id,
                        id2 = p2[i].id;
                    var key = id1 < id2 ? id1 + "," + id2 : id2 + "," + id1;
                    t[key] = i;
                    t.keys.push(key);
                }

                for (var i = 0; i !== t.keys.length; i++) {
                    var key = t.keys.pop(),
                        pairIndex = t[key];
                    pairs1.push(p1[pairIndex]);
                    pairs2.push(p2[pairIndex]);
                    delete t[key];
                }
            };

            /**
             * To be implemented by subcasses
             * @method setWorld
             * @param {World} world
             */
            Broadphase.prototype.setWorld = function (world) {
            };

            /**
             * Check if the bounding spheres of two bodies overlap.
             * @method boundingSphereCheck
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @return {boolean}
             */
            var bsc_dist = new Vec3();
            Broadphase.boundingSphereCheck = function (bodyA, bodyB) {
                var dist = bsc_dist;
                bodyA.position.vsub(bodyB.position, dist);
                return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius, 2) > dist.norm2();
            };

            /**
             * Returns all the bodies within the AABB.
             * @method aabbQuery
             * @param  {World} world
             * @param  {AABB} aabb
             * @param  {array} result An array to store resulting bodies in.
             * @return {array}
             */
            Broadphase.prototype.aabbQuery = function (world, aabb, result) {
                console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
                return [];
            };
        }, { "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/Body": 31, "../shapes/Plane": 42, "../shapes/Shape": 43 }], 6: [function (_dereq_, module, exports) {
            module.exports = GridBroadphase;

            var Broadphase = _dereq_('./Broadphase');
            var Vec3 = _dereq_('../math/Vec3');
            var Shape = _dereq_('../shapes/Shape');

            /**
             * Axis aligned uniform grid broadphase.
             * @class GridBroadphase
             * @constructor
             * @extends Broadphase
             * @todo Needs support for more than just planes and spheres.
             * @param {Vec3} aabbMin
             * @param {Vec3} aabbMax
             * @param {Number} nx Number of boxes along x
             * @param {Number} ny Number of boxes along y
             * @param {Number} nz Number of boxes along z
             */
            function GridBroadphase(aabbMin, aabbMax, nx, ny, nz) {
                Broadphase.apply(this);
                this.nx = nx || 10;
                this.ny = ny || 10;
                this.nz = nz || 10;
                this.aabbMin = aabbMin || new Vec3(100, 100, 100);
                this.aabbMax = aabbMax || new Vec3(-100, -100, -100);
                var nbins = this.nx * this.ny * this.nz;
                if (nbins <= 0) {
                    throw "GridBroadphase: Each dimension's n must be >0";
                }
                this.bins = [];
                this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow
                this.bins.length = nbins;
                this.binLengths.length = nbins;
                for (var i = 0; i < nbins; i++) {
                    this.bins[i] = [];
                    this.binLengths[i] = 0;
                }
            }
            GridBroadphase.prototype = new Broadphase();
            GridBroadphase.prototype.constructor = GridBroadphase;

            /**
             * Get all the collision pairs in the physics world
             * @method collisionPairs
             * @param {World} world
             * @param {Array} pairs1
             * @param {Array} pairs2
             */
            var GridBroadphase_collisionPairs_d = new Vec3();
            var GridBroadphase_collisionPairs_binPos = new Vec3();
            GridBroadphase.prototype.collisionPairs = function (world, pairs1, pairs2) {
                var N = world.numObjects(),
                    bodies = world.bodies;

                var max = this.aabbMax,
                    min = this.aabbMin,
                    nx = this.nx,
                    ny = this.ny,
                    nz = this.nz;

                var xstep = ny * nz;
                var ystep = nz;
                var zstep = 1;

                var xmax = max.x,
                    ymax = max.y,
                    zmax = max.z,
                    xmin = min.x,
                    ymin = min.y,
                    zmin = min.z;

                var xmult = nx / (xmax - xmin),
                    ymult = ny / (ymax - ymin),
                    zmult = nz / (zmax - zmin);

                var binsizeX = (xmax - xmin) / nx,
                    binsizeY = (ymax - ymin) / ny,
                    binsizeZ = (zmax - zmin) / nz;

                var binRadius = Math.sqrt(binsizeX * binsizeX + binsizeY * binsizeY + binsizeZ * binsizeZ) * 0.5;

                var types = Shape.types;
                var SPHERE = types.SPHERE,
                    PLANE = types.PLANE,
                    BOX = types.BOX,
                    COMPOUND = types.COMPOUND,
                    CONVEXPOLYHEDRON = types.CONVEXPOLYHEDRON;

                var bins = this.bins,
                    binLengths = this.binLengths,
                    Nbins = this.bins.length;

                // Reset bins
                for (var i = 0; i !== Nbins; i++) {
                    binLengths[i] = 0;
                }

                var ceil = Math.ceil;
                var min = Math.min;
                var max = Math.max;

                function addBoxToBins(x0, y0, z0, x1, y1, z1, bi) {
                    var xoff0 = ((x0 - xmin) * xmult) | 0,
                        yoff0 = ((y0 - ymin) * ymult) | 0,
                        zoff0 = ((z0 - zmin) * zmult) | 0,
                        xoff1 = ceil((x1 - xmin) * xmult),
                        yoff1 = ceil((y1 - ymin) * ymult),
                        zoff1 = ceil((z1 - zmin) * zmult);

                    if (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }
                    if (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }
                    if (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }
                    if (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }
                    if (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }
                    if (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }

                    xoff0 *= xstep;
                    yoff0 *= ystep;
                    zoff0 *= zstep;
                    xoff1 *= xstep;
                    yoff1 *= ystep;
                    zoff1 *= zstep;

                    for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
                        for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
                            for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
                                var idx = xoff + yoff + zoff;
                                bins[idx][binLengths[idx]++] = bi;
                            }
                        }
                    }
                }

                // Put all bodies into the bins
                for (var i = 0; i !== N; i++) {
                    var bi = bodies[i];
                    var si = bi.shape;

                    switch (si.type) {
                        case SPHERE:
                            // Put in bin
                            // check if overlap with other bins
                            var x = bi.position.x,
                                y = bi.position.y,
                                z = bi.position.z;
                            var r = si.radius;

                            addBoxToBins(x - r, y - r, z - r, x + r, y + r, z + r, bi);
                            break;

                        case PLANE:
                            if (si.worldNormalNeedsUpdate) {
                                si.computeWorldNormal(bi.quaternion);
                            }
                            var planeNormal = si.worldNormal;

                            //Relative position from origin of plane object to the first bin
                            //Incremented as we iterate through the bins
                            var xreset = xmin + binsizeX * 0.5 - bi.position.x,
                                yreset = ymin + binsizeY * 0.5 - bi.position.y,
                                zreset = zmin + binsizeZ * 0.5 - bi.position.z;

                            var d = GridBroadphase_collisionPairs_d;
                            d.set(xreset, yreset, zreset);

                            for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
                                for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
                                    for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
                                        if (d.dot(planeNormal) < binRadius) {
                                            var idx = xoff + yoff + zoff;
                                            bins[idx][binLengths[idx]++] = bi;
                                        }
                                    }
                                }
                            }
                            break;

                        default:
                            if (bi.aabbNeedsUpdate) {
                                bi.computeAABB();
                            }

                            addBoxToBins(
                                bi.aabb.lowerBound.x,
                                bi.aabb.lowerBound.y,
                                bi.aabb.lowerBound.z,
                                bi.aabb.upperBound.x,
                                bi.aabb.upperBound.y,
                                bi.aabb.upperBound.z,
                                bi);
                            break;
                    }
                }

                // Check each bin
                for (var i = 0; i !== Nbins; i++) {
                    var binLength = binLengths[i];
                    //Skip bins with no potential collisions
                    if (binLength > 1) {
                        var bin = bins[i];

                        // Do N^2 broadphase inside
                        for (var xi = 0; xi !== binLength; xi++) {
                            var bi = bin[xi];
                            for (var yi = 0; yi !== xi; yi++) {
                                var bj = bin[yi];
                                if (this.needBroadphaseCollision(bi, bj)) {
                                    this.intersectionTest(bi, bj, pairs1, pairs2);
                                }
                            }
                        }
                    }
                }

                //	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
                //		console.log("layer "+zi);
                //		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
                //			var row = '';
                //			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
                //				var idx = xoff + yoff + zoff;
                //				row += ' ' + binLengths[idx];
                //			}
                //			console.log(row);
                //		}
                //	}

                this.makePairsUnique(pairs1, pairs2);
            };

        }, { "../math/Vec3": 30, "../shapes/Shape": 43, "./Broadphase": 5 }], 7: [function (_dereq_, module, exports) {
            module.exports = NaiveBroadphase;

            var Broadphase = _dereq_('./Broadphase');
            var AABB = _dereq_('./AABB');

            /**
             * Naive broadphase implementation, used in lack of better ones.
             * @class NaiveBroadphase
             * @constructor
             * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
             * @extends Broadphase
             */
            function NaiveBroadphase() {
                Broadphase.apply(this);
            }
            NaiveBroadphase.prototype = new Broadphase();
            NaiveBroadphase.prototype.constructor = NaiveBroadphase;

            /**
             * Get all the collision pairs in the physics world
             * @method collisionPairs
             * @param {World} world
             * @param {Array} pairs1
             * @param {Array} pairs2
             */
            NaiveBroadphase.prototype.collisionPairs = function (world, pairs1, pairs2) {
                var bodies = world.bodies,
                    n = bodies.length,
                    i, j, bi, bj;

                // Naive N^2 ftw!
                for (i = 0; i !== n; i++) {
                    for (j = 0; j !== i; j++) {

                        bi = bodies[i];
                        bj = bodies[j];

                        if (!this.needBroadphaseCollision(bi, bj)) {
                            continue;
                        }

                        this.intersectionTest(bi, bj, pairs1, pairs2);
                    }
                }
            };

            var tmpAABB = new AABB();

            /**
             * Returns all the bodies within an AABB.
             * @method aabbQuery
             * @param  {World} world
             * @param  {AABB} aabb
             * @param {array} result An array to store resulting bodies in.
             * @return {array}
             */
            NaiveBroadphase.prototype.aabbQuery = function (world, aabb, result) {
                result = result || [];

                for (var i = 0; i < world.bodies.length; i++) {
                    var b = world.bodies[i];

                    if (b.aabbNeedsUpdate) {
                        b.computeAABB();
                    }

                    // Ugly hack until Body gets aabb
                    if (b.aabb.overlaps(aabb)) {
                        result.push(b);
                    }
                }

                return result;
            };
        }, { "./AABB": 3, "./Broadphase": 5 }], 8: [function (_dereq_, module, exports) {
            module.exports = ObjectCollisionMatrix;

            /**
             * Records what objects are colliding with each other
             * @class ObjectCollisionMatrix
             * @constructor
             */
            function ObjectCollisionMatrix() {

                /**
                 * The matrix storage
                 * @property matrix
                 * @type {Object}
                 */
                this.matrix = {};
            }

            /**
             * @method get
             * @param  {Number} i
             * @param  {Number} j
             * @return {Number}
             */
            ObjectCollisionMatrix.prototype.get = function (i, j) {
                i = i.id;
                j = j.id;
                if (j > i) {
                    var temp = j;
                    j = i;
                    i = temp;
                }
                return i + '-' + j in this.matrix;
            };

            /**
             * @method set
             * @param  {Number} i
             * @param  {Number} j
             * @param {Number} value
             */
            ObjectCollisionMatrix.prototype.set = function (i, j, value) {
                i = i.id;
                j = j.id;
                if (j > i) {
                    var temp = j;
                    j = i;
                    i = temp;
                }
                if (value) {
                    this.matrix[i + '-' + j] = true;
                }
                else {
                    delete this.matrix[i + '-' + j];
                }
            };

            /**
             * Empty the matrix
             * @method reset
             */
            ObjectCollisionMatrix.prototype.reset = function () {
                this.matrix = {};
            };

            /**
             * Set max number of objects
             * @method setNumObjects
             * @param {Number} n
             */
            ObjectCollisionMatrix.prototype.setNumObjects = function (n) {
            };

        }, {}], 9: [function (_dereq_, module, exports) {
            module.exports = Ray;

            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Transform = _dereq_('../math/Transform');
            var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
            var Box = _dereq_('../shapes/Box');
            var RaycastResult = _dereq_('../collision/RaycastResult');
            var Shape = _dereq_('../shapes/Shape');
            var AABB = _dereq_('../collision/AABB');

            /**
             * A line in 3D space that intersects bodies and return points.
             * @class Ray
             * @constructor
             * @param {Vec3} from
             * @param {Vec3} to
             */
            function Ray(from, to) {
                /**
                 * @property {Vec3} from
                 */
                this.from = from ? from.clone() : new Vec3();

                /**
                 * @property {Vec3} to
                 */
                this.to = to ? to.clone() : new Vec3();

                /**
                 * @private
                 * @property {Vec3} _direction
                 */
                this._direction = new Vec3();

                /**
                 * The precision of the ray. Used when checking parallelity etc.
                 * @property {Number} precision
                 */
                this.precision = 0.0001;

                /**
                 * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
                 * @property {Boolean} checkCollisionResponse
                 */
                this.checkCollisionResponse = true;

                /**
                 * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
                 * @property {Boolean} skipBackfaces
                 */
                this.skipBackfaces = false;

                /**
                 * @property {number} collisionFilterMask
                 * @default -1
                 */
                this.collisionFilterMask = -1;

                /**
                 * @property {number} collisionFilterGroup
                 * @default -1
                 */
                this.collisionFilterGroup = -1;

                /**
                 * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
                 * @property {number} mode
                 */
                this.mode = Ray.ANY;

                /**
                 * Current result object.
                 * @property {RaycastResult} result
                 */
                this.result = new RaycastResult();

                /**
                 * Will be set to true during intersectWorld() if the ray hit anything.
                 * @property {Boolean} hasHit
                 */
                this.hasHit = false;

                /**
                 * Current, user-provided result callback. Will be used if mode is Ray.ALL.
                 * @property {Function} callback
                 */
                this.callback = function (result) { };
            }
            Ray.prototype.constructor = Ray;

            Ray.CLOSEST = 1;
            Ray.ANY = 2;
            Ray.ALL = 4;

            var tmpAABB = new AABB();
            var tmpArray = [];

            /**
             * Do itersection against all bodies in the given World.
             * @method intersectWorld
             * @param  {World} world
             * @param  {object} options
             * @return {Boolean} True if the ray hit anything, otherwise false.
             */
            Ray.prototype.intersectWorld = function (world, options) {
                this.mode = options.mode || Ray.ANY;
                this.result = options.result || new RaycastResult();
                this.skipBackfaces = !!options.skipBackfaces;
                this.collisionFilterMask = typeof (options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;
                this.collisionFilterGroup = typeof (options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;
                if (options.from) {
                    this.from.copy(options.from);
                }
                if (options.to) {
                    this.to.copy(options.to);
                }
                this.callback = options.callback || function () { };
                this.hasHit = false;

                this.result.reset();
                this._updateDirection();

                this.getAABB(tmpAABB);
                tmpArray.length = 0;
                world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
                this.intersectBodies(tmpArray);

                return this.hasHit;
            };

            var v1 = new Vec3(),
                v2 = new Vec3();

            /*
             * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
             */
            Ray.pointInTriangle = pointInTriangle;
            function pointInTriangle(p, a, b, c) {
                c.vsub(a, v0);
                b.vsub(a, v1);
                p.vsub(a, v2);

                var dot00 = v0.dot(v0);
                var dot01 = v0.dot(v1);
                var dot02 = v0.dot(v2);
                var dot11 = v1.dot(v1);
                var dot12 = v1.dot(v2);

                var u, v;

                return ((u = dot11 * dot02 - dot01 * dot12) >= 0) &&
                    ((v = dot00 * dot12 - dot01 * dot02) >= 0) &&
                    (u + v < (dot00 * dot11 - dot01 * dot01));
            }

            /**
             * Shoot a ray at a body, get back information about the hit.
             * @method intersectBody
             * @private
             * @param {Body} body
             * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
             */
            var intersectBody_xi = new Vec3();
            var intersectBody_qi = new Quaternion();
            Ray.prototype.intersectBody = function (body, result) {
                if (result) {
                    this.result = result;
                    this._updateDirection();
                }
                var checkCollisionResponse = this.checkCollisionResponse;

                if (checkCollisionResponse && !body.collisionResponse) {
                    return;
                }

                if ((this.collisionFilterGroup & body.collisionFilterMask) === 0 || (body.collisionFilterGroup & this.collisionFilterMask) === 0) {
                    return;
                }

                var xi = intersectBody_xi;
                var qi = intersectBody_qi;

                for (var i = 0, N = body.shapes.length; i < N; i++) {
                    var shape = body.shapes[i];

                    if (checkCollisionResponse && !shape.collisionResponse) {
                        continue; // Skip
                    }

                    body.quaternion.mult(body.shapeOrientations[i], qi);
                    body.quaternion.vmult(body.shapeOffsets[i], xi);
                    xi.vadd(body.position, xi);

                    this.intersectShape(
                        shape,
                        qi,
                        xi,
                        body
                    );

                    if (this.result._shouldStop) {
                        break;
                    }
                }
            };

            /**
             * @method intersectBodies
             * @param {Array} bodies An array of Body objects.
             * @param {RaycastResult} [result] Deprecated
             */
            Ray.prototype.intersectBodies = function (bodies, result) {
                if (result) {
                    this.result = result;
                    this._updateDirection();
                }

                for (var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i++) {
                    this.intersectBody(bodies[i]);
                }
            };

            /**
             * Updates the _direction vector.
             * @private
             * @method _updateDirection
             */
            Ray.prototype._updateDirection = function () {
                this.to.vsub(this.from, this._direction);
                this._direction.normalize();
            };

            /**
             * @method intersectShape
             * @private
             * @param {Shape} shape
             * @param {Quaternion} quat
             * @param {Vec3} position
             * @param {Body} body
             */
            Ray.prototype.intersectShape = function (shape, quat, position, body) {
                var from = this.from;


                // Checking boundingSphere
                var distance = distanceFromIntersection(from, this._direction, position);
                if (distance > shape.boundingSphereRadius) {
                    return;
                }

                var intersectMethod = this[shape.type];
                if (intersectMethod) {
                    intersectMethod.call(this, shape, quat, position, body);
                }
            };

            var vector = new Vec3();
            var normal = new Vec3();
            var intersectPoint = new Vec3();

            var a = new Vec3();
            var b = new Vec3();
            var c = new Vec3();
            var d = new Vec3();

            var tmpRaycastResult = new RaycastResult();

            /**
             * @method intersectBox
             * @private
             * @param  {Shape} shape
             * @param  {Quaternion} quat
             * @param  {Vec3} position
             * @param  {Body} body
             */
            Ray.prototype.intersectBox = function (shape, quat, position, body) {
                return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body);
            };
            Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;

            /**
             * @method intersectPlane
             * @private
             * @param  {Shape} shape
             * @param  {Quaternion} quat
             * @param  {Vec3} position
             * @param  {Body} body
             */
            Ray.prototype.intersectPlane = function (shape, quat, position, body) {
                var from = this.from;
                var to = this.to;
                var direction = this._direction;

                // Get plane normal
                var worldNormal = new Vec3(0, 0, 1);
                quat.vmult(worldNormal, worldNormal);

                var len = new Vec3();
                from.vsub(position, len);
                var planeToFrom = len.dot(worldNormal);
                to.vsub(position, len);
                var planeToTo = len.dot(worldNormal);

                if (planeToFrom * planeToTo > 0) {
                    // "from" and "to" are on the same side of the plane... bail out
                    return;
                }

                if (from.distanceTo(to) < planeToFrom) {
                    return;
                }

                var n_dot_dir = worldNormal.dot(direction);

                if (Math.abs(n_dot_dir) < this.precision) {
                    // No intersection
                    return;
                }

                var planePointToFrom = new Vec3();
                var dir_scaled_with_t = new Vec3();
                var hitPointWorld = new Vec3();

                from.vsub(position, planePointToFrom);
                var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
                direction.scale(t, dir_scaled_with_t);
                from.vadd(dir_scaled_with_t, hitPointWorld);

                this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
            };
            Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;

            /**
             * Get the world AABB of the ray.
             * @method getAABB
             * @param  {AABB} aabb
             */
            Ray.prototype.getAABB = function (result) {
                var to = this.to;
                var from = this.from;
                result.lowerBound.x = Math.min(to.x, from.x);
                result.lowerBound.y = Math.min(to.y, from.y);
                result.lowerBound.z = Math.min(to.z, from.z);
                result.upperBound.x = Math.max(to.x, from.x);
                result.upperBound.y = Math.max(to.y, from.y);
                result.upperBound.z = Math.max(to.z, from.z);
            };

            var intersectConvexOptions = {
                faceList: [0]
            };

            /**
             * @method intersectHeightfield
             * @private
             * @param  {Shape} shape
             * @param  {Quaternion} quat
             * @param  {Vec3} position
             * @param  {Body} body
             */
            Ray.prototype.intersectHeightfield = function (shape, quat, position, body) {
                var data = shape.data,
                    w = shape.elementSize,
                    worldPillarOffset = new Vec3();

                // Convert the ray to local heightfield coordinates
                var localRay = new Ray(this.from, this.to);
                Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
                Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);

                // Get the index of the data points to test against
                var index = [];
                var iMinX = null;
                var iMinY = null;
                var iMaxX = null;
                var iMaxY = null;

                var inside = shape.getIndexOfPosition(localRay.from.x, localRay.from.y, index, false);
                if (inside) {
                    iMinX = index[0];
                    iMinY = index[1];
                    iMaxX = index[0];
                    iMaxY = index[1];
                }
                inside = shape.getIndexOfPosition(localRay.to.x, localRay.to.y, index, false);
                if (inside) {
                    if (iMinX === null || index[0] < iMinX) { iMinX = index[0]; }
                    if (iMaxX === null || index[0] > iMaxX) { iMaxX = index[0]; }
                    if (iMinY === null || index[1] < iMinY) { iMinY = index[1]; }
                    if (iMaxY === null || index[1] > iMaxY) { iMaxY = index[1]; }
                }

                if (iMinX === null) {
                    return;
                }

                var minMax = [];
                shape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
                var min = minMax[0];
                var max = minMax[1];

                // // Bail out if the ray can't touch the bounding box
                // // TODO
                // var aabb = new AABB();
                // this.getAABB(aabb);
                // if(aabb.intersects()){
                //     return;
                // }

                for (var i = iMinX; i <= iMaxX; i++) {
                    for (var j = iMinY; j <= iMaxY; j++) {

                        if (this.result._shouldStop) {
                            return;
                        }

                        // Lower triangle
                        shape.getConvexTrianglePillar(i, j, false);
                        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
                        this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);

                        if (this.result._shouldStop) {
                            return;
                        }

                        // Upper triangle
                        shape.getConvexTrianglePillar(i, j, true);
                        Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
                        this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);
                    }
                }
            };
            Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;

            var Ray_intersectSphere_intersectionPoint = new Vec3();
            var Ray_intersectSphere_normal = new Vec3();

            /**
             * @method intersectSphere
             * @private
             * @param  {Shape} shape
             * @param  {Quaternion} quat
             * @param  {Vec3} position
             * @param  {Body} body
             */
            Ray.prototype.intersectSphere = function (shape, quat, position, body) {
                var from = this.from,
                    to = this.to,
                    r = shape.radius;

                var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
                var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
                var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);

                var delta = Math.pow(b, 2) - 4 * a * c;

                var intersectionPoint = Ray_intersectSphere_intersectionPoint;
                var normal = Ray_intersectSphere_normal;

                if (delta < 0) {
                    // No intersection
                    return;

                } else if (delta === 0) {
                    // single intersection point
                    from.lerp(to, delta, intersectionPoint);

                    intersectionPoint.vsub(position, normal);
                    normal.normalize();

                    this.reportIntersection(normal, intersectionPoint, shape, body, -1);

                } else {
                    var d1 = (- b - Math.sqrt(delta)) / (2 * a);
                    var d2 = (- b + Math.sqrt(delta)) / (2 * a);

                    if (d1 >= 0 && d1 <= 1) {
                        from.lerp(to, d1, intersectionPoint);
                        intersectionPoint.vsub(position, normal);
                        normal.normalize();
                        this.reportIntersection(normal, intersectionPoint, shape, body, -1);
                    }

                    if (this.result._shouldStop) {
                        return;
                    }

                    if (d2 >= 0 && d2 <= 1) {
                        from.lerp(to, d2, intersectionPoint);
                        intersectionPoint.vsub(position, normal);
                        normal.normalize();
                        this.reportIntersection(normal, intersectionPoint, shape, body, -1);
                    }
                }
            };
            Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;


            var intersectConvex_normal = new Vec3();
            var intersectConvex_minDistNormal = new Vec3();
            var intersectConvex_minDistIntersect = new Vec3();
            var intersectConvex_vector = new Vec3();

            /**
             * @method intersectConvex
             * @private
             * @param  {Shape} shape
             * @param  {Quaternion} quat
             * @param  {Vec3} position
             * @param  {Body} body
             * @param {object} [options]
             * @param {array} [options.faceList]
             */
            Ray.prototype.intersectConvex = function intersectConvex(
                shape,
                quat,
                position,
                body,
                options
            ) {
                var minDistNormal = intersectConvex_minDistNormal;
                var normal = intersectConvex_normal;
                var vector = intersectConvex_vector;
                var minDistIntersect = intersectConvex_minDistIntersect;
                var faceList = (options && options.faceList) || null;

                // Checking faces
                var faces = shape.faces,
                    vertices = shape.vertices,
                    normals = shape.faceNormals;
                var direction = this._direction;

                var from = this.from;
                var to = this.to;
                var fromToDistance = from.distanceTo(to);

                var minDist = -1;
                var Nfaces = faceList ? faceList.length : faces.length;
                var result = this.result;

                for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
                    var fi = faceList ? faceList[j] : j;

                    var face = faces[fi];
                    var faceNormal = normals[fi];
                    var q = quat;
                    var x = position;

                    // determine if ray intersects the plane of the face
                    // note: this works regardless of the direction of the face normal

                    // Get plane point in world coordinates...
                    vector.copy(vertices[face[0]]);
                    q.vmult(vector, vector);
                    vector.vadd(x, vector);

                    // ...but make it relative to the ray from. We'll fix this later.
                    vector.vsub(from, vector);

                    // Get plane normal
                    q.vmult(faceNormal, normal);

                    // If this dot product is negative, we have something interesting
                    var dot = direction.dot(normal);

                    // Bail out if ray and plane are parallel
                    if (Math.abs(dot) < this.precision) {
                        continue;
                    }

                    // calc distance to plane
                    var scalar = normal.dot(vector) / dot;

                    // if negative distance, then plane is behind ray
                    if (scalar < 0) {
                        continue;
                    }

                    // if (dot < 0) {

                    // Intersection point is from + direction * scalar
                    direction.mult(scalar, intersectPoint);
                    intersectPoint.vadd(from, intersectPoint);

                    // a is the point we compare points b and c with.
                    a.copy(vertices[face[0]]);
                    q.vmult(a, a);
                    x.vadd(a, a);

                    for (var i = 1; !result._shouldStop && i < face.length - 1; i++) {
                        // Transform 3 vertices to world coords
                        b.copy(vertices[face[i]]);
                        c.copy(vertices[face[i + 1]]);
                        q.vmult(b, b);
                        q.vmult(c, c);
                        x.vadd(b, b);
                        x.vadd(c, c);

                        var distance = intersectPoint.distanceTo(from);

                        if (!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance) {
                            continue;
                        }

                        this.reportIntersection(normal, intersectPoint, shape, body, fi);
                    }
                    // }
                }
            };
            Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;

            var intersectTrimesh_normal = new Vec3();
            var intersectTrimesh_localDirection = new Vec3();
            var intersectTrimesh_localFrom = new Vec3();
            var intersectTrimesh_localTo = new Vec3();
            var intersectTrimesh_worldNormal = new Vec3();
            var intersectTrimesh_worldIntersectPoint = new Vec3();
            var intersectTrimesh_localAABB = new AABB();
            var intersectTrimesh_triangles = [];
            var intersectTrimesh_treeTransform = new Transform();

            /**
             * @method intersectTrimesh
             * @private
             * @param  {Shape} shape
             * @param  {Quaternion} quat
             * @param  {Vec3} position
             * @param  {Body} body
             * @param {object} [options]
             * @todo Optimize by transforming the world to local space first.
             * @todo Use Octree lookup
             */
            Ray.prototype.intersectTrimesh = function intersectTrimesh(
                mesh,
                quat,
                position,
                body,
                options
            ) {
                var normal = intersectTrimesh_normal;
                var triangles = intersectTrimesh_triangles;
                var treeTransform = intersectTrimesh_treeTransform;
                var minDistNormal = intersectConvex_minDistNormal;
                var vector = intersectConvex_vector;
                var minDistIntersect = intersectConvex_minDistIntersect;
                var localAABB = intersectTrimesh_localAABB;
                var localDirection = intersectTrimesh_localDirection;
                var localFrom = intersectTrimesh_localFrom;
                var localTo = intersectTrimesh_localTo;
                var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
                var worldNormal = intersectTrimesh_worldNormal;
                var faceList = (options && options.faceList) || null;

                // Checking faces
                var indices = mesh.indices,
                    vertices = mesh.vertices,
                    normals = mesh.faceNormals;

                var from = this.from;
                var to = this.to;
                var direction = this._direction;

                var minDist = -1;
                treeTransform.position.copy(position);
                treeTransform.quaternion.copy(quat);

                // Transform ray to local space!
                Transform.vectorToLocalFrame(position, quat, direction, localDirection);
                //body.vectorToLocalFrame(direction, localDirection);
                Transform.pointToLocalFrame(position, quat, from, localFrom);
                //body.pointToLocalFrame(from, localFrom);
                Transform.pointToLocalFrame(position, quat, to, localTo);
                //body.pointToLocalFrame(to, localTo);
                var fromToDistanceSquared = localFrom.distanceSquared(localTo);

                mesh.tree.rayQuery(this, treeTransform, triangles);

                for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
                    var trianglesIndex = triangles[i];

                    mesh.getNormal(trianglesIndex, normal);

                    // determine if ray intersects the plane of the face
                    // note: this works regardless of the direction of the face normal

                    // Get plane point in world coordinates...
                    mesh.getVertex(indices[trianglesIndex * 3], a);

                    // ...but make it relative to the ray from. We'll fix this later.
                    a.vsub(localFrom, vector);

                    // Get plane normal
                    // quat.vmult(normal, normal);

                    // If this dot product is negative, we have something interesting
                    var dot = localDirection.dot(normal);

                    // Bail out if ray and plane are parallel
                    // if (Math.abs( dot ) < this.precision){
                    //     continue;
                    // }

                    // calc distance to plane
                    var scalar = normal.dot(vector) / dot;

                    // if negative distance, then plane is behind ray
                    if (scalar < 0) {
                        continue;
                    }

                    // Intersection point is from + direction * scalar
                    localDirection.scale(scalar, intersectPoint);
                    intersectPoint.vadd(localFrom, intersectPoint);

                    // Get triangle vertices
                    mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
                    mesh.getVertex(indices[trianglesIndex * 3 + 2], c);

                    var squaredDistance = intersectPoint.distanceSquared(localFrom);

                    if (!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared) {
                        continue;
                    }

                    // transform intersectpoint and normal to world
                    Transform.vectorToWorldFrame(quat, normal, worldNormal);
                    //body.vectorToWorldFrame(normal, worldNormal);
                    Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
                    //body.pointToWorldFrame(intersectPoint, worldIntersectPoint);
                    this.reportIntersection(worldNormal, worldIntersectPoint, mesh, body, trianglesIndex);
                }
                triangles.length = 0;
            };
            Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;


            /**
             * @method reportIntersection
             * @private
             * @param  {Vec3} normal
             * @param  {Vec3} hitPointWorld
             * @param  {Shape} shape
             * @param  {Body} body
             * @return {boolean} True if the intersections should continue
             */
            Ray.prototype.reportIntersection = function (normal, hitPointWorld, shape, body, hitFaceIndex) {
                var from = this.from;
                var to = this.to;
                var distance = from.distanceTo(hitPointWorld);
                var result = this.result;

                // Skip back faces?
                if (this.skipBackfaces && normal.dot(this._direction) > 0) {
                    return;
                }

                result.hitFaceIndex = typeof (hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

                switch (this.mode) {
                    case Ray.ALL:
                        this.hasHit = true;
                        result.set(
                            from,
                            to,
                            normal,
                            hitPointWorld,
                            shape,
                            body,
                            distance
                        );
                        result.hasHit = true;
                        this.callback(result);
                        break;

                    case Ray.CLOSEST:

                        // Store if closer than current closest
                        if (distance < result.distance || !result.hasHit) {
                            this.hasHit = true;
                            result.hasHit = true;
                            result.set(
                                from,
                                to,
                                normal,
                                hitPointWorld,
                                shape,
                                body,
                                distance
                            );
                        }
                        break;

                    case Ray.ANY:

                        // Report and stop.
                        this.hasHit = true;
                        result.hasHit = true;
                        result.set(
                            from,
                            to,
                            normal,
                            hitPointWorld,
                            shape,
                            body,
                            distance
                        );
                        result._shouldStop = true;
                        break;
                }
            };

            var v0 = new Vec3(),
                intersect = new Vec3();
            function distanceFromIntersection(from, direction, position) {

                // v0 is vector from from to position
                position.vsub(from, v0);
                var dot = v0.dot(direction);

                // intersect = direction*dot + from
                direction.mult(dot, intersect);
                intersect.vadd(from, intersect);

                var distance = position.distanceTo(intersect);

                return distance;
            }


        }, { "../collision/AABB": 3, "../collision/RaycastResult": 10, "../math/Quaternion": 28, "../math/Transform": 29, "../math/Vec3": 30, "../shapes/Box": 37, "../shapes/ConvexPolyhedron": 38, "../shapes/Shape": 43 }], 10: [function (_dereq_, module, exports) {
            var Vec3 = _dereq_('../math/Vec3');

            module.exports = RaycastResult;

            /**
             * Storage for Ray casting data.
             * @class RaycastResult
             * @constructor
             */
            function RaycastResult() {

                /**
                 * @property {Vec3} rayFromWorld
                 */
                this.rayFromWorld = new Vec3();

                /**
                 * @property {Vec3} rayToWorld
                 */
                this.rayToWorld = new Vec3();

                /**
                 * @property {Vec3} hitNormalWorld
                 */
                this.hitNormalWorld = new Vec3();

                /**
                 * @property {Vec3} hitPointWorld
                 */
                this.hitPointWorld = new Vec3();

                /**
                 * @property {boolean} hasHit
                 */
                this.hasHit = false;

                /**
                 * The hit shape, or null.
                 * @property {Shape} shape
                 */
                this.shape = null;

                /**
                 * The hit body, or null.
                 * @property {Body} body
                 */
                this.body = null;

                /**
                 * The index of the hit triangle, if the hit shape was a trimesh.
                 * @property {number} hitFaceIndex
                 * @default -1
                 */
                this.hitFaceIndex = -1;

                /**
                 * Distance to the hit. Will be set to -1 if there was no hit.
                 * @property {number} distance
                 * @default -1
                 */
                this.distance = -1;

                /**
                 * If the ray should stop traversing the bodies.
                 * @private
                 * @property {Boolean} _shouldStop
                 * @default false
                 */
                this._shouldStop = false;
            }

            /**
             * Reset all result data.
             * @method reset
             */
            RaycastResult.prototype.reset = function () {
                this.rayFromWorld.setZero();
                this.rayToWorld.setZero();
                this.hitNormalWorld.setZero();
                this.hitPointWorld.setZero();
                this.hasHit = false;
                this.shape = null;
                this.body = null;
                this.hitFaceIndex = -1;
                this.distance = -1;
                this._shouldStop = false;
            };

            /**
             * @method abort
             */
            RaycastResult.prototype.abort = function () {
                this._shouldStop = true;
            };

            /**
             * @method set
             * @param {Vec3} rayFromWorld
             * @param {Vec3} rayToWorld
             * @param {Vec3} hitNormalWorld
             * @param {Vec3} hitPointWorld
             * @param {Shape} shape
             * @param {Body} body
             * @param {number} distance
             */
            RaycastResult.prototype.set = function (
                rayFromWorld,
                rayToWorld,
                hitNormalWorld,
                hitPointWorld,
                shape,
                body,
                distance
            ) {
                this.rayFromWorld.copy(rayFromWorld);
                this.rayToWorld.copy(rayToWorld);
                this.hitNormalWorld.copy(hitNormalWorld);
                this.hitPointWorld.copy(hitPointWorld);
                this.shape = shape;
                this.body = body;
                this.distance = distance;
            };
        }, { "../math/Vec3": 30 }], 11: [function (_dereq_, module, exports) {
            var Shape = _dereq_('../shapes/Shape');
            var Broadphase = _dereq_('../collision/Broadphase');

            module.exports = SAPBroadphase;

            /**
             * Sweep and prune broadphase along one axis.
             *
             * @class SAPBroadphase
             * @constructor
             * @param {World} [world]
             * @extends Broadphase
             */
            function SAPBroadphase(world) {
                Broadphase.apply(this);

                /**
                 * List of bodies currently in the broadphase.
                 * @property axisList
                 * @type {Array}
                 */
                this.axisList = [];

                /**
                 * The world to search in.
                 * @property world
                 * @type {World}
                 */
                this.world = null;

                /**
                 * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
                 * @property axisIndex
                 * @type {Number}
                 */
                this.axisIndex = 0;

                var axisList = this.axisList;

                this._addBodyHandler = function (e) {
                    axisList.push(e.body);
                };

                this._removeBodyHandler = function (e) {
                    var idx = axisList.indexOf(e.body);
                    if (idx !== -1) {
                        axisList.splice(idx, 1);
                    }
                };

                if (world) {
                    this.setWorld(world);
                }
            }
            SAPBroadphase.prototype = new Broadphase();

            /**
             * Change the world
             * @method setWorld
             * @param  {World} world
             */
            SAPBroadphase.prototype.setWorld = function (world) {
                // Clear the old axis array
                this.axisList.length = 0;

                // Add all bodies from the new world
                for (var i = 0; i < world.bodies.length; i++) {
                    this.axisList.push(world.bodies[i]);
                }

                // Remove old handlers, if any
                world.removeEventListener("addBody", this._addBodyHandler);
                world.removeEventListener("removeBody", this._removeBodyHandler);

                // Add handlers to update the list of bodies.
                world.addEventListener("addBody", this._addBodyHandler);
                world.addEventListener("removeBody", this._removeBodyHandler);

                this.world = world;
                this.dirty = true;
            };

            /**
             * @static
             * @method insertionSortX
             * @param  {Array} a
             * @return {Array}
             */
            SAPBroadphase.insertionSortX = function (a) {
                for (var i = 1, l = a.length; i < l; i++) {
                    var v = a[i];
                    for (var j = i - 1; j >= 0; j--) {
                        if (a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x) {
                            break;
                        }
                        a[j + 1] = a[j];
                    }
                    a[j + 1] = v;
                }
                return a;
            };

            /**
             * @static
             * @method insertionSortY
             * @param  {Array} a
             * @return {Array}
             */
            SAPBroadphase.insertionSortY = function (a) {
                for (var i = 1, l = a.length; i < l; i++) {
                    var v = a[i];
                    for (var j = i - 1; j >= 0; j--) {
                        if (a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y) {
                            break;
                        }
                        a[j + 1] = a[j];
                    }
                    a[j + 1] = v;
                }
                return a;
            };

            /**
             * @static
             * @method insertionSortZ
             * @param  {Array} a
             * @return {Array}
             */
            SAPBroadphase.insertionSortZ = function (a) {
                for (var i = 1, l = a.length; i < l; i++) {
                    var v = a[i];
                    for (var j = i - 1; j >= 0; j--) {
                        if (a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z) {
                            break;
                        }
                        a[j + 1] = a[j];
                    }
                    a[j + 1] = v;
                }
                return a;
            };

            /**
             * Collect all collision pairs
             * @method collisionPairs
             * @param  {World} world
             * @param  {Array} p1
             * @param  {Array} p2
             */
            SAPBroadphase.prototype.collisionPairs = function (world, p1, p2) {
                var bodies = this.axisList,
                    N = bodies.length,
                    axisIndex = this.axisIndex,
                    i, j;

                if (this.dirty) {
                    this.sortList();
                    this.dirty = false;
                }

                // Look through the list
                for (i = 0; i !== N; i++) {
                    var bi = bodies[i];

                    for (j = i + 1; j < N; j++) {
                        var bj = bodies[j];

                        if (!this.needBroadphaseCollision(bi, bj)) {
                            continue;
                        }

                        if (!SAPBroadphase.checkBounds(bi, bj, axisIndex)) {
                            break;
                        }

                        this.intersectionTest(bi, bj, p1, p2);
                    }
                }
            };

            SAPBroadphase.prototype.sortList = function () {
                var axisList = this.axisList;
                var axisIndex = this.axisIndex;
                var N = axisList.length;

                // Update AABBs
                for (var i = 0; i !== N; i++) {
                    var bi = axisList[i];
                    if (bi.aabbNeedsUpdate) {
                        bi.computeAABB();
                    }
                }

                // Sort the list
                if (axisIndex === 0) {
                    SAPBroadphase.insertionSortX(axisList);
                } else if (axisIndex === 1) {
                    SAPBroadphase.insertionSortY(axisList);
                } else if (axisIndex === 2) {
                    SAPBroadphase.insertionSortZ(axisList);
                }
            };

            /**
             * Check if the bounds of two bodies overlap, along the given SAP axis.
             * @static
             * @method checkBounds
             * @param  {Body} bi
             * @param  {Body} bj
             * @param  {Number} axisIndex
             * @return {Boolean}
             */
            SAPBroadphase.checkBounds = function (bi, bj, axisIndex) {
                var biPos;
                var bjPos;

                if (axisIndex === 0) {
                    biPos = bi.position.x;
                    bjPos = bj.position.x;
                } else if (axisIndex === 1) {
                    biPos = bi.position.y;
                    bjPos = bj.position.y;
                } else if (axisIndex === 2) {
                    biPos = bi.position.z;
                    bjPos = bj.position.z;
                }

                var ri = bi.boundingRadius,
                    rj = bj.boundingRadius,
                    boundA1 = biPos - ri,
                    boundA2 = biPos + ri,
                    boundB1 = bjPos - rj,
                    boundB2 = bjPos + rj;

                return boundB1 < boundA2;
            };

            /**
             * Computes the variance of the body positions and estimates the best
             * axis to use. Will automatically set property .axisIndex.
             * @method autoDetectAxis
             */
            SAPBroadphase.prototype.autoDetectAxis = function () {
                var sumX = 0,
                    sumX2 = 0,
                    sumY = 0,
                    sumY2 = 0,
                    sumZ = 0,
                    sumZ2 = 0,
                    bodies = this.axisList,
                    N = bodies.length,
                    invN = 1 / N;

                for (var i = 0; i !== N; i++) {
                    var b = bodies[i];

                    var centerX = b.position.x;
                    sumX += centerX;
                    sumX2 += centerX * centerX;

                    var centerY = b.position.y;
                    sumY += centerY;
                    sumY2 += centerY * centerY;

                    var centerZ = b.position.z;
                    sumZ += centerZ;
                    sumZ2 += centerZ * centerZ;
                }

                var varianceX = sumX2 - sumX * sumX * invN,
                    varianceY = sumY2 - sumY * sumY * invN,
                    varianceZ = sumZ2 - sumZ * sumZ * invN;

                if (varianceX > varianceY) {
                    if (varianceX > varianceZ) {
                        this.axisIndex = 0;
                    } else {
                        this.axisIndex = 2;
                    }
                } else if (varianceY > varianceZ) {
                    this.axisIndex = 1;
                } else {
                    this.axisIndex = 2;
                }
            };

            /**
             * Returns all the bodies within an AABB.
             * @method aabbQuery
             * @param  {World} world
             * @param  {AABB} aabb
             * @param {array} result An array to store resulting bodies in.
             * @return {array}
             */
            SAPBroadphase.prototype.aabbQuery = function (world, aabb, result) {
                result = result || [];

                if (this.dirty) {
                    this.sortList();
                    this.dirty = false;
                }

                var axisIndex = this.axisIndex, axis = 'x';
                if (axisIndex === 1) { axis = 'y'; }
                if (axisIndex === 2) { axis = 'z'; }

                var axisList = this.axisList;
                var lower = aabb.lowerBound[axis];
                var upper = aabb.upperBound[axis];
                for (var i = 0; i < axisList.length; i++) {
                    var b = axisList[i];

                    if (b.aabbNeedsUpdate) {
                        b.computeAABB();
                    }

                    if (b.aabb.overlaps(aabb)) {
                        result.push(b);
                    }
                }

                return result;
            };
        }, { "../collision/Broadphase": 5, "../shapes/Shape": 43 }], 12: [function (_dereq_, module, exports) {
            module.exports = ConeTwistConstraint;

            var Constraint = _dereq_('./Constraint');
            var PointToPointConstraint = _dereq_('./PointToPointConstraint');
            var ConeEquation = _dereq_('../equations/ConeEquation');
            var RotationalEquation = _dereq_('../equations/RotationalEquation');
            var ContactEquation = _dereq_('../equations/ContactEquation');
            var Vec3 = _dereq_('../math/Vec3');

            /**
             * @class ConeTwistConstraint
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {object} [options]
             * @param {Vec3} [options.pivotA]
             * @param {Vec3} [options.pivotB]
             * @param {Vec3} [options.axisA]
             * @param {Vec3} [options.axisB]
             * @param {Number} [options.maxForce=1e6]
             * @extends PointToPointConstraint
             */
            function ConeTwistConstraint(bodyA, bodyB, options) {
                options = options || {};
                var maxForce = typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

                // Set pivot point in between
                var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
                var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
                this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
                this.axisB = options.axisB ? options.axisB.clone() : new Vec3();

                PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

                this.collideConnected = !!options.collideConnected;

                this.angle = typeof (options.angle) !== 'undefined' ? options.angle : 0;

                /**
                 * @property {ConeEquation} coneEquation
                 */
                var c = this.coneEquation = new ConeEquation(bodyA, bodyB, options);

                /**
                 * @property {RotationalEquation} twistEquation
                 */
                var t = this.twistEquation = new RotationalEquation(bodyA, bodyB, options);
                this.twistAngle = typeof (options.twistAngle) !== 'undefined' ? options.twistAngle : 0;

                // Make the cone equation push the bodies toward the cone axis, not outward
                c.maxForce = 0;
                c.minForce = -maxForce;

                // Make the twist equation add torque toward the initial position
                t.maxForce = 0;
                t.minForce = -maxForce;

                this.equations.push(c, t);
            }
            ConeTwistConstraint.prototype = new PointToPointConstraint();
            ConeTwistConstraint.constructor = ConeTwistConstraint;

            var ConeTwistConstraint_update_tmpVec1 = new Vec3();
            var ConeTwistConstraint_update_tmpVec2 = new Vec3();

            ConeTwistConstraint.prototype.update = function () {
                var bodyA = this.bodyA,
                    bodyB = this.bodyB,
                    cone = this.coneEquation,
                    twist = this.twistEquation;

                PointToPointConstraint.prototype.update.call(this);

                // Update the axes to the cone constraint
                bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
                bodyB.vectorToWorldFrame(this.axisB, cone.axisB);

                // Update the world axes in the twist constraint
                this.axisA.tangents(twist.axisA, twist.axisA);
                bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);

                this.axisB.tangents(twist.axisB, twist.axisB);
                bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);

                cone.angle = this.angle;
                twist.maxAngle = this.twistAngle;
            };


        }, { "../equations/ConeEquation": 18, "../equations/ContactEquation": 19, "../equations/RotationalEquation": 22, "../math/Vec3": 30, "./Constraint": 13, "./PointToPointConstraint": 17 }], 13: [function (_dereq_, module, exports) {
            module.exports = Constraint;

            var Utils = _dereq_('../utils/Utils');

            /**
             * Constraint base class
             * @class Constraint
             * @author schteppe
             * @constructor
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {object} [options]
             * @param {boolean} [options.collideConnected=true]
             * @param {boolean} [options.wakeUpBodies=true]
             */
            function Constraint(bodyA, bodyB, options) {
                options = Utils.defaults(options, {
                    collideConnected: true,
                    wakeUpBodies: true,
                });

                /**
                 * Equations to be solved in this constraint
                 * @property equations
                 * @type {Array}
                 */
                this.equations = [];

                /**
                 * @property {Body} bodyA
                 */
                this.bodyA = bodyA;

                /**
                 * @property {Body} bodyB
                 */
                this.bodyB = bodyB;

                /**
                 * @property {Number} id
                 */
                this.id = Constraint.idCounter++;

                /**
                 * Set to true if you want the bodies to collide when they are connected.
                 * @property collideConnected
                 * @type {boolean}
                 */
                this.collideConnected = options.collideConnected;

                if (options.wakeUpBodies) {
                    if (bodyA) {
                        bodyA.wakeUp();
                    }
                    if (bodyB) {
                        bodyB.wakeUp();
                    }
                }
            }

            /**
             * Update all the equations with data.
             * @method update
             */
            Constraint.prototype.update = function () {
                throw new Error("method update() not implmemented in this Constraint subclass!");
            };

            /**
             * Enables all equations in the constraint.
             * @method enable
             */
            Constraint.prototype.enable = function () {
                var eqs = this.equations;
                for (var i = 0; i < eqs.length; i++) {
                    eqs[i].enabled = true;
                }
            };

            /**
             * Disables all equations in the constraint.
             * @method disable
             */
            Constraint.prototype.disable = function () {
                var eqs = this.equations;
                for (var i = 0; i < eqs.length; i++) {
                    eqs[i].enabled = false;
                }
            };

            Constraint.idCounter = 0;

        }, { "../utils/Utils": 53 }], 14: [function (_dereq_, module, exports) {
            module.exports = DistanceConstraint;

            var Constraint = _dereq_('./Constraint');
            var ContactEquation = _dereq_('../equations/ContactEquation');

            /**
             * Constrains two bodies to be at a constant distance from each others center of mass.
             * @class DistanceConstraint
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
             * @param {Number} [maxForce=1e6]
             * @extends Constraint
             */
            function DistanceConstraint(bodyA, bodyB, distance, maxForce) {
                Constraint.call(this, bodyA, bodyB);

                if (typeof (distance) === "undefined") {
                    distance = bodyA.position.distanceTo(bodyB.position);
                }

                if (typeof (maxForce) === "undefined") {
                    maxForce = 1e6;
                }

                /**
                 * @property {number} distance
                 */
                this.distance = distance;

                /**
                 * @property {ContactEquation} distanceEquation
                 */
                var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
                this.equations.push(eq);

                // Make it bidirectional
                eq.minForce = -maxForce;
                eq.maxForce = maxForce;
            }
            DistanceConstraint.prototype = new Constraint();

            DistanceConstraint.prototype.update = function () {
                var bodyA = this.bodyA;
                var bodyB = this.bodyB;
                var eq = this.distanceEquation;
                var halfDist = this.distance * 0.5;
                var normal = eq.ni;

                bodyB.position.vsub(bodyA.position, normal);
                normal.normalize();
                normal.mult(halfDist, eq.ri);
                normal.mult(-halfDist, eq.rj);
            };
        }, { "../equations/ContactEquation": 19, "./Constraint": 13 }], 15: [function (_dereq_, module, exports) {
            module.exports = HingeConstraint;

            var Constraint = _dereq_('./Constraint');
            var PointToPointConstraint = _dereq_('./PointToPointConstraint');
            var RotationalEquation = _dereq_('../equations/RotationalEquation');
            var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
            var ContactEquation = _dereq_('../equations/ContactEquation');
            var Vec3 = _dereq_('../math/Vec3');

            /**
             * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
             * @class HingeConstraint
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {object} [options]
             * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
             * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
             * @param {Vec3} [options.pivotB]
             * @param {Vec3} [options.axisB]
             * @param {Number} [options.maxForce=1e6]
             * @extends PointToPointConstraint
             */
            function HingeConstraint(bodyA, bodyB, options) {
                options = options || {};
                var maxForce = typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
                var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
                var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();

                PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

                /**
                 * Rotation axis, defined locally in bodyA.
                 * @property {Vec3} axisA
                 */
                var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
                axisA.normalize();

                /**
                 * Rotation axis, defined locally in bodyB.
                 * @property {Vec3} axisB
                 */
                var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1, 0, 0);
                axisB.normalize();

                /**
                 * @property {RotationalEquation} rotationalEquation1
                 */
                var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);

                /**
                 * @property {RotationalEquation} rotationalEquation2
                 */
                var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);

                /**
                 * @property {RotationalMotorEquation} motorEquation
                 */
                var motor = this.motorEquation = new RotationalMotorEquation(bodyA, bodyB, maxForce);
                motor.enabled = false; // Not enabled by default

                // Equations to be fed to the solver
                this.equations.push(
                    r1, // rotational1
                    r2, // rotational2
                    motor
                );
            }
            HingeConstraint.prototype = new PointToPointConstraint();
            HingeConstraint.constructor = HingeConstraint;

            /**
             * @method enableMotor
             */
            HingeConstraint.prototype.enableMotor = function () {
                this.motorEquation.enabled = true;
            };

            /**
             * @method disableMotor
             */
            HingeConstraint.prototype.disableMotor = function () {
                this.motorEquation.enabled = false;
            };

            /**
             * @method setMotorSpeed
             * @param {number} speed
             */
            HingeConstraint.prototype.setMotorSpeed = function (speed) {
                this.motorEquation.targetVelocity = speed;
            };

            /**
             * @method setMotorMaxForce
             * @param {number} maxForce
             */
            HingeConstraint.prototype.setMotorMaxForce = function (maxForce) {
                this.motorEquation.maxForce = maxForce;
                this.motorEquation.minForce = -maxForce;
            };

            var HingeConstraint_update_tmpVec1 = new Vec3();
            var HingeConstraint_update_tmpVec2 = new Vec3();

            HingeConstraint.prototype.update = function () {
                var bodyA = this.bodyA,
                    bodyB = this.bodyB,
                    motor = this.motorEquation,
                    r1 = this.rotationalEquation1,
                    r2 = this.rotationalEquation2,
                    worldAxisA = HingeConstraint_update_tmpVec1,
                    worldAxisB = HingeConstraint_update_tmpVec2;

                var axisA = this.axisA;
                var axisB = this.axisB;

                PointToPointConstraint.prototype.update.call(this);

                // Get world axes
                bodyA.quaternion.vmult(axisA, worldAxisA);
                bodyB.quaternion.vmult(axisB, worldAxisB);

                worldAxisA.tangents(r1.axisA, r2.axisA);
                r1.axisB.copy(worldAxisB);
                r2.axisB.copy(worldAxisB);

                if (this.motorEquation.enabled) {
                    bodyA.quaternion.vmult(this.axisA, motor.axisA);
                    bodyB.quaternion.vmult(this.axisB, motor.axisB);
                }
            };


        }, { "../equations/ContactEquation": 19, "../equations/RotationalEquation": 22, "../equations/RotationalMotorEquation": 23, "../math/Vec3": 30, "./Constraint": 13, "./PointToPointConstraint": 17 }], 16: [function (_dereq_, module, exports) {
            module.exports = LockConstraint;

            var Constraint = _dereq_('./Constraint');
            var PointToPointConstraint = _dereq_('./PointToPointConstraint');
            var RotationalEquation = _dereq_('../equations/RotationalEquation');
            var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
            var ContactEquation = _dereq_('../equations/ContactEquation');
            var Vec3 = _dereq_('../math/Vec3');

            /**
             * Lock constraint. Will remove all degrees of freedom between the bodies.
             * @class LockConstraint
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {object} [options]
             * @param {Number} [options.maxForce=1e6]
             * @extends PointToPointConstraint
             */
            function LockConstraint(bodyA, bodyB, options) {
                options = options || {};
                var maxForce = typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

                // Set pivot point in between
                var pivotA = new Vec3();
                var pivotB = new Vec3();
                var halfWay = new Vec3();
                bodyA.position.vadd(bodyB.position, halfWay);
                halfWay.scale(0.5, halfWay);
                bodyB.pointToLocalFrame(halfWay, pivotB);
                bodyA.pointToLocalFrame(halfWay, pivotA);
                PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

                /**
                 * @property {RotationalEquation} rotationalEquation1
                 */
                var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA, bodyB, options);

                /**
                 * @property {RotationalEquation} rotationalEquation2
                 */
                var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA, bodyB, options);

                /**
                 * @property {RotationalEquation} rotationalEquation3
                 */
                var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA, bodyB, options);

                this.equations.push(r1, r2, r3);
            }
            LockConstraint.prototype = new PointToPointConstraint();
            LockConstraint.constructor = LockConstraint;

            var LockConstraint_update_tmpVec1 = new Vec3();
            var LockConstraint_update_tmpVec2 = new Vec3();

            LockConstraint.prototype.update = function () {
                var bodyA = this.bodyA,
                    bodyB = this.bodyB,
                    motor = this.motorEquation,
                    r1 = this.rotationalEquation1,
                    r2 = this.rotationalEquation2,
                    r3 = this.rotationalEquation3,
                    worldAxisA = LockConstraint_update_tmpVec1,
                    worldAxisB = LockConstraint_update_tmpVec2;

                PointToPointConstraint.prototype.update.call(this);

                bodyA.vectorToWorldFrame(Vec3.UNIT_X, r1.axisA);
                bodyB.vectorToWorldFrame(Vec3.UNIT_Y, r1.axisB);

                bodyA.vectorToWorldFrame(Vec3.UNIT_Y, r2.axisA);
                bodyB.vectorToWorldFrame(Vec3.UNIT_Z, r2.axisB);

                bodyA.vectorToWorldFrame(Vec3.UNIT_Z, r3.axisA);
                bodyB.vectorToWorldFrame(Vec3.UNIT_X, r3.axisB);
            };


        }, { "../equations/ContactEquation": 19, "../equations/RotationalEquation": 22, "../equations/RotationalMotorEquation": 23, "../math/Vec3": 30, "./Constraint": 13, "./PointToPointConstraint": 17 }], 17: [function (_dereq_, module, exports) {
            module.exports = PointToPointConstraint;

            var Constraint = _dereq_('./Constraint');
            var ContactEquation = _dereq_('../equations/ContactEquation');
            var Vec3 = _dereq_('../math/Vec3');

            /**
             * Connects two bodies at given offset points.
             * @class PointToPointConstraint
             * @extends Constraint
             * @constructor
             * @param {Body} bodyA
             * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
             * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
             * @param {Vec3} pivotB See pivotA.
             * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
             *
             * @example
             *     var bodyA = new Body({ mass: 1 });
             *     var bodyB = new Body({ mass: 1 });
             *     bodyA.position.set(-1, 0, 0);
             *     bodyB.position.set(1, 0, 0);
             *     bodyA.addShape(shapeA);
             *     bodyB.addShape(shapeB);
             *     world.addBody(bodyA);
             *     world.addBody(bodyB);
             *     var localPivotA = new Vec3(1, 0, 0);
             *     var localPivotB = new Vec3(-1, 0, 0);
             *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
             *     world.addConstraint(constraint);
             */
            function PointToPointConstraint(bodyA, pivotA, bodyB, pivotB, maxForce) {
                Constraint.call(this, bodyA, bodyB);

                maxForce = typeof (maxForce) !== 'undefined' ? maxForce : 1e6;

                /**
                 * Pivot, defined locally in bodyA.
                 * @property {Vec3} pivotA
                 */
                this.pivotA = pivotA ? pivotA.clone() : new Vec3();

                /**
                 * Pivot, defined locally in bodyB.
                 * @property {Vec3} pivotB
                 */
                this.pivotB = pivotB ? pivotB.clone() : new Vec3();

                /**
                 * @property {ContactEquation} equationX
                 */
                var x = this.equationX = new ContactEquation(bodyA, bodyB);

                /**
                 * @property {ContactEquation} equationY
                 */
                var y = this.equationY = new ContactEquation(bodyA, bodyB);

                /**
                 * @property {ContactEquation} equationZ
                 */
                var z = this.equationZ = new ContactEquation(bodyA, bodyB);

                // Equations to be fed to the solver
                this.equations.push(x, y, z);

                // Make the equations bidirectional
                x.minForce = y.minForce = z.minForce = -maxForce;
                x.maxForce = y.maxForce = z.maxForce = maxForce;

                x.ni.set(1, 0, 0);
                y.ni.set(0, 1, 0);
                z.ni.set(0, 0, 1);
            }
            PointToPointConstraint.prototype = new Constraint();

            PointToPointConstraint.prototype.update = function () {
                var bodyA = this.bodyA;
                var bodyB = this.bodyB;
                var x = this.equationX;
                var y = this.equationY;
                var z = this.equationZ;

                // Rotate the pivots to world space
                bodyA.quaternion.vmult(this.pivotA, x.ri);
                bodyB.quaternion.vmult(this.pivotB, x.rj);

                y.ri.copy(x.ri);
                y.rj.copy(x.rj);
                z.ri.copy(x.ri);
                z.rj.copy(x.rj);
            };
        }, { "../equations/ContactEquation": 19, "../math/Vec3": 30, "./Constraint": 13 }], 18: [function (_dereq_, module, exports) {
            module.exports = ConeEquation;

            var Vec3 = _dereq_('../math/Vec3');
            var Mat3 = _dereq_('../math/Mat3');
            var Equation = _dereq_('./Equation');

            /**
             * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
             * @class ConeEquation
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {Vec3} [options.axisA] Local axis in A
             * @param {Vec3} [options.axisB] Local axis in B
             * @param {Vec3} [options.angle] The "cone angle" to keep
             * @param {number} [options.maxForce=1e6]
             * @extends Equation
             */
            function ConeEquation(bodyA, bodyB, options) {
                options = options || {};
                var maxForce = typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

                Equation.call(this, bodyA, bodyB, -maxForce, maxForce);

                this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
                this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

                /**
                 * The cone angle to keep
                 * @property {number} angle
                 */
                this.angle = typeof (options.angle) !== 'undefined' ? options.angle : 0;
            }

            ConeEquation.prototype = new Equation();
            ConeEquation.prototype.constructor = ConeEquation;

            var tmpVec1 = new Vec3();
            var tmpVec2 = new Vec3();

            ConeEquation.prototype.computeB = function (h) {
                var a = this.a,
                    b = this.b,

                    ni = this.axisA,
                    nj = this.axisB,

                    nixnj = tmpVec1,
                    njxni = tmpVec2,

                    GA = this.jacobianElementA,
                    GB = this.jacobianElementB;

                // Caluclate cross products
                ni.cross(nj, nixnj);
                nj.cross(ni, njxni);

                // The angle between two vector is:
                // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b

                // g = a * b
                // gdot = (b x a) * wi + (a x b) * wj
                // G = [0 bxa 0 axb]
                // W = [vi wi vj wj]
                GA.rotational.copy(njxni);
                GB.rotational.copy(nixnj);

                var g = Math.cos(this.angle) - ni.dot(nj),
                    GW = this.computeGW(),
                    GiMf = this.computeGiMf();

                var B = - g * a - GW * b - h * GiMf;

                return B;
            };


        }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 19: [function (_dereq_, module, exports) {
            module.exports = ContactEquation;

            var Equation = _dereq_('./Equation');
            var Vec3 = _dereq_('../math/Vec3');
            var Mat3 = _dereq_('../math/Mat3');

            /**
             * Contact/non-penetration constraint equation
             * @class ContactEquation
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @extends Equation
             */
            function ContactEquation(bodyA, bodyB, maxForce) {
                maxForce = typeof (maxForce) !== 'undefined' ? maxForce : 1e6;
                Equation.call(this, bodyA, bodyB, 0, maxForce);

                /**
                 * @property restitution
                 * @type {Number}
                 */
                this.restitution = 0.0; // "bounciness": u1 = -e*u0

                /**
                 * World-oriented vector that goes from the center of bi to the contact point.
                 * @property {Vec3} ri
                 */
                this.ri = new Vec3();

                /**
                 * World-oriented vector that starts in body j position and goes to the contact point.
                 * @property {Vec3} rj
                 */
                this.rj = new Vec3();

                /**
                 * Contact normal, pointing out of body i.
                 * @property {Vec3} ni
                 */
                this.ni = new Vec3();
            }

            ContactEquation.prototype = new Equation();
            ContactEquation.prototype.constructor = ContactEquation;

            var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors
            var ContactEquation_computeB_temp2 = new Vec3();
            var ContactEquation_computeB_temp3 = new Vec3();
            ContactEquation.prototype.computeB = function (h) {
                var a = this.a,
                    b = this.b,
                    bi = this.bi,
                    bj = this.bj,
                    ri = this.ri,
                    rj = this.rj,
                    rixn = ContactEquation_computeB_temp1,
                    rjxn = ContactEquation_computeB_temp2,

                    vi = bi.velocity,
                    wi = bi.angularVelocity,
                    fi = bi.force,
                    taui = bi.torque,

                    vj = bj.velocity,
                    wj = bj.angularVelocity,
                    fj = bj.force,
                    tauj = bj.torque,

                    penetrationVec = ContactEquation_computeB_temp3,

                    GA = this.jacobianElementA,
                    GB = this.jacobianElementB,

                    n = this.ni;

                // Caluclate cross products
                ri.cross(n, rixn);
                rj.cross(n, rjxn);

                // g = xj+rj -(xi+ri)
                // G = [ -ni  -rixn  ni  rjxn ]
                n.negate(GA.spatial);
                rixn.negate(GA.rotational);
                GB.spatial.copy(n);
                GB.rotational.copy(rjxn);

                // Calculate the penetration vector
                penetrationVec.copy(bj.position);
                penetrationVec.vadd(rj, penetrationVec);
                penetrationVec.vsub(bi.position, penetrationVec);
                penetrationVec.vsub(ri, penetrationVec);

                var g = n.dot(penetrationVec);

                // Compute iteration
                var ePlusOne = this.restitution + 1;
                var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
                var GiMf = this.computeGiMf();

                var B = - g * a - GW * b - h * GiMf;

                return B;
            };

            var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
            var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
            var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
            var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
            var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

            /**
             * Get the current relative velocity in the contact point.
             * @method getImpactVelocityAlongNormal
             * @return {number}
             */
            ContactEquation.prototype.getImpactVelocityAlongNormal = function () {
                var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
                var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
                var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
                var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
                var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;

                this.bi.position.vadd(this.ri, xi);
                this.bj.position.vadd(this.rj, xj);

                this.bi.getVelocityAtWorldPoint(xi, vi);
                this.bj.getVelocityAtWorldPoint(xj, vj);

                vi.vsub(vj, relVel);

                return this.ni.dot(relVel);
            };


        }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 20: [function (_dereq_, module, exports) {
            module.exports = Equation;

            var JacobianElement = _dereq_('../math/JacobianElement'),
                Vec3 = _dereq_('../math/Vec3');

            /**
             * Equation base class
             * @class Equation
             * @constructor
             * @author schteppe
             * @param {Body} bi
             * @param {Body} bj
             * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
             * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
             */
            function Equation(bi, bj, minForce, maxForce) {
                this.id = Equation.id++;

                /**
                 * @property {number} minForce
                 */
                this.minForce = typeof (minForce) === "undefined" ? -1e6 : minForce;

                /**
                 * @property {number} maxForce
                 */
                this.maxForce = typeof (maxForce) === "undefined" ? 1e6 : maxForce;

                /**
                 * @property bi
                 * @type {Body}
                 */
                this.bi = bi;

                /**
                 * @property bj
                 * @type {Body}
                 */
                this.bj = bj;

                /**
                 * SPOOK parameter
                 * @property {number} a
                 */
                this.a = 0.0;

                /**
                 * SPOOK parameter
                 * @property {number} b
                 */
                this.b = 0.0;

                /**
                 * SPOOK parameter
                 * @property {number} eps
                 */
                this.eps = 0.0;

                /**
                 * @property {JacobianElement} jacobianElementA
                 */
                this.jacobianElementA = new JacobianElement();

                /**
                 * @property {JacobianElement} jacobianElementB
                 */
                this.jacobianElementB = new JacobianElement();

                /**
                 * @property {boolean} enabled
                 * @default true
                 */
                this.enabled = true;

                // Set typical spook params
                this.setSpookParams(1e7, 4, 1 / 60);
            }
            Equation.prototype.constructor = Equation;

            Equation.id = 0;

            /**
             * Recalculates a,b,eps.
             * @method setSpookParams
             */
            Equation.prototype.setSpookParams = function (stiffness, relaxation, timeStep) {
                var d = relaxation,
                    k = stiffness,
                    h = timeStep;
                this.a = 4.0 / (h * (1 + 4 * d));
                this.b = (4.0 * d) / (1 + 4 * d);
                this.eps = 4.0 / (h * h * k * (1 + 4 * d));
            };

            /**
             * Computes the RHS of the SPOOK equation
             * @method computeB
             * @return {Number}
             */
            Equation.prototype.computeB = function (a, b, h) {
                var GW = this.computeGW(),
                    Gq = this.computeGq(),
                    GiMf = this.computeGiMf();
                return - Gq * a - GW * b - GiMf * h;
            };

            /**
             * Computes G*q, where q are the generalized body coordinates
             * @method computeGq
             * @return {Number}
             */
            Equation.prototype.computeGq = function () {
                var GA = this.jacobianElementA,
                    GB = this.jacobianElementB,
                    bi = this.bi,
                    bj = this.bj,
                    xi = bi.position,
                    xj = bj.position;
                return GA.spatial.dot(xi) + GB.spatial.dot(xj);
            };

            var zero = new Vec3();

            /**
             * Computes G*W, where W are the body velocities
             * @method computeGW
             * @return {Number}
             */
            Equation.prototype.computeGW = function () {
                var GA = this.jacobianElementA,
                    GB = this.jacobianElementB,
                    bi = this.bi,
                    bj = this.bj,
                    vi = bi.velocity,
                    vj = bj.velocity,
                    wi = bi.angularVelocity || zero,
                    wj = bj.angularVelocity || zero;
                return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
            };


            /**
             * Computes G*Wlambda, where W are the body velocities
             * @method computeGWlambda
             * @return {Number}
             */
            Equation.prototype.computeGWlambda = function () {
                var GA = this.jacobianElementA,
                    GB = this.jacobianElementB,
                    bi = this.bi,
                    bj = this.bj,
                    vi = bi.vlambda,
                    vj = bj.vlambda,
                    wi = bi.wlambda || zero,
                    wj = bj.wlambda || zero;
                return GA.multiplyVectors(vi, wi) + GB.multiplyVectors(vj, wj);
            };

            /**
             * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
             * @method computeGiMf
             * @return {Number}
             */
            var iMfi = new Vec3(),
                iMfj = new Vec3(),
                invIi_vmult_taui = new Vec3(),
                invIj_vmult_tauj = new Vec3();
            Equation.prototype.computeGiMf = function () {
                var GA = this.jacobianElementA,
                    GB = this.jacobianElementB,
                    bi = this.bi,
                    bj = this.bj,
                    fi = bi.force,
                    ti = bi.torque,
                    fj = bj.force,
                    tj = bj.torque,
                    invMassi = bi.invMassSolve,
                    invMassj = bj.invMassSolve;

                if (bi.invInertiaWorldSolve) { bi.invInertiaWorldSolve.vmult(ti, invIi_vmult_taui); }
                else { invIi_vmult_taui.set(0, 0, 0); }
                if (bj.invInertiaWorldSolve) { bj.invInertiaWorldSolve.vmult(tj, invIj_vmult_tauj); }
                else { invIj_vmult_tauj.set(0, 0, 0); }

                fi.mult(invMassi, iMfi);
                fj.mult(invMassj, iMfj);

                return GA.multiplyVectors(iMfi, invIi_vmult_taui) + GB.multiplyVectors(iMfj, invIj_vmult_tauj);
            };

            /**
             * Computes G*inv(M)*G'
             * @method computeGiMGt
             * @return {Number}
             */
            var tmp = new Vec3();
            Equation.prototype.computeGiMGt = function () {
                var GA = this.jacobianElementA,
                    GB = this.jacobianElementB,
                    bi = this.bi,
                    bj = this.bj,
                    invMassi = bi.invMassSolve,
                    invMassj = bj.invMassSolve,
                    invIi = bi.invInertiaWorldSolve,
                    invIj = bj.invInertiaWorldSolve,
                    result = invMassi + invMassj;

                if (invIi) {
                    invIi.vmult(GA.rotational, tmp);
                    result += tmp.dot(GA.rotational);
                }

                if (invIj) {
                    invIj.vmult(GB.rotational, tmp);
                    result += tmp.dot(GB.rotational);
                }

                return result;
            };

            var addToWlambda_temp = new Vec3(),
                addToWlambda_Gi = new Vec3(),
                addToWlambda_Gj = new Vec3(),
                addToWlambda_ri = new Vec3(),
                addToWlambda_rj = new Vec3(),
                addToWlambda_Mdiag = new Vec3();

            /**
             * Add constraint velocity to the bodies.
             * @method addToWlambda
             * @param {Number} deltalambda
             */
            Equation.prototype.addToWlambda = function (deltalambda) {
                var GA = this.jacobianElementA,
                    GB = this.jacobianElementB,
                    bi = this.bi,
                    bj = this.bj,
                    temp = addToWlambda_temp;

                // Add to linear velocity
                // v_lambda += inv(M) * delta_lamba * G
                GA.spatial.mult(bi.invMassSolve * deltalambda, temp);
                bi.vlambda.vadd(temp, bi.vlambda);

                GB.spatial.mult(bj.invMassSolve * deltalambda, temp);
                bj.vlambda.vadd(temp, bj.vlambda);

                // Add to angular velocity
                if (bi.invInertiaWorldSolve) {
                    bi.invInertiaWorldSolve.vmult(GA.rotational, temp);
                    temp.mult(deltalambda, temp);
                    bi.wlambda.vadd(temp, bi.wlambda);
                }

                if (bj.invInertiaWorldSolve) {
                    bj.invInertiaWorldSolve.vmult(GB.rotational, temp);
                    temp.mult(deltalambda, temp);
                    bj.wlambda.vadd(temp, bj.wlambda);
                }
            };

            /**
             * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
             * @method computeInvC
             * @param  {Number} eps
             * @return {Number}
             */
            Equation.prototype.computeC = function () {
                return this.computeGiMGt() + this.eps;
            };

        }, { "../math/JacobianElement": 26, "../math/Vec3": 30 }], 21: [function (_dereq_, module, exports) {
            module.exports = FrictionEquation;

            var Equation = _dereq_('./Equation');
            var Vec3 = _dereq_('../math/Vec3');
            var Mat3 = _dereq_('../math/Mat3');

            /**
             * Constrains the slipping in a contact along a tangent
             * @class FrictionEquation
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
             * @extends Equation
             */
            function FrictionEquation(bodyA, bodyB, slipForce) {
                Equation.call(this, bodyA, bodyB, -slipForce, slipForce);
                this.ri = new Vec3();
                this.rj = new Vec3();
                this.t = new Vec3(); // tangent
            }

            FrictionEquation.prototype = new Equation();
            FrictionEquation.prototype.constructor = FrictionEquation;

            var FrictionEquation_computeB_temp1 = new Vec3();
            var FrictionEquation_computeB_temp2 = new Vec3();
            FrictionEquation.prototype.computeB = function (h) {
                var a = this.a,
                    b = this.b,
                    bi = this.bi,
                    bj = this.bj,
                    ri = this.ri,
                    rj = this.rj,
                    rixt = FrictionEquation_computeB_temp1,
                    rjxt = FrictionEquation_computeB_temp2,
                    t = this.t;

                // Caluclate cross products
                ri.cross(t, rixt);
                rj.cross(t, rjxt);

                // G = [-t -rixt t rjxt]
                // And remember, this is a pure velocity constraint, g is always zero!
                var GA = this.jacobianElementA,
                    GB = this.jacobianElementB;
                t.negate(GA.spatial);
                rixt.negate(GA.rotational);
                GB.spatial.copy(t);
                GB.rotational.copy(rjxt);

                var GW = this.computeGW();
                var GiMf = this.computeGiMf();

                var B = - GW * b - h * GiMf;

                return B;
            };

        }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 22: [function (_dereq_, module, exports) {
            module.exports = RotationalEquation;

            var Vec3 = _dereq_('../math/Vec3');
            var Mat3 = _dereq_('../math/Mat3');
            var Equation = _dereq_('./Equation');

            /**
             * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
             * @class RotationalEquation
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {Vec3} [options.axisA]
             * @param {Vec3} [options.axisB]
             * @param {number} [options.maxForce]
             * @extends Equation
             */
            function RotationalEquation(bodyA, bodyB, options) {
                options = options || {};
                var maxForce = typeof (options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

                Equation.call(this, bodyA, bodyB, -maxForce, maxForce);

                this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
                this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

                this.maxAngle = Math.PI / 2;
            }

            RotationalEquation.prototype = new Equation();
            RotationalEquation.prototype.constructor = RotationalEquation;

            var tmpVec1 = new Vec3();
            var tmpVec2 = new Vec3();

            RotationalEquation.prototype.computeB = function (h) {
                var a = this.a,
                    b = this.b,

                    ni = this.axisA,
                    nj = this.axisB,

                    nixnj = tmpVec1,
                    njxni = tmpVec2,

                    GA = this.jacobianElementA,
                    GB = this.jacobianElementB;

                // Caluclate cross products
                ni.cross(nj, nixnj);
                nj.cross(ni, njxni);

                // g = ni * nj
                // gdot = (nj x ni) * wi + (ni x nj) * wj
                // G = [0 njxni 0 nixnj]
                // W = [vi wi vj wj]
                GA.rotational.copy(njxni);
                GB.rotational.copy(nixnj);

                var g = Math.cos(this.maxAngle) - ni.dot(nj),
                    GW = this.computeGW(),
                    GiMf = this.computeGiMf();

                var B = - g * a - GW * b - h * GiMf;

                return B;
            };


        }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 23: [function (_dereq_, module, exports) {
            module.exports = RotationalMotorEquation;

            var Vec3 = _dereq_('../math/Vec3');
            var Mat3 = _dereq_('../math/Mat3');
            var Equation = _dereq_('./Equation');

            /**
             * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
             * @class RotationalMotorEquation
             * @constructor
             * @author schteppe
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {Number} maxForce
             * @extends Equation
             */
            function RotationalMotorEquation(bodyA, bodyB, maxForce) {
                maxForce = typeof (maxForce) !== 'undefined' ? maxForce : 1e6;
                Equation.call(this, bodyA, bodyB, -maxForce, maxForce);

                /**
                 * World oriented rotational axis
                 * @property {Vec3} axisA
                 */
                this.axisA = new Vec3();

                /**
                 * World oriented rotational axis
                 * @property {Vec3} axisB
                 */
                this.axisB = new Vec3(); // World oriented rotational axis

                /**
                 * Motor velocity
                 * @property {Number} targetVelocity
                 */
                this.targetVelocity = 0;
            }

            RotationalMotorEquation.prototype = new Equation();
            RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;

            RotationalMotorEquation.prototype.computeB = function (h) {
                var a = this.a,
                    b = this.b,
                    bi = this.bi,
                    bj = this.bj,

                    axisA = this.axisA,
                    axisB = this.axisB,

                    GA = this.jacobianElementA,
                    GB = this.jacobianElementB;

                // g = 0
                // gdot = axisA * wi - axisB * wj
                // gdot = G * W = G * [vi wi vj wj]
                // =>
                // G = [0 axisA 0 -axisB]

                GA.rotational.copy(axisA);
                axisB.negate(GB.rotational);

                var GW = this.computeGW() - this.targetVelocity,
                    GiMf = this.computeGiMf();

                var B = - GW * b - h * GiMf;

                return B;
            };

        }, { "../math/Mat3": 27, "../math/Vec3": 30, "./Equation": 20 }], 24: [function (_dereq_, module, exports) {
            var Utils = _dereq_('../utils/Utils');

            module.exports = ContactMaterial;

            /**
             * Defines what happens when two materials meet.
             * @class ContactMaterial
             * @constructor
             * @param {Material} m1
             * @param {Material} m2
             * @param {object} [options]
             * @param {Number} [options.friction=0.3]
             * @param {Number} [options.restitution=0.3]
             * @param {number} [options.contactEquationStiffness=1e7]
             * @param {number} [options.contactEquationRelaxation=3]
             * @param {number} [options.frictionEquationStiffness=1e7]
             * @param {Number} [options.frictionEquationRelaxation=3]
             */
            function ContactMaterial(m1, m2, options) {
                options = Utils.defaults(options, {
                    friction: 0.3,
                    restitution: 0.3,
                    contactEquationStiffness: 1e7,
                    contactEquationRelaxation: 3,
                    frictionEquationStiffness: 1e7,
                    frictionEquationRelaxation: 3
                });

                /**
                 * Identifier of this material
                 * @property {Number} id
                 */
                this.id = ContactMaterial.idCounter++;

                /**
                 * Participating materials
                 * @property {Array} materials
                 * @todo  Should be .materialA and .materialB instead
                 */
                this.materials = [m1, m2];

                /**
                 * Friction coefficient
                 * @property {Number} friction
                 */
                this.friction = options.friction;

                /**
                 * Restitution coefficient
                 * @property {Number} restitution
                 */
                this.restitution = options.restitution;

                /**
                 * Stiffness of the produced contact equations
                 * @property {Number} contactEquationStiffness
                 */
                this.contactEquationStiffness = options.contactEquationStiffness;

                /**
                 * Relaxation time of the produced contact equations
                 * @property {Number} contactEquationRelaxation
                 */
                this.contactEquationRelaxation = options.contactEquationRelaxation;

                /**
                 * Stiffness of the produced friction equations
                 * @property {Number} frictionEquationStiffness
                 */
                this.frictionEquationStiffness = options.frictionEquationStiffness;

                /**
                 * Relaxation time of the produced friction equations
                 * @property {Number} frictionEquationRelaxation
                 */
                this.frictionEquationRelaxation = options.frictionEquationRelaxation;
            }

            ContactMaterial.idCounter = 0;

        }, { "../utils/Utils": 53 }], 25: [function (_dereq_, module, exports) {
            module.exports = Material;

            /**
             * Defines a physics material.
             * @class Material
             * @constructor
             * @param {object} [options]
             * @author schteppe
             */
            function Material(options) {
                var name = '';
                options = options || {};

                // Backwards compatibility fix
                if (typeof (options) === 'string') {
                    name = options;
                    options = {};
                } else if (typeof (options) === 'object') {
                    name = '';
                }

                /**
                 * @property name
                 * @type {String}
                 */
                this.name = name;

                /**
                 * material id.
                 * @property id
                 * @type {number}
                 */
                this.id = Material.idCounter++;

                /**
                 * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
                 * @property {number} friction
                 */
                this.friction = typeof (options.friction) !== 'undefined' ? options.friction : -1;

                /**
                 * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
                 * @property {number} restitution
                 */
                this.restitution = typeof (options.restitution) !== 'undefined' ? options.restitution : -1;
            }

            Material.idCounter = 0;

        }, {}], 26: [function (_dereq_, module, exports) {
            module.exports = JacobianElement;

            var Vec3 = _dereq_('./Vec3');

            /**
             * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
             * @class JacobianElement
             * @constructor
             */
            function JacobianElement() {

                /**
                 * @property {Vec3} spatial
                 */
                this.spatial = new Vec3();

                /**
                 * @property {Vec3} rotational
                 */
                this.rotational = new Vec3();
            }

            /**
             * Multiply with other JacobianElement
             * @method multiplyElement
             * @param  {JacobianElement} element
             * @return {Number}
             */
            JacobianElement.prototype.multiplyElement = function (element) {
                return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
            };

            /**
             * Multiply with two vectors
             * @method multiplyVectors
             * @param  {Vec3} spatial
             * @param  {Vec3} rotational
             * @return {Number}
             */
            JacobianElement.prototype.multiplyVectors = function (spatial, rotational) {
                return spatial.dot(this.spatial) + rotational.dot(this.rotational);
            };

        }, { "./Vec3": 30 }], 27: [function (_dereq_, module, exports) {
            module.exports = Mat3;

            var Vec3 = _dereq_('./Vec3');

            /**
             * A 3x3 matrix.
             * @class Mat3
             * @constructor
             * @param array elements Array of nine elements. Optional.
             * @author schteppe / http://github.com/schteppe
             */
            function Mat3(elements) {
                /**
                 * A vector of length 9, containing all matrix elements
                 * @property {Array} elements
                 */
                if (elements) {
                    this.elements = elements;
                } else {
                    this.elements = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                }
            }

            /**
             * Sets the matrix to identity
             * @method identity
             * @todo Should perhaps be renamed to setIdentity() to be more clear.
             * @todo Create another function that immediately creates an identity matrix eg. eye()
             */
            Mat3.prototype.identity = function () {
                var e = this.elements;
                e[0] = 1;
                e[1] = 0;
                e[2] = 0;

                e[3] = 0;
                e[4] = 1;
                e[5] = 0;

                e[6] = 0;
                e[7] = 0;
                e[8] = 1;
            };

            /**
             * Set all elements to zero
             * @method setZero
             */
            Mat3.prototype.setZero = function () {
                var e = this.elements;
                e[0] = 0;
                e[1] = 0;
                e[2] = 0;
                e[3] = 0;
                e[4] = 0;
                e[5] = 0;
                e[6] = 0;
                e[7] = 0;
                e[8] = 0;
            };

            /**
             * Sets the matrix diagonal elements from a Vec3
             * @method setTrace
             * @param {Vec3} vec3
             */
            Mat3.prototype.setTrace = function (vec3) {
                var e = this.elements;
                e[0] = vec3.x;
                e[4] = vec3.y;
                e[8] = vec3.z;
            };

            /**
             * Gets the matrix diagonal elements
             * @method getTrace
             * @return {Vec3}
             */
            Mat3.prototype.getTrace = function (target) {
                var target = target || new Vec3();
                var e = this.elements;
                target.x = e[0];
                target.y = e[4];
                target.z = e[8];
            };

            /**
             * Matrix-Vector multiplication
             * @method vmult
             * @param {Vec3} v The vector to multiply with
             * @param {Vec3} target Optional, target to save the result in.
             */
            Mat3.prototype.vmult = function (v, target) {
                target = target || new Vec3();

                var e = this.elements,
                    x = v.x,
                    y = v.y,
                    z = v.z;
                target.x = e[0] * x + e[1] * y + e[2] * z;
                target.y = e[3] * x + e[4] * y + e[5] * z;
                target.z = e[6] * x + e[7] * y + e[8] * z;

                return target;
            };

            /**
             * Matrix-scalar multiplication
             * @method smult
             * @param {Number} s
             */
            Mat3.prototype.smult = function (s) {
                for (var i = 0; i < this.elements.length; i++) {
                    this.elements[i] *= s;
                }
            };

            /**
             * Matrix multiplication
             * @method mmult
             * @param {Mat3} m Matrix to multiply with from left side.
             * @return {Mat3} The result.
             */
            Mat3.prototype.mmult = function (m, target) {
                var r = target || new Mat3();
                for (var i = 0; i < 3; i++) {
                    for (var j = 0; j < 3; j++) {
                        var sum = 0.0;
                        for (var k = 0; k < 3; k++) {
                            sum += m.elements[i + k * 3] * this.elements[k + j * 3];
                        }
                        r.elements[i + j * 3] = sum;
                    }
                }
                return r;
            };

            /**
             * Scale each column of the matrix
             * @method scale
             * @param {Vec3} v
             * @return {Mat3} The result.
             */
            Mat3.prototype.scale = function (v, target) {
                target = target || new Mat3();
                var e = this.elements,
                    t = target.elements;
                for (var i = 0; i !== 3; i++) {
                    t[3 * i + 0] = v.x * e[3 * i + 0];
                    t[3 * i + 1] = v.y * e[3 * i + 1];
                    t[3 * i + 2] = v.z * e[3 * i + 2];
                }
                return target;
            };

            /**
             * Solve Ax=b
             * @method solve
             * @param {Vec3} b The right hand side
             * @param {Vec3} target Optional. Target vector to save in.
             * @return {Vec3} The solution x
             * @todo should reuse arrays
             */
            Mat3.prototype.solve = function (b, target) {
                target = target || new Vec3();

                // Construct equations
                var nr = 3; // num rows
                var nc = 4; // num cols
                var eqns = [];
                for (var i = 0; i < nr * nc; i++) {
                    eqns.push(0);
                }
                var i, j;
                for (i = 0; i < 3; i++) {
                    for (j = 0; j < 3; j++) {
                        eqns[i + nc * j] = this.elements[i + 3 * j];
                    }
                }
                eqns[3 + 4 * 0] = b.x;
                eqns[3 + 4 * 1] = b.y;
                eqns[3 + 4 * 2] = b.z;

                // Compute right upper triangular version of the matrix - Gauss elimination
                var n = 3, k = n, np;
                var kp = 4; // num rows
                var p, els;
                do {
                    i = k - n;
                    if (eqns[i + nc * i] === 0) {
                        // the pivot is null, swap lines
                        for (j = i + 1; j < k; j++) {
                            if (eqns[i + nc * j] !== 0) {
                                np = kp;
                                do {  // do ligne( i ) = ligne( i ) + ligne( k )
                                    p = kp - np;
                                    eqns[p + nc * i] += eqns[p + nc * j];
                                } while (--np);
                                break;
                            }
                        }
                    }
                    if (eqns[i + nc * i] !== 0) {
                        for (j = i + 1; j < k; j++) {
                            var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                            np = kp;
                            do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                                p = kp - np;
                                eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                            } while (--np);
                        }
                    }
                } while (--n);

                // Get the solution
                target.z = eqns[2 * nc + 3] / eqns[2 * nc + 2];
                target.y = (eqns[1 * nc + 3] - eqns[1 * nc + 2] * target.z) / eqns[1 * nc + 1];
                target.x = (eqns[0 * nc + 3] - eqns[0 * nc + 2] * target.z - eqns[0 * nc + 1] * target.y) / eqns[0 * nc + 0];

                if (isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x === Infinity || target.y === Infinity || target.z === Infinity) {
                    throw "Could not solve equation! Got x=[" + target.toString() + "], b=[" + b.toString() + "], A=[" + this.toString() + "]";
                }

                return target;
            };

            /**
             * Get an element in the matrix by index. Index starts at 0, not 1!!!
             * @method e
             * @param {Number} row
             * @param {Number} column
             * @param {Number} value Optional. If provided, the matrix element will be set to this value.
             * @return {Number}
             */
            Mat3.prototype.e = function (row, column, value) {
                if (value === undefined) {
                    return this.elements[column + 3 * row];
                } else {
                    // Set value
                    this.elements[column + 3 * row] = value;
                }
            };

            /**
             * Copy another matrix into this matrix object.
             * @method copy
             * @param {Mat3} source
             * @return {Mat3} this
             */
            Mat3.prototype.copy = function (source) {
                for (var i = 0; i < source.elements.length; i++) {
                    this.elements[i] = source.elements[i];
                }
                return this;
            };

            /**
             * Returns a string representation of the matrix.
             * @method toString
             * @return string
             */
            Mat3.prototype.toString = function () {
                var r = "";
                var sep = ",";
                for (var i = 0; i < 9; i++) {
                    r += this.elements[i] + sep;
                }
                return r;
            };

            /**
             * reverse the matrix
             * @method reverse
             * @param {Mat3} target Optional. Target matrix to save in.
             * @return {Mat3} The solution x
             */
            Mat3.prototype.reverse = function (target) {

                target = target || new Mat3();

                // Construct equations
                var nr = 3; // num rows
                var nc = 6; // num cols
                var eqns = [];
                for (var i = 0; i < nr * nc; i++) {
                    eqns.push(0);
                }
                var i, j;
                for (i = 0; i < 3; i++) {
                    for (j = 0; j < 3; j++) {
                        eqns[i + nc * j] = this.elements[i + 3 * j];
                    }
                }
                eqns[3 + 6 * 0] = 1;
                eqns[3 + 6 * 1] = 0;
                eqns[3 + 6 * 2] = 0;
                eqns[4 + 6 * 0] = 0;
                eqns[4 + 6 * 1] = 1;
                eqns[4 + 6 * 2] = 0;
                eqns[5 + 6 * 0] = 0;
                eqns[5 + 6 * 1] = 0;
                eqns[5 + 6 * 2] = 1;

                // Compute right upper triangular version of the matrix - Gauss elimination
                var n = 3, k = n, np;
                var kp = nc; // num rows
                var p;
                do {
                    i = k - n;
                    if (eqns[i + nc * i] === 0) {
                        // the pivot is null, swap lines
                        for (j = i + 1; j < k; j++) {
                            if (eqns[i + nc * j] !== 0) {
                                np = kp;
                                do { // do line( i ) = line( i ) + line( k )
                                    p = kp - np;
                                    eqns[p + nc * i] += eqns[p + nc * j];
                                } while (--np);
                                break;
                            }
                        }
                    }
                    if (eqns[i + nc * i] !== 0) {
                        for (j = i + 1; j < k; j++) {
                            var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                            np = kp;
                            do { // do line( k ) = line( k ) - multiplier * line( i )
                                p = kp - np;
                                eqns[p + nc * j] = p <= i ? 0 : eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                            } while (--np);
                        }
                    }
                } while (--n);

                // eliminate the upper left triangle of the matrix
                i = 2;
                do {
                    j = i - 1;
                    do {
                        var multiplier = eqns[i + nc * j] / eqns[i + nc * i];
                        np = nc;
                        do {
                            p = nc - np;
                            eqns[p + nc * j] = eqns[p + nc * j] - eqns[p + nc * i] * multiplier;
                        } while (--np);
                    } while (j--);
                } while (--i);

                // operations on the diagonal
                i = 2;
                do {
                    var multiplier = 1 / eqns[i + nc * i];
                    np = nc;
                    do {
                        p = nc - np;
                        eqns[p + nc * i] = eqns[p + nc * i] * multiplier;
                    } while (--np);
                } while (i--);

                i = 2;
                do {
                    j = 2;
                    do {
                        p = eqns[nr + j + nc * i];
                        if (isNaN(p) || p === Infinity) {
                            throw "Could not reverse! A=[" + this.toString() + "]";
                        }
                        target.e(i, j, p);
                    } while (j--);
                } while (i--);

                return target;
            };

            /**
             * Set the matrix from a quaterion
             * @method setRotationFromQuaternion
             * @param {Quaternion} q
             */
            Mat3.prototype.setRotationFromQuaternion = function (q) {
                var x = q.x, y = q.y, z = q.z, w = q.w,
                    x2 = x + x, y2 = y + y, z2 = z + z,
                    xx = x * x2, xy = x * y2, xz = x * z2,
                    yy = y * y2, yz = y * z2, zz = z * z2,
                    wx = w * x2, wy = w * y2, wz = w * z2,
                    e = this.elements;

                e[3 * 0 + 0] = 1 - (yy + zz);
                e[3 * 0 + 1] = xy - wz;
                e[3 * 0 + 2] = xz + wy;

                e[3 * 1 + 0] = xy + wz;
                e[3 * 1 + 1] = 1 - (xx + zz);
                e[3 * 1 + 2] = yz - wx;

                e[3 * 2 + 0] = xz - wy;
                e[3 * 2 + 1] = yz + wx;
                e[3 * 2 + 2] = 1 - (xx + yy);

                return this;
            };

            /**
             * Transpose the matrix
             * @method transpose
             * @param  {Mat3} target Where to store the result.
             * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
             */
            Mat3.prototype.transpose = function (target) {
                target = target || new Mat3();

                var Mt = target.elements,
                    M = this.elements;

                for (var i = 0; i !== 3; i++) {
                    for (var j = 0; j !== 3; j++) {
                        Mt[3 * i + j] = M[3 * j + i];
                    }
                }

                return target;
            };

        }, { "./Vec3": 30 }], 28: [function (_dereq_, module, exports) {
            module.exports = Quaternion;

            var Vec3 = _dereq_('./Vec3');

            /**
             * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
             * @class Quaternion
             * @constructor
             * @param {Number} x Multiplier of the imaginary basis vector i.
             * @param {Number} y Multiplier of the imaginary basis vector j.
             * @param {Number} z Multiplier of the imaginary basis vector k.
             * @param {Number} w Multiplier of the real part.
             * @see http://en.wikipedia.org/wiki/Quaternion
             */
            function Quaternion(x, y, z, w) {
                /**
                 * @property {Number} x
                 */
                this.x = x !== undefined ? x : 0;

                /**
                 * @property {Number} y
                 */
                this.y = y !== undefined ? y : 0;

                /**
                 * @property {Number} z
                 */
                this.z = z !== undefined ? z : 0;

                /**
                 * The multiplier of the real quaternion basis vector.
                 * @property {Number} w
                 */
                this.w = w !== undefined ? w : 1;
            }

            /**
             * Set the value of the quaternion.
             * @method set
             * @param {Number} x
             * @param {Number} y
             * @param {Number} z
             * @param {Number} w
             */
            Quaternion.prototype.set = function (x, y, z, w) {
                this.x = x;
                this.y = y;
                this.z = z;
                this.w = w;
            };

            /**
             * Convert to a readable format
             * @method toString
             * @return string
             */
            Quaternion.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z + "," + this.w;
            };

            /**
             * Convert to an Array
             * @method toArray
             * @return Array
             */
            Quaternion.prototype.toArray = function () {
                return [this.x, this.y, this.z, this.w];
            };

            /**
             * Set the quaternion components given an axis and an angle.
             * @method setFromAxisAngle
             * @param {Vec3} axis
             * @param {Number} angle in radians
             */
            Quaternion.prototype.setFromAxisAngle = function (axis, angle) {
                var s = Math.sin(angle * 0.5);
                this.x = axis.x * s;
                this.y = axis.y * s;
                this.z = axis.z * s;
                this.w = Math.cos(angle * 0.5);
            };

            /**
             * Converts the quaternion to axis/angle representation.
             * @method toAxisAngle
             * @param {Vec3} targetAxis Optional. A vector object to reuse for storing the axis.
             * @return Array An array, first elemnt is the axis and the second is the angle in radians.
             */
            Quaternion.prototype.toAxisAngle = function (targetAxis) {
                targetAxis = targetAxis || new Vec3();
                this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
                var angle = 2 * Math.acos(this.w);
                var s = Math.sqrt(1 - this.w * this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
                if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
                    // if s close to zero then direction of axis not important
                    targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
                    targetAxis.y = this.y;
                    targetAxis.z = this.z;
                } else {
                    targetAxis.x = this.x / s; // normalise axis
                    targetAxis.y = this.y / s;
                    targetAxis.z = this.z / s;
                }
                return [targetAxis, angle];
            };

            var sfv_t1 = new Vec3(),
                sfv_t2 = new Vec3();

            /**
             * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
             * @method setFromVectors
             * @param {Vec3} u
             * @param {Vec3} v
             */
            Quaternion.prototype.setFromVectors = function (u, v) {
                if (u.isAntiparallelTo(v)) {
                    var t1 = sfv_t1;
                    var t2 = sfv_t2;

                    u.tangents(t1, t2);
                    this.setFromAxisAngle(t1, Math.PI);
                } else {
                    var a = u.cross(v);
                    this.x = a.x;
                    this.y = a.y;
                    this.z = a.z;
                    this.w = Math.sqrt(Math.pow(u.norm(), 2) * Math.pow(v.norm(), 2)) + u.dot(v);
                    this.normalize();
                }
            };

            /**
             * Quaternion multiplication
             * @method mult
             * @param {Quaternion} q
             * @param {Quaternion} target Optional.
             * @return {Quaternion}
             */
            var Quaternion_mult_va = new Vec3();
            var Quaternion_mult_vb = new Vec3();
            var Quaternion_mult_vaxvb = new Vec3();
            Quaternion.prototype.mult = function (q, target) {
                target = target || new Quaternion();
                var w = this.w,
                    va = Quaternion_mult_va,
                    vb = Quaternion_mult_vb,
                    vaxvb = Quaternion_mult_vaxvb;

                va.set(this.x, this.y, this.z);
                vb.set(q.x, q.y, q.z);
                target.w = w * q.w - va.dot(vb);
                va.cross(vb, vaxvb);

                target.x = w * vb.x + q.w * va.x + vaxvb.x;
                target.y = w * vb.y + q.w * va.y + vaxvb.y;
                target.z = w * vb.z + q.w * va.z + vaxvb.z;

                return target;
            };

            /**
             * Get the inverse quaternion rotation.
             * @method inverse
             * @param {Quaternion} target
             * @return {Quaternion}
             */
            Quaternion.prototype.inverse = function (target) {
                var x = this.x, y = this.y, z = this.z, w = this.w;
                target = target || new Quaternion();

                this.conjugate(target);
                var inorm2 = 1 / (x * x + y * y + z * z + w * w);
                target.x *= inorm2;
                target.y *= inorm2;
                target.z *= inorm2;
                target.w *= inorm2;

                return target;
            };

            /**
             * Get the quaternion conjugate
             * @method conjugate
             * @param {Quaternion} target
             * @return {Quaternion}
             */
            Quaternion.prototype.conjugate = function (target) {
                target = target || new Quaternion();

                target.x = -this.x;
                target.y = -this.y;
                target.z = -this.z;
                target.w = this.w;

                return target;
            };

            /**
             * Normalize the quaternion. Note that this changes the values of the quaternion.
             * @method normalize
             */
            Quaternion.prototype.normalize = function () {
                var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                if (l === 0) {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                    this.w = 0;
                } else {
                    l = 1 / l;
                    this.x *= l;
                    this.y *= l;
                    this.z *= l;
                    this.w *= l;
                }
            };

            /**
             * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
             * @method normalizeFast
             * @see http://jsperf.com/fast-quaternion-normalization
             * @author unphased, https://github.com/unphased
             */
            Quaternion.prototype.normalizeFast = function () {
                var f = (3.0 - (this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)) / 2.0;
                if (f === 0) {
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                    this.w = 0;
                } else {
                    this.x *= f;
                    this.y *= f;
                    this.z *= f;
                    this.w *= f;
                }
            };

            /**
             * Multiply the quaternion by a vector
             * @method vmult
             * @param {Vec3} v
             * @param {Vec3} target Optional
             * @return {Vec3}
             */
            Quaternion.prototype.vmult = function (v, target) {
                target = target || new Vec3();

                var x = v.x,
                    y = v.y,
                    z = v.z;

                var qx = this.x,
                    qy = this.y,
                    qz = this.z,
                    qw = this.w;

                // q*v
                var ix = qw * x + qy * z - qz * y,
                    iy = qw * y + qz * x - qx * z,
                    iz = qw * z + qx * y - qy * x,
                    iw = -qx * x - qy * y - qz * z;

                target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
                target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
                target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

                return target;
            };

            /**
             * Copies value of source to this quaternion.
             * @method copy
             * @param {Quaternion} source
             * @return {Quaternion} this
             */
            Quaternion.prototype.copy = function (source) {
                this.x = source.x;
                this.y = source.y;
                this.z = source.z;
                this.w = source.w;
                return this;
            };

            /**
             * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
             * @method toEuler
             * @param {Vec3} target
             * @param string order Three-character string e.g. "YZX", which also is default.
             */
            Quaternion.prototype.toEuler = function (target, order) {
                order = order || "YZX";

                var heading, attitude, bank;
                var x = this.x, y = this.y, z = this.z, w = this.w;

                switch (order) {
                    case "YZX":
                        var test = x * y + z * w;
                        if (test > 0.499) { // singularity at north pole
                            heading = 2 * Math.atan2(x, w);
                            attitude = Math.PI / 2;
                            bank = 0;
                        }
                        if (test < -0.499) { // singularity at south pole
                            heading = -2 * Math.atan2(x, w);
                            attitude = - Math.PI / 2;
                            bank = 0;
                        }
                        if (isNaN(heading)) {
                            var sqx = x * x;
                            var sqy = y * y;
                            var sqz = z * z;
                            heading = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * sqy - 2 * sqz); // Heading
                            attitude = Math.asin(2 * test); // attitude
                            bank = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * sqx - 2 * sqz); // bank
                        }
                        break;
                    default:
                        throw new Error("Euler order " + order + " not supported yet.");
                }

                target.y = heading;
                target.z = attitude;
                target.x = bank;
            };

            /**
             * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
             * @method setFromEuler
             * @param {Number} x
             * @param {Number} y
             * @param {Number} z
             * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
             */
            Quaternion.prototype.setFromEuler = function (x, y, z, order) {
                order = order || "XYZ";

                var c1 = Math.cos(x / 2);
                var c2 = Math.cos(y / 2);
                var c3 = Math.cos(z / 2);
                var s1 = Math.sin(x / 2);
                var s2 = Math.sin(y / 2);
                var s3 = Math.sin(z / 2);

                if (order === 'XYZ') {

                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;

                } else if (order === 'YXZ') {

                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;

                } else if (order === 'ZXY') {

                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;

                } else if (order === 'ZYX') {

                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;

                } else if (order === 'YZX') {

                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;

                } else if (order === 'XZY') {

                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;

                }

                return this;

            };

            Quaternion.prototype.clone = function () {
                return new Quaternion(this.x, this.y, this.z, this.w);
            };
        }, { "./Vec3": 30 }], 29: [function (_dereq_, module, exports) {
            var Vec3 = _dereq_('./Vec3');
            var Quaternion = _dereq_('./Quaternion');

            module.exports = Transform;

            /**
             * @class Transform
             * @constructor
             */
            function Transform(options) {
                options = options || {};

                /**
                 * @property {Vec3} position
                 */
                this.position = new Vec3();
                if (options.position) {
                    this.position.copy(options.position);
                }

                /**
                 * @property {Quaternion} quaternion
                 */
                this.quaternion = new Quaternion();
                if (options.quaternion) {
                    this.quaternion.copy(options.quaternion);
                }
            }

            var tmpQuat = new Quaternion();

            /**
             * @static
             * @method pointToLocaFrame
             * @param {Vec3} position
             * @param {Quaternion} quaternion
             * @param {Vec3} worldPoint
             * @param {Vec3} result
             */
            Transform.pointToLocalFrame = function (position, quaternion, worldPoint, result) {
                var result = result || new Vec3();
                worldPoint.vsub(position, result);
                quaternion.conjugate(tmpQuat);
                tmpQuat.vmult(result, result);
                return result;
            };

            /**
             * Get a global point in local transform coordinates.
             * @method pointToLocal
             * @param  {Vec3} point
             * @param  {Vec3} result
             * @return {Vec3} The "result" vector object
             */
            Transform.prototype.pointToLocal = function (worldPoint, result) {
                return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
            };

            /**
             * @static
             * @method pointToWorldFrame
             * @param {Vec3} position
             * @param {Vec3} quaternion
             * @param {Vec3} localPoint
             * @param {Vec3} result
             */
            Transform.pointToWorldFrame = function (position, quaternion, localPoint, result) {
                var result = result || new Vec3();
                quaternion.vmult(localPoint, result);
                result.vadd(position, result);
                return result;
            };

            /**
             * Get a local point in global transform coordinates.
             * @method pointToWorld
             * @param  {Vec3} point
             * @param  {Vec3} result
             * @return {Vec3} The "result" vector object
             */
            Transform.prototype.pointToWorld = function (localPoint, result) {
                return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
            };


            Transform.prototype.vectorToWorldFrame = function (localVector, result) {
                var result = result || new Vec3();
                this.quaternion.vmult(localVector, result);
                return result;
            };

            Transform.vectorToWorldFrame = function (quaternion, localVector, result) {
                quaternion.vmult(localVector, result);
                return result;
            };

            Transform.vectorToLocalFrame = function (position, quaternion, worldVector, result) {
                var result = result || new Vec3();
                quaternion.w *= -1;
                quaternion.vmult(worldVector, result);
                quaternion.w *= -1;
                return result;
            };

        }, { "./Quaternion": 28, "./Vec3": 30 }], 30: [function (_dereq_, module, exports) {
            module.exports = Vec3;

            var Mat3 = _dereq_('./Mat3');

            /**
             * 3-dimensional vector
             * @class Vec3
             * @constructor
             * @param {Number} x
             * @param {Number} y
             * @param {Number} z
             * @author schteppe
             * @example
             *     var v = new Vec3(1, 2, 3);
             *     console.log('x=' + v.x); // x=1
             */
            function Vec3(x, y, z) {
                /**
                 * @property x
                 * @type {Number}
                 */
                this.x = x || 0.0;

                /**
                 * @property y
                 * @type {Number}
                 */
                this.y = y || 0.0;

                /**
                 * @property z
                 * @type {Number}
                 */
                this.z = z || 0.0;
            }

            /**
             * @static
             * @property {Vec3} ZERO
             */
            Vec3.ZERO = new Vec3(0, 0, 0);

            /**
             * @static
             * @property {Vec3} UNIT_X
             */
            Vec3.UNIT_X = new Vec3(1, 0, 0);

            /**
             * @static
             * @property {Vec3} UNIT_Y
             */
            Vec3.UNIT_Y = new Vec3(0, 1, 0);

            /**
             * @static
             * @property {Vec3} UNIT_Z
             */
            Vec3.UNIT_Z = new Vec3(0, 0, 1);

            /**
             * Vector cross product
             * @method cross
             * @param {Vec3} v
             * @param {Vec3} target Optional. Target to save in.
             * @return {Vec3}
             */
            Vec3.prototype.cross = function (v, target) {
                var vx = v.x, vy = v.y, vz = v.z, x = this.x, y = this.y, z = this.z;
                target = target || new Vec3();

                target.x = (y * vz) - (z * vy);
                target.y = (z * vx) - (x * vz);
                target.z = (x * vy) - (y * vx);

                return target;
            };

            /**
             * Set the vectors' 3 elements
             * @method set
             * @param {Number} x
             * @param {Number} y
             * @param {Number} z
             * @return Vec3
             */
            Vec3.prototype.set = function (x, y, z) {
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            };

            /**
             * Set all components of the vector to zero.
             * @method setZero
             */
            Vec3.prototype.setZero = function () {
                this.x = this.y = this.z = 0;
            };

            /**
             * Vector addition
             * @method vadd
             * @param {Vec3} v
             * @param {Vec3} target Optional.
             * @return {Vec3}
             */
            Vec3.prototype.vadd = function (v, target) {
                if (target) {
                    target.x = v.x + this.x;
                    target.y = v.y + this.y;
                    target.z = v.z + this.z;
                } else {
                    return new Vec3(this.x + v.x,
                        this.y + v.y,
                        this.z + v.z);
                }
            };

            /**
             * Vector subtraction
             * @method vsub
             * @param {Vec3} v
             * @param {Vec3} target Optional. Target to save in.
             * @return {Vec3}
             */
            Vec3.prototype.vsub = function (v, target) {
                if (target) {
                    target.x = this.x - v.x;
                    target.y = this.y - v.y;
                    target.z = this.z - v.z;
                } else {
                    return new Vec3(this.x - v.x,
                        this.y - v.y,
                        this.z - v.z);
                }
            };

            /**
             * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
             * @method crossmat
             * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
             * @return {Mat3}
             */
            Vec3.prototype.crossmat = function () {
                return new Mat3([0, -this.z, this.y,
                    this.z, 0, -this.x,
                    -this.y, this.x, 0]);
            };

            /**
             * Normalize the vector. Note that this changes the values in the vector.
             * @method normalize
             * @return {Number} Returns the norm of the vector
             */
            Vec3.prototype.normalize = function () {
                var x = this.x, y = this.y, z = this.z;
                var n = Math.sqrt(x * x + y * y + z * z);
                if (n > 0.0) {
                    var invN = 1 / n;
                    this.x *= invN;
                    this.y *= invN;
                    this.z *= invN;
                } else {
                    // Make something up
                    this.x = 0;
                    this.y = 0;
                    this.z = 0;
                }
                return n;
            };

            /**
             * Get the version of this vector that is of length 1.
             * @method unit
             * @param {Vec3} target Optional target to save in
             * @return {Vec3} Returns the unit vector
             */
            Vec3.prototype.unit = function (target) {
                target = target || new Vec3();
                var x = this.x, y = this.y, z = this.z;
                var ninv = Math.sqrt(x * x + y * y + z * z);
                if (ninv > 0.0) {
                    ninv = 1.0 / ninv;
                    target.x = x * ninv;
                    target.y = y * ninv;
                    target.z = z * ninv;
                } else {
                    target.x = 1;
                    target.y = 0;
                    target.z = 0;
                }
                return target;
            };

            /**
             * Get the length of the vector
             * @method norm
             * @return {Number}
             * @deprecated Use .length() instead
             */
            Vec3.prototype.norm = function () {
                var x = this.x, y = this.y, z = this.z;
                return Math.sqrt(x * x + y * y + z * z);
            };

            /**
             * Get the length of the vector
             * @method length
             * @return {Number}
             */
            Vec3.prototype.length = Vec3.prototype.norm;

            /**
             * Get the squared length of the vector
             * @method norm2
             * @return {Number}
             * @deprecated Use .lengthSquared() instead.
             */
            Vec3.prototype.norm2 = function () {
                return this.dot(this);
            };

            /**
             * Get the squared length of the vector.
             * @method lengthSquared
             * @return {Number}
             */
            Vec3.prototype.lengthSquared = Vec3.prototype.norm2;

            /**
             * Get distance from this point to another point
             * @method distanceTo
             * @param  {Vec3} p
             * @return {Number}
             */
            Vec3.prototype.distanceTo = function (p) {
                var x = this.x, y = this.y, z = this.z;
                var px = p.x, py = p.y, pz = p.z;
                return Math.sqrt((px - x) * (px - x) +
                    (py - y) * (py - y) +
                    (pz - z) * (pz - z));
            };

            /**
             * Get squared distance from this point to another point
             * @method distanceSquared
             * @param  {Vec3} p
             * @return {Number}
             */
            Vec3.prototype.distanceSquared = function (p) {
                var x = this.x, y = this.y, z = this.z;
                var px = p.x, py = p.y, pz = p.z;
                return (px - x) * (px - x) + (py - y) * (py - y) + (pz - z) * (pz - z);
            };

            /**
             * Multiply all the components of the vector with a scalar.
             * @deprecated Use .scale instead
             * @method mult
             * @param {Number} scalar
             * @param {Vec3} target The vector to save the result in.
             * @return {Vec3}
             * @deprecated Use .scale() instead
             */
            Vec3.prototype.mult = function (scalar, target) {
                target = target || new Vec3();
                var x = this.x,
                    y = this.y,
                    z = this.z;
                target.x = scalar * x;
                target.y = scalar * y;
                target.z = scalar * z;
                return target;
            };

            /**
             * Multiply the vector with a scalar.
             * @method scale
             * @param {Number} scalar
             * @param {Vec3} target
             * @return {Vec3}
             */
            Vec3.prototype.scale = Vec3.prototype.mult;

            /**
             * Calculate dot product
             * @method dot
             * @param {Vec3} v
             * @return {Number}
             */
            Vec3.prototype.dot = function (v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            };

            /**
             * @method isZero
             * @return bool
             */
            Vec3.prototype.isZero = function () {
                return this.x === 0 && this.y === 0 && this.z === 0;
            };

            /**
             * Make the vector point in the opposite direction.
             * @method negate
             * @param {Vec3} target Optional target to save in
             * @return {Vec3}
             */
            Vec3.prototype.negate = function (target) {
                target = target || new Vec3();
                target.x = -this.x;
                target.y = -this.y;
                target.z = -this.z;
                return target;
            };

            /**
             * Compute two artificial tangents to the vector
             * @method tangents
             * @param {Vec3} t1 Vector object to save the first tangent in
             * @param {Vec3} t2 Vector object to save the second tangent in
             */
            var Vec3_tangents_n = new Vec3();
            var Vec3_tangents_randVec = new Vec3();
            Vec3.prototype.tangents = function (t1, t2) {
                var norm = this.norm();
                if (norm > 0.0) {
                    var n = Vec3_tangents_n;
                    var inorm = 1 / norm;
                    n.set(this.x * inorm, this.y * inorm, this.z * inorm);
                    var randVec = Vec3_tangents_randVec;
                    if (Math.abs(n.x) < 0.9) {
                        randVec.set(1, 0, 0);
                        n.cross(randVec, t1);
                    } else {
                        randVec.set(0, 1, 0);
                        n.cross(randVec, t1);
                    }
                    n.cross(t1, t2);
                } else {
                    // The normal length is zero, make something up
                    t1.set(1, 0, 0);
                    t2.set(0, 1, 0);
                }
            };

            /**
             * Converts to a more readable format
             * @method toString
             * @return string
             */
            Vec3.prototype.toString = function () {
                return this.x + "," + this.y + "," + this.z;
            };

            /**
             * Converts to an array
             * @method toArray
             * @return Array
             */
            Vec3.prototype.toArray = function () {
                return [this.x, this.y, this.z];
            };

            /**
             * Copies value of source to this vector.
             * @method copy
             * @param {Vec3} source
             * @return {Vec3} this
             */
            Vec3.prototype.copy = function (source) {
                this.x = source.x;
                this.y = source.y;
                this.z = source.z;
                return this;
            };


            /**
             * Do a linear interpolation between two vectors
             * @method lerp
             * @param {Vec3} v
             * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
             * @param {Vec3} target
             */
            Vec3.prototype.lerp = function (v, t, target) {
                var x = this.x, y = this.y, z = this.z;
                target.x = x + (v.x - x) * t;
                target.y = y + (v.y - y) * t;
                target.z = z + (v.z - z) * t;
            };

            /**
             * Check if a vector equals is almost equal to another one.
             * @method almostEquals
             * @param {Vec3} v
             * @param {Number} precision
             * @return bool
             */
            Vec3.prototype.almostEquals = function (v, precision) {
                if (precision === undefined) {
                    precision = 1e-6;
                }
                if (Math.abs(this.x - v.x) > precision ||
                    Math.abs(this.y - v.y) > precision ||
                    Math.abs(this.z - v.z) > precision) {
                    return false;
                }
                return true;
            };

            /**
             * Check if a vector is almost zero
             * @method almostZero
             * @param {Number} precision
             */
            Vec3.prototype.almostZero = function (precision) {
                if (precision === undefined) {
                    precision = 1e-6;
                }
                if (Math.abs(this.x) > precision ||
                    Math.abs(this.y) > precision ||
                    Math.abs(this.z) > precision) {
                    return false;
                }
                return true;
            };

            var antip_neg = new Vec3();

            /**
             * Check if the vector is anti-parallel to another vector.
             * @method isAntiparallelTo
             * @param  {Vec3}  v
             * @param  {Number}  precision Set to zero for exact comparisons
             * @return {Boolean}
             */
            Vec3.prototype.isAntiparallelTo = function (v, precision) {
                this.negate(antip_neg);
                return antip_neg.almostEquals(v, precision);
            };

            /**
             * Clone the vector
             * @method clone
             * @return {Vec3}
             */
            Vec3.prototype.clone = function () {
                return new Vec3(this.x, this.y, this.z);
            };
        }, { "./Mat3": 27 }], 31: [function (_dereq_, module, exports) {
            module.exports = Body;

            var EventTarget = _dereq_('../utils/EventTarget');
            var Shape = _dereq_('../shapes/Shape');
            var Vec3 = _dereq_('../math/Vec3');
            var Mat3 = _dereq_('../math/Mat3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Material = _dereq_('../material/Material');
            var AABB = _dereq_('../collision/AABB');
            var Box = _dereq_('../shapes/Box');

            /**
             * Base class for all body types.
             * @class Body
             * @constructor
             * @extends EventTarget
             * @param {object} [options]
             * @param {Vec3} [options.position]
             * @param {Vec3} [options.velocity]
             * @param {Vec3} [options.angularVelocity]
             * @param {Quaternion} [options.quaternion]
             * @param {number} [options.mass]
             * @param {Material} [options.material]
             * @param {number} [options.type]
             * @param {number} [options.linearDamping=0.01]
             * @param {number} [options.angularDamping=0.01]
             * @param {boolean} [options.allowSleep=true]
             * @param {number} [options.sleepSpeedLimit=0.1]
             * @param {number} [options.sleepTimeLimit=1]
             * @param {number} [options.collisionFilterGroup=1]
             * @param {number} [options.collisionFilterMask=1]
             * @param {boolean} [options.fixedRotation=false]
             * @param {Body} [options.shape]
             * @example
             *     var body = new Body({
             *         mass: 1
             *     });
             *     var shape = new Sphere(1);
             *     body.addShape(shape);
             *     world.add(body);
             */
            function Body(options) {
                options = options || {};

                EventTarget.apply(this);

                this.id = Body.idCounter++;

                /**
                 * Reference to the world the body is living in
                 * @property world
                 * @type {World}
                 */
                this.world = null;

                /**
                 * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
                 * @property preStep
                 * @type {Function}
                 * @deprecated Use World events instead
                 */
                this.preStep = null;

                /**
                 * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
                 * @property postStep
                 * @type {Function}
                 * @deprecated Use World events instead
                 */
                this.postStep = null;

                this.vlambda = new Vec3();

                /**
                 * @property {Number} collisionFilterGroup
                 */
                this.collisionFilterGroup = typeof (options.collisionFilterGroup) === 'number' ? options.collisionFilterGroup : 1;

                /**
                 * @property {Number} collisionFilterMask
                 */
                this.collisionFilterMask = typeof (options.collisionFilterMask) === 'number' ? options.collisionFilterMask : 1;

                /**
                 * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
                 * @property {Number} collisionResponse
                 */
                this.collisionResponse = true;

                /**
                 * @property position
                 * @type {Vec3}
                 */
                this.position = new Vec3();

                if (options.position) {
                    this.position.copy(options.position);
                }

                /**
                 * @property {Vec3} previousPosition
                 */
                this.previousPosition = new Vec3();

                /**
                 * Initial position of the body
                 * @property initPosition
                 * @type {Vec3}
                 */
                this.initPosition = new Vec3();

                /**
                 * @property velocity
                 * @type {Vec3}
                 */
                this.velocity = new Vec3();

                if (options.velocity) {
                    this.velocity.copy(options.velocity);
                }

                /**
                 * @property initVelocity
                 * @type {Vec3}
                 */
                this.initVelocity = new Vec3();

                /**
                 * Linear force on the body
                 * @property force
                 * @type {Vec3}
                 */
                this.force = new Vec3();

                var mass = typeof (options.mass) === 'number' ? options.mass : 0;

                /**
                 * @property mass
                 * @type {Number}
                 * @default 0
                 */
                this.mass = mass;

                /**
                 * @property invMass
                 * @type {Number}
                 */
                this.invMass = mass > 0 ? 1.0 / mass : 0;

                /**
                 * @property material
                 * @type {Material}
                 */
                this.material = options.material || null;

                /**
                 * @property linearDamping
                 * @type {Number}
                 */
                this.linearDamping = typeof (options.linearDamping) === 'number' ? options.linearDamping : 0.01;

                /**
                 * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
                 * @property type
                 * @type {Number}
                 */
                this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);
                if (typeof (options.type) === typeof (Body.STATIC)) {
                    this.type = options.type;
                }

                /**
                 * If true, the body will automatically fall to sleep.
                 * @property allowSleep
                 * @type {Boolean}
                 * @default true
                 */
                this.allowSleep = typeof (options.allowSleep) !== 'undefined' ? options.allowSleep : true;

                /**
                 * Current sleep state.
                 * @property sleepState
                 * @type {Number}
                 */
                this.sleepState = 0;

                /**
                 * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
                 * @property sleepSpeedLimit
                 * @type {Number}
                 * @default 0.1
                 */
                this.sleepSpeedLimit = typeof (options.sleepSpeedLimit) !== 'undefined' ? options.sleepSpeedLimit : 0.1;

                /**
                 * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
                 * @property sleepTimeLimit
                 * @type {Number}
                 * @default 1
                 */
                this.sleepTimeLimit = typeof (options.sleepTimeLimit) !== 'undefined' ? options.sleepTimeLimit : 1;

                this.timeLastSleepy = 0;

                this._wakeUpAfterNarrowphase = false;


                /**
                 * Rotational force on the body, around center of mass
                 * @property {Vec3} torque
                 */
                this.torque = new Vec3();

                /**
                 * Orientation of the body
                 * @property quaternion
                 * @type {Quaternion}
                 */
                this.quaternion = new Quaternion();

                if (options.quaternion) {
                    this.quaternion.copy(options.quaternion);
                }

                /**
                 * @property initQuaternion
                 * @type {Quaternion}
                 */
                this.initQuaternion = new Quaternion();

                /**
                 * @property angularVelocity
                 * @type {Vec3}
                 */
                this.angularVelocity = new Vec3();

                if (options.angularVelocity) {
                    this.angularVelocity.copy(options.angularVelocity);
                }

                /**
                 * @property initAngularVelocity
                 * @type {Vec3}
                 */
                this.initAngularVelocity = new Vec3();

                this.interpolatedPosition = new Vec3();
                this.interpolatedQuaternion = new Quaternion();

                /**
                 * @property shapes
                 * @type {array}
                 */
                this.shapes = [];

                /**
                 * @property shapeOffsets
                 * @type {array}
                 */
                this.shapeOffsets = [];

                /**
                 * @property shapeOrientations
                 * @type {array}
                 */
                this.shapeOrientations = [];

                /**
                 * @property inertia
                 * @type {Vec3}
                 */
                this.inertia = new Vec3();

                /**
                 * @property {Vec3} invInertia
                 */
                this.invInertia = new Vec3();

                /**
                 * @property {Mat3} invInertiaWorld
                 */
                this.invInertiaWorld = new Mat3();

                this.invMassSolve = 0;

                /**
                 * @property {Vec3} invInertiaSolve
                 */
                this.invInertiaSolve = new Vec3();

                /**
                 * @property {Mat3} invInertiaWorldSolve
                 */
                this.invInertiaWorldSolve = new Mat3();

                /**
                 * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
                 * @property {Boolean} fixedRotation
                 * @default false
                 */
                this.fixedRotation = typeof (options.fixedRotation) !== "undefined" ? options.fixedRotation : false;

                /**
                 * @property {Number} angularDamping
                 */
                this.angularDamping = typeof (options.angularDamping) !== 'undefined' ? options.angularDamping : 0.01;

                /**
                 * @property aabb
                 * @type {AABB}
                 */
                this.aabb = new AABB();

                /**
                 * Indicates if the AABB needs to be updated before use.
                 * @property aabbNeedsUpdate
                 * @type {Boolean}
                 */
                this.aabbNeedsUpdate = true;

                this.wlambda = new Vec3();

                if (options.shape) {
                    this.addShape(options.shape);
                }

                this.updateMassProperties();
            }
            Body.prototype = new EventTarget();
            Body.prototype.constructor = Body;

            /**
             * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
             * @static
             * @property DYNAMIC
             * @type {Number}
             */
            Body.DYNAMIC = 1;

            /**
             * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
             * @static
             * @property STATIC
             * @type {Number}
             */
            Body.STATIC = 2;

            /**
             * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
             * @static
             * @property KINEMATIC
             * @type {Number}
             */
            Body.KINEMATIC = 4;



            /**
             * @static
             * @property AWAKE
             * @type {number}
             */
            Body.AWAKE = 0;

            /**
             * @static
             * @property SLEEPY
             * @type {number}
             */
            Body.SLEEPY = 1;

            /**
             * @static
             * @property SLEEPING
             * @type {number}
             */
            Body.SLEEPING = 2;

            Body.idCounter = 0;

            /**
             * Wake the body up.
             * @method wakeUp
             */
            Body.prototype.wakeUp = function () {
                var s = this.sleepState;
                this.sleepState = 0;
                if (s === Body.SLEEPING) {
                    this.dispatchEvent({ type: "wakeup" });
                }
            };

            /**
             * Force body sleep
             * @method sleep
             */
            Body.prototype.sleep = function () {
                this.sleepState = Body.SLEEPING;
                this.velocity.set(0, 0, 0);
                this.angularVelocity.set(0, 0, 0);
            };

            Body.sleepyEvent = {
                type: "sleepy"
            };

            Body.sleepEvent = {
                type: "sleep"
            };

            /**
             * Called every timestep to update internal sleep timer and change sleep state if needed.
             * @method sleepTick
             * @param {Number} time The world time in seconds
             */
            Body.prototype.sleepTick = function (time) {
                if (this.allowSleep) {
                    var sleepState = this.sleepState;
                    var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
                    var speedLimitSquared = Math.pow(this.sleepSpeedLimit, 2);
                    if (sleepState === Body.AWAKE && speedSquared < speedLimitSquared) {
                        this.sleepState = Body.SLEEPY; // Sleepy
                        this.timeLastSleepy = time;
                        this.dispatchEvent(Body.sleepyEvent);
                    } else if (sleepState === Body.SLEEPY && speedSquared > speedLimitSquared) {
                        this.wakeUp(); // Wake up
                    } else if (sleepState === Body.SLEEPY && (time - this.timeLastSleepy) > this.sleepTimeLimit) {
                        this.sleep(); // Sleeping
                        this.dispatchEvent(Body.sleepEvent);
                    }
                }
            };

            /**
             * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
             * @method updateSolveMassProperties
             */
            Body.prototype.updateSolveMassProperties = function () {
                if (this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC) {
                    this.invMassSolve = 0;
                    this.invInertiaSolve.setZero();
                    this.invInertiaWorldSolve.setZero();
                } else {
                    this.invMassSolve = this.invMass;
                    this.invInertiaSolve.copy(this.invInertia);
                    this.invInertiaWorldSolve.copy(this.invInertiaWorld);
                }
            };

            /**
             * Convert a world point to local body frame.
             * @method pointToLocalFrame
             * @param  {Vec3} worldPoint
             * @param  {Vec3} result
             * @return {Vec3}
             */
            Body.prototype.pointToLocalFrame = function (worldPoint, result) {
                var result = result || new Vec3();
                worldPoint.vsub(this.position, result);
                this.quaternion.conjugate().vmult(result, result);
                return result;
            };

            /**
             * Convert a world vector to local body frame.
             * @method vectorToLocalFrame
             * @param  {Vec3} worldPoint
             * @param  {Vec3} result
             * @return {Vec3}
             */
            Body.prototype.vectorToLocalFrame = function (worldVector, result) {
                var result = result || new Vec3();
                this.quaternion.conjugate().vmult(worldVector, result);
                return result;
            };

            /**
             * Convert a local body point to world frame.
             * @method pointToWorldFrame
             * @param  {Vec3} localPoint
             * @param  {Vec3} result
             * @return {Vec3}
             */
            Body.prototype.pointToWorldFrame = function (localPoint, result) {
                var result = result || new Vec3();
                this.quaternion.vmult(localPoint, result);
                result.vadd(this.position, result);
                return result;
            };

            /**
             * Convert a local body point to world frame.
             * @method vectorToWorldFrame
             * @param  {Vec3} localVector
             * @param  {Vec3} result
             * @return {Vec3}
             */
            Body.prototype.vectorToWorldFrame = function (localVector, result) {
                var result = result || new Vec3();
                this.quaternion.vmult(localVector, result);
                return result;
            };

            var tmpVec = new Vec3();
            var tmpQuat = new Quaternion();

            /**
             * Add a shape to the body with a local offset and orientation.
             * @method addShape
             * @param {Shape} shape
             * @param {Vec3} offset
             * @param {Quaternion} quaternion
             * @return {Body} The body object, for chainability.
             */
            Body.prototype.addShape = function (shape, _offset, _orientation) {
                var offset = new Vec3();
                var orientation = new Quaternion();

                if (_offset) {
                    offset.copy(_offset);
                }
                if (_orientation) {
                    orientation.copy(_orientation);
                }

                this.shapes.push(shape);
                this.shapeOffsets.push(offset);
                this.shapeOrientations.push(orientation);
                this.updateMassProperties();
                this.updateBoundingRadius();

                this.aabbNeedsUpdate = true;

                return this;
            };

            /**
             * Update the bounding radius of the body. Should be done if any of the shapes are changed.
             * @method updateBoundingRadius
             */
            Body.prototype.updateBoundingRadius = function () {
                var shapes = this.shapes,
                    shapeOffsets = this.shapeOffsets,
                    N = shapes.length,
                    radius = 0;

                for (var i = 0; i !== N; i++) {
                    var shape = shapes[i];
                    shape.updateBoundingSphereRadius();
                    var offset = shapeOffsets[i].norm(),
                        r = shape.boundingSphereRadius;
                    if (offset + r > radius) {
                        radius = offset + r;
                    }
                }

                this.boundingRadius = radius;
            };

            var computeAABB_shapeAABB = new AABB();

            /**
             * Updates the .aabb
             * @method computeAABB
             * @todo rename to updateAABB()
             */
            Body.prototype.computeAABB = function () {
                var shapes = this.shapes,
                    shapeOffsets = this.shapeOffsets,
                    shapeOrientations = this.shapeOrientations,
                    N = shapes.length,
                    offset = tmpVec,
                    orientation = tmpQuat,
                    bodyQuat = this.quaternion,
                    aabb = this.aabb,
                    shapeAABB = computeAABB_shapeAABB;

                for (var i = 0; i !== N; i++) {
                    var shape = shapes[i];

                    // Get shape world quaternion
                    shapeOrientations[i].mult(bodyQuat, orientation);

                    // Get shape world position
                    orientation.vmult(shapeOffsets[i], offset);
                    offset.vadd(this.position, offset);

                    // vec2.rotate(offset, shapeOffsets[i], bodyAngle);
                    // vec2.add(offset, offset, this.position);

                    // Get shape AABB
                    shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

                    if (i === 0) {
                        aabb.copy(shapeAABB);
                    } else {
                        aabb.extend(shapeAABB);
                    }
                }

                this.aabbNeedsUpdate = false;
            };

            var uiw_m1 = new Mat3(),
                uiw_m2 = new Mat3(),
                uiw_m3 = new Mat3();

            /**
             * Update .inertiaWorld and .invInertiaWorld
             * @method updateInertiaWorld
             */
            Body.prototype.updateInertiaWorld = function (force) {
                var I = this.invInertia;
                if (I.x === I.y && I.y === I.z && !force) {
                    // If inertia M = s*I, where I is identity and s a scalar, then
                    //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
                    // where R is the rotation matrix.
                    // In other words, we don't have to transform the inertia if all
                    // inertia diagonal entries are equal.
                } else {
                    var m1 = uiw_m1,
                        m2 = uiw_m2,
                        m3 = uiw_m3;
                    m1.setRotationFromQuaternion(this.quaternion);
                    m1.transpose(m2);
                    m1.scale(I, m1);
                    m1.mmult(m2, this.invInertiaWorld);
                    //m3.getTrace(this.invInertiaWorld);
                }

                /*
                this.quaternion.vmult(this.inertia,this.inertiaWorld);
                this.quaternion.vmult(this.invInertia,this.invInertiaWorld);
                */
            };

            /**
             * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
             * @method applyForce
             * @param  {Vec3} force The amount of force to add.
             * @param  {Vec3} worldPoint A world point to apply the force on.
             */
            var Body_applyForce_r = new Vec3();
            var Body_applyForce_rotForce = new Vec3();
            Body.prototype.applyForce = function (force, worldPoint) {
                if (this.type !== Body.DYNAMIC) {
                    return;
                }

                // Compute point position relative to the body center
                var r = Body_applyForce_r;
                worldPoint.vsub(this.position, r);

                // Compute produced rotational force
                var rotForce = Body_applyForce_rotForce;
                r.cross(force, rotForce);

                // Add linear force
                this.force.vadd(force, this.force);

                // Add rotational force
                this.torque.vadd(rotForce, this.torque);
            };

            /**
             * Apply force to a local point in the body.
             * @method applyLocalForce
             * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
             * @param  {Vec3} localPoint A local point in the body to apply the force on.
             */
            var Body_applyLocalForce_worldForce = new Vec3();
            var Body_applyLocalForce_worldPoint = new Vec3();
            Body.prototype.applyLocalForce = function (localForce, localPoint) {
                if (this.type !== Body.DYNAMIC) {
                    return;
                }

                var worldForce = Body_applyLocalForce_worldForce;
                var worldPoint = Body_applyLocalForce_worldPoint;

                // Transform the force vector to world space
                this.vectorToWorldFrame(localForce, worldForce);
                this.pointToWorldFrame(localPoint, worldPoint);

                this.applyForce(worldForce, worldPoint);
            };

            /**
             * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
             * @method applyImpulse
             * @param  {Vec3} impulse The amount of impulse to add.
             * @param  {Vec3} worldPoint A world point to apply the force on.
             */
            var Body_applyImpulse_r = new Vec3();
            var Body_applyImpulse_velo = new Vec3();
            var Body_applyImpulse_rotVelo = new Vec3();
            Body.prototype.applyImpulse = function (impulse, worldPoint) {
                if (this.type !== Body.DYNAMIC) {
                    return;
                }

                // Compute point position relative to the body center
                var r = Body_applyImpulse_r;
                worldPoint.vsub(this.position, r);

                // Compute produced central impulse velocity
                var velo = Body_applyImpulse_velo;
                velo.copy(impulse);
                velo.mult(this.invMass, velo);

                // Add linear impulse
                this.velocity.vadd(velo, this.velocity);

                // Compute produced rotational impulse velocity
                var rotVelo = Body_applyImpulse_rotVelo;
                r.cross(impulse, rotVelo);

                /*
                rotVelo.x *= this.invInertia.x;
                rotVelo.y *= this.invInertia.y;
                rotVelo.z *= this.invInertia.z;
                */
                this.invInertiaWorld.vmult(rotVelo, rotVelo);

                // Add rotational Impulse
                this.angularVelocity.vadd(rotVelo, this.angularVelocity);
            };

            /**
             * Apply locally-defined impulse to a local point in the body.
             * @method applyLocalImpulse
             * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
             * @param  {Vec3} localPoint A local point in the body to apply the force on.
             */
            var Body_applyLocalImpulse_worldImpulse = new Vec3();
            var Body_applyLocalImpulse_worldPoint = new Vec3();
            Body.prototype.applyLocalImpulse = function (localImpulse, localPoint) {
                if (this.type !== Body.DYNAMIC) {
                    return;
                }

                var worldImpulse = Body_applyLocalImpulse_worldImpulse;
                var worldPoint = Body_applyLocalImpulse_worldPoint;

                // Transform the force vector to world space
                this.vectorToWorldFrame(localImpulse, worldImpulse);
                this.pointToWorldFrame(localPoint, worldPoint);

                this.applyImpulse(worldImpulse, worldPoint);
            };

            var Body_updateMassProperties_halfExtents = new Vec3();

            /**
             * Should be called whenever you change the body shape or mass.
             * @method updateMassProperties
             */
            Body.prototype.updateMassProperties = function () {
                var halfExtents = Body_updateMassProperties_halfExtents;

                this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
                var I = this.inertia;
                var fixed = this.fixedRotation;

                // Approximate with AABB box
                this.computeAABB();
                halfExtents.set(
                    (this.aabb.upperBound.x - this.aabb.lowerBound.x) / 2,
                    (this.aabb.upperBound.y - this.aabb.lowerBound.y) / 2,
                    (this.aabb.upperBound.z - this.aabb.lowerBound.z) / 2
                );
                Box.calculateInertia(halfExtents, this.mass, I);

                this.invInertia.set(
                    I.x > 0 && !fixed ? 1.0 / I.x : 0,
                    I.y > 0 && !fixed ? 1.0 / I.y : 0,
                    I.z > 0 && !fixed ? 1.0 / I.z : 0
                );
                this.updateInertiaWorld(true);
            };

            /**
             * Get world velocity of a point in the body.
             * @method getVelocityAtWorldPoint
             * @param  {Vec3} worldPoint
             * @param  {Vec3} result
             * @return {Vec3} The result vector.
             */
            Body.prototype.getVelocityAtWorldPoint = function (worldPoint, result) {
                var r = new Vec3();
                worldPoint.vsub(this.position, r);
                this.angularVelocity.cross(r, result);
                this.velocity.vadd(result, result);
                return result;
            };

        }, { "../collision/AABB": 3, "../material/Material": 25, "../math/Mat3": 27, "../math/Quaternion": 28, "../math/Vec3": 30, "../shapes/Box": 37, "../shapes/Shape": 43, "../utils/EventTarget": 49 }], 32: [function (_dereq_, module, exports) {
            var Body = _dereq_('./Body');
            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var RaycastResult = _dereq_('../collision/RaycastResult');
            var Ray = _dereq_('../collision/Ray');
            var WheelInfo = _dereq_('../objects/WheelInfo');

            module.exports = RaycastVehicle;

            /**
             * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
             * @class RaycastVehicle
             * @constructor
             * @param {object} [options]
             * @param {Body} [options.chassisBody] The car chassis body.
             * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
             * @param {integer} [options.indexLeftAxis]
             * @param {integer} [options.indexUpAxis]
             */
            function RaycastVehicle(options) {

                /**
                 * @property {Body} chassisBody
                 */
                this.chassisBody = options.chassisBody;

                /**
                 * An array of WheelInfo objects.
                 * @property {array} wheelInfos
                 */
                this.wheelInfos = [];

                /**
                 * Will be set to true if the car is sliding.
                 * @property {boolean} sliding
                 */
                this.sliding = false;

                /**
                 * @property {World} world
                 */
                this.world = null;

                /**
                 * Index of the right axis, 0=x, 1=y, 2=z
                 * @property {integer} indexRightAxis
                 * @default 1
                 */
                this.indexRightAxis = typeof (options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;

                /**
                 * Index of the forward axis, 0=x, 1=y, 2=z
                 * @property {integer} indexForwardAxis
                 * @default 0
                 */
                this.indexForwardAxis = typeof (options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;

                /**
                 * Index of the up axis, 0=x, 1=y, 2=z
                 * @property {integer} indexUpAxis
                 * @default 2
                 */
                this.indexUpAxis = typeof (options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;
            }

            var tmpVec1 = new Vec3();
            var tmpVec2 = new Vec3();
            var tmpVec3 = new Vec3();
            var tmpVec4 = new Vec3();
            var tmpVec5 = new Vec3();
            var tmpVec6 = new Vec3();
            var tmpRay = new Ray();

            /**
             * Add a wheel. For information about the options, see WheelInfo.
             * @method addWheel
             * @param {object} [options]
             */
            RaycastVehicle.prototype.addWheel = function (options) {
                options = options || {};

                var info = new WheelInfo(options);
                var index = this.wheelInfos.length;
                this.wheelInfos.push(info);

                return index;
            };

            /**
             * Set the steering value of a wheel.
             * @method setSteeringValue
             * @param {number} value
             * @param {integer} wheelIndex
             */
            RaycastVehicle.prototype.setSteeringValue = function (value, wheelIndex) {
                var wheel = this.wheelInfos[wheelIndex];
                wheel.steering = value;
            };

            var torque = new Vec3();

            /**
             * Set the wheel force to apply on one of the wheels each time step
             * @method applyEngineForce
             * @param  {number} value
             * @param  {integer} wheelIndex
             */
            RaycastVehicle.prototype.applyEngineForce = function (value, wheelIndex) {
                this.wheelInfos[wheelIndex].engineForce = value;
            };

            /**
             * Set the braking force of a wheel
             * @method setBrake
             * @param {number} brake
             * @param {integer} wheelIndex
             */
            RaycastVehicle.prototype.setBrake = function (brake, wheelIndex) {
                this.wheelInfos[wheelIndex].brake = brake;
            };

            /**
             * Add the vehicle including its constraints to the world.
             * @method addToWorld
             * @param {World} world
             */
            RaycastVehicle.prototype.addToWorld = function (world) {
                var constraints = this.constraints;
                world.add(this.chassisBody);
                var that = this;
                this.preStepCallback = function () {
                    that.updateVehicle(world.dt);
                };
                world.addEventListener('preStep', this.preStepCallback);
                this.world = world;
            };

            /**
             * Get one of the wheel axles, world-oriented.
             * @private
             * @method getVehicleAxisWorld
             * @param  {integer} axisIndex
             * @param  {Vec3} result
             */
            RaycastVehicle.prototype.getVehicleAxisWorld = function (axisIndex, result) {
                result.set(
                    axisIndex === 0 ? 1 : 0,
                    axisIndex === 1 ? 1 : 0,
                    axisIndex === 2 ? 1 : 0
                );
                this.chassisBody.vectorToWorldFrame(result, result);
            };

            RaycastVehicle.prototype.updateVehicle = function (timeStep) {
                var wheelInfos = this.wheelInfos;
                var numWheels = wheelInfos.length;
                var chassisBody = this.chassisBody;

                for (var i = 0; i < numWheels; i++) {
                    this.updateWheelTransform(i);
                }

                this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();

                var forwardWorld = new Vec3();
                this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

                if (forwardWorld.dot(chassisBody.velocity) < 0) {
                    this.currentVehicleSpeedKmHour *= -1;
                }

                // simulate suspension
                for (var i = 0; i < numWheels; i++) {
                    this.castRay(wheelInfos[i]);
                }

                this.updateSuspension(timeStep);

                var impulse = new Vec3();
                var relpos = new Vec3();
                for (var i = 0; i < numWheels; i++) {
                    //apply suspension force
                    var wheel = wheelInfos[i];
                    var suspensionForce = wheel.suspensionForce;
                    if (suspensionForce > wheel.maxSuspensionForce) {
                        suspensionForce = wheel.maxSuspensionForce;
                    }
                    wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);

                    wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
                    chassisBody.applyImpulse(impulse, wheel.raycastResult.hitPointWorld/*relpos*/);
                }

                this.updateFriction(timeStep);

                var hitNormalWorldScaledWithProj = new Vec3();
                var fwd = new Vec3();
                var vel = new Vec3();
                for (i = 0; i < numWheels; i++) {
                    var wheel = wheelInfos[i];
                    //var relpos = new Vec3();
                    //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);
                    chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);

                    // Hack to get the rotation in the correct direction
                    var m = 1;
                    switch (this.indexUpAxis) {
                        case 1:
                            m = -1;
                            break;
                    }

                    if (wheel.isInContact) {

                        this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
                        var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
                        wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);

                        fwd.vsub(hitNormalWorldScaledWithProj, fwd);

                        var proj2 = fwd.dot(vel);
                        wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
                    }

                    if ((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed) {
                        // Apply custom rotation when accelerating and sliding
                        wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
                    }

                    // Lock wheels
                    if (Math.abs(wheel.brake) > Math.abs(wheel.engineForce)) {
                        wheel.deltaRotation = 0;
                    }

                    wheel.rotation += wheel.deltaRotation; // Use the old value
                    wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
                }
            };

            RaycastVehicle.prototype.updateSuspension = function (deltaTime) {
                var chassisBody = this.chassisBody;
                var chassisMass = chassisBody.mass;
                var wheelInfos = this.wheelInfos;
                var numWheels = wheelInfos.length;

                for (var w_it = 0; w_it < numWheels; w_it++) {
                    var wheel = wheelInfos[w_it];

                    if (wheel.isInContact) {
                        var force;

                        // Spring
                        var susp_length = wheel.suspensionRestLength;
                        var current_length = wheel.suspensionLength;
                        var length_diff = (susp_length - current_length);

                        force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;

                        // Damper
                        var projected_rel_vel = wheel.suspensionRelativeVelocity;
                        var susp_damping;
                        if (projected_rel_vel < 0) {
                            susp_damping = wheel.dampingCompression;
                        } else {
                            susp_damping = wheel.dampingRelaxation;
                        }
                        force -= susp_damping * projected_rel_vel;

                        wheel.suspensionForce = force * chassisMass;
                        if (wheel.suspensionForce < 0) {
                            wheel.suspensionForce = 0;
                        }
                    } else {
                        wheel.suspensionForce = 0;
                    }
                }
            };

            /**
             * Remove the vehicle including its constraints from the world.
             * @method removeFromWorld
             * @param {World} world
             */
            RaycastVehicle.prototype.removeFromWorld = function (world) {
                var constraints = this.constraints;
                world.remove(this.chassisBody);
                world.removeEventListener('preStep', this.preStepCallback);
                this.world = null;
            };

            var castRay_rayvector = new Vec3();
            var castRay_target = new Vec3();
            RaycastVehicle.prototype.castRay = function (wheel) {
                var rayvector = castRay_rayvector;
                var target = castRay_target;

                this.updateWheelTransformWorld(wheel);
                var chassisBody = this.chassisBody;

                var depth = -1;

                var raylen = wheel.suspensionRestLength + wheel.radius;

                wheel.directionWorld.scale(raylen, rayvector);
                var source = wheel.chassisConnectionPointWorld;
                source.vadd(rayvector, target);
                var raycastResult = wheel.raycastResult;

                var param = 0;

                raycastResult.reset();
                // Turn off ray collision with the chassis temporarily
                var oldState = chassisBody.collisionResponse;
                chassisBody.collisionResponse = false;

                // Cast ray against world
                this.world.rayTest(source, target, raycastResult);
                chassisBody.collisionResponse = oldState;

                var object = raycastResult.body;

                wheel.raycastResult.groundObject = 0;

                if (object) {
                    depth = raycastResult.distance;
                    wheel.raycastResult.hitNormalWorld = raycastResult.hitNormalWorld;
                    wheel.isInContact = true;

                    var hitDistance = raycastResult.distance;
                    wheel.suspensionLength = hitDistance - wheel.radius;

                    // clamp on max suspension travel
                    var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
                    var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
                    if (wheel.suspensionLength < minSuspensionLength) {
                        wheel.suspensionLength = minSuspensionLength;
                    }
                    if (wheel.suspensionLength > maxSuspensionLength) {
                        wheel.suspensionLength = maxSuspensionLength;
                        wheel.raycastResult.reset();
                    }

                    var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);

                    var chassis_velocity_at_contactPoint = new Vec3();
                    chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);

                    var projVel = wheel.raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);

                    if (denominator >= -0.1) {
                        wheel.suspensionRelativeVelocity = 0;
                        wheel.clippedInvContactDotSuspension = 1 / 0.1;
                    } else {
                        var inv = -1 / denominator;
                        wheel.suspensionRelativeVelocity = projVel * inv;
                        wheel.clippedInvContactDotSuspension = inv;
                    }

                } else {

                    //put wheel info as in rest position
                    wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
                    wheel.suspensionRelativeVelocity = 0.0;
                    wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
                    wheel.clippedInvContactDotSuspension = 1.0;
                }

                return depth;
            };

            RaycastVehicle.prototype.updateWheelTransformWorld = function (wheel) {
                wheel.isInContact = false;
                var chassisBody = this.chassisBody;
                chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
                chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
                chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
            };


            /**
             * Update one of the wheel transform.
             * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
             * @method updateWheelTransform
             * @param {integer} wheelIndex The wheel index to update.
             */
            RaycastVehicle.prototype.updateWheelTransform = function (wheelIndex) {
                var up = tmpVec4;
                var right = tmpVec5;
                var fwd = tmpVec6;

                var wheel = this.wheelInfos[wheelIndex];
                this.updateWheelTransformWorld(wheel);

                wheel.directionLocal.scale(-1, up);
                right.copy(wheel.axleLocal);
                up.cross(right, fwd);
                fwd.normalize();
                right.normalize();

                // Rotate around steering over the wheelAxle
                var steering = wheel.steering;
                var steeringOrn = new Quaternion();
                steeringOrn.setFromAxisAngle(up, steering);

                var rotatingOrn = new Quaternion();
                rotatingOrn.setFromAxisAngle(right, wheel.rotation);

                // World rotation of the wheel
                var q = wheel.worldTransform.quaternion;
                this.chassisBody.quaternion.mult(steeringOrn, q);
                q.mult(rotatingOrn, q);

                q.normalize();

                // world position of the wheel
                var p = wheel.worldTransform.position;
                p.copy(wheel.directionWorld);
                p.scale(wheel.suspensionLength, p);
                p.vadd(wheel.chassisConnectionPointWorld, p);
            };

            var directions = [
                new Vec3(1, 0, 0),
                new Vec3(0, 1, 0),
                new Vec3(0, 0, 1)
            ];

            /**
             * Get the world transform of one of the wheels
             * @method getWheelTransformWorld
             * @param  {integer} wheelIndex
             * @return {Transform}
             */
            RaycastVehicle.prototype.getWheelTransformWorld = function (wheelIndex) {
                return this.wheelInfos[wheelIndex].worldTransform;
            };


            var updateFriction_surfNormalWS_scaled_proj = new Vec3();
            var updateFriction_axle = [];
            var updateFriction_forwardWS = [];
            var sideFrictionStiffness2 = 1;
            RaycastVehicle.prototype.updateFriction = function (timeStep) {
                var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;

                //calculate the impulse, so that the wheels don't move sidewards
                var wheelInfos = this.wheelInfos;
                var numWheels = wheelInfos.length;
                var chassisBody = this.chassisBody;
                var forwardWS = updateFriction_forwardWS;
                var axle = updateFriction_axle;

                var numWheelsOnGround = 0;

                for (var i = 0; i < numWheels; i++) {
                    var wheel = wheelInfos[i];

                    var groundObject = wheel.raycastResult.body;
                    if (groundObject) {
                        numWheelsOnGround++;
                    }

                    wheel.sideImpulse = 0;
                    wheel.forwardImpulse = 0;
                    if (!forwardWS[i]) {
                        forwardWS[i] = new Vec3();
                    }
                    if (!axle[i]) {
                        axle[i] = new Vec3();
                    }
                }

                for (var i = 0; i < numWheels; i++) {
                    var wheel = wheelInfos[i];

                    var groundObject = wheel.raycastResult.body;

                    if (groundObject) {
                        var axlei = axle[i];
                        var wheelTrans = this.getWheelTransformWorld(i);

                        // Get world axle
                        wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);

                        var surfNormalWS = wheel.raycastResult.hitNormalWorld;
                        var proj = axlei.dot(surfNormalWS);
                        surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
                        axlei.vsub(surfNormalWS_scaled_proj, axlei);
                        axlei.normalize();

                        surfNormalWS.cross(axlei, forwardWS[i]);
                        forwardWS[i].normalize();

                        wheel.sideImpulse = resolveSingleBilateral(
                            chassisBody,
                            wheel.raycastResult.hitPointWorld,
                            groundObject,
                            wheel.raycastResult.hitPointWorld,
                            axlei
                        );

                        wheel.sideImpulse *= sideFrictionStiffness2;
                    }
                }

                var sideFactor = 1;
                var fwdFactor = 0.5;

                this.sliding = false;
                for (var i = 0; i < numWheels; i++) {
                    var wheel = wheelInfos[i];
                    var groundObject = wheel.raycastResult.body;

                    var rollingFriction = 0;

                    wheel.slipInfo = 1;
                    if (groundObject) {
                        var defaultRollingFrictionImpulse = 0;
                        var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;

                        // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
                        // rollingFriction = calcRollingFriction(contactPt);
                        rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);

                        rollingFriction += wheel.engineForce * timeStep;

                        // rollingFriction = 0;
                        var factor = maxImpulse / rollingFriction;
                        wheel.slipInfo *= factor;
                    }

                    //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)

                    wheel.forwardImpulse = 0;
                    wheel.skidInfo = 1;

                    if (groundObject) {
                        wheel.skidInfo = 1;

                        var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
                        var maximpSide = maximp;

                        var maximpSquared = maximp * maximpSide;

                        wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;

                        var x = wheel.forwardImpulse * fwdFactor;
                        var y = wheel.sideImpulse * sideFactor;

                        var impulseSquared = x * x + y * y;

                        wheel.sliding = false;
                        if (impulseSquared > maximpSquared) {
                            this.sliding = true;
                            wheel.sliding = true;

                            var factor = maximp / Math.sqrt(impulseSquared);

                            wheel.skidInfo *= factor;
                        }
                    }
                }

                if (this.sliding) {
                    for (var i = 0; i < numWheels; i++) {
                        var wheel = wheelInfos[i];
                        if (wheel.sideImpulse !== 0) {
                            if (wheel.skidInfo < 1) {
                                wheel.forwardImpulse *= wheel.skidInfo;
                                wheel.sideImpulse *= wheel.skidInfo;
                            }
                        }
                    }
                }

                // apply the impulses
                for (var i = 0; i < numWheels; i++) {
                    var wheel = wheelInfos[i];

                    var rel_pos = new Vec3();
                    //wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
                    // cannons applyimpulse is using world coord for the position
                    rel_pos.copy(wheel.raycastResult.hitPointWorld);

                    if (wheel.forwardImpulse !== 0) {
                        var impulse = new Vec3();
                        forwardWS[i].scale(wheel.forwardImpulse, impulse);
                        chassisBody.applyImpulse(impulse, rel_pos);
                    }

                    if (wheel.sideImpulse !== 0) {
                        var groundObject = wheel.raycastResult.body;

                        var rel_pos2 = new Vec3();
                        //wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
                        rel_pos2.copy(wheel.raycastResult.hitPointWorld);
                        var sideImp = new Vec3();
                        axle[i].scale(wheel.sideImpulse, sideImp);

                        // Scale the relative position in the up direction with rollInfluence.
                        // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).
                        chassisBody.pointToLocalFrame(rel_pos, rel_pos);
                        rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
                        chassisBody.pointToWorldFrame(rel_pos, rel_pos);
                        chassisBody.applyImpulse(sideImp, rel_pos);

                        //apply friction impulse on the ground
                        sideImp.scale(-1, sideImp);
                        groundObject.applyImpulse(sideImp, rel_pos2);
                    }
                }
            };

            var calcRollingFriction_vel1 = new Vec3();
            var calcRollingFriction_vel2 = new Vec3();
            var calcRollingFriction_vel = new Vec3();

            function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
                var j1 = 0;
                var contactPosWorld = frictionPosWorld;

                // var rel_pos1 = new Vec3();
                // var rel_pos2 = new Vec3();
                var vel1 = calcRollingFriction_vel1;
                var vel2 = calcRollingFriction_vel2;
                var vel = calcRollingFriction_vel;
                // contactPosWorld.vsub(body0.position, rel_pos1);
                // contactPosWorld.vsub(body1.position, rel_pos2);

                body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
                body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
                vel1.vsub(vel2, vel);

                var vrel = frictionDirectionWorld.dot(vel);

                var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
                var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
                var relaxation = 1;
                var jacDiagABInv = relaxation / (denom0 + denom1);

                // calculate j that moves us to zero relative velocity
                j1 = -vrel * jacDiagABInv;

                if (maxImpulse < j1) {
                    j1 = maxImpulse;
                }
                if (j1 < -maxImpulse) {
                    j1 = -maxImpulse;
                }

                return j1;
            }

            var computeImpulseDenominator_r0 = new Vec3();
            var computeImpulseDenominator_c0 = new Vec3();
            var computeImpulseDenominator_vec = new Vec3();
            var computeImpulseDenominator_m = new Vec3();
            function computeImpulseDenominator(body, pos, normal) {
                var r0 = computeImpulseDenominator_r0;
                var c0 = computeImpulseDenominator_c0;
                var vec = computeImpulseDenominator_vec;
                var m = computeImpulseDenominator_m;

                pos.vsub(body.position, r0);
                r0.cross(normal, c0);
                body.invInertiaWorld.vmult(c0, m);
                m.cross(r0, vec);

                return body.invMass + normal.dot(vec);
            }


            var resolveSingleBilateral_vel1 = new Vec3();
            var resolveSingleBilateral_vel2 = new Vec3();
            var resolveSingleBilateral_vel = new Vec3();

            //bilateral constraint between two dynamic objects
            function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse) {
                var normalLenSqr = normal.norm2();
                if (normalLenSqr > 1.1) {
                    return 0; // no impulse
                }
                // var rel_pos1 = new Vec3();
                // var rel_pos2 = new Vec3();
                // pos1.vsub(body1.position, rel_pos1);
                // pos2.vsub(body2.position, rel_pos2);

                var vel1 = resolveSingleBilateral_vel1;
                var vel2 = resolveSingleBilateral_vel2;
                var vel = resolveSingleBilateral_vel;
                body1.getVelocityAtWorldPoint(pos1, vel1);
                body2.getVelocityAtWorldPoint(pos2, vel2);

                vel1.vsub(vel2, vel);

                var rel_vel = normal.dot(vel);

                var contactDamping = 0.2;
                var massTerm = 1 / (body1.invMass + body2.invMass);
                var impulse = - contactDamping * rel_vel * massTerm;

                return impulse;
            }
        }, { "../collision/Ray": 9, "../collision/RaycastResult": 10, "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/WheelInfo": 36, "./Body": 31 }], 33: [function (_dereq_, module, exports) {
            var Body = _dereq_('./Body');
            var Sphere = _dereq_('../shapes/Sphere');
            var Box = _dereq_('../shapes/Box');
            var Vec3 = _dereq_('../math/Vec3');
            var HingeConstraint = _dereq_('../constraints/HingeConstraint');

            module.exports = RigidVehicle;

            /**
             * Simple vehicle helper class with spherical rigid body wheels.
             * @class RigidVehicle
             * @constructor
             * @param {Body} [options.chassisBody]
             */
            function RigidVehicle(options) {
                this.wheelBodies = [];

                /**
                 * @property coordinateSystem
                 * @type {Vec3}
                 */
                this.coordinateSystem = typeof (options.coordinateSystem) === 'undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();

                /**
                 * @property {Body} chassisBody
                 */
                this.chassisBody = options.chassisBody;

                if (!this.chassisBody) {
                    // No chassis body given. Create it!
                    var chassisShape = new Box(new Vec3(5, 2, 0.5));
                    this.chassisBody = new Body(1, chassisShape);
                }

                /**
                 * @property constraints
                 * @type {Array}
                 */
                this.constraints = [];

                this.wheelAxes = [];
                this.wheelForces = [];
            }

            /**
             * Add a wheel
             * @method addWheel
             * @param {object} options
             * @param {boolean} [options.isFrontWheel]
             * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
             * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
             * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
             * @param {Body} [options.body] The wheel body.
             */
            RigidVehicle.prototype.addWheel = function (options) {
                options = options || {};
                var wheelBody = options.body;
                if (!wheelBody) {
                    wheelBody = new Body(1, new Sphere(1.2));
                }
                this.wheelBodies.push(wheelBody);
                this.wheelForces.push(0);

                // Position constrain wheels
                var zero = new Vec3();
                var position = typeof (options.position) !== 'undefined' ? options.position.clone() : new Vec3();

                // Set position locally to the chassis
                var worldPosition = new Vec3();
                this.chassisBody.pointToWorldFrame(position, worldPosition);
                wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);

                // Constrain wheel
                var axis = typeof (options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
                this.wheelAxes.push(axis);

                var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
                    pivotA: position,
                    axisA: axis,
                    pivotB: Vec3.ZERO,
                    axisB: axis,
                    collideConnected: false
                });
                this.constraints.push(hingeConstraint);

                return this.wheelBodies.length - 1;
            };

            /**
             * Set the steering value of a wheel.
             * @method setSteeringValue
             * @param {number} value
             * @param {integer} wheelIndex
             * @todo check coordinateSystem
             */
            RigidVehicle.prototype.setSteeringValue = function (value, wheelIndex) {
                // Set angle of the hinge axis
                var axis = this.wheelAxes[wheelIndex];

                var c = Math.cos(value),
                    s = Math.sin(value),
                    x = axis.x,
                    y = axis.y;
                this.constraints[wheelIndex].axisA.set(
                    c * x - s * y,
                    s * x + c * y,
                    0
                );
            };

            /**
             * Set the target rotational speed of the hinge constraint.
             * @method setMotorSpeed
             * @param {number} value
             * @param {integer} wheelIndex
             */
            RigidVehicle.prototype.setMotorSpeed = function (value, wheelIndex) {
                var hingeConstraint = this.constraints[wheelIndex];
                hingeConstraint.enableMotor();
                hingeConstraint.motorTargetVelocity = value;
            };

            /**
             * Set the target rotational speed of the hinge constraint.
             * @method disableMotor
             * @param {number} value
             * @param {integer} wheelIndex
             */
            RigidVehicle.prototype.disableMotor = function (wheelIndex) {
                var hingeConstraint = this.constraints[wheelIndex];
                hingeConstraint.disableMotor();
            };

            var torque = new Vec3();

            /**
             * Set the wheel force to apply on one of the wheels each time step
             * @method setWheelForce
             * @param  {number} value
             * @param  {integer} wheelIndex
             */
            RigidVehicle.prototype.setWheelForce = function (value, wheelIndex) {
                this.wheelForces[wheelIndex] = value;
            };

            /**
             * Apply a torque on one of the wheels.
             * @method applyWheelForce
             * @param  {number} value
             * @param  {integer} wheelIndex
             */
            RigidVehicle.prototype.applyWheelForce = function (value, wheelIndex) {
                var axis = this.wheelAxes[wheelIndex];
                var wheelBody = this.wheelBodies[wheelIndex];
                var bodyTorque = wheelBody.torque;

                axis.scale(value, torque);
                wheelBody.vectorToWorldFrame(torque, torque);
                bodyTorque.vadd(torque, bodyTorque);
            };

            /**
             * Add the vehicle including its constraints to the world.
             * @method addToWorld
             * @param {World} world
             */
            RigidVehicle.prototype.addToWorld = function (world) {
                var constraints = this.constraints;
                var bodies = this.wheelBodies.concat([this.chassisBody]);

                for (var i = 0; i < bodies.length; i++) {
                    world.add(bodies[i]);
                }

                for (var i = 0; i < constraints.length; i++) {
                    world.addConstraint(constraints[i]);
                }

                world.addEventListener('preStep', this._update.bind(this));
            };

            RigidVehicle.prototype._update = function () {
                var wheelForces = this.wheelForces;
                for (var i = 0; i < wheelForces.length; i++) {
                    this.applyWheelForce(wheelForces[i], i);
                }
            };

            /**
             * Remove the vehicle including its constraints from the world.
             * @method removeFromWorld
             * @param {World} world
             */
            RigidVehicle.prototype.removeFromWorld = function (world) {
                var constraints = this.constraints;
                var bodies = this.wheelBodies.concat([this.chassisBody]);

                for (var i = 0; i < bodies.length; i++) {
                    world.remove(bodies[i]);
                }

                for (var i = 0; i < constraints.length; i++) {
                    world.removeConstraint(constraints[i]);
                }
            };

            var worldAxis = new Vec3();

            /**
             * Get current rotational velocity of a wheel
             * @method getWheelSpeed
             * @param {integer} wheelIndex
             */
            RigidVehicle.prototype.getWheelSpeed = function (wheelIndex) {
                var axis = this.wheelAxes[wheelIndex];
                var wheelBody = this.wheelBodies[wheelIndex];
                var w = wheelBody.angularVelocity;
                this.chassisBody.vectorToWorldFrame(axis, worldAxis);
                return w.dot(worldAxis);
            };

        }, { "../constraints/HingeConstraint": 15, "../math/Vec3": 30, "../shapes/Box": 37, "../shapes/Sphere": 44, "./Body": 31 }], 34: [function (_dereq_, module, exports) {
            module.exports = SPHSystem;

            var Shape = _dereq_('../shapes/Shape');
            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Particle = _dereq_('../shapes/Particle');
            var Body = _dereq_('../objects/Body');
            var Material = _dereq_('../material/Material');

            /**
             * Smoothed-particle hydrodynamics system
             * @class SPHSystem
             * @constructor
             */
            function SPHSystem() {
                this.particles = [];

                /**
                 * Density of the system (kg/m3).
                 * @property {number} density
                 */
                this.density = 1;

                /**
                 * Distance below which two particles are considered to be neighbors.
                 * It should be adjusted so there are about 15-20 neighbor particles within this radius.
                 * @property {number} smoothingRadius
                 */
                this.smoothingRadius = 1;
                this.speedOfSound = 1;

                /**
                 * Viscosity of the system.
                 * @property {number} viscosity
                 */
                this.viscosity = 0.01;
                this.eps = 0.000001;

                // Stuff Computed per particle
                this.pressures = [];
                this.densities = [];
                this.neighbors = [];
            }

            /**
             * Add a particle to the system.
             * @method add
             * @param {Body} particle
             */
            SPHSystem.prototype.add = function (particle) {
                this.particles.push(particle);
                if (this.neighbors.length < this.particles.length) {
                    this.neighbors.push([]);
                }
            };

            /**
             * Remove a particle from the system.
             * @method remove
             * @param {Body} particle
             */
            SPHSystem.prototype.remove = function (particle) {
                var idx = this.particles.indexOf(particle);
                if (idx !== -1) {
                    this.particles.splice(idx, 1);
                    if (this.neighbors.length > this.particles.length) {
                        this.neighbors.pop();
                    }
                }
            };

            /**
             * Get neighbors within smoothing volume, save in the array neighbors
             * @method getNeighbors
             * @param {Body} particle
             * @param {Array} neighbors
             */
            var SPHSystem_getNeighbors_dist = new Vec3();
            SPHSystem.prototype.getNeighbors = function (particle, neighbors) {
                var N = this.particles.length,
                    id = particle.id,
                    R2 = this.smoothingRadius * this.smoothingRadius,
                    dist = SPHSystem_getNeighbors_dist;
                for (var i = 0; i !== N; i++) {
                    var p = this.particles[i];
                    p.position.vsub(particle.position, dist);
                    if (id !== p.id && dist.norm2() < R2) {
                        neighbors.push(p);
                    }
                }
            };

            // Temp vectors for calculation
            var SPHSystem_update_dist = new Vec3(),
                SPHSystem_update_a_pressure = new Vec3(),
                SPHSystem_update_a_visc = new Vec3(),
                SPHSystem_update_gradW = new Vec3(),
                SPHSystem_update_r_vec = new Vec3(),
                SPHSystem_update_u = new Vec3(); // Relative velocity
            SPHSystem.prototype.update = function () {
                var N = this.particles.length,
                    dist = SPHSystem_update_dist,
                    cs = this.speedOfSound,
                    eps = this.eps;

                for (var i = 0; i !== N; i++) {
                    var p = this.particles[i]; // Current particle
                    var neighbors = this.neighbors[i];

                    // Get neighbors
                    neighbors.length = 0;
                    this.getNeighbors(p, neighbors);
                    neighbors.push(this.particles[i]); // Add current too
                    var numNeighbors = neighbors.length;

                    // Accumulate density for the particle
                    var sum = 0.0;
                    for (var j = 0; j !== numNeighbors; j++) {

                        //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
                        p.position.vsub(neighbors[j].position, dist);
                        var len = dist.norm();

                        var weight = this.w(len);
                        sum += neighbors[j].mass * weight;
                    }

                    // Save
                    this.densities[i] = sum;
                    this.pressures[i] = cs * cs * (this.densities[i] - this.density);
                }

                // Add forces

                // Sum to these accelerations
                var a_pressure = SPHSystem_update_a_pressure;
                var a_visc = SPHSystem_update_a_visc;
                var gradW = SPHSystem_update_gradW;
                var r_vec = SPHSystem_update_r_vec;
                var u = SPHSystem_update_u;

                for (var i = 0; i !== N; i++) {

                    var particle = this.particles[i];

                    a_pressure.set(0, 0, 0);
                    a_visc.set(0, 0, 0);

                    // Init vars
                    var Pij;
                    var nabla;
                    var Vij;

                    // Sum up for all other neighbors
                    var neighbors = this.neighbors[i];
                    var numNeighbors = neighbors.length;

                    //printf("Neighbors: ");
                    for (var j = 0; j !== numNeighbors; j++) {

                        var neighbor = neighbors[j];
                        //printf("%d ",nj);

                        // Get r once for all..
                        particle.position.vsub(neighbor.position, r_vec);
                        var r = r_vec.norm();

                        // Pressure contribution
                        Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i] * this.densities[i] + eps) + this.pressures[j] / (this.densities[j] * this.densities[j] + eps));
                        this.gradw(r_vec, gradW);
                        // Add to pressure acceleration
                        gradW.mult(Pij, gradW);
                        a_pressure.vadd(gradW, a_pressure);

                        // Viscosity contribution
                        neighbor.velocity.vsub(particle.velocity, u);
                        u.mult(1.0 / (0.0001 + this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass, u);
                        nabla = this.nablaw(r);
                        u.mult(nabla, u);
                        // Add to viscosity acceleration
                        a_visc.vadd(u, a_visc);
                    }

                    // Calculate force
                    a_visc.mult(particle.mass, a_visc);
                    a_pressure.mult(particle.mass, a_pressure);

                    // Add force to particles
                    particle.force.vadd(a_visc, particle.force);
                    particle.force.vadd(a_pressure, particle.force);
                }
            };

            // Calculate the weight using the W(r) weightfunction
            SPHSystem.prototype.w = function (r) {
                // 315
                var h = this.smoothingRadius;
                return 315.0 / (64.0 * Math.PI * Math.pow(h, 9)) * Math.pow(h * h - r * r, 3);
            };

            // calculate gradient of the weight function
            SPHSystem.prototype.gradw = function (rVec, resultVec) {
                var r = rVec.norm(),
                    h = this.smoothingRadius;
                rVec.mult(945.0 / (32.0 * Math.PI * Math.pow(h, 9)) * Math.pow((h * h - r * r), 2), resultVec);
            };

            // Calculate nabla(W)
            SPHSystem.prototype.nablaw = function (r) {
                var h = this.smoothingRadius;
                var nabla = 945.0 / (32.0 * Math.PI * Math.pow(h, 9)) * (h * h - r * r) * (7 * r * r - 3 * h * h);
                return nabla;
            };

        }, { "../material/Material": 25, "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/Body": 31, "../shapes/Particle": 41, "../shapes/Shape": 43 }], 35: [function (_dereq_, module, exports) {
            var Vec3 = _dereq_('../math/Vec3');

            module.exports = Spring;

            /**
             * A spring, connecting two bodies.
             *
             * @class Spring
             * @constructor
             * @param {Body} bodyA
             * @param {Body} bodyB
             * @param {Object} [options]
             * @param {number} [options.restLength]   A number > 0. Default: 1
             * @param {number} [options.stiffness]    A number >= 0. Default: 100
             * @param {number} [options.damping]      A number >= 0. Default: 1
             * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
             * @param {Vec3}  [options.worldAnchorB]
             * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
             * @param {Vec3}  [options.localAnchorB]
             */
            function Spring(bodyA, bodyB, options) {
                options = options || {};

                /**
                 * Rest length of the spring.
                 * @property restLength
                 * @type {number}
                 */
                this.restLength = typeof (options.restLength) === "number" ? options.restLength : 1;

                /**
                 * Stiffness of the spring.
                 * @property stiffness
                 * @type {number}
                 */
                this.stiffness = options.stiffness || 100;

                /**
                 * Damping of the spring.
                 * @property damping
                 * @type {number}
                 */
                this.damping = options.damping || 1;

                /**
                 * First connected body.
                 * @property bodyA
                 * @type {Body}
                 */
                this.bodyA = bodyA;

                /**
                 * Second connected body.
                 * @property bodyB
                 * @type {Body}
                 */
                this.bodyB = bodyB;

                /**
                 * Anchor for bodyA in local bodyA coordinates.
                 * @property localAnchorA
                 * @type {Vec3}
                 */
                this.localAnchorA = new Vec3();

                /**
                 * Anchor for bodyB in local bodyB coordinates.
                 * @property localAnchorB
                 * @type {Vec3}
                 */
                this.localAnchorB = new Vec3();

                if (options.localAnchorA) {
                    this.localAnchorA.copy(options.localAnchorA);
                }
                if (options.localAnchorB) {
                    this.localAnchorB.copy(options.localAnchorB);
                }
                if (options.worldAnchorA) {
                    this.setWorldAnchorA(options.worldAnchorA);
                }
                if (options.worldAnchorB) {
                    this.setWorldAnchorB(options.worldAnchorB);
                }
            }

            /**
             * Set the anchor point on body A, using world coordinates.
             * @method setWorldAnchorA
             * @param {Vec3} worldAnchorA
             */
            Spring.prototype.setWorldAnchorA = function (worldAnchorA) {
                this.bodyA.pointToLocalFrame(worldAnchorA, this.localAnchorA);
            };

            /**
             * Set the anchor point on body B, using world coordinates.
             * @method setWorldAnchorB
             * @param {Vec3} worldAnchorB
             */
            Spring.prototype.setWorldAnchorB = function (worldAnchorB) {
                this.bodyB.pointToLocalFrame(worldAnchorB, this.localAnchorB);
            };

            /**
             * Get the anchor point on body A, in world coordinates.
             * @method getWorldAnchorA
             * @param {Vec3} result The vector to store the result in.
             */
            Spring.prototype.getWorldAnchorA = function (result) {
                this.bodyA.pointToWorldFrame(this.localAnchorA, result);
            };

            /**
             * Get the anchor point on body B, in world coordinates.
             * @method getWorldAnchorB
             * @param {Vec3} result The vector to store the result in.
             */
            Spring.prototype.getWorldAnchorB = function (result) {
                this.bodyB.pointToWorldFrame(this.localAnchorB, result);
            };

            var applyForce_r = new Vec3(),
                applyForce_r_unit = new Vec3(),
                applyForce_u = new Vec3(),
                applyForce_f = new Vec3(),
                applyForce_worldAnchorA = new Vec3(),
                applyForce_worldAnchorB = new Vec3(),
                applyForce_ri = new Vec3(),
                applyForce_rj = new Vec3(),
                applyForce_ri_x_f = new Vec3(),
                applyForce_rj_x_f = new Vec3(),
                applyForce_tmp = new Vec3();

            /**
             * Apply the spring force to the connected bodies.
             * @method applyForce
             */
            Spring.prototype.applyForce = function () {
                var k = this.stiffness,
                    d = this.damping,
                    l = this.restLength,
                    bodyA = this.bodyA,
                    bodyB = this.bodyB,
                    r = applyForce_r,
                    r_unit = applyForce_r_unit,
                    u = applyForce_u,
                    f = applyForce_f,
                    tmp = applyForce_tmp;

                var worldAnchorA = applyForce_worldAnchorA,
                    worldAnchorB = applyForce_worldAnchorB,
                    ri = applyForce_ri,
                    rj = applyForce_rj,
                    ri_x_f = applyForce_ri_x_f,
                    rj_x_f = applyForce_rj_x_f;

                // Get world anchors
                this.getWorldAnchorA(worldAnchorA);
                this.getWorldAnchorB(worldAnchorB);

                // Get offset points
                worldAnchorA.vsub(bodyA.position, ri);
                worldAnchorB.vsub(bodyB.position, rj);

                // Compute distance vector between world anchor points
                worldAnchorB.vsub(worldAnchorA, r);
                var rlen = r.norm();
                r_unit.copy(r);
                r_unit.normalize();

                // Compute relative velocity of the anchor points, u
                bodyB.velocity.vsub(bodyA.velocity, u);
                // Add rotational velocity

                bodyB.angularVelocity.cross(rj, tmp);
                u.vadd(tmp, u);
                bodyA.angularVelocity.cross(ri, tmp);
                u.vsub(tmp, u);

                // F = - k * ( x - L ) - D * ( u )
                r_unit.mult(-k * (rlen - l) - d * u.dot(r_unit), f);

                // Add forces to bodies
                bodyA.force.vsub(f, bodyA.force);
                bodyB.force.vadd(f, bodyB.force);

                // Angular force
                ri.cross(f, ri_x_f);
                rj.cross(f, rj_x_f);
                bodyA.torque.vsub(ri_x_f, bodyA.torque);
                bodyB.torque.vadd(rj_x_f, bodyB.torque);
            };

        }, { "../math/Vec3": 30 }], 36: [function (_dereq_, module, exports) {
            var Vec3 = _dereq_('../math/Vec3');
            var Transform = _dereq_('../math/Transform');
            var RaycastResult = _dereq_('../collision/RaycastResult');
            var Utils = _dereq_('../utils/Utils');

            module.exports = WheelInfo;

            /**
             * @class WheelInfo
             * @constructor
             * @param {Object} [options]
             *
             * @param {Vec3} [options.chassisConnectionPointLocal]
             * @param {Vec3} [options.chassisConnectionPointWorld]
             * @param {Vec3} [options.directionLocal]
             * @param {Vec3} [options.directionWorld]
             * @param {Vec3} [options.axleLocal]
             * @param {Vec3} [options.axleWorld]
             * @param {number} [options.suspensionRestLength=1]
             * @param {number} [options.suspensionMaxLength=2]
             * @param {number} [options.radius=1]
             * @param {number} [options.suspensionStiffness=100]
             * @param {number} [options.dampingCompression=10]
             * @param {number} [options.dampingRelaxation=10]
             * @param {number} [options.frictionSlip=10000]
             * @param {number} [options.steering=0]
             * @param {number} [options.rotation=0]
             * @param {number} [options.deltaRotation=0]
             * @param {number} [options.rollInfluence=0.01]
             * @param {number} [options.maxSuspensionForce]
             * @param {boolean} [options.isFrontWheel=true]
             * @param {number} [options.clippedInvContactDotSuspension=1]
             * @param {number} [options.suspensionRelativeVelocity=0]
             * @param {number} [options.suspensionForce=0]
             * @param {number} [options.skidInfo=0]
             * @param {number} [options.suspensionLength=0]
             * @param {number} [options.maxSuspensionTravel=1]
             * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
             * @param {number} [options.customSlidingRotationalSpeed=-0.1]
             */
            function WheelInfo(options) {
                options = Utils.defaults(options, {
                    chassisConnectionPointLocal: new Vec3(),
                    chassisConnectionPointWorld: new Vec3(),
                    directionLocal: new Vec3(),
                    directionWorld: new Vec3(),
                    axleLocal: new Vec3(),
                    axleWorld: new Vec3(),
                    suspensionRestLength: 1,
                    suspensionMaxLength: 2,
                    radius: 1,
                    suspensionStiffness: 100,
                    dampingCompression: 10,
                    dampingRelaxation: 10,
                    frictionSlip: 10000,
                    steering: 0,
                    rotation: 0,
                    deltaRotation: 0,
                    rollInfluence: 0.01,
                    maxSuspensionForce: Number.MAX_VALUE,
                    isFrontWheel: true,
                    clippedInvContactDotSuspension: 1,
                    suspensionRelativeVelocity: 0,
                    suspensionForce: 0,
                    skidInfo: 0,
                    suspensionLength: 0,
                    maxSuspensionTravel: 1,
                    useCustomSlidingRotationalSpeed: false,
                    customSlidingRotationalSpeed: -0.1
                });

                /**
                 * Max travel distance of the suspension, in meters.
                 * @property {number} maxSuspensionTravel
                 */
                this.maxSuspensionTravel = options.maxSuspensionTravel;

                /**
                 * Speed to apply to the wheel rotation when the wheel is sliding.
                 * @property {number} customSlidingRotationalSpeed
                 */
                this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;

                /**
                 * If the customSlidingRotationalSpeed should be used.
                 * @property {Boolean} useCustomSlidingRotationalSpeed
                 */
                this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;

                /**
                 * @property {Boolean} sliding
                 */
                this.sliding = false;

                /**
                 * Connection point, defined locally in the chassis body frame.
                 * @property {Vec3} chassisConnectionPointLocal
                 */
                this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();

                /**
                 * @property {Vec3} chassisConnectionPointWorld
                 */
                this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();

                /**
                 * @property {Vec3} directionLocal
                 */
                this.directionLocal = options.directionLocal.clone();

                /**
                 * @property {Vec3} directionWorld
                 */
                this.directionWorld = options.directionWorld.clone();

                /**
                 * @property {Vec3} axleLocal
                 */
                this.axleLocal = options.axleLocal.clone();

                /**
                 * @property {Vec3} axleWorld
                 */
                this.axleWorld = options.axleWorld.clone();

                /**
                 * @property {number} suspensionRestLength
                 */
                this.suspensionRestLength = options.suspensionRestLength;

                /**
                 * @property {number} suspensionMaxLength
                 */
                this.suspensionMaxLength = options.suspensionMaxLength;

                /**
                 * @property {number} radius
                 */
                this.radius = options.radius;

                /**
                 * @property {number} suspensionStiffness
                 */
                this.suspensionStiffness = options.suspensionStiffness;

                /**
                 * @property {number} dampingCompression
                 */
                this.dampingCompression = options.dampingCompression;

                /**
                 * @property {number} dampingRelaxation
                 */
                this.dampingRelaxation = options.dampingRelaxation;

                /**
                 * @property {number} frictionSlip
                 */
                this.frictionSlip = options.frictionSlip;

                /**
                 * @property {number} steering
                 */
                this.steering = 0;

                /**
                 * Rotation value, in radians.
                 * @property {number} rotation
                 */
                this.rotation = 0;

                /**
                 * @property {number} deltaRotation
                 */
                this.deltaRotation = 0;

                /**
                 * @property {number} rollInfluence
                 */
                this.rollInfluence = options.rollInfluence;

                /**
                 * @property {number} maxSuspensionForce
                 */
                this.maxSuspensionForce = options.maxSuspensionForce;

                /**
                 * @property {number} engineForce
                 */
                this.engineForce = 0;

                /**
                 * @property {number} brake
                 */
                this.brake = 0;

                /**
                 * @property {number} isFrontWheel
                 */
                this.isFrontWheel = options.isFrontWheel;

                /**
                 * @property {number} clippedInvContactDotSuspension
                 */
                this.clippedInvContactDotSuspension = 1;

                /**
                 * @property {number} suspensionRelativeVelocity
                 */
                this.suspensionRelativeVelocity = 0;

                /**
                 * @property {number} suspensionForce
                 */
                this.suspensionForce = 0;

                /**
                 * @property {number} skidInfo
                 */
                this.skidInfo = 0;

                /**
                 * @property {number} suspensionLength
                 */
                this.suspensionLength = 0;

                /**
                 * @property {number} sideImpulse
                 */
                this.sideImpulse = 0;

                /**
                 * @property {number} forwardImpulse
                 */
                this.forwardImpulse = 0;

                /**
                 * The result from raycasting
                 * @property {RaycastResult} raycastResult
                 */
                this.raycastResult = new RaycastResult();

                /**
                 * Wheel world transform
                 * @property {Transform} worldTransform
                 */
                this.worldTransform = new Transform();

                /**
                 * @property {boolean} isInContact
                 */
                this.isInContact = false;
            }

            var chassis_velocity_at_contactPoint = new Vec3();
            var relpos = new Vec3();
            var chassis_velocity_at_contactPoint = new Vec3();
            WheelInfo.prototype.updateWheel = function (chassis) {
                var raycastResult = this.raycastResult;

                if (this.isInContact) {
                    var project = raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
                    raycastResult.hitPointWorld.vsub(chassis.position, relpos);
                    chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
                    var projVel = raycastResult.hitNormalWorld.dot(chassis_velocity_at_contactPoint);
                    if (project >= -0.1) {
                        this.suspensionRelativeVelocity = 0.0;
                        this.clippedInvContactDotSuspension = 1.0 / 0.1;
                    } else {
                        var inv = -1 / project;
                        this.suspensionRelativeVelocity = projVel * inv;
                        this.clippedInvContactDotSuspension = inv;
                    }

                } else {
                    // Not in contact : position wheel in a nice (rest length) position
                    raycastResult.suspensionLength = this.suspensionRestLength;
                    this.suspensionRelativeVelocity = 0.0;
                    raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
                    this.clippedInvContactDotSuspension = 1.0;
                }
            };
        }, { "../collision/RaycastResult": 10, "../math/Transform": 29, "../math/Vec3": 30, "../utils/Utils": 53 }], 37: [function (_dereq_, module, exports) {
            module.exports = Box;

            var Shape = _dereq_('./Shape');
            var Vec3 = _dereq_('../math/Vec3');
            var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

            /**
             * A 3d box shape.
             * @class Box
             * @constructor
             * @param {Vec3} halfExtents
             * @author schteppe
             * @extends Shape
             */
            function Box(halfExtents) {
                Shape.call(this);

                this.type = Shape.types.BOX;

                /**
                 * @property halfExtents
                 * @type {Vec3}
                 */
                this.halfExtents = halfExtents;

                /**
                 * Used by the contact generator to make contacts with other convex polyhedra for example
                 * @property convexPolyhedronRepresentation
                 * @type {ConvexPolyhedron}
                 */
                this.convexPolyhedronRepresentation = null;

                this.updateConvexPolyhedronRepresentation();
                this.updateBoundingSphereRadius();
            }
            Box.prototype = new Shape();
            Box.prototype.constructor = Box;

            /**
             * Updates the local convex polyhedron representation used for some collisions.
             * @method updateConvexPolyhedronRepresentation
             */
            Box.prototype.updateConvexPolyhedronRepresentation = function () {
                var sx = this.halfExtents.x;
                var sy = this.halfExtents.y;
                var sz = this.halfExtents.z;
                var V = Vec3;

                var vertices = [
                    new V(-sx, -sy, -sz),
                    new V(sx, -sy, -sz),
                    new V(sx, sy, -sz),
                    new V(-sx, sy, -sz),
                    new V(-sx, -sy, sz),
                    new V(sx, -sy, sz),
                    new V(sx, sy, sz),
                    new V(-sx, sy, sz)
                ];

                var indices = [
                    [3, 2, 1, 0], // -z
                    [4, 5, 6, 7], // +z
                    [5, 4, 0, 1], // -y
                    [2, 3, 7, 6], // +y
                    [0, 4, 7, 3], // -x
                    [1, 2, 6, 5], // +x
                ];

                var axes = [
                    new V(0, 0, 1),
                    new V(0, 1, 0),
                    new V(1, 0, 0)
                ];

                var h = new ConvexPolyhedron(vertices, indices);
                this.convexPolyhedronRepresentation = h;
                h.material = this.material;
            };

            /**
             * @method calculateLocalInertia
             * @param  {Number} mass
             * @param  {Vec3} target
             * @return {Vec3}
             */
            Box.prototype.calculateLocalInertia = function (mass, target) {
                target = target || new Vec3();
                Box.calculateInertia(this.halfExtents, mass, target);
                return target;
            };

            Box.calculateInertia = function (halfExtents, mass, target) {
                var e = halfExtents;
                target.x = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.z * 2 * e.z);
                target.y = 1.0 / 12.0 * mass * (2 * e.x * 2 * e.x + 2 * e.z * 2 * e.z);
                target.z = 1.0 / 12.0 * mass * (2 * e.y * 2 * e.y + 2 * e.x * 2 * e.x);
            };

            /**
             * Get the box 6 side normals
             * @method getSideNormals
             * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
             * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
             * @return {array}
             */
            Box.prototype.getSideNormals = function (sixTargetVectors, quat) {
                var sides = sixTargetVectors;
                var ex = this.halfExtents;
                sides[0].set(ex.x, 0, 0);
                sides[1].set(0, ex.y, 0);
                sides[2].set(0, 0, ex.z);
                sides[3].set(-ex.x, 0, 0);
                sides[4].set(0, -ex.y, 0);
                sides[5].set(0, 0, -ex.z);

                if (quat !== undefined) {
                    for (var i = 0; i !== sides.length; i++) {
                        quat.vmult(sides[i], sides[i]);
                    }
                }

                return sides;
            };

            Box.prototype.volume = function () {
                return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
            };

            Box.prototype.updateBoundingSphereRadius = function () {
                this.boundingSphereRadius = this.halfExtents.norm();
            };

            var worldCornerTempPos = new Vec3();
            var worldCornerTempNeg = new Vec3();
            Box.prototype.forEachWorldCorner = function (pos, quat, callback) {

                var e = this.halfExtents;
                var corners = [[e.x, e.y, e.z],
                [-e.x, e.y, e.z],
                [-e.x, -e.y, e.z],
                [-e.x, -e.y, -e.z],
                [e.x, -e.y, -e.z],
                [e.x, e.y, -e.z],
                [-e.x, e.y, -e.z],
                [e.x, -e.y, e.z]];
                for (var i = 0; i < corners.length; i++) {
                    worldCornerTempPos.set(corners[i][0], corners[i][1], corners[i][2]);
                    quat.vmult(worldCornerTempPos, worldCornerTempPos);
                    pos.vadd(worldCornerTempPos, worldCornerTempPos);
                    callback(worldCornerTempPos.x,
                        worldCornerTempPos.y,
                        worldCornerTempPos.z);
                }
            };

            var worldCornersTemp = [
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3(),
                new Vec3()
            ];
            Box.prototype.calculateWorldAABB = function (pos, quat, min, max) {

                var e = this.halfExtents;
                worldCornersTemp[0].set(e.x, e.y, e.z);
                worldCornersTemp[1].set(-e.x, e.y, e.z);
                worldCornersTemp[2].set(-e.x, -e.y, e.z);
                worldCornersTemp[3].set(-e.x, -e.y, -e.z);
                worldCornersTemp[4].set(e.x, -e.y, -e.z);
                worldCornersTemp[5].set(e.x, e.y, -e.z);
                worldCornersTemp[6].set(-e.x, e.y, -e.z);
                worldCornersTemp[7].set(e.x, -e.y, e.z);

                var wc = worldCornersTemp[0];
                quat.vmult(wc, wc);
                pos.vadd(wc, wc);
                max.copy(wc);
                min.copy(wc);
                for (var i = 1; i < 8; i++) {
                    var wc = worldCornersTemp[i];
                    quat.vmult(wc, wc);
                    pos.vadd(wc, wc);
                    var x = wc.x;
                    var y = wc.y;
                    var z = wc.z;
                    if (x > max.x) {
                        max.x = x;
                    }
                    if (y > max.y) {
                        max.y = y;
                    }
                    if (z > max.z) {
                        max.z = z;
                    }

                    if (x < min.x) {
                        min.x = x;
                    }
                    if (y < min.y) {
                        min.y = y;
                    }
                    if (z < min.z) {
                        min.z = z;
                    }
                }

                // Get each axis max
                // min.set(Infinity,Infinity,Infinity);
                // max.set(-Infinity,-Infinity,-Infinity);
                // this.forEachWorldCorner(pos,quat,function(x,y,z){
                //     if(x > max.x){
                //         max.x = x;
                //     }
                //     if(y > max.y){
                //         max.y = y;
                //     }
                //     if(z > max.z){
                //         max.z = z;
                //     }

                //     if(x < min.x){
                //         min.x = x;
                //     }
                //     if(y < min.y){
                //         min.y = y;
                //     }
                //     if(z < min.z){
                //         min.z = z;
                //     }
                // });
            };

        }, { "../math/Vec3": 30, "./ConvexPolyhedron": 38, "./Shape": 43 }], 38: [function (_dereq_, module, exports) {
            module.exports = ConvexPolyhedron;

            var Shape = _dereq_('./Shape');
            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Transform = _dereq_('../math/Transform');

            /**
             * A set of polygons describing a convex shape.
             * @class ConvexPolyhedron
             * @constructor
             * @extends Shape
             * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
             * in the same 3D plane), instead these should be merged into one polygon.
             *
             * @param {array} points An array of Vec3's
             * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
             *
             * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
             * @author schteppe / https://github.com/schteppe
             * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
             * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
             *
             * @todo Move the clipping functions to ContactGenerator?
             * @todo Automatically merge coplanar polygons in constructor.
             */
            function ConvexPolyhedron(points, faces, uniqueAxes) {
                var that = this;
                Shape.call(this);
                this.type = Shape.types.CONVEXPOLYHEDRON;

                /**
                 * Array of Vec3
                 * @property vertices
                 * @type {Array}
                 */
                this.vertices = points || [];

                this.worldVertices = []; // World transformed version of .vertices
                this.worldVerticesNeedsUpdate = true;

                /**
                 * Array of integer arrays, indicating which vertices each face consists of
                 * @property faces
                 * @type {Array}
                 */
                this.faces = faces || [];

                /**
                 * Array of Vec3
                 * @property faceNormals
                 * @type {Array}
                 */
                this.faceNormals = [];
                this.computeNormals();

                this.worldFaceNormalsNeedsUpdate = true;
                this.worldFaceNormals = []; // World transformed version of .faceNormals

                /**
                 * Array of Vec3
                 * @property uniqueEdges
                 * @type {Array}
                 */
                this.uniqueEdges = [];

                /**
                 * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
                 * @property {Array} uniqueAxes
                 */
                this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;

                this.computeEdges();
                this.updateBoundingSphereRadius();
            }
            ConvexPolyhedron.prototype = new Shape();
            ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;

            var computeEdges_tmpEdge = new Vec3();
            /**
             * Computes uniqueEdges
             * @method computeEdges
             */
            ConvexPolyhedron.prototype.computeEdges = function () {
                var faces = this.faces;
                var vertices = this.vertices;
                var nv = vertices.length;
                var edges = this.uniqueEdges;

                edges.length = 0;

                var edge = computeEdges_tmpEdge;

                for (var i = 0; i !== faces.length; i++) {
                    var face = faces[i];
                    var numVertices = face.length;
                    for (var j = 0; j !== numVertices; j++) {
                        var k = (j + 1) % numVertices;
                        vertices[face[j]].vsub(vertices[face[k]], edge);
                        edge.normalize();
                        var found = false;
                        for (var p = 0; p !== edges.length; p++) {
                            if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)) {
                                found = true;
                                break;
                            }
                        }

                        if (!found) {
                            edges.push(edge.clone());
                        }
                    }
                }
            };

            /**
             * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
             * @method computeNormals
             */
            ConvexPolyhedron.prototype.computeNormals = function () {
                this.faceNormals.length = this.faces.length;

                // Generate normals
                for (var i = 0; i < this.faces.length; i++) {

                    // Check so all vertices exists for this face
                    for (var j = 0; j < this.faces[i].length; j++) {
                        if (!this.vertices[this.faces[i][j]]) {
                            throw new Error("Vertex " + this.faces[i][j] + " not found!");
                        }
                    }

                    var n = this.faceNormals[i] || new Vec3();
                    this.getFaceNormal(i, n);
                    n.negate(n);
                    this.faceNormals[i] = n;
                    var vertex = this.vertices[this.faces[i][0]];
                    if (n.dot(vertex) < 0) {
                        console.error(".faceNormals[" + i + "] = Vec3(" + n.toString() + ") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
                        for (var j = 0; j < this.faces[i].length; j++) {
                            console.warn(".vertices[" + this.faces[i][j] + "] = Vec3(" + this.vertices[this.faces[i][j]].toString() + ")");
                        }
                    }
                }
            };

            /**
             * Get face normal given 3 vertices
             * @static
             * @method getFaceNormal
             * @param {Vec3} va
             * @param {Vec3} vb
             * @param {Vec3} vc
             * @param {Vec3} target
             */
            var cb = new Vec3();
            var ab = new Vec3();
            ConvexPolyhedron.computeNormal = function (va, vb, vc, target) {
                vb.vsub(va, ab);
                vc.vsub(vb, cb);
                cb.cross(ab, target);
                if (!target.isZero()) {
                    target.normalize();
                }
            };

            /**
             * Compute the normal of a face from its vertices
             * @method getFaceNormal
             * @param  {Number} i
             * @param  {Vec3} target
             */
            ConvexPolyhedron.prototype.getFaceNormal = function (i, target) {
                var f = this.faces[i];
                var va = this.vertices[f[0]];
                var vb = this.vertices[f[1]];
                var vc = this.vertices[f[2]];
                return ConvexPolyhedron.computeNormal(va, vb, vc, target);
            };

            /**
             * @method clipAgainstHull
             * @param {Vec3} posA
             * @param {Quaternion} quatA
             * @param {ConvexPolyhedron} hullB
             * @param {Vec3} posB
             * @param {Quaternion} quatB
             * @param {Vec3} separatingNormal
             * @param {Number} minDist Clamp distance
             * @param {Number} maxDist
             * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
             * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
             */
            var cah_WorldNormal = new Vec3();
            ConvexPolyhedron.prototype.clipAgainstHull = function (posA, quatA, hullB, posB, quatB, separatingNormal, minDist, maxDist, result) {
                var WorldNormal = cah_WorldNormal;
                var hullA = this;
                var curMaxDist = maxDist;
                var closestFaceB = -1;
                var dmax = -Number.MAX_VALUE;
                for (var face = 0; face < hullB.faces.length; face++) {
                    WorldNormal.copy(hullB.faceNormals[face]);
                    quatB.vmult(WorldNormal, WorldNormal);
                    //posB.vadd(WorldNormal,WorldNormal);
                    var d = WorldNormal.dot(separatingNormal);
                    if (d > dmax) {
                        dmax = d;
                        closestFaceB = face;
                    }
                }
                var worldVertsB1 = [];
                var polyB = hullB.faces[closestFaceB];
                var numVertices = polyB.length;
                for (var e0 = 0; e0 < numVertices; e0++) {
                    var b = hullB.vertices[polyB[e0]];
                    var worldb = new Vec3();
                    worldb.copy(b);
                    quatB.vmult(worldb, worldb);
                    posB.vadd(worldb, worldb);
                    worldVertsB1.push(worldb);
                }

                if (closestFaceB >= 0) {
                    this.clipFaceAgainstHull(separatingNormal,
                        posA,
                        quatA,
                        worldVertsB1,
                        minDist,
                        maxDist,
                        result);
                }
            };

            /**
             * Find the separating axis between this hull and another
             * @method findSeparatingAxis
             * @param {ConvexPolyhedron} hullB
             * @param {Vec3} posA
             * @param {Quaternion} quatA
             * @param {Vec3} posB
             * @param {Quaternion} quatB
             * @param {Vec3} target The target vector to save the axis in
             * @return {bool} Returns false if a separation is found, else true
             */
            var fsa_faceANormalWS3 = new Vec3(),
                fsa_Worldnormal1 = new Vec3(),
                fsa_deltaC = new Vec3(),
                fsa_worldEdge0 = new Vec3(),
                fsa_worldEdge1 = new Vec3(),
                fsa_Cross = new Vec3();
            ConvexPolyhedron.prototype.findSeparatingAxis = function (hullB, posA, quatA, posB, quatB, target, faceListA, faceListB) {
                var faceANormalWS3 = fsa_faceANormalWS3,
                    Worldnormal1 = fsa_Worldnormal1,
                    deltaC = fsa_deltaC,
                    worldEdge0 = fsa_worldEdge0,
                    worldEdge1 = fsa_worldEdge1,
                    Cross = fsa_Cross;

                var dmin = Number.MAX_VALUE;
                var hullA = this;
                var curPlaneTests = 0;

                if (!hullA.uniqueAxes) {

                    var numFacesA = faceListA ? faceListA.length : hullA.faces.length;

                    // Test face normals from hullA
                    for (var i = 0; i < numFacesA; i++) {
                        var fi = faceListA ? faceListA[i] : i;

                        // Get world face normal
                        faceANormalWS3.copy(hullA.faceNormals[fi]);
                        quatA.vmult(faceANormalWS3, faceANormalWS3);

                        var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
                        if (d === false) {
                            return false;
                        }

                        if (d < dmin) {
                            dmin = d;
                            target.copy(faceANormalWS3);
                        }
                    }

                } else {

                    // Test unique axes
                    for (var i = 0; i !== hullA.uniqueAxes.length; i++) {

                        // Get world axis
                        quatA.vmult(hullA.uniqueAxes[i], faceANormalWS3);

                        var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
                        if (d === false) {
                            return false;
                        }

                        if (d < dmin) {
                            dmin = d;
                            target.copy(faceANormalWS3);
                        }
                    }
                }

                if (!hullB.uniqueAxes) {

                    // Test face normals from hullB
                    var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
                    for (var i = 0; i < numFacesB; i++) {

                        var fi = faceListB ? faceListB[i] : i;

                        Worldnormal1.copy(hullB.faceNormals[fi]);
                        quatB.vmult(Worldnormal1, Worldnormal1);
                        curPlaneTests++;
                        var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
                        if (d === false) {
                            return false;
                        }

                        if (d < dmin) {
                            dmin = d;
                            target.copy(Worldnormal1);
                        }
                    }
                } else {

                    // Test unique axes in B
                    for (var i = 0; i !== hullB.uniqueAxes.length; i++) {
                        quatB.vmult(hullB.uniqueAxes[i], Worldnormal1);

                        curPlaneTests++;
                        var d = hullA.testSepAxis(Worldnormal1, hullB, posA, quatA, posB, quatB);
                        if (d === false) {
                            return false;
                        }

                        if (d < dmin) {
                            dmin = d;
                            target.copy(Worldnormal1);
                        }
                    }
                }

                // Test edges
                for (var e0 = 0; e0 !== hullA.uniqueEdges.length; e0++) {

                    // Get world edge
                    quatA.vmult(hullA.uniqueEdges[e0], worldEdge0);

                    for (var e1 = 0; e1 !== hullB.uniqueEdges.length; e1++) {

                        // Get world edge 2
                        quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
                        worldEdge0.cross(worldEdge1, Cross);

                        if (!Cross.almostZero()) {
                            Cross.normalize();
                            var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
                            if (dist === false) {
                                return false;
                            }
                            if (dist < dmin) {
                                dmin = dist;
                                target.copy(Cross);
                            }
                        }
                    }
                }

                posB.vsub(posA, deltaC);
                if ((deltaC.dot(target)) > 0.0) {
                    target.negate(target);
                }

                return true;
            };

            var maxminA = [], maxminB = [];

            /**
             * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
             * @method testSepAxis
             * @param {Vec3} axis
             * @param {ConvexPolyhedron} hullB
             * @param {Vec3} posA
             * @param {Quaternion} quatA
             * @param {Vec3} posB
             * @param {Quaternion} quatB
             * @return {number} The overlap depth, or FALSE if no penetration.
             */
            ConvexPolyhedron.prototype.testSepAxis = function (axis, hullB, posA, quatA, posB, quatB) {
                var hullA = this;
                ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
                ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
                var maxA = maxminA[0];
                var minA = maxminA[1];
                var maxB = maxminB[0];
                var minB = maxminB[1];
                if (maxA < minB || maxB < minA) {
                    return false; // Separated
                }
                var d0 = maxA - minB;
                var d1 = maxB - minA;
                var depth = d0 < d1 ? d0 : d1;
                return depth;
            };

            var cli_aabbmin = new Vec3(),
                cli_aabbmax = new Vec3();

            /**
             * @method calculateLocalInertia
             * @param  {Number} mass
             * @param  {Vec3} target
             */
            ConvexPolyhedron.prototype.calculateLocalInertia = function (mass, target) {
                // Approximate with box inertia
                // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
                this.computeLocalAABB(cli_aabbmin, cli_aabbmax);
                var x = cli_aabbmax.x - cli_aabbmin.x,
                    y = cli_aabbmax.y - cli_aabbmin.y,
                    z = cli_aabbmax.z - cli_aabbmin.z;
                target.x = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z);
                target.y = 1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z);
                target.z = 1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x);
            };

            /**
             * @method getPlaneConstantOfFace
             * @param  {Number} face_i Index of the face
             * @return {Number}
             */
            ConvexPolyhedron.prototype.getPlaneConstantOfFace = function (face_i) {
                var f = this.faces[face_i];
                var n = this.faceNormals[face_i];
                var v = this.vertices[f[0]];
                var c = -n.dot(v);
                return c;
            };

            /**
             * Clip a face against a hull.
             * @method clipFaceAgainstHull
             * @param {Vec3} separatingNormal
             * @param {Vec3} posA
             * @param {Quaternion} quatA
             * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
             * @param {Number} minDist Distance clamping
             * @param {Number} maxDist
             * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
             */
            var cfah_faceANormalWS = new Vec3(),
                cfah_edge0 = new Vec3(),
                cfah_WorldEdge0 = new Vec3(),
                cfah_worldPlaneAnormal1 = new Vec3(),
                cfah_planeNormalWS1 = new Vec3(),
                cfah_worldA1 = new Vec3(),
                cfah_localPlaneNormal = new Vec3(),
                cfah_planeNormalWS = new Vec3();
            ConvexPolyhedron.prototype.clipFaceAgainstHull = function (separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist, result) {
                var faceANormalWS = cfah_faceANormalWS,
                    edge0 = cfah_edge0,
                    WorldEdge0 = cfah_WorldEdge0,
                    worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
                    planeNormalWS1 = cfah_planeNormalWS1,
                    worldA1 = cfah_worldA1,
                    localPlaneNormal = cfah_localPlaneNormal,
                    planeNormalWS = cfah_planeNormalWS;

                var hullA = this;
                var worldVertsB2 = [];
                var pVtxIn = worldVertsB1;
                var pVtxOut = worldVertsB2;
                // Find the face with normal closest to the separating axis
                var closestFaceA = -1;
                var dmin = Number.MAX_VALUE;
                for (var face = 0; face < hullA.faces.length; face++) {
                    faceANormalWS.copy(hullA.faceNormals[face]);
                    quatA.vmult(faceANormalWS, faceANormalWS);
                    //posA.vadd(faceANormalWS,faceANormalWS);
                    var d = faceANormalWS.dot(separatingNormal);
                    if (d < dmin) {
                        dmin = d;
                        closestFaceA = face;
                    }
                }
                if (closestFaceA < 0) {
                    // console.log("--- did not find any closest face... ---");
                    return;
                }
                //console.log("closest A: ",closestFaceA);
                // Get the face and construct connected faces
                var polyA = hullA.faces[closestFaceA];
                polyA.connectedFaces = [];
                for (var i = 0; i < hullA.faces.length; i++) {
                    for (var j = 0; j < hullA.faces[i].length; j++) {
                        if (polyA.indexOf(hullA.faces[i][j]) !== -1 /* Sharing a vertex*/ && i !== closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i) === -1 /* Not already added */) {
                            polyA.connectedFaces.push(i);
                        }
                    }
                }
                // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
                var numContacts = pVtxIn.length;
                var numVerticesA = polyA.length;
                var res = [];
                for (var e0 = 0; e0 < numVerticesA; e0++) {
                    var a = hullA.vertices[polyA[e0]];
                    var b = hullA.vertices[polyA[(e0 + 1) % numVerticesA]];
                    a.vsub(b, edge0);
                    WorldEdge0.copy(edge0);
                    quatA.vmult(WorldEdge0, WorldEdge0);
                    posA.vadd(WorldEdge0, WorldEdge0);
                    worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
                    quatA.vmult(worldPlaneAnormal1, worldPlaneAnormal1);
                    posA.vadd(worldPlaneAnormal1, worldPlaneAnormal1);
                    WorldEdge0.cross(worldPlaneAnormal1, planeNormalWS1);
                    planeNormalWS1.negate(planeNormalWS1);
                    worldA1.copy(a);
                    quatA.vmult(worldA1, worldA1);
                    posA.vadd(worldA1, worldA1);
                    var planeEqWS1 = -worldA1.dot(planeNormalWS1);
                    var planeEqWS;
                    if (true) {
                        var otherFace = polyA.connectedFaces[e0];
                        localPlaneNormal.copy(this.faceNormals[otherFace]);
                        var localPlaneEq = this.getPlaneConstantOfFace(otherFace);

                        planeNormalWS.copy(localPlaneNormal);
                        quatA.vmult(planeNormalWS, planeNormalWS);
                        //posA.vadd(planeNormalWS,planeNormalWS);
                        var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
                    } else {
                        planeNormalWS.copy(planeNormalWS1);
                        planeEqWS = planeEqWS1;
                    }

                    // Clip face against our constructed plane
                    this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);

                    // Throw away all clipped points, but save the reamining until next clip
                    while (pVtxIn.length) {
                        pVtxIn.shift();
                    }
                    while (pVtxOut.length) {
                        pVtxIn.push(pVtxOut.shift());
                    }
                }

                //console.log("Resulting points after clip:",pVtxIn);

                // only keep contact points that are behind the witness face
                localPlaneNormal.copy(this.faceNormals[closestFaceA]);

                var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
                planeNormalWS.copy(localPlaneNormal);
                quatA.vmult(planeNormalWS, planeNormalWS);

                var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
                for (var i = 0; i < pVtxIn.length; i++) {
                    var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
                    /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
                    if (depth <= minDist) {
                        console.log("clamped: depth=" + depth + " to minDist=" + (minDist + ""));
                        depth = minDist;
                    }

                    if (depth <= maxDist) {
                        var point = pVtxIn[i];
                        if (depth <= 0) {
                            /*console.log("Got contact point ",point.toString(),
                              ", depth=",depth,
                              "contact normal=",separatingNormal.toString(),
                              "plane",planeNormalWS.toString(),
                              "planeConstant",planeEqWS);*/
                            var p = {
                                point: point,
                                normal: planeNormalWS,
                                depth: depth,
                            };
                            result.push(p);
                        }
                    }
                }
            };

            /**
             * Clip a face in a hull against the back of a plane.
             * @method clipFaceAgainstPlane
             * @param {Array} inVertices
             * @param {Array} outVertices
             * @param {Vec3} planeNormal
             * @param {Number} planeConstant The constant in the mathematical plane equation
             */
            ConvexPolyhedron.prototype.clipFaceAgainstPlane = function (inVertices, outVertices, planeNormal, planeConstant) {
                var n_dot_first, n_dot_last;
                var numVerts = inVertices.length;

                if (numVerts < 2) {
                    return outVertices;
                }

                var firstVertex = inVertices[inVertices.length - 1],
                    lastVertex = inVertices[0];

                n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

                for (var vi = 0; vi < numVerts; vi++) {
                    lastVertex = inVertices[vi];
                    n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
                    if (n_dot_first < 0) {
                        if (n_dot_last < 0) {
                            // Start < 0, end < 0, so output lastVertex
                            var newv = new Vec3();
                            newv.copy(lastVertex);
                            outVertices.push(newv);
                        } else {
                            // Start < 0, end >= 0, so output intersection
                            var newv = new Vec3();
                            firstVertex.lerp(lastVertex,
                                n_dot_first / (n_dot_first - n_dot_last),
                                newv);
                            outVertices.push(newv);
                        }
                    } else {
                        if (n_dot_last < 0) {
                            // Start >= 0, end < 0 so output intersection and end
                            var newv = new Vec3();
                            firstVertex.lerp(lastVertex,
                                n_dot_first / (n_dot_first - n_dot_last),
                                newv);
                            outVertices.push(newv);
                            outVertices.push(lastVertex);
                        }
                    }
                    firstVertex = lastVertex;
                    n_dot_first = n_dot_last;
                }
                return outVertices;
            };

            // Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
            ConvexPolyhedron.prototype.computeWorldVertices = function (position, quat) {
                var N = this.vertices.length;
                while (this.worldVertices.length < N) {
                    this.worldVertices.push(new Vec3());
                }

                var verts = this.vertices,
                    worldVerts = this.worldVertices;
                for (var i = 0; i !== N; i++) {
                    quat.vmult(verts[i], worldVerts[i]);
                    position.vadd(worldVerts[i], worldVerts[i]);
                }

                this.worldVerticesNeedsUpdate = false;
            };

            var computeLocalAABB_worldVert = new Vec3();
            ConvexPolyhedron.prototype.computeLocalAABB = function (aabbmin, aabbmax) {
                var n = this.vertices.length,
                    vertices = this.vertices,
                    worldVert = computeLocalAABB_worldVert;

                aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
                aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

                for (var i = 0; i < n; i++) {
                    var v = vertices[i];
                    if (v.x < aabbmin.x) {
                        aabbmin.x = v.x;
                    } else if (v.x > aabbmax.x) {
                        aabbmax.x = v.x;
                    }
                    if (v.y < aabbmin.y) {
                        aabbmin.y = v.y;
                    } else if (v.y > aabbmax.y) {
                        aabbmax.y = v.y;
                    }
                    if (v.z < aabbmin.z) {
                        aabbmin.z = v.z;
                    } else if (v.z > aabbmax.z) {
                        aabbmax.z = v.z;
                    }
                }
            };

            /**
             * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
             * @method computeWorldFaceNormals
             * @param  {Quaternion} quat
             */
            ConvexPolyhedron.prototype.computeWorldFaceNormals = function (quat) {
                var N = this.faceNormals.length;
                while (this.worldFaceNormals.length < N) {
                    this.worldFaceNormals.push(new Vec3());
                }

                var normals = this.faceNormals,
                    worldNormals = this.worldFaceNormals;
                for (var i = 0; i !== N; i++) {
                    quat.vmult(normals[i], worldNormals[i]);
                }

                this.worldFaceNormalsNeedsUpdate = false;
            };

            /**
             * @method updateBoundingSphereRadius
             */
            ConvexPolyhedron.prototype.updateBoundingSphereRadius = function () {
                // Assume points are distributed with local (0,0,0) as center
                var max2 = 0;
                var verts = this.vertices;
                for (var i = 0, N = verts.length; i !== N; i++) {
                    var norm2 = verts[i].norm2();
                    if (norm2 > max2) {
                        max2 = norm2;
                    }
                }
                this.boundingSphereRadius = Math.sqrt(max2);
            };

            var tempWorldVertex = new Vec3();

            /**
             * @method calculateWorldAABB
             * @param {Vec3}        pos
             * @param {Quaternion}  quat
             * @param {Vec3}        min
             * @param {Vec3}        max
             */
            ConvexPolyhedron.prototype.calculateWorldAABB = function (pos, quat, min, max) {
                var n = this.vertices.length, verts = this.vertices;
                var minx, miny, minz, maxx, maxy, maxz;
                for (var i = 0; i < n; i++) {
                    tempWorldVertex.copy(verts[i]);
                    quat.vmult(tempWorldVertex, tempWorldVertex);
                    pos.vadd(tempWorldVertex, tempWorldVertex);
                    var v = tempWorldVertex;
                    if (v.x < minx || minx === undefined) {
                        minx = v.x;
                    } else if (v.x > maxx || maxx === undefined) {
                        maxx = v.x;
                    }

                    if (v.y < miny || miny === undefined) {
                        miny = v.y;
                    } else if (v.y > maxy || maxy === undefined) {
                        maxy = v.y;
                    }

                    if (v.z < minz || minz === undefined) {
                        minz = v.z;
                    } else if (v.z > maxz || maxz === undefined) {
                        maxz = v.z;
                    }
                }
                min.set(minx, miny, minz);
                max.set(maxx, maxy, maxz);
            };

            /**
             * Get approximate convex volume
             * @method volume
             * @return {Number}
             */
            ConvexPolyhedron.prototype.volume = function () {
                return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
            };

            /**
             * Get an average of all the vertices positions
             * @method getAveragePointLocal
             * @param  {Vec3} target
             * @return {Vec3}
             */
            ConvexPolyhedron.prototype.getAveragePointLocal = function (target) {
                target = target || new Vec3();
                var n = this.vertices.length,
                    verts = this.vertices;
                for (var i = 0; i < n; i++) {
                    target.vadd(verts[i], target);
                }
                target.mult(1 / n, target);
                return target;
            };

            /**
             * Transform all local points. Will change the .vertices
             * @method transformAllPoints
             * @param  {Vec3} offset
             * @param  {Quaternion} quat
             */
            ConvexPolyhedron.prototype.transformAllPoints = function (offset, quat) {
                var n = this.vertices.length,
                    verts = this.vertices;

                // Apply rotation
                if (quat) {
                    // Rotate vertices
                    for (var i = 0; i < n; i++) {
                        var v = verts[i];
                        quat.vmult(v, v);
                    }
                    // Rotate face normals
                    for (var i = 0; i < this.faceNormals.length; i++) {
                        var v = this.faceNormals[i];
                        quat.vmult(v, v);
                    }
                    /*
                    // Rotate edges
                    for(var i=0; i<this.uniqueEdges.length; i++){
                        var v = this.uniqueEdges[i];
                        quat.vmult(v,v);
                    }*/
                }

                // Apply offset
                if (offset) {
                    for (var i = 0; i < n; i++) {
                        var v = verts[i];
                        v.vadd(offset, v);
                    }
                }
            };

            /**
             * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
             * @method pointIsInside
             * @param  {Vec3} p      A point given in local coordinates
             * @return {Boolean}
             */
            var ConvexPolyhedron_pointIsInside = new Vec3();
            var ConvexPolyhedron_vToP = new Vec3();
            var ConvexPolyhedron_vToPointInside = new Vec3();
            ConvexPolyhedron.prototype.pointIsInside = function (p) {
                var n = this.vertices.length,
                    verts = this.vertices,
                    faces = this.faces,
                    normals = this.faceNormals;
                var positiveResult = null;
                var N = this.faces.length;
                var pointInside = ConvexPolyhedron_pointIsInside;
                this.getAveragePointLocal(pointInside);
                for (var i = 0; i < N; i++) {
                    var numVertices = this.faces[i].length;
                    var n = normals[i];
                    var v = verts[faces[i][0]]; // We only need one point in the face

                    // This dot product determines which side of the edge the point is
                    var vToP = ConvexPolyhedron_vToP;
                    p.vsub(v, vToP);
                    var r1 = n.dot(vToP);

                    var vToPointInside = ConvexPolyhedron_vToPointInside;
                    pointInside.vsub(v, vToPointInside);
                    var r2 = n.dot(vToPointInside);

                    if ((r1 < 0 && r2 > 0) || (r1 > 0 && r2 < 0)) {
                        return false; // Encountered some other sign. Exit.
                    } else {
                    }
                }

                // If we got here, all dot products were of the same sign.
                return positiveResult ? 1 : -1;
            };

            /**
             * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
             * @static
             * @method project
             * @param {ConvexPolyhedron} hull
             * @param {Vec3} axis
             * @param {Vec3} pos
             * @param {Quaternion} quat
             * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
             */
            var project_worldVertex = new Vec3();
            var project_localAxis = new Vec3();
            var project_localOrigin = new Vec3();
            ConvexPolyhedron.project = function (hull, axis, pos, quat, result) {
                var n = hull.vertices.length,
                    worldVertex = project_worldVertex,
                    localAxis = project_localAxis,
                    max = 0,
                    min = 0,
                    localOrigin = project_localOrigin,
                    vs = hull.vertices;

                localOrigin.setZero();

                // Transform the axis to local
                Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
                Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
                var add = localOrigin.dot(localAxis);

                min = max = vs[0].dot(localAxis);

                for (var i = 1; i < n; i++) {
                    var val = vs[i].dot(localAxis);

                    if (val > max) {
                        max = val;
                    }

                    if (val < min) {
                        min = val;
                    }
                }

                min -= add;
                max -= add;

                if (min > max) {
                    // Inconsistent - swap
                    var temp = min;
                    min = max;
                    max = temp;
                }
                // Output
                result[0] = max;
                result[1] = min;
            };

        }, { "../math/Quaternion": 28, "../math/Transform": 29, "../math/Vec3": 30, "./Shape": 43 }], 39: [function (_dereq_, module, exports) {
            module.exports = Cylinder;

            var Shape = _dereq_('./Shape');
            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

            /**
             * @class Cylinder
             * @constructor
             * @extends ConvexPolyhedron
             * @author schteppe / https://github.com/schteppe
             * @param {Number} radiusTop
             * @param {Number} radiusBottom
             * @param {Number} height
             * @param {Number} numSegments The number of segments to build the cylinder out of
             */
            function Cylinder(radiusTop, radiusBottom, height, numSegments) {
                var N = numSegments,
                    verts = [],
                    axes = [],
                    faces = [],
                    bottomface = [],
                    topface = [],
                    cos = Math.cos,
                    sin = Math.sin;

                // First bottom point
                verts.push(new Vec3(radiusBottom * cos(0),
                    radiusBottom * sin(0),
                    -height * 0.5));
                bottomface.push(0);

                // First top point
                verts.push(new Vec3(radiusTop * cos(0),
                    radiusTop * sin(0),
                    height * 0.5));
                topface.push(1);

                for (var i = 0; i < N; i++) {
                    var theta = 2 * Math.PI / N * (i + 1);
                    var thetaN = 2 * Math.PI / N * (i + 0.5);
                    if (i < N - 1) {
                        // Bottom
                        verts.push(new Vec3(radiusBottom * cos(theta),
                            radiusBottom * sin(theta),
                            -height * 0.5));
                        bottomface.push(2 * i + 2);
                        // Top
                        verts.push(new Vec3(radiusTop * cos(theta),
                            radiusTop * sin(theta),
                            height * 0.5));
                        topface.push(2 * i + 3);

                        // Face
                        faces.push([2 * i + 2, 2 * i + 3, 2 * i + 1, 2 * i]);
                    } else {
                        faces.push([0, 1, 2 * i + 1, 2 * i]); // Connect
                    }

                    // Axis: we can cut off half of them if we have even number of segments
                    if (N % 2 === 1 || i < N / 2) {
                        axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
                    }
                }
                faces.push(topface);
                axes.push(new Vec3(0, 0, 1));

                // Reorder bottom face
                var temp = [];
                for (var i = 0; i < bottomface.length; i++) {
                    temp.push(bottomface[bottomface.length - i - 1]);
                }
                faces.push(temp);

                this.type = Shape.types.CONVEXPOLYHEDRON;
                ConvexPolyhedron.call(this, verts, faces, axes);
            }

            Cylinder.prototype = new ConvexPolyhedron();

        }, { "../math/Quaternion": 28, "../math/Vec3": 30, "./ConvexPolyhedron": 38, "./Shape": 43 }], 40: [function (_dereq_, module, exports) {
            var Shape = _dereq_('./Shape');
            var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
            var Vec3 = _dereq_('../math/Vec3');
            var Utils = _dereq_('../utils/Utils');

            module.exports = Heightfield;

            /**
             * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
             * @class Heightfield
             * @extends Shape
             * @constructor
             * @param {Array} data An array of Y values that will be used to construct the terrain.
             * @param {object} options
             * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
             * @param {Number} [options.maxValue] Maximum value.
             * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
             * @todo Should be possible to use along all axes, not just y
             *
             * @example
             *     // Generate some height data (y-values).
             *     var data = [];
             *     for(var i = 0; i < 1000; i++){
             *         var y = 0.5 * Math.cos(0.2 * i);
             *         data.push(y);
             *     }
             *
             *     // Create the heightfield shape
             *     var heightfieldShape = new Heightfield(data, {
             *         elementSize: 1 // Distance between the data points in X and Y directions
             *     });
             *     var heightfieldBody = new Body();
             *     heightfieldBody.addShape(heightfieldShape);
             *     world.addBody(heightfieldBody);
             */
            function Heightfield(data, options) {
                options = Utils.defaults(options, {
                    maxValue: null,
                    minValue: null,
                    elementSize: 1
                });

                /**
                 * An array of numbers, or height values, that are spread out along the x axis.
                 * @property {array} data
                 */
                this.data = data;

                /**
                 * Max value of the data
                 * @property {number} maxValue
                 */
                this.maxValue = options.maxValue;

                /**
                 * Max value of the data
                 * @property {number} minValue
                 */
                this.minValue = options.minValue;

                /**
                 * The width of each element
                 * @property {number} elementSize
                 * @todo elementSizeX and Y
                 */
                this.elementSize = options.elementSize;

                if (options.minValue === null) {
                    this.updateMinValue();
                }
                if (options.maxValue === null) {
                    this.updateMaxValue();
                }

                this.cacheEnabled = true;

                Shape.call(this);

                this.pillarConvex = new ConvexPolyhedron();
                this.pillarOffset = new Vec3();

                this.type = Shape.types.HEIGHTFIELD;
                this.updateBoundingSphereRadius();

                // "i_j_isUpper" => { convex: ..., offset: ... }
                // for example:
                // _cachedPillars["0_2_1"]
                this._cachedPillars = {};
            }
            Heightfield.prototype = new Shape();

            /**
             * Call whenever you change the data array.
             * @method update
             */
            Heightfield.prototype.update = function () {
                this._cachedPillars = {};
            };

            /**
             * Update the .minValue property
             * @method updateMinValue
             */
            Heightfield.prototype.updateMinValue = function () {
                var data = this.data;
                var minValue = data[0][0];
                for (var i = 0; i !== data.length; i++) {
                    for (var j = 0; j !== data[i].length; j++) {
                        var v = data[i][j];
                        if (v < minValue) {
                            minValue = v;
                        }
                    }
                }
                this.minValue = minValue;
            };

            /**
             * Update the .maxValue property
             * @method updateMaxValue
             */
            Heightfield.prototype.updateMaxValue = function () {
                var data = this.data;
                var maxValue = data[0][0];
                for (var i = 0; i !== data.length; i++) {
                    for (var j = 0; j !== data[i].length; j++) {
                        var v = data[i][j];
                        if (v > maxValue) {
                            maxValue = v;
                        }
                    }
                }
                this.maxValue = maxValue;
            };

            /**
             * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
             * @method setHeightValueAtIndex
             * @param {integer} xi
             * @param {integer} yi
             * @param {number} value
             */
            Heightfield.prototype.setHeightValueAtIndex = function (xi, yi, value) {
                var data = this.data;
                data[xi][yi] = value;

                // Invalidate cache
                this.clearCachedConvexTrianglePillar(xi, yi, false);
                if (xi > 0) {
                    this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
                    this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
                }
                if (yi > 0) {
                    this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
                    this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
                }
                if (yi > 0 && xi > 0) {
                    this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
                }
            };

            /**
             * Get max/min in a rectangle in the matrix data
             * @method getRectMinMax
             * @param  {integer} iMinX
             * @param  {integer} iMinY
             * @param  {integer} iMaxX
             * @param  {integer} iMaxY
             * @param  {array} [result] An array to store the results in.
             * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
             */
            Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
                result = result || [];

                // Get max and min of the data
                var data = this.data,
                    max = this.minValue; // Set first value
                for (var i = iMinX; i <= iMaxX; i++) {
                    for (var j = iMinY; j <= iMaxY; j++) {
                        var height = data[i][j];
                        if (height > max) {
                            max = height;
                        }
                    }
                }

                result[0] = this.minValue;
                result[1] = max;
            };

            /**
             * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
             * @method getIndexOfPosition
             * @param  {number} x
             * @param  {number} y
             * @param  {array} result Two-element array
             * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
             * @return {boolean}
             */
            Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {

                // Get the index of the data points to test against
                var w = this.elementSize;
                var data = this.data;
                var xi = Math.floor(x / w);
                var yi = Math.floor(y / w);

                result[0] = xi;
                result[1] = yi;

                if (clamp) {
                    // Clamp index to edges
                    if (xi < 0) { xi = 0; }
                    if (yi < 0) { yi = 0; }
                    if (xi >= data.length - 1) { xi = data.length - 1; }
                    if (yi >= data[0].length - 1) { yi = data[0].length - 1; }
                }

                // Bail out if we are out of the terrain
                if (xi < 0 || yi < 0 || xi >= data.length - 1 || yi >= data[0].length - 1) {
                    return false;
                }

                return true;
            };

            Heightfield.prototype.getHeightAt = function (x, y, edgeClamp) {
                var idx = [];
                this.getIndexOfPosition(x, y, idx, edgeClamp);

                // TODO: get upper or lower triangle, then use barycentric interpolation to get the height in the triangle.
                var minmax = [];
                this.getRectMinMax(idx[0], idx[1] + 1, idx[0], idx[1] + 1, minmax);

                return (minmax[0] + minmax[1]) / 2; // average
            };

            Heightfield.prototype.getCacheConvexTrianglePillarKey = function (xi, yi, getUpperTriangle) {
                return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
            };

            Heightfield.prototype.getCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
                return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
            };

            Heightfield.prototype.setCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle, convex, offset) {
                this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
                    convex: convex,
                    offset: offset
                };
            };

            Heightfield.prototype.clearCachedConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
                delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
            };

            /**
             * Get a triangle in the terrain in the form of a triangular convex shape.
             * @method getConvexTrianglePillar
             * @param  {integer} i
             * @param  {integer} j
             * @param  {boolean} getUpperTriangle
             */
            Heightfield.prototype.getConvexTrianglePillar = function (xi, yi, getUpperTriangle) {
                var result = this.pillarConvex;
                var offsetResult = this.pillarOffset;

                if (this.cacheEnabled) {
                    var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
                    if (data) {
                        this.pillarConvex = data.convex;
                        this.pillarOffset = data.offset;
                        return;
                    }

                    result = new ConvexPolyhedron();
                    offsetResult = new Vec3();

                    this.pillarConvex = result;
                    this.pillarOffset = offsetResult;
                }

                var data = this.data;
                var elementSize = this.elementSize;
                var faces = result.faces;

                // Reuse verts if possible
                result.vertices.length = 6;
                for (var i = 0; i < 6; i++) {
                    if (!result.vertices[i]) {
                        result.vertices[i] = new Vec3();
                    }
                }

                // Reuse faces if possible
                faces.length = 5;
                for (var i = 0; i < 5; i++) {
                    if (!faces[i]) {
                        faces[i] = [];
                    }
                }

                var verts = result.vertices;

                var h = (Math.min(
                    data[xi][yi],
                    data[xi + 1][yi],
                    data[xi][yi + 1],
                    data[xi + 1][yi + 1]
                ) - this.minValue) / 2 + this.minValue;

                if (!getUpperTriangle) {

                    // Center of the triangle pillar - all polygons are given relative to this one
                    offsetResult.set(
                        (xi + 0.25) * elementSize, // sort of center of a triangle
                        (yi + 0.25) * elementSize,
                        h // vertical center
                    );

                    // Top triangle verts
                    verts[0].set(
                        -0.25 * elementSize,
                        -0.25 * elementSize,
                        data[xi][yi] - h
                    );
                    verts[1].set(
                        0.75 * elementSize,
                        -0.25 * elementSize,
                        data[xi + 1][yi] - h
                    );
                    verts[2].set(
                        -0.25 * elementSize,
                        0.75 * elementSize,
                        data[xi][yi + 1] - h
                    );

                    // bottom triangle verts
                    verts[3].set(
                        -0.25 * elementSize,
                        -0.25 * elementSize,
                        -h - 1
                    );
                    verts[4].set(
                        0.75 * elementSize,
                        -0.25 * elementSize,
                        -h - 1
                    );
                    verts[5].set(
                        -0.25 * elementSize,
                        0.75 * elementSize,
                        -h - 1
                    );

                    // top triangle
                    faces[0][0] = 0;
                    faces[0][1] = 1;
                    faces[0][2] = 2;

                    // bottom triangle
                    faces[1][0] = 5;
                    faces[1][1] = 4;
                    faces[1][2] = 3;

                    // -x facing quad
                    faces[2][0] = 0;
                    faces[2][1] = 2;
                    faces[2][2] = 5;
                    faces[2][3] = 3;

                    // -y facing quad
                    faces[3][0] = 1;
                    faces[3][1] = 0;
                    faces[3][2] = 3;
                    faces[3][3] = 4;

                    // +xy facing quad
                    faces[4][0] = 4;
                    faces[4][1] = 5;
                    faces[4][2] = 2;
                    faces[4][3] = 1;


                } else {

                    // Center of the triangle pillar - all polygons are given relative to this one
                    offsetResult.set(
                        (xi + 0.75) * elementSize, // sort of center of a triangle
                        (yi + 0.75) * elementSize,
                        h // vertical center
                    );

                    // Top triangle verts
                    verts[0].set(
                        0.25 * elementSize,
                        0.25 * elementSize,
                        data[xi + 1][yi + 1] - h
                    );
                    verts[1].set(
                        -0.75 * elementSize,
                        0.25 * elementSize,
                        data[xi][yi + 1] - h
                    );
                    verts[2].set(
                        0.25 * elementSize,
                        -0.75 * elementSize,
                        data[xi + 1][yi] - h
                    );

                    // bottom triangle verts
                    verts[3].set(
                        0.25 * elementSize,
                        0.25 * elementSize,
                        - h - 1
                    );
                    verts[4].set(
                        -0.75 * elementSize,
                        0.25 * elementSize,
                        - h - 1
                    );
                    verts[5].set(
                        0.25 * elementSize,
                        -0.75 * elementSize,
                        - h - 1
                    );

                    // Top triangle
                    faces[0][0] = 0;
                    faces[0][1] = 1;
                    faces[0][2] = 2;

                    // bottom triangle
                    faces[1][0] = 5;
                    faces[1][1] = 4;
                    faces[1][2] = 3;

                    // +x facing quad
                    faces[2][0] = 2;
                    faces[2][1] = 5;
                    faces[2][2] = 3;
                    faces[2][3] = 0;

                    // +y facing quad
                    faces[3][0] = 3;
                    faces[3][1] = 4;
                    faces[3][2] = 1;
                    faces[3][3] = 0;

                    // -xy facing quad
                    faces[4][0] = 1;
                    faces[4][1] = 4;
                    faces[4][2] = 5;
                    faces[4][3] = 2;
                }

                result.computeNormals();
                result.computeEdges();
                result.updateBoundingSphereRadius();

                this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
            };

            Heightfield.prototype.calculateLocalInertia = function (mass, target) {
                target = target || new Vec3();
                target.set(0, 0, 0);
                return target;
            };

            Heightfield.prototype.volume = function () {
                return Number.MAX_VALUE; // The terrain is infinite
            };

            Heightfield.prototype.calculateWorldAABB = function (pos, quat, min, max) {
                // TODO: do it properly
                min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
                max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            };

            Heightfield.prototype.updateBoundingSphereRadius = function () {
                // Use the bounding box of the min/max values
                var data = this.data,
                    s = this.elementSize;
                this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
            };

        }, { "../math/Vec3": 30, "../utils/Utils": 53, "./ConvexPolyhedron": 38, "./Shape": 43 }], 41: [function (_dereq_, module, exports) {
            module.exports = Particle;

            var Shape = _dereq_('./Shape');
            var Vec3 = _dereq_('../math/Vec3');

            /**
             * Particle shape.
             * @class Particle
             * @constructor
             * @author schteppe
             * @extends Shape
             */
            function Particle() {
                Shape.call(this);

                this.type = Shape.types.PARTICLE;
            }
            Particle.prototype = new Shape();
            Particle.prototype.constructor = Particle;

            /**
             * @method calculateLocalInertia
             * @param  {Number} mass
             * @param  {Vec3} target
             * @return {Vec3}
             */
            Particle.prototype.calculateLocalInertia = function (mass, target) {
                target = target || new Vec3();
                target.set(0, 0, 0);
                return target;
            };

            Particle.prototype.volume = function () {
                return 0;
            };

            Particle.prototype.updateBoundingSphereRadius = function () {
                this.boundingSphereRadius = 0;
            };

            Particle.prototype.calculateWorldAABB = function (pos, quat, min, max) {
                // Get each axis max
                min.copy(pos);
                max.copy(pos);
            };

        }, { "../math/Vec3": 30, "./Shape": 43 }], 42: [function (_dereq_, module, exports) {
            module.exports = Plane;

            var Shape = _dereq_('./Shape');
            var Vec3 = _dereq_('../math/Vec3');

            /**
             * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a RigidBody and rotate that body. See the demos.
             * @class Plane
             * @constructor
             * @extends Shape
             * @author schteppe
             */
            function Plane() {
                Shape.call(this);
                this.type = Shape.types.PLANE;

                // World oriented normal
                this.worldNormal = new Vec3();
                this.worldNormalNeedsUpdate = true;

                this.boundingSphereRadius = Number.MAX_VALUE;
            }
            Plane.prototype = new Shape();
            Plane.prototype.constructor = Plane;

            Plane.prototype.computeWorldNormal = function (quat) {
                var n = this.worldNormal;
                n.set(0, 0, 1);
                quat.vmult(n, n);
                this.worldNormalNeedsUpdate = false;
            };

            Plane.prototype.calculateLocalInertia = function (mass, target) {
                target = target || new Vec3();
                return target;
            };

            Plane.prototype.volume = function () {
                return Number.MAX_VALUE; // The plane is infinite...
            };

            var tempNormal = new Vec3();
            Plane.prototype.calculateWorldAABB = function (pos, quat, min, max) {
                // The plane AABB is infinite, except if the normal is pointing along any axis
                tempNormal.set(0, 0, 1); // Default plane normal is z
                quat.vmult(tempNormal, tempNormal);
                var maxVal = Number.MAX_VALUE;
                min.set(-maxVal, -maxVal, -maxVal);
                max.set(maxVal, maxVal, maxVal);

                if (tempNormal.x === 1) { max.x = pos.x; }
                if (tempNormal.y === 1) { max.y = pos.y; }
                if (tempNormal.z === 1) { max.z = pos.z; }

                if (tempNormal.x === -1) { min.x = pos.x; }
                if (tempNormal.y === -1) { min.y = pos.y; }
                if (tempNormal.z === -1) { min.z = pos.z; }
            };

            Plane.prototype.updateBoundingSphereRadius = function () {
                this.boundingSphereRadius = Number.MAX_VALUE;
            };
        }, { "../math/Vec3": 30, "./Shape": 43 }], 43: [function (_dereq_, module, exports) {
            module.exports = Shape;

            var Shape = _dereq_('./Shape');
            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Material = _dereq_('../material/Material');

            /**
             * Base class for shapes
             * @class Shape
             * @constructor
             * @author schteppe
             * @todo Should have a mechanism for caching bounding sphere radius instead of calculating it each time
             */
            function Shape() {

                /**
                 * Identifyer of the Shape.
                 * @property {number} id
                 */
                this.id = Shape.idCounter++;

                /**
                 * The type of this shape. Must be set to an int > 0 by subclasses.
                 * @property type
                 * @type {Number}
                 * @see Shape.types
                 */
                this.type = 0;

                /**
                 * The local bounding sphere radius of this shape.
                 * @property {Number} boundingSphereRadius
                 */
                this.boundingSphereRadius = 0;

                /**
                 * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
                 * @property {boolean} collisionResponse
                 */
                this.collisionResponse = true;

                /**
                 * @property {Material} material
                 */
                this.material = null;
            }
            Shape.prototype.constructor = Shape;

            /**
             * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
             * @method updateBoundingSphereRadius
             * @return {Number}
             */
            Shape.prototype.updateBoundingSphereRadius = function () {
                throw "computeBoundingSphereRadius() not implemented for shape type " + this.type;
            };

            /**
             * Get the volume of this shape
             * @method volume
             * @return {Number}
             */
            Shape.prototype.volume = function () {
                throw "volume() not implemented for shape type " + this.type;
            };

            /**
             * Calculates the inertia in the local frame for this shape.
             * @method calculateLocalInertia
             * @return {Vec3}
             * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
             */
            Shape.prototype.calculateLocalInertia = function (mass, target) {
                throw "calculateLocalInertia() not implemented for shape type " + this.type;
            };

            Shape.idCounter = 0;

            /**
             * The available shape types.
             * @static
             * @property types
             * @type {Object}
             */
            Shape.types = {
                SPHERE: 1,
                PLANE: 2,
                BOX: 4,
                COMPOUND: 8,
                CONVEXPOLYHEDRON: 16,
                HEIGHTFIELD: 32,
                PARTICLE: 64,
                CYLINDER: 128,
                TRIMESH: 256
            };


        }, { "../material/Material": 25, "../math/Quaternion": 28, "../math/Vec3": 30, "./Shape": 43 }], 44: [function (_dereq_, module, exports) {
            module.exports = Sphere;

            var Shape = _dereq_('./Shape');
            var Vec3 = _dereq_('../math/Vec3');

            /**
             * Spherical shape
             * @class Sphere
             * @constructor
             * @extends Shape
             * @param {Number} radius The radius of the sphere, a non-negative number.
             * @author schteppe / http://github.com/schteppe
             */
            function Sphere(radius) {
                Shape.call(this);

                /**
                 * @property {Number} radius
                 */
                this.radius = radius !== undefined ? Number(radius) : 1.0;
                this.type = Shape.types.SPHERE;

                if (this.radius < 0) {
                    throw new Error('The sphere radius cannot be negative.');
                }

                this.updateBoundingSphereRadius();
            }
            Sphere.prototype = new Shape();
            Sphere.prototype.constructor = Sphere;

            Sphere.prototype.calculateLocalInertia = function (mass, target) {
                target = target || new Vec3();
                var I = 2.0 * mass * this.radius * this.radius / 5.0;
                target.x = I;
                target.y = I;
                target.z = I;
                return target;
            };

            Sphere.prototype.volume = function () {
                return 4.0 * Math.PI * this.radius / 3.0;
            };

            Sphere.prototype.updateBoundingSphereRadius = function () {
                this.boundingSphereRadius = this.radius;
            };

            Sphere.prototype.calculateWorldAABB = function (pos, quat, min, max) {
                var r = this.radius;
                var axes = ['x', 'y', 'z'];
                for (var i = 0; i < axes.length; i++) {
                    var ax = axes[i];
                    min[ax] = pos[ax] - r;
                    max[ax] = pos[ax] + r;
                }
            };

        }, { "../math/Vec3": 30, "./Shape": 43 }], 45: [function (_dereq_, module, exports) {
            module.exports = Trimesh;

            var Shape = _dereq_('./Shape');
            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Transform = _dereq_('../math/Transform');
            var AABB = _dereq_('../collision/AABB');
            var Octree = _dereq_('../utils/Octree');

            /**
             * @class Trimesh
             * @constructor
             * @param {array} vertices
             * @param {array} indices
             * @extends Shape
             * @example
             *     // How to make a mesh with a single triangle
             *     var vertices = [
             *         0, 0, 0, // vertex 0
             *         1, 0, 0, // vertex 1
             *         0, 1, 0  // vertex 2
             *     ];
             *     var indices = [
             *         0, 1, 2  // triangle 0
             *     ];
             *     var trimeshShape = new Trimesh(vertices, indices);
             */
            function Trimesh(vertices, indices) {
                Shape.call(this);
                this.type = Shape.types.TRIMESH;

                /**
                 * @property vertices
                 * @type {Array}
                 */
                this.vertices = new Float32Array(vertices);

                /**
                 * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
                 * @property indices
                 * @type {Array}
                 */
                this.indices = new Int16Array(indices);

                /**
                 * The normals data.
                 * @property normals
                 * @type {Array}
                 */
                this.normals = new Float32Array(indices.length);

                /**
                 * The local AABB of the mesh.
                 * @property aabb
                 * @type {Array}
                 */
                this.aabb = new AABB();

                /**
                 * References to vertex pairs, making up all unique edges in the trimesh.
                 * @property {array} edges
                 */
                this.edges = null;

                /**
                 * Local scaling of the mesh. Use .setScale() to set it.
                 * @property {Vec3} scale
                 */
                this.scale = new Vec3(1, 1, 1);

                /**
                 * The indexed triangles. Use .updateTree() to update it.
                 * @property {Octree} tree
                 */
                this.tree = new Octree();

                this.updateEdges();
                this.updateNormals();
                this.updateAABB();
                this.updateBoundingSphereRadius();
                this.updateTree();
            }
            Trimesh.prototype = new Shape();
            Trimesh.prototype.constructor = Trimesh;

            var computeNormals_n = new Vec3();

            /**
             * @method updateTree
             */
            Trimesh.prototype.updateTree = function () {
                var tree = this.tree;

                tree.reset();
                tree.aabb.copy(this.aabb);
                var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled
                tree.aabb.lowerBound.x *= 1 / scale.x;
                tree.aabb.lowerBound.y *= 1 / scale.y;
                tree.aabb.lowerBound.z *= 1 / scale.z;
                tree.aabb.upperBound.x *= 1 / scale.x;
                tree.aabb.upperBound.y *= 1 / scale.y;
                tree.aabb.upperBound.z *= 1 / scale.z;

                // Insert all triangles
                var triangleAABB = new AABB();
                var a = new Vec3();
                var b = new Vec3();
                var c = new Vec3();
                var points = [a, b, c];
                for (var i = 0; i < this.indices.length / 3; i++) {
                    //this.getTriangleVertices(i, a, b, c);

                    // Get unscaled triangle verts
                    var i3 = i * 3;
                    this._getUnscaledVertex(this.indices[i3], a);
                    this._getUnscaledVertex(this.indices[i3 + 1], b);
                    this._getUnscaledVertex(this.indices[i3 + 2], c);

                    triangleAABB.setFromPoints(points);
                    tree.insert(triangleAABB, i);
                }
                tree.removeEmptyNodes();
            };

            var unscaledAABB = new AABB();

            /**
             * Get triangles in a local AABB from the trimesh.
             * @method getTrianglesInAABB
             * @param  {AABB} aabb
             * @param  {array} result An array of integers, referencing the queried triangles.
             */
            Trimesh.prototype.getTrianglesInAABB = function (aabb, result) {
                unscaledAABB.copy(aabb);

                // Scale it to local
                var scale = this.scale;
                var isx = scale.x;
                var isy = scale.y;
                var isz = scale.z;
                var l = unscaledAABB.lowerBound;
                var u = unscaledAABB.upperBound;
                l.x /= isx;
                l.y /= isy;
                l.z /= isz;
                u.x /= isx;
                u.y /= isy;
                u.z /= isz;

                return this.tree.aabbQuery(unscaledAABB, result);
            };

            /**
             * @method setScale
             * @param {Vec3} scale
             */
            Trimesh.prototype.setScale = function (scale) {
                var wasUniform = this.scale.x === this.scale.y === this.scale.z;
                var isUniform = scale.x === scale.y === scale.z;

                if (!(wasUniform && isUniform)) {
                    // Non-uniform scaling. Need to update normals.
                    this.updateNormals();
                }
                this.scale.copy(scale);
                this.updateAABB();
                this.updateBoundingSphereRadius();
            };

            /**
             * Compute the normals of the faces. Will save in the .normals array.
             * @method updateNormals
             */
            Trimesh.prototype.updateNormals = function () {
                var n = computeNormals_n;

                // Generate normals
                var normals = this.normals;
                for (var i = 0; i < this.indices.length / 3; i++) {
                    var i3 = i * 3;

                    var a = this.indices[i3],
                        b = this.indices[i3 + 1],
                        c = this.indices[i3 + 2];

                    this.getVertex(a, va);
                    this.getVertex(b, vb);
                    this.getVertex(c, vc);

                    Trimesh.computeNormal(vb, va, vc, n);

                    normals[i3] = n.x;
                    normals[i3 + 1] = n.y;
                    normals[i3 + 2] = n.z;
                }
            };

            /**
             * Update the .edges property
             * @method updateEdges
             */
            Trimesh.prototype.updateEdges = function () {
                var edges = {};
                var add = function (indexA, indexB) {
                    var key = a < b ? a + '_' + b : b + '_' + a;
                    edges[key] = true;
                };
                for (var i = 0; i < this.indices.length / 3; i++) {
                    var i3 = i * 3;
                    var a = this.indices[i3],
                        b = this.indices[i3 + 1],
                        c = this.indices[i3 + 2];
                    add(a, b);
                    add(b, c);
                    add(c, a);
                }
                var keys = Object.keys(edges);
                this.edges = new Int16Array(keys.length * 2);
                for (var i = 0; i < keys.length; i++) {
                    var indices = keys[i].split('_');
                    this.edges[2 * i] = parseInt(indices[0], 10);
                    this.edges[2 * i + 1] = parseInt(indices[1], 10);
                }
            };

            /**
             * Get an edge vertex
             * @method getEdgeVertex
             * @param  {number} edgeIndex
             * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
             * @param  {Vec3} vertexStore Where to store the result
             */
            Trimesh.prototype.getEdgeVertex = function (edgeIndex, firstOrSecond, vertexStore) {
                var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
                this.getVertex(vertexIndex, vertexStore);
            };

            var getEdgeVector_va = new Vec3();
            var getEdgeVector_vb = new Vec3();

            /**
             * Get a vector along an edge.
             * @method getEdgeVector
             * @param  {number} edgeIndex
             * @param  {Vec3} vectorStore
             */
            Trimesh.prototype.getEdgeVector = function (edgeIndex, vectorStore) {
                var va = getEdgeVector_va;
                var vb = getEdgeVector_vb;
                this.getEdgeVertex(edgeIndex, 0, va);
                this.getEdgeVertex(edgeIndex, 1, vb);
                vb.vsub(va, vectorStore);
            };

            /**
             * Get face normal given 3 vertices
             * @static
             * @method computeNormal
             * @param {Vec3} va
             * @param {Vec3} vb
             * @param {Vec3} vc
             * @param {Vec3} target
             */
            var cb = new Vec3();
            var ab = new Vec3();
            Trimesh.computeNormal = function (va, vb, vc, target) {
                vb.vsub(va, ab);
                vc.vsub(vb, cb);
                cb.cross(ab, target);
                if (!target.isZero()) {
                    target.normalize();
                }
            };

            var va = new Vec3();
            var vb = new Vec3();
            var vc = new Vec3();

            /**
             * Get vertex i.
             * @method getVertex
             * @param  {number} i
             * @param  {Vec3} out
             * @return {Vec3} The "out" vector object
             */
            Trimesh.prototype.getVertex = function (i, out) {
                var scale = this.scale;
                this._getUnscaledVertex(i, out);
                out.x *= scale.x;
                out.y *= scale.y;
                out.z *= scale.z;
                return out;
            };

            /**
             * Get raw vertex i
             * @private
             * @method _getUnscaledVertex
             * @param  {number} i
             * @param  {Vec3} out
             * @return {Vec3} The "out" vector object
             */
            Trimesh.prototype._getUnscaledVertex = function (i, out) {
                var i3 = i * 3;
                var vertices = this.vertices;
                return out.set(
                    vertices[i3],
                    vertices[i3 + 1],
                    vertices[i3 + 2]
                );
            };

            /**
             * Get a vertex from the trimesh,transformed by the given position and quaternion.
             * @method getWorldVertex
             * @param  {number} i
             * @param  {Vec3} pos
             * @param  {Quaternion} quat
             * @param  {Vec3} out
             * @return {Vec3} The "out" vector object
             */
            Trimesh.prototype.getWorldVertex = function (i, pos, quat, out) {
                this.getVertex(i, out);
                Transform.pointToWorldFrame(pos, quat, out, out);
                return out;
            };

            /**
             * Get the three vertices for triangle i.
             * @method getTriangleVertices
             * @param  {number} i
             * @param  {Vec3} a
             * @param  {Vec3} b
             * @param  {Vec3} c
             */
            Trimesh.prototype.getTriangleVertices = function (i, a, b, c) {
                var i3 = i * 3;
                this.getVertex(this.indices[i3], a);
                this.getVertex(this.indices[i3 + 1], b);
                this.getVertex(this.indices[i3 + 2], c);
            };

            /**
             * Compute the normal of triangle i.
             * @method getNormal
             * @param  {Number} i
             * @param  {Vec3} target
             * @return {Vec3} The "target" vector object
             */
            Trimesh.prototype.getNormal = function (i, target) {
                var i3 = i * 3;
                return target.set(
                    this.normals[i3],
                    this.normals[i3 + 1],
                    this.normals[i3 + 2]
                );
            };

            var cli_aabb = new AABB();

            /**
             * @method calculateLocalInertia
             * @param  {Number} mass
             * @param  {Vec3} target
             * @return {Vec3} The "target" vector object
             */
            Trimesh.prototype.calculateLocalInertia = function (mass, target) {
                // Approximate with box inertia
                // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
                this.computeLocalAABB(cli_aabb);
                var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,
                    y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,
                    z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
                return target.set(
                    1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * z * 2 * z),
                    1.0 / 12.0 * mass * (2 * x * 2 * x + 2 * z * 2 * z),
                    1.0 / 12.0 * mass * (2 * y * 2 * y + 2 * x * 2 * x)
                );
            };

            var computeLocalAABB_worldVert = new Vec3();

            /**
             * Compute the local AABB for the trimesh
             * @method computeLocalAABB
             * @param  {AABB} aabb
             */
            Trimesh.prototype.computeLocalAABB = function (aabb) {
                var l = aabb.lowerBound,
                    u = aabb.upperBound,
                    n = this.vertices.length,
                    vertices = this.vertices,
                    v = computeLocalAABB_worldVert;

                this.getVertex(0, v);
                l.copy(v);
                u.copy(v);

                for (var i = 0; i !== n; i++) {
                    this.getVertex(i, v);

                    if (v.x < l.x) {
                        l.x = v.x;
                    } else if (v.x > u.x) {
                        u.x = v.x;
                    }

                    if (v.y < l.y) {
                        l.y = v.y;
                    } else if (v.y > u.y) {
                        u.y = v.y;
                    }

                    if (v.z < l.z) {
                        l.z = v.z;
                    } else if (v.z > u.z) {
                        u.z = v.z;
                    }
                }
            };


            /**
             * Update the .aabb property
             * @method updateAABB
             */
            Trimesh.prototype.updateAABB = function () {
                this.computeLocalAABB(this.aabb);
            };

            /**
             * Will update the .boundingSphereRadius property
             * @method updateBoundingSphereRadius
             */
            Trimesh.prototype.updateBoundingSphereRadius = function () {
                // Assume points are distributed with local (0,0,0) as center
                var max2 = 0;
                var vertices = this.vertices;
                var v = new Vec3();
                for (var i = 0, N = vertices.length / 3; i !== N; i++) {
                    this.getVertex(i, v);
                    var norm2 = v.norm2();
                    if (norm2 > max2) {
                        max2 = norm2;
                    }
                }
                this.boundingSphereRadius = Math.sqrt(max2);
            };

            var tempWorldVertex = new Vec3();
            var calculateWorldAABB_frame = new Transform();
            var calculateWorldAABB_aabb = new AABB();

            /**
             * @method calculateWorldAABB
             * @param {Vec3}        pos
             * @param {Quaternion}  quat
             * @param {Vec3}        min
             * @param {Vec3}        max
             */
            Trimesh.prototype.calculateWorldAABB = function (pos, quat, min, max) {
                /*
                var n = this.vertices.length / 3,
                    verts = this.vertices;
                var minx,miny,minz,maxx,maxy,maxz;
            
                var v = tempWorldVertex;
                for(var i=0; i<n; i++){
                    this.getVertex(i, v);
                    quat.vmult(v, v);
                    pos.vadd(v, v);
                    if (v.x < minx || minx===undefined){
                        minx = v.x;
                    } else if(v.x > maxx || maxx===undefined){
                        maxx = v.x;
                    }
            
                    if (v.y < miny || miny===undefined){
                        miny = v.y;
                    } else if(v.y > maxy || maxy===undefined){
                        maxy = v.y;
                    }
            
                    if (v.z < minz || minz===undefined){
                        minz = v.z;
                    } else if(v.z > maxz || maxz===undefined){
                        maxz = v.z;
                    }
                }
                min.set(minx,miny,minz);
                max.set(maxx,maxy,maxz);
                */

                // Faster approximation using local AABB
                var frame = calculateWorldAABB_frame;
                var result = calculateWorldAABB_aabb;
                frame.position = pos;
                frame.quaternion = quat;
                this.aabb.toWorldFrame(frame, result);
                min.copy(result.lowerBound);
                max.copy(result.upperBound);
            };

            /**
             * Get approximate volume
             * @method volume
             * @return {Number}
             */
            Trimesh.prototype.volume = function () {
                return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
            };

            /**
             * Create a Trimesh instance, shaped as a torus.
             * @static
             * @method createTorus
             * @param  {number} [radius=1]
             * @param  {number} [tube=0.5]
             * @param  {number} [radialSegments=8]
             * @param  {number} [tubularSegments=6]
             * @param  {number} [arc=6.283185307179586]
             * @return {Trimesh} A torus
             */
            Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
                radius = radius || 1;
                tube = tube || 0.5;
                radialSegments = radialSegments || 8;
                tubularSegments = tubularSegments || 6;
                arc = arc || Math.PI * 2;

                var vertices = [];
                var indices = [];

                for (var j = 0; j <= radialSegments; j++) {
                    for (var i = 0; i <= tubularSegments; i++) {
                        var u = i / tubularSegments * arc;
                        var v = j / radialSegments * Math.PI * 2;

                        var x = (radius + tube * Math.cos(v)) * Math.cos(u);
                        var y = (radius + tube * Math.cos(v)) * Math.sin(u);
                        var z = tube * Math.sin(v);

                        vertices.push(x, y, z);
                    }
                }

                for (var j = 1; j <= radialSegments; j++) {
                    for (var i = 1; i <= tubularSegments; i++) {
                        var a = (tubularSegments + 1) * j + i - 1;
                        var b = (tubularSegments + 1) * (j - 1) + i - 1;
                        var c = (tubularSegments + 1) * (j - 1) + i;
                        var d = (tubularSegments + 1) * j + i;

                        indices.push(a, b, d);
                        indices.push(b, c, d);
                    }
                }

                return new Trimesh(vertices, indices);
            };

        }, { "../collision/AABB": 3, "../math/Quaternion": 28, "../math/Transform": 29, "../math/Vec3": 30, "../utils/Octree": 50, "./Shape": 43 }], 46: [function (_dereq_, module, exports) {
            module.exports = GSSolver;

            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Solver = _dereq_('./Solver');

            /**
             * Constraint equation Gauss-Seidel solver.
             * @class GSSolver
             * @constructor
             * @todo The spook parameters should be specified for each constraint, not globally.
             * @author schteppe / https://github.com/schteppe
             * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
             * @extends Solver
             */
            function GSSolver() {
                Solver.call(this);

                /**
                 * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
                 * @property iterations
                 * @type {Number}
                 * @todo write more about solver and iterations in the wiki
                 */
                this.iterations = 10;

                /**
                 * When tolerance is reached, the system is assumed to be converged.
                 * @property tolerance
                 * @type {Number}
                 */
                this.tolerance = 1e-7;
            }
            GSSolver.prototype = new Solver();

            var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.
            var GSSolver_solve_invCs = [];
            var GSSolver_solve_Bs = [];
            GSSolver.prototype.solve = function (dt, world) {
                var iter = 0,
                    maxIter = this.iterations,
                    tolSquared = this.tolerance * this.tolerance,
                    equations = this.equations,
                    Neq = equations.length,
                    bodies = world.bodies,
                    Nbodies = bodies.length,
                    h = dt,
                    q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;

                // Update solve mass
                if (Neq !== 0) {
                    for (var i = 0; i !== Nbodies; i++) {
                        bodies[i].updateSolveMassProperties();
                    }
                }

                // Things that does not change during iteration can be computed once
                var invCs = GSSolver_solve_invCs,
                    Bs = GSSolver_solve_Bs,
                    lambda = GSSolver_solve_lambda;
                invCs.length = Neq;
                Bs.length = Neq;
                lambda.length = Neq;
                for (var i = 0; i !== Neq; i++) {
                    var c = equations[i];
                    lambda[i] = 0.0;
                    Bs[i] = c.computeB(h);
                    invCs[i] = 1.0 / c.computeC();
                }

                if (Neq !== 0) {

                    // Reset vlambda
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i],
                            vlambda = b.vlambda,
                            wlambda = b.wlambda;
                        vlambda.set(0, 0, 0);
                        if (wlambda) {
                            wlambda.set(0, 0, 0);
                        }
                    }

                    // Iterate over equations
                    for (iter = 0; iter !== maxIter; iter++) {

                        // Accumulate the total error for each iteration.
                        deltalambdaTot = 0.0;

                        for (var j = 0; j !== Neq; j++) {

                            var c = equations[j];

                            // Compute iteration
                            B = Bs[j];
                            invC = invCs[j];
                            lambdaj = lambda[j];
                            GWlambda = c.computeGWlambda();
                            deltalambda = invC * (B - GWlambda - c.eps * lambdaj);

                            // Clamp if we are not within the min/max interval
                            if (lambdaj + deltalambda < c.minForce) {
                                deltalambda = c.minForce - lambdaj;
                            } else if (lambdaj + deltalambda > c.maxForce) {
                                deltalambda = c.maxForce - lambdaj;
                            }
                            lambda[j] += deltalambda;

                            deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

                            c.addToWlambda(deltalambda);
                        }

                        // If the total error is small enough - stop iterate
                        if (deltalambdaTot * deltalambdaTot < tolSquared) {
                            break;
                        }
                    }

                    // Add result to velocity
                    for (var i = 0; i !== Nbodies; i++) {
                        var b = bodies[i],
                            v = b.velocity,
                            w = b.angularVelocity;
                        v.vadd(b.vlambda, v);
                        if (w) {
                            w.vadd(b.wlambda, w);
                        }
                    }
                }

                return iter;
            };

        }, { "../math/Quaternion": 28, "../math/Vec3": 30, "./Solver": 47 }], 47: [function (_dereq_, module, exports) {
            module.exports = Solver;

            /**
             * Constraint equation solver base class.
             * @class Solver
             * @constructor
             * @author schteppe / https://github.com/schteppe
             */
            function Solver() {
                /**
                 * All equations to be solved
                 * @property {Array} equations
                 */
                this.equations = [];
            }

            /**
             * Should be implemented in subclasses!
             * @method solve
             * @param  {Number} dt
             * @param  {World} world
             */
            Solver.prototype.solve = function (dt, world) {
                // Should return the number of iterations done!
                return 0;
            };

            /**
             * Add an equation
             * @method addEquation
             * @param {Equation} eq
             */
            Solver.prototype.addEquation = function (eq) {
                if (eq.enabled) {
                    this.equations.push(eq);
                }
            };

            /**
             * Remove an equation
             * @method removeEquation
             * @param {Equation} eq
             */
            Solver.prototype.removeEquation = function (eq) {
                var eqs = this.equations;
                var i = eqs.indexOf(eq);
                if (i !== -1) {
                    eqs.splice(i, 1);
                }
            };

            /**
             * Add all equations
             * @method removeAllEquations
             */
            Solver.prototype.removeAllEquations = function () {
                this.equations.length = 0;
            };


        }, {}], 48: [function (_dereq_, module, exports) {
            module.exports = SplitSolver;

            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var Solver = _dereq_('./Solver');
            var Body = _dereq_('../objects/Body');

            /**
             * Splits the equations into islands and solves them independently. Can improve performance.
             * @class SplitSolver
             * @constructor
             * @extends Solver
             * @param {Solver} subsolver
             */
            function SplitSolver(subsolver) {
                Solver.call(this);
                this.iterations = 10;
                this.tolerance = 1e-7;
                this.subsolver = subsolver;
                this.nodes = [];
                this.nodePool = [];

                // Create needed nodes, reuse if possible
                while (this.nodePool.length < 128) {
                    this.nodePool.push(this.createNode());
                }
            }
            SplitSolver.prototype = new Solver();

            // Returns the number of subsystems
            var SplitSolver_solve_nodes = []; // All allocated node objects
            var SplitSolver_solve_nodePool = []; // All allocated node objects
            var SplitSolver_solve_eqs = [];   // Temp array
            var SplitSolver_solve_bds = [];   // Temp array
            var SplitSolver_solve_dummyWorld = { bodies: [] }; // Temp object

            var STATIC = Body.STATIC;
            function getUnvisitedNode(nodes) {
                var Nnodes = nodes.length;
                for (var i = 0; i !== Nnodes; i++) {
                    var node = nodes[i];
                    if (!node.visited && !(node.body.type & STATIC)) {
                        return node;
                    }
                }
                return false;
            }

            var queue = [];
            function bfs(root, visitFunc, bds, eqs) {
                queue.push(root);
                root.visited = true;
                visitFunc(root, bds, eqs);
                while (queue.length) {
                    var node = queue.pop();
                    // Loop over unvisited child nodes
                    var child;
                    while ((child = getUnvisitedNode(node.children))) {
                        child.visited = true;
                        visitFunc(child, bds, eqs);
                        queue.push(child);
                    }
                }
            }

            function visitFunc(node, bds, eqs) {
                bds.push(node.body);
                var Neqs = node.eqs.length;
                for (var i = 0; i !== Neqs; i++) {
                    var eq = node.eqs[i];
                    if (eqs.indexOf(eq) === -1) {
                        eqs.push(eq);
                    }
                }
            }

            SplitSolver.prototype.createNode = function () {
                return { body: null, children: [], eqs: [], visited: false };
            };

            /**
             * Solve the subsystems
             * @method solve
             * @param  {Number} dt
             * @param  {World} world
             */
            SplitSolver.prototype.solve = function (dt, world) {
                var nodes = SplitSolver_solve_nodes,
                    nodePool = this.nodePool,
                    bodies = world.bodies,
                    equations = this.equations,
                    Neq = equations.length,
                    Nbodies = bodies.length,
                    subsolver = this.subsolver;

                // Create needed nodes, reuse if possible
                while (nodePool.length < Nbodies) {
                    nodePool.push(this.createNode());
                }
                nodes.length = Nbodies;
                for (var i = 0; i < Nbodies; i++) {
                    nodes[i] = nodePool[i];
                }

                // Reset node values
                for (var i = 0; i !== Nbodies; i++) {
                    var node = nodes[i];
                    node.body = bodies[i];
                    node.children.length = 0;
                    node.eqs.length = 0;
                    node.visited = false;
                }
                for (var k = 0; k !== Neq; k++) {
                    var eq = equations[k],
                        i = bodies.indexOf(eq.bi),
                        j = bodies.indexOf(eq.bj),
                        ni = nodes[i],
                        nj = nodes[j];
                    ni.children.push(nj);
                    ni.eqs.push(eq);
                    nj.children.push(ni);
                    nj.eqs.push(eq);
                }

                var child, n = 0, eqs = SplitSolver_solve_eqs;

                subsolver.tolerance = this.tolerance;
                subsolver.iterations = this.iterations;

                var dummyWorld = SplitSolver_solve_dummyWorld;
                while ((child = getUnvisitedNode(nodes))) {
                    eqs.length = 0;
                    dummyWorld.bodies.length = 0;
                    bfs(child, visitFunc, dummyWorld.bodies, eqs);

                    var Neqs = eqs.length;

                    eqs = eqs.sort(sortById);

                    for (var i = 0; i !== Neqs; i++) {
                        subsolver.addEquation(eqs[i]);
                    }

                    var iter = subsolver.solve(dt, dummyWorld);
                    subsolver.removeAllEquations();
                    n++;
                }

                return n;
            };

            function sortById(a, b) {
                return b.id - a.id;
            }
        }, { "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/Body": 31, "./Solver": 47 }], 49: [function (_dereq_, module, exports) {
            /**
             * Base class for objects that dispatches events.
             * @class EventTarget
             * @constructor
             */
            var EventTarget = function () {

            };

            module.exports = EventTarget;

            EventTarget.prototype = {
                constructor: EventTarget,

                /**
                 * Add an event listener
                 * @method addEventListener
                 * @param  {String} type
                 * @param  {Function} listener
                 * @return {EventTarget} The self object, for chainability.
                 */
                addEventListener(type, listener) {
                    if (this._listeners === undefined) { this._listeners = {}; }
                    var listeners = this._listeners;
                    if (listeners[type] === undefined) {
                        listeners[type] = [];
                    }
                    if (listeners[type].indexOf(listener) === - 1) {
                        listeners[type].push(listener);
                    }
                    return this;
                },

                /**
                 * Check if an event listener is added
                 * @method hasEventListener
                 * @param  {String} type
                 * @param  {Function} listener
                 * @return {Boolean}
                 */
                hasEventListener(type, listener) {
                    if (this._listeners === undefined) { return false; }
                    var listeners = this._listeners;
                    if (listeners[type] !== undefined && listeners[type].indexOf(listener) !== - 1) {
                        return true;
                    }
                    return false;
                },

                /**
                 * Remove an event listener
                 * @method removeEventListener
                 * @param  {String} type
                 * @param  {Function} listener
                 * @return {EventTarget} The self object, for chainability.
                 */
                removeEventListener(type, listener) {
                    if (this._listeners === undefined) { return this; }
                    var listeners = this._listeners;
                    if (listeners[type] === undefined) { return this; }
                    var index = listeners[type].indexOf(listener);
                    if (index !== - 1) {
                        listeners[type].splice(index, 1);
                    }
                    return this;
                },

                /**
                 * Emit an event.
                 * @method dispatchEvent
                 * @param  {Object} event
                 * @param  {String} event.type
                 * @return {EventTarget} The self object, for chainability.
                 */
                dispatchEvent(event) {
                    if (this._listeners === undefined) { return this; }
                    var listeners = this._listeners;
                    var listenerArray = listeners[event.type];
                    if (listenerArray !== undefined) {
                        event.target = this;
                        for (var i = 0, l = listenerArray.length; i < l; i++) {
                            listenerArray[i].call(this, event);
                        }
                    }
                    return this;
                }
            };

        }, {}], 50: [function (_dereq_, module, exports) {
            var AABB = _dereq_('../collision/AABB');
            var Vec3 = _dereq_('../math/Vec3');

            module.exports = Octree;

            /**
             * @class OctreeNode
             * @param {object} [options]
             * @param {Octree} [options.root]
             * @param {AABB} [options.aabb]
             */
            function OctreeNode(options) {
                options = options || {};

                /**
                 * The root node
                 * @property {OctreeNode} root
                 */
                this.root = options.root || null;

                /**
                 * Boundary of this node
                 * @property {AABB} aabb
                 */
                this.aabb = options.aabb ? options.aabb.clone() : new AABB();

                /**
                 * Contained data at the current node level.
                 * @property {Array} data
                 */
                this.data = [];

                /**
                 * Children to this node
                 * @property {Array} children
                 */
                this.children = [];
            }

            /**
             * @class Octree
             * @param {AABB} aabb The total AABB of the tree
             * @param {object} [options]
             * @param {number} [options.maxDepth=8]
             * @extends OctreeNode
             */
            function Octree(aabb, options) {
                options = options || {};
                options.root = null;
                options.aabb = aabb;
                OctreeNode.call(this, options);

                /**
                 * Maximum subdivision depth
                 * @property {number} maxDepth
                 */
                this.maxDepth = typeof (options.maxDepth) !== 'undefined' ? options.maxDepth : 8;
            }
            Octree.prototype = new OctreeNode();

            OctreeNode.prototype.reset = function (aabb, options) {
                this.children.length = this.data.length = 0;
            };

            /**
             * Insert data into this node
             * @method insert
             * @param  {AABB} aabb
             * @param  {object} elementData
             * @return {boolean} True if successful, otherwise false
             */
            OctreeNode.prototype.insert = function (aabb, elementData, level) {
                var nodeData = this.data;
                level = level || 0;

                // Ignore objects that do not belong in this node
                if (!this.aabb.contains(aabb)) {
                    return false; // object cannot be added
                }

                var children = this.children;

                if (level < (this.maxDepth || this.root.maxDepth)) {
                    // Subdivide if there are no children yet
                    var subdivided = false;
                    if (!children.length) {
                        this.subdivide();
                        subdivided = true;
                    }

                    // add to whichever node will accept it
                    for (var i = 0; i !== 8; i++) {
                        if (children[i].insert(aabb, elementData, level + 1)) {
                            return true;
                        }
                    }

                    if (subdivided) {
                        // No children accepted! Might as well just remove em since they contain none
                        children.length = 0;
                    }
                }

                // Too deep, or children didnt want it. add it in current node
                nodeData.push(elementData);

                return true;
            };

            var halfDiagonal = new Vec3();

            /**
             * Create 8 equally sized children nodes and put them in the .children array.
             * @method subdivide
             */
            OctreeNode.prototype.subdivide = function () {
                var aabb = this.aabb;
                var l = aabb.lowerBound;
                var u = aabb.upperBound;

                var children = this.children;

                children.push(
                    new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0, 0, 0) }) }),
                    new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1, 0, 0) }) }),
                    new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1, 1, 0) }) }),
                    new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1, 1, 1) }) }),
                    new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0, 1, 1) }) }),
                    new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0, 0, 1) }) }),
                    new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1, 0, 1) }) }),
                    new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0, 1, 0) }) })
                );

                u.vsub(l, halfDiagonal);
                halfDiagonal.scale(0.5, halfDiagonal);

                var root = this.root || this;

                for (var i = 0; i !== 8; i++) {
                    var child = children[i];

                    // Set current node as root
                    child.root = root;

                    // Compute bounds
                    var lowerBound = child.aabb.lowerBound;
                    lowerBound.x *= halfDiagonal.x;
                    lowerBound.y *= halfDiagonal.y;
                    lowerBound.z *= halfDiagonal.z;

                    lowerBound.vadd(l, lowerBound);

                    // Upper bound is always lower bound + halfDiagonal
                    lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
                }
            };

            /**
             * Get all data, potentially within an AABB
             * @method aabbQuery
             * @param  {AABB} aabb
             * @param  {array} result
             * @return {array} The "result" object
             */
            OctreeNode.prototype.aabbQuery = function (aabb, result) {

                var nodeData = this.data;

                // abort if the range does not intersect this node
                // if (!this.aabb.overlaps(aabb)){
                //     return result;
                // }

                // Add objects at this level
                // Array.prototype.push.apply(result, nodeData);

                // Add child data
                // @todo unwrap recursion into a queue / loop, that's faster in JS
                var children = this.children;


                // for (var i = 0, N = this.children.length; i !== N; i++) {
                //     children[i].aabbQuery(aabb, result);
                // }

                var queue = [this];
                while (queue.length) {
                    var node = queue.pop();
                    if (node.aabb.overlaps(aabb)) {
                        Array.prototype.push.apply(result, node.data);
                    }
                    Array.prototype.push.apply(queue, node.children);
                }

                return result;
            };

            var tmpAABB = new AABB();

            /**
             * Get all data, potentially intersected by a ray.
             * @method rayQuery
             * @param  {Ray} ray
             * @param  {Transform} treeTransform
             * @param  {array} result
             * @return {array} The "result" object
             */
            OctreeNode.prototype.rayQuery = function (ray, treeTransform, result) {

                // Use aabb query for now.
                // @todo implement real ray query which needs less lookups
                ray.getAABB(tmpAABB);
                tmpAABB.toLocalFrame(treeTransform, tmpAABB);
                this.aabbQuery(tmpAABB, result);

                return result;
            };

            /**
             * @method removeEmptyNodes
             */
            OctreeNode.prototype.removeEmptyNodes = function () {
                var queue = [this];
                while (queue.length) {
                    var node = queue.pop();
                    for (var i = node.children.length - 1; i >= 0; i--) {
                        if (!node.children[i].data.length) {
                            node.children.splice(i, 1);
                        }
                    }
                    Array.prototype.push.apply(queue, node.children);
                }
            };

        }, { "../collision/AABB": 3, "../math/Vec3": 30 }], 51: [function (_dereq_, module, exports) {
            module.exports = Pool;

            /**
             * For pooling objects that can be reused.
             * @class Pool
             * @constructor
             */
            function Pool() {
                /**
                 * The pooled objects
                 * @property {Array} objects
                 */
                this.objects = [];

                /**
                 * Constructor of the objects
                 * @property {mixed} type
                 */
                this.type = Object;
            }

            /**
             * Release an object after use
             * @method release
             * @param {Object} obj
             */
            Pool.prototype.release = function () {
                var Nargs = arguments.length;
                for (var i = 0; i !== Nargs; i++) {
                    this.objects.push(arguments[i]);
                }
            };

            /**
             * Get an object
             * @method get
             * @return {mixed}
             */
            Pool.prototype.get = function () {
                if (this.objects.length === 0) {
                    return this.constructObject();
                } else {
                    return this.objects.pop();
                }
            };

            /**
             * Construct an object. Should be implmented in each subclass.
             * @method constructObject
             * @return {mixed}
             */
            Pool.prototype.constructObject = function () {
                throw new Error("constructObject() not implemented in this Pool subclass yet!");
            };

        }, {}], 52: [function (_dereq_, module, exports) {
            module.exports = TupleDictionary;

            /**
             * @class TupleDictionary
             * @constructor
             */
            function TupleDictionary() {

                /**
                 * The data storage
                 * @property data
                 * @type {Object}
                 */
                this.data = { keys: [] };
            }

            /**
             * @method get
             * @param  {Number} i
             * @param  {Number} j
             * @return {Number}
             */
            TupleDictionary.prototype.get = function (i, j) {
                if (i > j) {
                    // swap
                    var temp = j;
                    j = i;
                    i = temp;
                }
                return this.data[i + '-' + j];
            };

            /**
             * @method set
             * @param  {Number} i
             * @param  {Number} j
             * @param {Number} value
             */
            TupleDictionary.prototype.set = function (i, j, value) {
                if (i > j) {
                    var temp = j;
                    j = i;
                    i = temp;
                }
                var key = i + '-' + j;

                // Check if key already exists
                if (!this.get(i, j)) {
                    this.data.keys.push(key);
                }

                this.data[key] = value;
            };

            /**
             * @method reset
             */
            TupleDictionary.prototype.reset = function () {
                var data = this.data,
                    keys = data.keys;
                while (keys.length > 0) {
                    var key = keys.pop();
                    delete data[key];
                }
            };

        }, {}], 53: [function (_dereq_, module, exports) {
            function Utils() { }

            module.exports = Utils;

            /**
             * Extend an options object with default values.
             * @static
             * @method defaults
             * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
             * @param  {object} defaults An object containing default values.
             * @return {object} The modified options object.
             */
            Utils.defaults = function (options, defaults) {
                options = options || {};

                for (var key in defaults) {
                    if (!(key in options)) {
                        options[key] = defaults[key];
                    }
                }

                return options;
            };

        }, {}], 54: [function (_dereq_, module, exports) {
            module.exports = Vec3Pool;

            var Vec3 = _dereq_('../math/Vec3');
            var Pool = _dereq_('./Pool');

            /**
             * @class Vec3Pool
             * @constructor
             * @extends Pool
             */
            function Vec3Pool() {
                Pool.call(this);
                this.type = Vec3;
            }
            Vec3Pool.prototype = new Pool();

            /**
             * Construct a vector
             * @method constructObject
             * @return {Vec3}
             */
            Vec3Pool.prototype.constructObject = function () {
                return new Vec3();
            };

        }, { "../math/Vec3": 30, "./Pool": 51 }], 55: [function (_dereq_, module, exports) {
            module.exports = Narrowphase;

            var AABB = _dereq_('../collision/AABB');
            var Shape = _dereq_('../shapes/Shape');
            var Ray = _dereq_('../collision/Ray');
            var Vec3 = _dereq_('../math/Vec3');
            var Transform = _dereq_('../math/Transform');
            var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
            var Quaternion = _dereq_('../math/Quaternion');
            var Solver = _dereq_('../solver/Solver');
            var Vec3Pool = _dereq_('../utils/Vec3Pool');
            var ContactEquation = _dereq_('../equations/ContactEquation');
            var FrictionEquation = _dereq_('../equations/FrictionEquation');

            /**
             * Helper class for the World. Generates ContactEquations.
             * @class Narrowphase
             * @constructor
             * @todo Sphere-ConvexPolyhedron contacts
             * @todo Contact reduction
             * @todo  should move methods to prototype
             */
            function Narrowphase(world) {

                /**
                 * Internal storage of pooled contact points.
                 * @property {Array} contactPointPool
                 */
                this.contactPointPool = [];

                this.frictionEquationPool = [];

                this.result = [];
                this.frictionResult = [];

                /**
                 * Pooled vectors.
                 * @property {Vec3Pool} v3pool
                 */
                this.v3pool = new Vec3Pool();

                this.world = world;
                this.currentContactMaterial = null;

                /**
                 * @property {Boolean} enableFrictionReduction
                 */
                this.enableFrictionReduction = false;
            }

            /**
             * Make a contact object, by using the internal pool or creating a new one.
             * @method createContactEquation
             * @return {ContactEquation}
             */
            Narrowphase.prototype.createContactEquation = function (bi, bj, si, sj, rsi, rsj) {
                var c;
                if (this.contactPointPool.length) {
                    c = this.contactPointPool.pop();
                    c.bi = bi;
                    c.bj = bj;
                } else {
                    c = new ContactEquation(bi, bj);
                }

                c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

                var cm = this.currentContactMaterial;

                c.restitution = cm.restitution;

                c.setSpookParams(
                    cm.contactEquationStiffness,
                    cm.contactEquationRelaxation,
                    this.world.dt
                );

                var matA = si.material || bi.material;
                var matB = sj.material || bj.material;
                if (matA && matB && matA.restitution >= 0 && matB.restitution >= 0) {
                    c.restitution = matA.restitution * matB.restitution;
                }

                c.si = rsi || si;
                c.sj = rsj || sj;

                return c;
            };

            Narrowphase.prototype.createFrictionEquationsFromContact = function (contactEquation, outArray) {
                var bodyA = contactEquation.bi;
                var bodyB = contactEquation.bj;
                var shapeA = contactEquation.si;
                var shapeB = contactEquation.sj;

                var world = this.world;
                var cm = this.currentContactMaterial;

                // If friction or restitution were specified in the material, use them
                var friction = cm.friction;
                var matA = shapeA.material || bodyA.material;
                var matB = shapeB.material || bodyB.material;
                if (matA && matB && matA.friction >= 0 && matB.friction >= 0) {
                    friction = matA.friction * matB.friction;
                }

                if (friction > 0) {

                    // Create 2 tangent equations
                    var mug = friction * world.gravity.length();
                    var reducedMass = (bodyA.invMass + bodyB.invMass);
                    if (reducedMass > 0) {
                        reducedMass = 1 / reducedMass;
                    }
                    var pool = this.frictionEquationPool;
                    var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);
                    var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA, bodyB, mug * reducedMass);

                    c1.bi = c2.bi = bodyA;
                    c1.bj = c2.bj = bodyB;
                    c1.minForce = c2.minForce = -mug * reducedMass;
                    c1.maxForce = c2.maxForce = mug * reducedMass;

                    // Copy over the relative vectors
                    c1.ri.copy(contactEquation.ri);
                    c1.rj.copy(contactEquation.rj);
                    c2.ri.copy(contactEquation.ri);
                    c2.rj.copy(contactEquation.rj);

                    // Construct tangents
                    contactEquation.ni.tangents(c1.t, c2.t);

                    // Set spook params
                    c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
                    c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);

                    c1.enabled = c2.enabled = contactEquation.enabled;

                    outArray.push(c1, c2);

                    return true;
                }

                return false;
            };

            var averageNormal = new Vec3();
            var averageContactPointA = new Vec3();
            var averageContactPointB = new Vec3();

            // Take the average N latest contact point on the plane.
            Narrowphase.prototype.createFrictionFromAverage = function (numContacts) {
                // The last contactEquation
                var c = this.result[this.result.length - 1];

                // Create the result: two "average" friction equations
                if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
                    return;
                }

                var f1 = this.frictionResult[this.frictionResult.length - 2];
                var f2 = this.frictionResult[this.frictionResult.length - 1];

                averageNormal.setZero();
                averageContactPointA.setZero();
                averageContactPointB.setZero();

                var bodyA = c.bi;
                var bodyB = c.bj;
                for (var i = 0; i !== numContacts; i++) {
                    c = this.result[this.result.length - 1 - i];
                    if (c.bodyA !== bodyA) {
                        averageNormal.vadd(c.ni, averageNormal); // vec2.add(eq.t, eq.t, c.normalA);
                        averageContactPointA.vadd(c.ri, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                        averageContactPointB.vadd(c.rj, averageContactPointB);
                    } else {
                        averageNormal.vsub(c.ni, averageNormal); // vec2.sub(eq.t, eq.t, c.normalA);
                        averageContactPointA.vadd(c.rj, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
                        averageContactPointB.vadd(c.ri, averageContactPointB);
                    }
                }

                var invNumContacts = 1 / numContacts;
                averageContactPointA.scale(invNumContacts, f1.ri); // vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
                averageContactPointB.scale(invNumContacts, f1.rj); // vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
                f2.ri.copy(f1.ri); // Should be the same
                f2.rj.copy(f1.rj);
                averageNormal.normalize();
                averageNormal.tangents(f1.t, f2.t);
                // return eq;
            };


            var tmpVec1 = new Vec3();
            var tmpVec2 = new Vec3();
            var tmpQuat1 = new Quaternion();
            var tmpQuat2 = new Quaternion();

            /**
             * Generate all contacts between a list of body pairs
             * @method getContacts
             * @param {array} p1 Array of body indices
             * @param {array} p2 Array of body indices
             * @param {World} world
             * @param {array} result Array to store generated contacts
             * @param {array} oldcontacts Optional. Array of reusable contact objects
             */
            Narrowphase.prototype.getContacts = function (p1, p2, world, result, oldcontacts, frictionResult, frictionPool) {
                // Save old contact objects
                this.contactPointPool = oldcontacts;
                this.frictionEquationPool = frictionPool;
                this.result = result;
                this.frictionResult = frictionResult;

                var qi = tmpQuat1;
                var qj = tmpQuat2;
                var xi = tmpVec1;
                var xj = tmpVec2;

                for (var k = 0, N = p1.length; k !== N; k++) {

                    // Get current collision bodies
                    var bi = p1[k],
                        bj = p2[k];

                    // Get contact material
                    var bodyContactMaterial = null;
                    if (bi.material && bj.material) {
                        bodyContactMaterial = world.getContactMaterial(bi.material, bj.material) || null;
                    }

                    for (var i = 0; i < bi.shapes.length; i++) {
                        bi.quaternion.mult(bi.shapeOrientations[i], qi);
                        bi.quaternion.vmult(bi.shapeOffsets[i], xi);
                        xi.vadd(bi.position, xi);
                        var si = bi.shapes[i];

                        for (var j = 0; j < bj.shapes.length; j++) {

                            // Compute world transform of shapes
                            bj.quaternion.mult(bj.shapeOrientations[j], qj);
                            bj.quaternion.vmult(bj.shapeOffsets[j], xj);
                            xj.vadd(bj.position, xj);
                            var sj = bj.shapes[j];

                            if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
                                continue;
                            }

                            // Get collision material
                            var shapeContactMaterial = null;
                            if (si.material && sj.material) {
                                shapeContactMaterial = world.getContactMaterial(si.material, sj.material) || null;
                            }

                            this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;

                            // Get contacts
                            var resolver = this[si.type | sj.type];
                            if (resolver) {
                                if (si.type < sj.type) {
                                    resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj);
                                } else {
                                    resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj);
                                }
                            }
                        }
                    }
                }
            };

            var numWarnings = 0;
            var maxWarnings = 10;

            function warn(msg) {
                if (numWarnings > maxWarnings) {
                    return;
                }

                numWarnings++;

                console.warn(msg);
            }

            Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =
                Narrowphase.prototype.boxBox = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    si.convexPolyhedronRepresentation.material = si.material;
                    sj.convexPolyhedronRepresentation.material = sj.material;
                    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
                    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
                    this.convexConvex(si.convexPolyhedronRepresentation, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj, si, sj);
                };

            Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =
                Narrowphase.prototype.boxConvex = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    si.convexPolyhedronRepresentation.material = si.material;
                    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
                    this.convexConvex(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj);
                };

            Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =
                Narrowphase.prototype.boxParticle = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    si.convexPolyhedronRepresentation.material = si.material;
                    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
                    this.convexParticle(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj, si, sj);
                };

            /**
             * @method sphereSphere
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.SPHERE] =
                Narrowphase.prototype.sphereSphere = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    // We will have only one contact in this case
                    var r = this.createContactEquation(bi, bj, si, sj);

                    // Contact normal
                    xj.vsub(xi, r.ni);
                    r.ni.normalize();

                    // Contact point locations
                    r.ri.copy(r.ni);
                    r.rj.copy(r.ni);
                    r.ri.mult(si.radius, r.ri);
                    r.rj.mult(-sj.radius, r.rj);

                    r.ri.vadd(xi, r.ri);
                    r.ri.vsub(bi.position, r.ri);

                    r.rj.vadd(xj, r.rj);
                    r.rj.vsub(bj.position, r.rj);

                    this.result.push(r);

                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                };

            /**
             * @method planeTrimesh
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            var planeTrimesh_normal = new Vec3();
            var planeTrimesh_relpos = new Vec3();
            var planeTrimesh_projected = new Vec3();
            Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] =
                Narrowphase.prototype.planeTrimesh = function (
                    planeShape,
                    trimeshShape,
                    planePos,
                    trimeshPos,
                    planeQuat,
                    trimeshQuat,
                    planeBody,
                    trimeshBody
                ) {
                    // Make contacts!
                    var v = new Vec3();

                    var normal = planeTrimesh_normal;
                    normal.set(0, 0, 1);
                    planeQuat.vmult(normal, normal); // Turn normal according to plane

                    for (var i = 0; i < trimeshShape.vertices.length / 3; i++) {

                        // Get world vertex from trimesh
                        trimeshShape.getVertex(i, v);

                        // Safe up
                        var v2 = new Vec3();
                        v2.copy(v);
                        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

                        // Check plane side
                        var relpos = planeTrimesh_relpos;
                        v.vsub(planePos, relpos);
                        var dot = normal.dot(relpos);

                        if (dot <= 0.0) {
                            var r = this.createContactEquation(planeBody, trimeshBody, planeShape, trimeshShape);

                            r.ni.copy(normal); // Contact normal is the plane normal

                            // Get vertex position projected on plane
                            var projected = planeTrimesh_projected;
                            normal.scale(relpos.dot(normal), projected);
                            v.vsub(projected, projected);

                            // ri is the projected world position minus plane position
                            r.ri.copy(projected);
                            r.ri.vsub(planeBody.position, r.ri);

                            r.rj.copy(v);
                            r.rj.vsub(trimeshBody.position, r.rj);

                            // Store result
                            this.result.push(r);
                            this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                    }
                };

            /**
             * @method sphereTrimesh
             * @param  {Shape}      sphereShape
             * @param  {Shape}      trimeshShape
             * @param  {Vec3}       spherePos
             * @param  {Vec3}       trimeshPos
             * @param  {Quaternion} sphereQuat
             * @param  {Quaternion} trimeshQuat
             * @param  {Body}       sphereBody
             * @param  {Body}       trimeshBody
             */
            var sphereTrimesh_normal = new Vec3();
            var sphereTrimesh_relpos = new Vec3();
            var sphereTrimesh_projected = new Vec3();
            var sphereTrimesh_v = new Vec3();
            var sphereTrimesh_v2 = new Vec3();
            var sphereTrimesh_edgeVertexA = new Vec3();
            var sphereTrimesh_edgeVertexB = new Vec3();
            var sphereTrimesh_edgeVector = new Vec3();
            var sphereTrimesh_edgeVectorUnit = new Vec3();
            var sphereTrimesh_localSpherePos = new Vec3();
            var sphereTrimesh_tmp = new Vec3();
            var sphereTrimesh_va = new Vec3();
            var sphereTrimesh_vb = new Vec3();
            var sphereTrimesh_vc = new Vec3();
            var sphereTrimesh_localSphereAABB = new AABB();
            var sphereTrimesh_triangles = [];
            Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] =
                Narrowphase.prototype.sphereTrimesh = function (
                    sphereShape,
                    trimeshShape,
                    spherePos,
                    trimeshPos,
                    sphereQuat,
                    trimeshQuat,
                    sphereBody,
                    trimeshBody
                ) {

                    var edgeVertexA = sphereTrimesh_edgeVertexA;
                    var edgeVertexB = sphereTrimesh_edgeVertexB;
                    var edgeVector = sphereTrimesh_edgeVector;
                    var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
                    var localSpherePos = sphereTrimesh_localSpherePos;
                    var tmp = sphereTrimesh_tmp;
                    var localSphereAABB = sphereTrimesh_localSphereAABB;
                    var v2 = sphereTrimesh_v2;
                    var relpos = sphereTrimesh_relpos;
                    var triangles = sphereTrimesh_triangles;

                    // Convert sphere position to local in the trimesh
                    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);

                    // Get the aabb of the sphere locally in the trimesh
                    var sphereRadius = sphereShape.radius;
                    localSphereAABB.lowerBound.set(
                        localSpherePos.x - sphereRadius,
                        localSpherePos.y - sphereRadius,
                        localSpherePos.z - sphereRadius
                    );
                    localSphereAABB.upperBound.set(
                        localSpherePos.x + sphereRadius,
                        localSpherePos.y + sphereRadius,
                        localSpherePos.z + sphereRadius
                    );

                    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
                    //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All

                    // Vertices
                    var v = sphereTrimesh_v;
                    var radiusSquared = sphereShape.radius * sphereShape.radius;
                    for (var i = 0; i < triangles.length; i++) {
                        for (var j = 0; j < 3; j++) {

                            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);

                            // Check vertex overlap in sphere
                            v.vsub(localSpherePos, relpos);

                            if (relpos.norm2() <= radiusSquared) {

                                // Safe up
                                v2.copy(v);
                                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

                                v.vsub(spherePos, relpos);

                                var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);
                                r.ni.copy(relpos);
                                r.ni.normalize();

                                // ri is the vector from sphere center to the sphere surface
                                r.ri.copy(r.ni);
                                r.ri.scale(sphereShape.radius, r.ri);
                                r.ri.vadd(spherePos, r.ri);
                                r.ri.vsub(sphereBody.position, r.ri);

                                r.rj.copy(v);
                                r.rj.vsub(trimeshBody.position, r.rj);

                                // Store result
                                this.result.push(r);
                                this.createFrictionEquationsFromContact(r, this.frictionResult);
                            }
                        }
                    }

                    // Check all edges
                    for (var i = 0; i < triangles.length; i++) {
                        for (var j = 0; j < 3; j++) {

                            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
                            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j + 1) % 3)], edgeVertexB);
                            edgeVertexB.vsub(edgeVertexA, edgeVector);

                            // Project sphere position to the edge
                            localSpherePos.vsub(edgeVertexB, tmp);
                            var positionAlongEdgeB = tmp.dot(edgeVector);

                            localSpherePos.vsub(edgeVertexA, tmp);
                            var positionAlongEdgeA = tmp.dot(edgeVector);

                            if (positionAlongEdgeA > 0 && positionAlongEdgeB < 0) {

                                // Now check the orthogonal distance from edge to sphere center
                                localSpherePos.vsub(edgeVertexA, tmp);

                                edgeVectorUnit.copy(edgeVector);
                                edgeVectorUnit.normalize();
                                positionAlongEdgeA = tmp.dot(edgeVectorUnit);

                                edgeVectorUnit.scale(positionAlongEdgeA, tmp);
                                tmp.vadd(edgeVertexA, tmp);

                                // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame
                                var dist = tmp.distanceTo(localSpherePos);
                                if (dist < sphereShape.radius) {
                                    var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);

                                    tmp.vsub(localSpherePos, r.ni);
                                    r.ni.normalize();
                                    r.ni.scale(sphereShape.radius, r.ri);

                                    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                                    tmp.vsub(trimeshBody.position, r.rj);

                                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

                                    this.result.push(r);
                                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                                }
                            }
                        }
                    }

                    // Triangle faces
                    var va = sphereTrimesh_va;
                    var vb = sphereTrimesh_vb;
                    var vc = sphereTrimesh_vc;
                    var normal = sphereTrimesh_normal;
                    for (var i = 0, N = triangles.length; i !== N; i++) {
                        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
                        trimeshShape.getNormal(triangles[i], normal);
                        localSpherePos.vsub(va, tmp);
                        var dist = tmp.dot(normal);
                        normal.scale(dist, tmp);
                        localSpherePos.vsub(tmp, tmp);

                        // tmp is now the sphere position projected to the triangle plane
                        dist = tmp.distanceTo(localSpherePos);
                        if (Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius) {
                            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);

                            tmp.vsub(localSpherePos, r.ni);
                            r.ni.normalize();
                            r.ni.scale(sphereShape.radius, r.ri);

                            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                            tmp.vsub(trimeshBody.position, r.rj);

                            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

                            this.result.push(r);
                            this.createFrictionEquationsFromContact(r, this.frictionResult);
                        }
                    }

                    triangles.length = 0;
                };

            var point_on_plane_to_sphere = new Vec3();
            var plane_to_sphere_ortho = new Vec3();

            /**
             * @method spherePlane
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =
                Narrowphase.prototype.spherePlane = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    // We will have one contact in this case
                    var r = this.createContactEquation(bi, bj, si, sj);

                    // Contact normal
                    r.ni.set(0, 0, 1);
                    qj.vmult(r.ni, r.ni);
                    r.ni.negate(r.ni); // body i is the sphere, flip normal
                    r.ni.normalize(); // Needed?

                    // Vector from sphere center to contact point
                    r.ni.mult(si.radius, r.ri);

                    // Project down sphere on plane
                    xi.vsub(xj, point_on_plane_to_sphere);
                    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
                    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho, r.rj); // The sphere position projected to plane

                    if (-point_on_plane_to_sphere.dot(r.ni) <= si.radius) {

                        // Make it relative to the body
                        var ri = r.ri;
                        var rj = r.rj;
                        ri.vadd(xi, ri);
                        ri.vsub(bi.position, ri);
                        rj.vadd(xj, rj);
                        rj.vsub(bj.position, rj);

                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                };

            // See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
            var pointInPolygon_edge = new Vec3();
            var pointInPolygon_edge_x_normal = new Vec3();
            var pointInPolygon_vtp = new Vec3();
            function pointInPolygon(verts, normal, p) {
                var positiveResult = null;
                var N = verts.length;
                for (var i = 0; i !== N; i++) {
                    var v = verts[i];

                    // Get edge to the next vertex
                    var edge = pointInPolygon_edge;
                    verts[(i + 1) % (N)].vsub(v, edge);

                    // Get cross product between polygon normal and the edge
                    var edge_x_normal = pointInPolygon_edge_x_normal;
                    //var edge_x_normal = new Vec3();
                    edge.cross(normal, edge_x_normal);

                    // Get vector between point and current vertex
                    var vertex_to_p = pointInPolygon_vtp;
                    p.vsub(v, vertex_to_p);

                    // This dot product determines which side of the edge the point is
                    var r = edge_x_normal.dot(vertex_to_p);

                    // If all such dot products have same sign, we are inside the polygon.
                    if (positiveResult === null || (r > 0 && positiveResult === true) || (r <= 0 && positiveResult === false)) {
                        if (positiveResult === null) {
                            positiveResult = r > 0;
                        }
                        continue;
                    } else {
                        return false; // Encountered some other sign. Exit.
                    }
                }

                // If we got here, all dot products were of the same sign.
                return true;
            }

            var box_to_sphere = new Vec3();
            var sphereBox_ns = new Vec3();
            var sphereBox_ns1 = new Vec3();
            var sphereBox_ns2 = new Vec3();
            var sphereBox_sides = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];
            var sphereBox_sphere_to_corner = new Vec3();
            var sphereBox_side_ns = new Vec3();
            var sphereBox_side_ns1 = new Vec3();
            var sphereBox_side_ns2 = new Vec3();

            /**
             * @method sphereBox
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =
                Narrowphase.prototype.sphereBox = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    var v3pool = this.v3pool;

                    // we refer to the box as body j
                    var sides = sphereBox_sides;
                    xi.vsub(xj, box_to_sphere);
                    sj.getSideNormals(sides, qj);
                    var R = si.radius;
                    var penetrating_sides = [];

                    // Check side (plane) intersections
                    var found = false;

                    // Store the resulting side penetration info
                    var side_ns = sphereBox_side_ns;
                    var side_ns1 = sphereBox_side_ns1;
                    var side_ns2 = sphereBox_side_ns2;
                    var side_h = null;
                    var side_penetrations = 0;
                    var side_dot1 = 0;
                    var side_dot2 = 0;
                    var side_distance = null;
                    for (var idx = 0, nsides = sides.length; idx !== nsides && found === false; idx++) {
                        // Get the plane side normal (ns)
                        var ns = sphereBox_ns;
                        ns.copy(sides[idx]);

                        var h = ns.norm();
                        ns.normalize();

                        // The normal/distance dot product tells which side of the plane we are
                        var dot = box_to_sphere.dot(ns);

                        if (dot < h + R && dot > 0) {
                            // Intersects plane. Now check the other two dimensions
                            var ns1 = sphereBox_ns1;
                            var ns2 = sphereBox_ns2;
                            ns1.copy(sides[(idx + 1) % 3]);
                            ns2.copy(sides[(idx + 2) % 3]);
                            var h1 = ns1.norm();
                            var h2 = ns2.norm();
                            ns1.normalize();
                            ns2.normalize();
                            var dot1 = box_to_sphere.dot(ns1);
                            var dot2 = box_to_sphere.dot(ns2);
                            if (dot1 < h1 && dot1 > -h1 && dot2 < h2 && dot2 > -h2) {
                                var dist = Math.abs(dot - h - R);
                                if (side_distance === null || dist < side_distance) {
                                    side_distance = dist;
                                    side_dot1 = dot1;
                                    side_dot2 = dot2;
                                    side_h = h;
                                    side_ns.copy(ns);
                                    side_ns1.copy(ns1);
                                    side_ns2.copy(ns2);
                                    side_penetrations++;
                                }
                            }
                        }
                    }
                    if (side_penetrations) {
                        found = true;
                        var r = this.createContactEquation(bi, bj, si, sj);
                        side_ns.mult(-R, r.ri); // Sphere r
                        r.ni.copy(side_ns);
                        r.ni.negate(r.ni); // Normal should be out of sphere
                        side_ns.mult(side_h, side_ns);
                        side_ns1.mult(side_dot1, side_ns1);
                        side_ns.vadd(side_ns1, side_ns);
                        side_ns2.mult(side_dot2, side_ns2);
                        side_ns.vadd(side_ns2, r.rj);

                        // Make relative to bodies
                        r.ri.vadd(xi, r.ri);
                        r.ri.vsub(bi.position, r.ri);
                        r.rj.vadd(xj, r.rj);
                        r.rj.vsub(bj.position, r.rj);

                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }

                    // Check corners
                    var rj = v3pool.get();
                    var sphere_to_corner = sphereBox_sphere_to_corner;
                    for (var j = 0; j !== 2 && !found; j++) {
                        for (var k = 0; k !== 2 && !found; k++) {
                            for (var l = 0; l !== 2 && !found; l++) {
                                rj.set(0, 0, 0);
                                if (j) {
                                    rj.vadd(sides[0], rj);
                                } else {
                                    rj.vsub(sides[0], rj);
                                }
                                if (k) {
                                    rj.vadd(sides[1], rj);
                                } else {
                                    rj.vsub(sides[1], rj);
                                }
                                if (l) {
                                    rj.vadd(sides[2], rj);
                                } else {
                                    rj.vsub(sides[2], rj);
                                }

                                // World position of corner
                                xj.vadd(rj, sphere_to_corner);
                                sphere_to_corner.vsub(xi, sphere_to_corner);

                                if (sphere_to_corner.norm2() < R * R) {
                                    found = true;
                                    var r = this.createContactEquation(bi, bj, si, sj);
                                    r.ri.copy(sphere_to_corner);
                                    r.ri.normalize();
                                    r.ni.copy(r.ri);
                                    r.ri.mult(R, r.ri);
                                    r.rj.copy(rj);

                                    // Make relative to bodies
                                    r.ri.vadd(xi, r.ri);
                                    r.ri.vsub(bi.position, r.ri);
                                    r.rj.vadd(xj, r.rj);
                                    r.rj.vsub(bj.position, r.rj);

                                    this.result.push(r);
                                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                                }
                            }
                        }
                    }
                    v3pool.release(rj);
                    rj = null;

                    // Check edges
                    var edgeTangent = v3pool.get();
                    var edgeCenter = v3pool.get();
                    var r = v3pool.get(); // r = edge center to sphere center
                    var orthogonal = v3pool.get();
                    var dist = v3pool.get();
                    var Nsides = sides.length;
                    for (var j = 0; j !== Nsides && !found; j++) {
                        for (var k = 0; k !== Nsides && !found; k++) {
                            if (j % 3 !== k % 3) {
                                // Get edge tangent
                                sides[k].cross(sides[j], edgeTangent);
                                edgeTangent.normalize();
                                sides[j].vadd(sides[k], edgeCenter);
                                r.copy(xi);
                                r.vsub(edgeCenter, r);
                                r.vsub(xj, r);
                                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
                                edgeTangent.mult(orthonorm, orthogonal); // Vector from edge center to sphere center in the tangent direction

                                // Find the third side orthogonal to this one
                                var l = 0;
                                while (l === j % 3 || l === k % 3) {
                                    l++;
                                }

                                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
                                dist.copy(xi);
                                dist.vsub(orthogonal, dist);
                                dist.vsub(edgeCenter, dist);
                                dist.vsub(xj, dist);

                                // Distances in tangent direction and distance in the plane orthogonal to it
                                var tdist = Math.abs(orthonorm);
                                var ndist = dist.norm();

                                if (tdist < sides[l].norm() && ndist < R) {
                                    found = true;
                                    var res = this.createContactEquation(bi, bj, si, sj);
                                    edgeCenter.vadd(orthogonal, res.rj); // box rj
                                    res.rj.copy(res.rj);
                                    dist.negate(res.ni);
                                    res.ni.normalize();

                                    res.ri.copy(res.rj);
                                    res.ri.vadd(xj, res.ri);
                                    res.ri.vsub(xi, res.ri);
                                    res.ri.normalize();
                                    res.ri.mult(R, res.ri);

                                    // Make relative to bodies
                                    res.ri.vadd(xi, res.ri);
                                    res.ri.vsub(bi.position, res.ri);
                                    res.rj.vadd(xj, res.rj);
                                    res.rj.vsub(bj.position, res.rj);

                                    this.result.push(res);
                                    this.createFrictionEquationsFromContact(res, this.frictionResult);
                                }
                            }
                        }
                    }
                    v3pool.release(edgeTangent, edgeCenter, r, orthogonal, dist);
                };

            var convex_to_sphere = new Vec3();
            var sphereConvex_edge = new Vec3();
            var sphereConvex_edgeUnit = new Vec3();
            var sphereConvex_sphereToCorner = new Vec3();
            var sphereConvex_worldCorner = new Vec3();
            var sphereConvex_worldNormal = new Vec3();
            var sphereConvex_worldPoint = new Vec3();
            var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
            var sphereConvex_penetrationVec = new Vec3();
            var sphereConvex_sphereToWorldPoint = new Vec3();

            /**
             * @method sphereConvex
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =
                Narrowphase.prototype.sphereConvex = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    var v3pool = this.v3pool;
                    xi.vsub(xj, convex_to_sphere);
                    var normals = sj.faceNormals;
                    var faces = sj.faces;
                    var verts = sj.vertices;
                    var R = si.radius;
                    var penetrating_sides = [];

                    // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
                    //     return;
                    // }

                    // Check corners
                    for (var i = 0; i !== verts.length; i++) {
                        var v = verts[i];

                        // World position of corner
                        var worldCorner = sphereConvex_worldCorner;
                        qj.vmult(v, worldCorner);
                        xj.vadd(worldCorner, worldCorner);
                        var sphere_to_corner = sphereConvex_sphereToCorner;
                        worldCorner.vsub(xi, sphere_to_corner);
                        if (sphere_to_corner.norm2() < R * R) {
                            found = true;
                            var r = this.createContactEquation(bi, bj, si, sj);
                            r.ri.copy(sphere_to_corner);
                            r.ri.normalize();
                            r.ni.copy(r.ri);
                            r.ri.mult(R, r.ri);
                            worldCorner.vsub(xj, r.rj);

                            // Should be relative to the body.
                            r.ri.vadd(xi, r.ri);
                            r.ri.vsub(bi.position, r.ri);

                            // Should be relative to the body.
                            r.rj.vadd(xj, r.rj);
                            r.rj.vsub(bj.position, r.rj);

                            this.result.push(r);
                            this.createFrictionEquationsFromContact(r, this.frictionResult);
                            return;
                        }
                    }

                    // Check side (plane) intersections
                    var found = false;
                    for (var i = 0, nfaces = faces.length; i !== nfaces && found === false; i++) {
                        var normal = normals[i];
                        var face = faces[i];

                        // Get world-transformed normal of the face
                        var worldNormal = sphereConvex_worldNormal;
                        qj.vmult(normal, worldNormal);

                        // Get a world vertex from the face
                        var worldPoint = sphereConvex_worldPoint;
                        qj.vmult(verts[face[0]], worldPoint);
                        worldPoint.vadd(xj, worldPoint);

                        // Get a point on the sphere, closest to the face normal
                        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
                        worldNormal.mult(-R, worldSpherePointClosestToPlane);
                        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);

                        // Vector from a face point to the closest point on the sphere
                        var penetrationVec = sphereConvex_penetrationVec;
                        worldSpherePointClosestToPlane.vsub(worldPoint, penetrationVec);

                        // The penetration. Negative value means overlap.
                        var penetration = penetrationVec.dot(worldNormal);

                        var worldPointToSphere = sphereConvex_sphereToWorldPoint;
                        xi.vsub(worldPoint, worldPointToSphere);

                        if (penetration < 0 && worldPointToSphere.dot(worldNormal) > 0) {
                            // Intersects plane. Now check if the sphere is inside the face polygon
                            var faceVerts = []; // Face vertices, in world coords
                            for (var j = 0, Nverts = face.length; j !== Nverts; j++) {
                                var worldVertex = v3pool.get();
                                qj.vmult(verts[face[j]], worldVertex);
                                xj.vadd(worldVertex, worldVertex);
                                faceVerts.push(worldVertex);
                            }

                            if (pointInPolygon(faceVerts, worldNormal, xi)) { // Is the sphere center in the face polygon?
                                found = true;
                                var r = this.createContactEquation(bi, bj, si, sj);

                                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact
                                worldNormal.negate(r.ni); // Normal pointing out of sphere

                                var penetrationVec2 = v3pool.get();
                                worldNormal.mult(-penetration, penetrationVec2);
                                var penetrationSpherePoint = v3pool.get();
                                worldNormal.mult(-R, penetrationSpherePoint);

                                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
                                xi.vsub(xj, r.rj);
                                r.rj.vadd(penetrationSpherePoint, r.rj);
                                r.rj.vadd(penetrationVec2, r.rj);

                                // Should be relative to the body.
                                r.rj.vadd(xj, r.rj);
                                r.rj.vsub(bj.position, r.rj);

                                // Should be relative to the body.
                                r.ri.vadd(xi, r.ri);
                                r.ri.vsub(bi.position, r.ri);

                                v3pool.release(penetrationVec2);
                                v3pool.release(penetrationSpherePoint);

                                this.result.push(r);
                                this.createFrictionEquationsFromContact(r, this.frictionResult);

                                // Release world vertices
                                for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                                    v3pool.release(faceVerts[j]);
                                }

                                return; // We only expect *one* face contact
                            } else {
                                // Edge?
                                for (var j = 0; j !== face.length; j++) {

                                    // Get two world transformed vertices
                                    var v1 = v3pool.get();
                                    var v2 = v3pool.get();
                                    qj.vmult(verts[face[(j + 1) % face.length]], v1);
                                    qj.vmult(verts[face[(j + 2) % face.length]], v2);
                                    xj.vadd(v1, v1);
                                    xj.vadd(v2, v2);

                                    // Construct edge vector
                                    var edge = sphereConvex_edge;
                                    v2.vsub(v1, edge);

                                    // Construct the same vector, but normalized
                                    var edgeUnit = sphereConvex_edgeUnit;
                                    edge.unit(edgeUnit);

                                    // p is xi projected onto the edge
                                    var p = v3pool.get();
                                    var v1_to_xi = v3pool.get();
                                    xi.vsub(v1, v1_to_xi);
                                    var dot = v1_to_xi.dot(edgeUnit);
                                    edgeUnit.mult(dot, p);
                                    p.vadd(v1, p);

                                    // Compute a vector from p to the center of the sphere
                                    var xi_to_p = v3pool.get();
                                    p.vsub(xi, xi_to_p);

                                    // Collision if the edge-sphere distance is less than the radius
                                    // AND if p is in between v1 and v2
                                    if (dot > 0 && dot * dot < edge.norm2() && xi_to_p.norm2() < R * R) { // Collision if the edge-sphere distance is less than the radius
                                        // Edge contact!
                                        var r = this.createContactEquation(bi, bj, si, sj);
                                        p.vsub(xj, r.rj);

                                        p.vsub(xi, r.ni);
                                        r.ni.normalize();

                                        r.ni.mult(R, r.ri);

                                        // Should be relative to the body.
                                        r.rj.vadd(xj, r.rj);
                                        r.rj.vsub(bj.position, r.rj);

                                        // Should be relative to the body.
                                        r.ri.vadd(xi, r.ri);
                                        r.ri.vsub(bi.position, r.ri);

                                        this.result.push(r);
                                        this.createFrictionEquationsFromContact(r, this.frictionResult);

                                        // Release world vertices
                                        for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                                            v3pool.release(faceVerts[j]);
                                        }

                                        v3pool.release(v1);
                                        v3pool.release(v2);
                                        v3pool.release(p);
                                        v3pool.release(xi_to_p);
                                        v3pool.release(v1_to_xi);

                                        return;
                                    }

                                    v3pool.release(v1);
                                    v3pool.release(v2);
                                    v3pool.release(p);
                                    v3pool.release(xi_to_p);
                                    v3pool.release(v1_to_xi);
                                }
                            }

                            // Release world vertices
                            for (var j = 0, Nfaceverts = faceVerts.length; j !== Nfaceverts; j++) {
                                v3pool.release(faceVerts[j]);
                            }
                        }
                    }
                };

            var planeBox_normal = new Vec3();
            var plane_to_corner = new Vec3();

            /**
             * @method planeBox
             * @param  {Array}      result
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =
                Narrowphase.prototype.planeBox = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    sj.convexPolyhedronRepresentation.material = sj.material;
                    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
                    this.planeConvex(si, sj.convexPolyhedronRepresentation, xi, xj, qi, qj, bi, bj);
                };

            var planeConvex_v = new Vec3();
            var planeConvex_normal = new Vec3();
            var planeConvex_relpos = new Vec3();
            var planeConvex_projected = new Vec3();

            /**
             * @method planeConvex
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =
                Narrowphase.prototype.planeConvex = function (
                    planeShape,
                    convexShape,
                    planePosition,
                    convexPosition,
                    planeQuat,
                    convexQuat,
                    planeBody,
                    convexBody
                ) {
                    // Simply return the points behind the plane.
                    var worldVertex = planeConvex_v,
                        worldNormal = planeConvex_normal;
                    worldNormal.set(0, 0, 1);
                    planeQuat.vmult(worldNormal, worldNormal); // Turn normal according to plane orientation

                    var numContacts = 0;
                    var relpos = planeConvex_relpos;
                    for (var i = 0; i !== convexShape.vertices.length; i++) {

                        // Get world convex vertex
                        worldVertex.copy(convexShape.vertices[i]);
                        convexQuat.vmult(worldVertex, worldVertex);
                        convexPosition.vadd(worldVertex, worldVertex);
                        worldVertex.vsub(planePosition, relpos);

                        var dot = worldNormal.dot(relpos);
                        if (dot <= 0.0) {

                            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);

                            // Get vertex position projected on plane
                            var projected = planeConvex_projected;
                            worldNormal.mult(worldNormal.dot(relpos), projected);
                            worldVertex.vsub(projected, projected);
                            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

                            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane

                            // rj is now just the vector from the convex center to the vertex
                            worldVertex.vsub(convexPosition, r.rj);

                            // Make it relative to the body
                            r.ri.vadd(planePosition, r.ri);
                            r.ri.vsub(planeBody.position, r.ri);
                            r.rj.vadd(convexPosition, r.rj);
                            r.rj.vsub(convexBody.position, r.rj);

                            this.result.push(r);
                            numContacts++;
                            if (!this.enableFrictionReduction) {
                                this.createFrictionEquationsFromContact(r, this.frictionResult);
                            }
                        }
                    }

                    if (this.enableFrictionReduction && numContacts) {
                        this.createFrictionFromAverage(numContacts);
                    }
                };

            var convexConvex_sepAxis = new Vec3();
            var convexConvex_q = new Vec3();

            /**
             * @method convexConvex
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =
                Narrowphase.prototype.convexConvex = function (si, sj, xi, xj, qi, qj, bi, bj, rsi, rsj, faceListA, faceListB) {
                    var sepAxis = convexConvex_sepAxis;

                    if (xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius) {
                        return;
                    }

                    if (si.findSeparatingAxis(sj, xi, qi, xj, qj, sepAxis, faceListA, faceListB)) {
                        var res = [];
                        var q = convexConvex_q;
                        si.clipAgainstHull(xi, qi, sj, xj, qj, sepAxis, -100, 100, res);
                        var numContacts = 0;
                        for (var j = 0; j !== res.length; j++) {
                            var r = this.createContactEquation(bi, bj, si, sj, rsi, rsj),
                                ri = r.ri,
                                rj = r.rj;
                            sepAxis.negate(r.ni);
                            res[j].normal.negate(q);
                            q.mult(res[j].depth, q);
                            res[j].point.vadd(q, ri);
                            rj.copy(res[j].point);

                            // Contact points are in world coordinates. Transform back to relative
                            ri.vsub(xi, ri);
                            rj.vsub(xj, rj);

                            // Make relative to bodies
                            ri.vadd(xi, ri);
                            ri.vsub(bi.position, ri);
                            rj.vadd(xj, rj);
                            rj.vsub(bj.position, rj);

                            this.result.push(r);
                            numContacts++;
                            if (!this.enableFrictionReduction) {
                                this.createFrictionEquationsFromContact(r, this.frictionResult);
                            }
                        }
                        if (this.enableFrictionReduction && numContacts) {
                            this.createFrictionFromAverage(numContacts);
                        }
                    }
                };


            /**
             * @method convexTrimesh
             * @param  {Array}      result
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            // Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
            // Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
            //     var sepAxis = convexConvex_sepAxis;

            //     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
            //         return;
            //     }

            //     // Construct a temp hull for each triangle
            //     var hullB = new ConvexPolyhedron();

            //     hullB.faces = [[0,1,2]];
            //     var va = new Vec3();
            //     var vb = new Vec3();
            //     var vc = new Vec3();
            //     hullB.vertices = [
            //         va,
            //         vb,
            //         vc
            //     ];

            //     for (var i = 0; i < sj.indices.length / 3; i++) {

            //         var triangleNormal = new Vec3();
            //         sj.getNormal(i, triangleNormal);
            //         hullB.faceNormals = [triangleNormal];

            //         sj.getTriangleVertices(i, va, vb, vc);

            //         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
            //         if(!d){
            //             triangleNormal.scale(-1, triangleNormal);
            //             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);

            //             if(!d){
            //                 continue;
            //             }
            //         }

            //         var res = [];
            //         var q = convexConvex_q;
            //         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
            //         for(var j = 0; j !== res.length; j++){
            //             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
            //                 ri = r.ri,
            //                 rj = r.rj;
            //             r.ni.copy(triangleNormal);
            //             r.ni.negate(r.ni);
            //             res[j].normal.negate(q);
            //             q.mult(res[j].depth, q);
            //             res[j].point.vadd(q, ri);
            //             rj.copy(res[j].point);

            //             // Contact points are in world coordinates. Transform back to relative
            //             ri.vsub(xi,ri);
            //             rj.vsub(xj,rj);

            //             // Make relative to bodies
            //             ri.vadd(xi, ri);
            //             ri.vsub(bi.position, ri);
            //             rj.vadd(xj, rj);
            //             rj.vsub(bj.position, rj);

            //             result.push(r);
            //         }
            //     }
            // };

            var particlePlane_normal = new Vec3();
            var particlePlane_relpos = new Vec3();
            var particlePlane_projected = new Vec3();

            /**
             * @method particlePlane
             * @param  {Array}      result
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =
                Narrowphase.prototype.planeParticle = function (sj, si, xj, xi, qj, qi, bj, bi) {
                    var normal = particlePlane_normal;
                    normal.set(0, 0, 1);
                    bj.quaternion.vmult(normal, normal); // Turn normal according to plane orientation
                    var relpos = particlePlane_relpos;
                    xi.vsub(bj.position, relpos);
                    var dot = normal.dot(relpos);
                    if (dot <= 0.0) {
                        var r = this.createContactEquation(bi, bj, si, sj);
                        r.ni.copy(normal); // Contact normal is the plane normal
                        r.ni.negate(r.ni);
                        r.ri.set(0, 0, 0); // Center of particle

                        // Get particle position projected on plane
                        var projected = particlePlane_projected;
                        normal.mult(normal.dot(xi), projected);
                        xi.vsub(projected, projected);
                        //projected.vadd(bj.position,projected);

                        // rj is now the projected world position minus plane position
                        r.rj.copy(projected);
                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                };

            var particleSphere_normal = new Vec3();

            /**
             * @method particleSphere
             * @param  {Array}      result
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =
                Narrowphase.prototype.sphereParticle = function (sj, si, xj, xi, qj, qi, bj, bi) {
                    // The normal is the unit vector from sphere center to particle center
                    var normal = particleSphere_normal;
                    normal.set(0, 0, 1);
                    xi.vsub(xj, normal);
                    var lengthSquared = normal.norm2();

                    if (lengthSquared <= sj.radius * sj.radius) {
                        var r = this.createContactEquation(bi, bj, si, sj);
                        normal.normalize();
                        r.rj.copy(normal);
                        r.rj.mult(sj.radius, r.rj);
                        r.ni.copy(normal); // Contact normal
                        r.ni.negate(r.ni);
                        r.ri.set(0, 0, 0); // Center of particle
                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);
                    }
                };

            // WIP
            var cqj = new Quaternion();
            var convexParticle_local = new Vec3();
            var convexParticle_normal = new Vec3();
            var convexParticle_penetratedFaceNormal = new Vec3();
            var convexParticle_vertexToParticle = new Vec3();
            var convexParticle_worldPenetrationVec = new Vec3();

            /**
             * @method convexParticle
             * @param  {Array}      result
             * @param  {Shape}      si
             * @param  {Shape}      sj
             * @param  {Vec3}       xi
             * @param  {Vec3}       xj
             * @param  {Quaternion} qi
             * @param  {Quaternion} qj
             * @param  {Body}       bi
             * @param  {Body}       bj
             */
            Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =
                Narrowphase.prototype.convexParticle = function (sj, si, xj, xi, qj, qi, bj, bi) {
                    var penetratedFaceIndex = -1;
                    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
                    var worldPenetrationVec = convexParticle_worldPenetrationVec;
                    var minPenetration = null;
                    var numDetectedFaces = 0;

                    // Convert particle position xi to local coords in the convex
                    var local = convexParticle_local;
                    local.copy(xi);
                    local.vsub(xj, local); // Convert position to relative the convex origin
                    qj.conjugate(cqj);
                    cqj.vmult(local, local);

                    if (sj.pointIsInside(local)) {

                        if (sj.worldVerticesNeedsUpdate) {
                            sj.computeWorldVertices(xj, qj);
                        }
                        if (sj.worldFaceNormalsNeedsUpdate) {
                            sj.computeWorldFaceNormals(qj);
                        }

                        // For each world polygon in the polyhedra
                        for (var i = 0, nfaces = sj.faces.length; i !== nfaces; i++) {

                            // Construct world face vertices
                            var verts = [sj.worldVertices[sj.faces[i][0]]];
                            var normal = sj.worldFaceNormals[i];

                            // Check how much the particle penetrates the polygon plane.
                            xi.vsub(verts[0], convexParticle_vertexToParticle);
                            var penetration = -normal.dot(convexParticle_vertexToParticle);
                            if (minPenetration === null || Math.abs(penetration) < Math.abs(minPenetration)) {
                                minPenetration = penetration;
                                penetratedFaceIndex = i;
                                penetratedFaceNormal.copy(normal);
                                numDetectedFaces++;
                            }
                        }

                        if (penetratedFaceIndex !== -1) {
                            // Setup contact
                            var r = this.createContactEquation(bi, bj, si, sj);
                            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);

                            // rj is the particle position projected to the face
                            worldPenetrationVec.vadd(xi, worldPenetrationVec);
                            worldPenetrationVec.vsub(xj, worldPenetrationVec);
                            r.rj.copy(worldPenetrationVec);
                            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
                            //projectedToFace.copy(r.rj);

                            //qj.vmult(r.rj,r.rj);
                            penetratedFaceNormal.negate(r.ni); // Contact normal
                            r.ri.set(0, 0, 0); // Center of particle

                            var ri = r.ri,
                                rj = r.rj;

                            // Make relative to bodies
                            ri.vadd(xi, ri);
                            ri.vsub(bi.position, ri);
                            rj.vadd(xj, rj);
                            rj.vsub(bj.position, rj);

                            this.result.push(r);
                            this.createFrictionEquationsFromContact(r, this.frictionResult);
                        } else {
                            console.warn("Point found inside convex, but did not find penetrating face!");
                        }
                    }
                };

            Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =
                Narrowphase.prototype.boxHeightfield = function (si, sj, xi, xj, qi, qj, bi, bj) {
                    si.convexPolyhedronRepresentation.material = si.material;
                    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
                    this.convexHeightfield(si.convexPolyhedronRepresentation, sj, xi, xj, qi, qj, bi, bj);
                };

            var convexHeightfield_tmp1 = new Vec3();
            var convexHeightfield_tmp2 = new Vec3();
            var convexHeightfield_faceList = [0];

            /**
             * @method convexHeightfield
             */
            Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =
                Narrowphase.prototype.convexHeightfield = function (
                    convexShape,
                    hfShape,
                    convexPos,
                    hfPos,
                    convexQuat,
                    hfQuat,
                    convexBody,
                    hfBody
                ) {
                    var data = hfShape.data,
                        w = hfShape.elementSize,
                        radius = convexShape.boundingSphereRadius,
                        worldPillarOffset = convexHeightfield_tmp2,
                        faceList = convexHeightfield_faceList;

                    // Get sphere position to heightfield local!
                    var localConvexPos = convexHeightfield_tmp1;
                    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);

                    // Get the index of the data points to test against
                    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
                        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
                        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
                        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;

                    // Bail out if we are out of the terrain
                    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length) {
                        return;
                    }

                    // Clamp index to edges
                    if (iMinX < 0) { iMinX = 0; }
                    if (iMaxX < 0) { iMaxX = 0; }
                    if (iMinY < 0) { iMinY = 0; }
                    if (iMaxY < 0) { iMaxY = 0; }
                    if (iMinX >= data.length) { iMinX = data.length - 1; }
                    if (iMaxX >= data.length) { iMaxX = data.length - 1; }
                    if (iMaxY >= data[0].length) { iMaxY = data[0].length - 1; }
                    if (iMinY >= data[0].length) { iMinY = data[0].length - 1; }

                    var minMax = [];
                    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
                    var min = minMax[0];
                    var max = minMax[1];

                    // Bail out if we're cant touch the bounding height box
                    if (localConvexPos.z - radius > max || localConvexPos.z + radius < min) {
                        return;
                    }

                    for (var i = iMinX; i < iMaxX; i++) {
                        for (var j = iMinY; j < iMaxY; j++) {

                            // Lower triangle
                            hfShape.getConvexTrianglePillar(i, j, false);
                            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
                            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
                            }

                            // Upper triangle
                            hfShape.getConvexTrianglePillar(i, j, true);
                            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
                            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
                            }
                        }
                    }
                };

            var sphereHeightfield_tmp1 = new Vec3();
            var sphereHeightfield_tmp2 = new Vec3();

            /**
             * @method sphereHeightfield
             */
            Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =
                Narrowphase.prototype.sphereHeightfield = function (
                    sphereShape,
                    hfShape,
                    spherePos,
                    hfPos,
                    sphereQuat,
                    hfQuat,
                    sphereBody,
                    hfBody
                ) {
                    var data = hfShape.data,
                        radius = sphereShape.radius,
                        w = hfShape.elementSize,
                        worldPillarOffset = sphereHeightfield_tmp2;

                    // Get sphere position to heightfield local!
                    var localSpherePos = sphereHeightfield_tmp1;
                    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);

                    // Get the index of the data points to test against
                    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
                        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
                        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
                        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;

                    // Bail out if we are out of the terrain
                    if (iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length) {
                        return;
                    }

                    // Clamp index to edges
                    if (iMinX < 0) { iMinX = 0; }
                    if (iMaxX < 0) { iMaxX = 0; }
                    if (iMinY < 0) { iMinY = 0; }
                    if (iMaxY < 0) { iMaxY = 0; }
                    if (iMinX >= data.length) { iMinX = data.length - 1; }
                    if (iMaxX >= data.length) { iMaxX = data.length - 1; }
                    if (iMaxY >= data[0].length) { iMaxY = data[0].length - 1; }
                    if (iMinY >= data[0].length) { iMinY = data[0].length - 1; }

                    var minMax = [];
                    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
                    var min = minMax[0];
                    var max = minMax[1];

                    // Bail out if we're cant touch the bounding height box
                    if (localSpherePos.z - radius > max || localSpherePos.z + radius < min) {
                        return;
                    }

                    var result = this.result;
                    for (var i = iMinX; i < iMaxX; i++) {
                        for (var j = iMinY; j < iMaxY; j++) {

                            var numContactsBefore = result.length;

                            // Lower triangle
                            hfShape.getConvexTrianglePillar(i, j, false);
                            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
                            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
                            }

                            // Upper triangle
                            hfShape.getConvexTrianglePillar(i, j, true);
                            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
                            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
                            }

                            var numContacts = result.length - numContactsBefore;

                            if (numContacts > 2) {
                                return;
                            }
                            /*
                            // Skip all but 1
                            for (var k = 0; k < numContacts - 1; k++) {
                                result.pop();
                            }
                            */
                        }
                    }
                };

        }, { "../collision/AABB": 3, "../collision/Ray": 9, "../equations/ContactEquation": 19, "../equations/FrictionEquation": 21, "../math/Quaternion": 28, "../math/Transform": 29, "../math/Vec3": 30, "../shapes/ConvexPolyhedron": 38, "../shapes/Shape": 43, "../solver/Solver": 47, "../utils/Vec3Pool": 54 }], 56: [function (_dereq_, module, exports) {
            /* global performance */

            module.exports = World;

            var Shape = _dereq_('../shapes/Shape');
            var Vec3 = _dereq_('../math/Vec3');
            var Quaternion = _dereq_('../math/Quaternion');
            var GSSolver = _dereq_('../solver/GSSolver');
            var Vec3Pool = _dereq_('../utils/Vec3Pool');
            var ContactEquation = _dereq_('../equations/ContactEquation');
            var FrictionEquation = _dereq_('../equations/FrictionEquation');
            var Narrowphase = _dereq_('./Narrowphase');
            var EventTarget = _dereq_('../utils/EventTarget');
            var ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');
            var Material = _dereq_('../material/Material');
            var ContactMaterial = _dereq_('../material/ContactMaterial');
            var Body = _dereq_('../objects/Body');
            var TupleDictionary = _dereq_('../utils/TupleDictionary');
            var RaycastResult = _dereq_('../collision/RaycastResult');
            var AABB = _dereq_('../collision/AABB');
            var Ray = _dereq_('../collision/Ray');
            var NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');

            /**
             * The physics world
             * @class World
             * @constructor
             * @extends EventTarget
             */
            function World() {
                EventTarget.apply(this);

                /**
                 * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
                 * @property {Number} dt
                 */
                this.dt = -1;

                /**
                 * Makes bodies go to sleep when they've been inactive
                 * @property allowSleep
                 * @type {Boolean}
                 */
                this.allowSleep = false;

                /**
                 * All the current contacts (instances of ContactEquation) in the world.
                 * @property contacts
                 * @type {Array}
                 */
                this.contacts = [];
                this.frictionEquations = [];

                /**
                 * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
                 * @property quatNormalizeSkip
                 * @type {Number}
                 */
                this.quatNormalizeSkip = 0;

                /**
                 * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
                 * @property quatNormalizeFast
                 * @type {Boolean}
                 * @see Quaternion.normalizeFast
                 * @see Quaternion.normalize
                 */
                this.quatNormalizeFast = false;

                /**
                 * The wall-clock time since simulation start
                 * @property time
                 * @type {Number}
                 */
                this.time = 0.0;

                /**
                 * Number of timesteps taken since start
                 * @property stepnumber
                 * @type {Number}
                 */
                this.stepnumber = 0;

                /// Default and last timestep sizes
                this.default_dt = 1 / 60;

                this.nextId = 0;
                /**
                 * @property gravity
                 * @type {Vec3}
                 */
                this.gravity = new Vec3();

                /**
                 * @property broadphase
                 * @type {Broadphase}
                 */
                this.broadphase = new NaiveBroadphase();

                /**
                 * @property bodies
                 * @type {Array}
                 */
                this.bodies = [];

                /**
                 * @property solver
                 * @type {Solver}
                 */
                this.solver = new GSSolver();

                /**
                 * @property constraints
                 * @type {Array}
                 */
                this.constraints = [];

                /**
                 * @property narrowphase
                 * @type {Narrowphase}
                 */
                this.narrowphase = new Narrowphase(this);

                /**
                 * @property {ArrayCollisionMatrix} collisionMatrix
                 * @type {ArrayCollisionMatrix}
                 */
                this.collisionMatrix = new ArrayCollisionMatrix();

                /**
                 * CollisionMatrix from the previous step.
                 * @property {ArrayCollisionMatrix} collisionMatrixPrevious
                 * @type {ArrayCollisionMatrix}
                 */
                this.collisionMatrixPrevious = new ArrayCollisionMatrix();

                /**
                 * All added materials
                 * @property materials
                 * @type {Array}
                 */
                this.materials = [];

                /**
                 * @property contactmaterials
                 * @type {Array}
                 */
                this.contactmaterials = [];

                /**
                 * Used to look up a ContactMaterial given two instances of Material.
                 * @property {TupleDictionary} contactMaterialTable
                 */
                this.contactMaterialTable = new TupleDictionary();

                this.defaultMaterial = new Material("default");

                /**
                 * This contact material is used if no suitable contactmaterial is found for a contact.
                 * @property defaultContactMaterial
                 * @type {ContactMaterial}
                 */
                this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });

                /**
                 * @property doProfiling
                 * @type {Boolean}
                 */
                this.doProfiling = false;

                /**
                 * @property profile
                 * @type {Object}
                 */
                this.profile = {
                    solve: 0,
                    makeContactConstraints: 0,
                    broadphase: 0,
                    integrate: 0,
                    narrowphase: 0,
                };

                /**
                 * @property subsystems
                 * @type {Array}
                 */
                this.subsystems = [];

                this.addBodyEvent = {
                    type: "addBody",
                    body: null,
                };

                this.removeBodyEvent = {
                    type: "removeBody",
                    body: null,
                };
            }
            World.prototype = new EventTarget();

            // Temp stuff
            var tmpAABB1 = new AABB();
            var tmpArray1 = [];
            var tmpRay = new Ray();

            /**
             * Get the contact material between materials m1 and m2
             * @method getContactMaterial
             * @param {Material} m1
             * @param {Material} m2
             * @return {ContactMaterial} The contact material if it was found.
             */
            World.prototype.getContactMaterial = function (m1, m2) {
                return this.contactMaterialTable.get(m1.id, m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
            };

            /**
             * Get number of objects in the world.
             * @method numObjects
             * @return {Number}
             * @deprecated
             */
            World.prototype.numObjects = function () {
                return this.bodies.length;
            };

            /**
             * Store old collision state info
             * @method collisionMatrixTick
             */
            World.prototype.collisionMatrixTick = function () {
                var temp = this.collisionMatrixPrevious;
                this.collisionMatrixPrevious = this.collisionMatrix;
                this.collisionMatrix = temp;
                this.collisionMatrix.reset();
            };

            /**
             * Add a rigid body to the simulation.
             * @method add
             * @param {Body} body
             * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
             * @todo Adding an array of bodies should be possible. This would save some loops too
             * @deprecated Use .addBody instead
             */
            World.prototype.add = World.prototype.addBody = function (body) {
                if (this.bodies.indexOf(body) !== -1) {
                    return;
                }
                body.index = this.bodies.length;
                this.bodies.push(body);
                body.world = this;
                body.initPosition.copy(body.position);
                body.initVelocity.copy(body.velocity);
                body.timeLastSleepy = this.time;
                if (body instanceof Body) {
                    body.initAngularVelocity.copy(body.angularVelocity);
                    body.initQuaternion.copy(body.quaternion);
                }
                this.collisionMatrix.setNumObjects(this.bodies.length);
                this.addBodyEvent.body = body;
                this.dispatchEvent(this.addBodyEvent);
            };

            /**
             * Add a constraint to the simulation.
             * @method addConstraint
             * @param {Constraint} c
             */
            World.prototype.addConstraint = function (c) {
                this.constraints.push(c);
            };

            /**
             * Removes a constraint
             * @method removeConstraint
             * @param {Constraint} c
             */
            World.prototype.removeConstraint = function (c) {
                var idx = this.constraints.indexOf(c);
                if (idx !== -1) {
                    this.constraints.splice(idx, 1);
                }
            };

            /**
             * Raycast test
             * @method rayTest
             * @param {Vec3} from
             * @param {Vec3} to
             * @param {Function|RaycastResult} result
             * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
             */
            World.prototype.rayTest = function (from, to, result) {
                if (result instanceof RaycastResult) {
                    // Do raycastclosest
                    this.raycastClosest(from, to, {
                        skipBackfaces: true
                    }, result);
                } else {
                    // Do raycastAll
                    this.raycastAll(from, to, {
                        skipBackfaces: true
                    }, result);
                }
            };

            /**
             * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
             * @method raycastAll
             * @param  {Vec3} from
             * @param  {Vec3} to
             * @param  {Object} options
             * @param  {number} [options.collisionFilterMask=-1]
             * @param  {number} [options.collisionFilterGroup=-1]
             * @param  {boolean} [options.skipBackfaces=false]
             * @param  {boolean} [options.checkCollisionResponse=true]
             * @param  {Function} callback
             * @return {boolean} True if any body was hit.
             */
            World.prototype.raycastAll = function (from, to, options, callback) {
                options.mode = Ray.ALL;
                options.from = from;
                options.to = to;
                options.callback = callback;
                return tmpRay.intersectWorld(this, options);
            };

            /**
             * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
             * @method raycastAny
             * @param  {Vec3} from
             * @param  {Vec3} to
             * @param  {Object} options
             * @param  {number} [options.collisionFilterMask=-1]
             * @param  {number} [options.collisionFilterGroup=-1]
             * @param  {boolean} [options.skipBackfaces=false]
             * @param  {boolean} [options.checkCollisionResponse=true]
             * @param  {RaycastResult} result
             * @return {boolean} True if any body was hit.
             */
            World.prototype.raycastAny = function (from, to, options, result) {
                options.mode = Ray.ANY;
                options.from = from;
                options.to = to;
                options.result = result;
                return tmpRay.intersectWorld(this, options);
            };

            /**
             * Ray cast, and return information of the closest hit.
             * @method raycastClosest
             * @param  {Vec3} from
             * @param  {Vec3} to
             * @param  {Object} options
             * @param  {number} [options.collisionFilterMask=-1]
             * @param  {number} [options.collisionFilterGroup=-1]
             * @param  {boolean} [options.skipBackfaces=false]
             * @param  {boolean} [options.checkCollisionResponse=true]
             * @param  {RaycastResult} result
             * @return {boolean} True if any body was hit.
             */
            World.prototype.raycastClosest = function (from, to, options, result) {
                options.mode = Ray.CLOSEST;
                options.from = from;
                options.to = to;
                options.result = result;
                return tmpRay.intersectWorld(this, options);
            };

            /**
             * Remove a rigid body from the simulation.
             * @method remove
             * @param {Body} body
             * @deprecated Use .removeBody instead
             */
            World.prototype.remove = function (body) {
                body.world = null;
                var n = this.bodies.length - 1,
                    bodies = this.bodies,
                    idx = bodies.indexOf(body);
                if (idx !== -1) {
                    bodies.splice(idx, 1); // Todo: should use a garbage free method

                    // Recompute index
                    for (var i = 0; i !== bodies.length; i++) {
                        bodies[i].index = i;
                    }

                    this.collisionMatrix.setNumObjects(n);
                    this.removeBodyEvent.body = body;
                    this.dispatchEvent(this.removeBodyEvent);
                }
            };

            /**
             * Remove a rigid body from the simulation.
             * @method removeBody
             * @param {Body} body
             */
            World.prototype.removeBody = World.prototype.remove;

            /**
             * Adds a material to the World.
             * @method addMaterial
             * @param {Material} m
             * @todo Necessary?
             */
            World.prototype.addMaterial = function (m) {
                this.materials.push(m);
            };

            /**
             * Adds a contact material to the World
             * @method addContactMaterial
             * @param {ContactMaterial} cmat
             */
            World.prototype.addContactMaterial = function (cmat) {

                // Add contact material
                this.contactmaterials.push(cmat);

                // Add current contact material to the material table
                this.contactMaterialTable.set(cmat.materials[0].id, cmat.materials[1].id, cmat);
            };

            // performance.now()
            if (typeof performance === 'undefined') {
                performance = {};
            }
            if (!performance.now) {
                var nowOffset = Date.now();
                if (performance.timing && performance.timing.navigationStart) {
                    nowOffset = performance.timing.navigationStart;
                }
                performance.now = function () {
                    return Date.now() - nowOffset;
                };
            }

            var step_tmp1 = new Vec3();

            /**
             * Step the physics world forward in time.
             *
             * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
             *
             * @method step
             * @param {Number} dt                       The fixed time step size to use.
             * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
             * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
             *
             * @example
             *     // fixed timestepping without interpolation
             *     world.step(1/60);
             *
             * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
             */
            World.prototype.step = function (dt, timeSinceLastCalled, maxSubSteps) {
                maxSubSteps = maxSubSteps || 10;
                timeSinceLastCalled = timeSinceLastCalled || 0;

                if (timeSinceLastCalled === 0) { // Fixed, simple stepping

                    this.internalStep(dt);

                    // Increment time
                    this.time += dt;

                } else {

                    // Compute the number of fixed steps we should have taken since the last step
                    var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
                    internalSteps = Math.min(internalSteps, maxSubSteps);

                    // Do some fixed steps to catch up
                    var t0 = performance.now();
                    for (var i = 0; i !== internalSteps; i++) {
                        this.internalStep(dt);
                        if (performance.now() - t0 > dt * 1000) {
                            // We are slower than real-time. Better bail out.
                            break;
                        }
                    }

                    // Increment internal clock
                    this.time += timeSinceLastCalled;

                    // Compute "Left over" time step
                    var h = this.time % dt;
                    var h_div_dt = h / dt;
                    var interpvelo = step_tmp1;
                    var bodies = this.bodies;

                    for (var j = 0; j !== bodies.length; j++) {
                        var b = bodies[j];
                        if (b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING) {

                            // Interpolate
                            b.position.vsub(b.previousPosition, interpvelo);
                            interpvelo.scale(h_div_dt, interpvelo);
                            b.position.vadd(interpvelo, b.interpolatedPosition);

                            // TODO: interpolate quaternion
                            // b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;

                        } else {

                            // For static bodies, just copy. Who else will do it?
                            b.interpolatedPosition.copy(b.position);
                            b.interpolatedQuaternion.copy(b.quaternion);
                        }
                    }
                }
            };

            /**
             * Step the simulation
             * @method step
             * @param {Number} dt
             */
            var World_step_postStepEvent = { type: "postStep" }, // Reusable event objects to save memory
                World_step_preStepEvent = { type: "preStep" },
                World_step_collideEvent = { type: "collide", body: null, contact: null },
                World_step_oldContacts = [], // Pools for unused objects
                World_step_frictionEquationPool = [],
                World_step_p1 = [], // Reusable arrays for collision pairs
                World_step_p2 = [],
                World_step_gvec = new Vec3(), // Temporary vectors and quats
                World_step_vi = new Vec3(),
                World_step_vj = new Vec3(),
                World_step_wi = new Vec3(),
                World_step_wj = new Vec3(),
                World_step_t1 = new Vec3(),
                World_step_t2 = new Vec3(),
                World_step_rixn = new Vec3(),
                World_step_rjxn = new Vec3(),
                World_step_step_q = new Quaternion(),
                World_step_step_w = new Quaternion(),
                World_step_step_wq = new Quaternion(),
                invI_tau_dt = new Vec3();
            World.prototype.internalStep = function (dt) {
                this.dt = dt;

                var world = this,
                    that = this,
                    contacts = this.contacts,
                    p1 = World_step_p1,
                    p2 = World_step_p2,
                    N = this.numObjects(),
                    bodies = this.bodies,
                    solver = this.solver,
                    gravity = this.gravity,
                    doProfiling = this.doProfiling,
                    profile = this.profile,
                    DYNAMIC = Body.DYNAMIC,
                    profilingStart,
                    constraints = this.constraints,
                    frictionEquationPool = World_step_frictionEquationPool,
                    gnorm = gravity.norm(),
                    gx = gravity.x,
                    gy = gravity.y,
                    gz = gravity.z,
                    i = 0;

                if (doProfiling) {
                    profilingStart = performance.now();
                }

                // Add gravity to all objects
                for (i = 0; i !== N; i++) {
                    var bi = bodies[i];
                    if (bi.type & DYNAMIC) { // Only for dynamic bodies
                        var f = bi.force, m = bi.mass;
                        f.x += m * gx;
                        f.y += m * gy;
                        f.z += m * gz;
                    }
                }

                // Update subsystems
                for (var i = 0, Nsubsystems = this.subsystems.length; i !== Nsubsystems; i++) {
                    this.subsystems[i].update();
                }

                // Collision detection
                if (doProfiling) { profilingStart = performance.now(); }
                p1.length = 0; // Clean up pair arrays from last step
                p2.length = 0;
                this.broadphase.collisionPairs(this, p1, p2);
                if (doProfiling) { profile.broadphase = performance.now() - profilingStart; }

                // Remove constrained pairs with collideConnected == false
                var Nconstraints = constraints.length;
                for (i = 0; i !== Nconstraints; i++) {
                    var c = constraints[i];
                    if (!c.collideConnected) {
                        for (var j = p1.length - 1; j >= 0; j -= 1) {
                            if ((c.bodyA === p1[j] && c.bodyB === p2[j]) ||
                                (c.bodyB === p1[j] && c.bodyA === p2[j])) {
                                p1.splice(j, 1);
                                p2.splice(j, 1);
                            }
                        }
                    }
                }

                this.collisionMatrixTick();

                // Generate contacts
                if (doProfiling) { profilingStart = performance.now(); }
                var oldcontacts = World_step_oldContacts;
                var NoldContacts = contacts.length;

                for (i = 0; i !== NoldContacts; i++) {
                    oldcontacts.push(contacts[i]);
                }
                contacts.length = 0;

                // Transfer FrictionEquation from current list to the pool for reuse
                var NoldFrictionEquations = this.frictionEquations.length;
                for (i = 0; i !== NoldFrictionEquations; i++) {
                    frictionEquationPool.push(this.frictionEquations[i]);
                }
                this.frictionEquations.length = 0;

                this.narrowphase.getContacts(
                    p1,
                    p2,
                    this,
                    contacts,
                    oldcontacts, // To be reused
                    this.frictionEquations,
                    frictionEquationPool
                );

                if (doProfiling) {
                    profile.narrowphase = performance.now() - profilingStart;
                }

                // Loop over all collisions
                if (doProfiling) {
                    profilingStart = performance.now();
                }

                // Add all friction eqs
                for (var i = 0; i < this.frictionEquations.length; i++) {
                    solver.addEquation(this.frictionEquations[i]);
                }

                var ncontacts = contacts.length;
                for (var k = 0; k !== ncontacts; k++) {

                    // Current contact
                    var c = contacts[k];

                    // Get current collision indeces
                    var bi = c.bi,
                        bj = c.bj,
                        si = c.si,
                        sj = c.sj;

                    // Get collision properties
                    var cm;
                    if (bi.material && bj.material) {
                        cm = this.getContactMaterial(bi.material, bj.material) || this.defaultContactMaterial;
                    } else {
                        cm = this.defaultContactMaterial;
                    }

                    // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

                    var mu = cm.friction;
                    // c.restitution = cm.restitution;

                    // If friction or restitution were specified in the material, use them
                    if (bi.material && bj.material) {
                        if (bi.material.friction >= 0 && bj.material.friction >= 0) {
                            mu = bi.material.friction * bj.material.friction;
                        }

                        if (bi.material.restitution >= 0 && bj.material.restitution >= 0) {
                            c.restitution = bi.material.restitution * bj.material.restitution;
                        }
                    }

                    // c.setSpookParams(
                    //           cm.contactEquationStiffness,
                    //           cm.contactEquationRelaxation,
                    //           dt
                    //       );

                    solver.addEquation(c);

                    // // Add friction constraint equation
                    // if(mu > 0){

                    // 	// Create 2 tangent equations
                    // 	var mug = mu * gnorm;
                    // 	var reducedMass = (bi.invMass + bj.invMass);
                    // 	if(reducedMass > 0){
                    // 		reducedMass = 1/reducedMass;
                    // 	}
                    // 	var pool = frictionEquationPool;
                    // 	var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
                    // 	var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
                    // 	this.frictionEquations.push(c1, c2);

                    // 	c1.bi = c2.bi = bi;
                    // 	c1.bj = c2.bj = bj;
                    // 	c1.minForce = c2.minForce = -mug*reducedMass;
                    // 	c1.maxForce = c2.maxForce = mug*reducedMass;

                    // 	// Copy over the relative vectors
                    // 	c1.ri.copy(c.ri);
                    // 	c1.rj.copy(c.rj);
                    // 	c2.ri.copy(c.ri);
                    // 	c2.rj.copy(c.rj);

                    // 	// Construct tangents
                    // 	c.ni.tangents(c1.t, c2.t);

                    //           // Set spook params
                    //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
                    //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);

                    //           c1.enabled = c2.enabled = c.enabled;

                    // 	// Add equations to solver
                    // 	solver.addEquation(c1);
                    // 	solver.addEquation(c2);
                    // }

                    if (bi.allowSleep &&
                        bi.type === Body.DYNAMIC &&
                        bi.sleepState === Body.SLEEPING &&
                        bj.sleepState === Body.AWAKE &&
                        bj.type !== Body.STATIC
                    ) {
                        var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
                        var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit, 2);
                        if (speedSquaredB >= speedLimitSquaredB * 2) {
                            bi._wakeUpAfterNarrowphase = true;
                        }
                    }

                    if (bj.allowSleep &&
                        bj.type === Body.DYNAMIC &&
                        bj.sleepState === Body.SLEEPING &&
                        bi.sleepState === Body.AWAKE &&
                        bi.type !== Body.STATIC
                    ) {
                        var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
                        var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit, 2);
                        if (speedSquaredA >= speedLimitSquaredA * 2) {
                            bj._wakeUpAfterNarrowphase = true;
                        }
                    }

                    // Now we know that i and j are in contact. Set collision matrix state
                    this.collisionMatrix.set(bi, bj, true);

                    if (!this.collisionMatrixPrevious.get(bi, bj)) {
                        // First contact!
                        // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
                        World_step_collideEvent.body = bj;
                        World_step_collideEvent.contact = c;
                        bi.dispatchEvent(World_step_collideEvent);

                        World_step_collideEvent.body = bi;
                        bj.dispatchEvent(World_step_collideEvent);
                    }
                }
                if (doProfiling) {
                    profile.makeContactConstraints = performance.now() - profilingStart;
                    profilingStart = performance.now();
                }

                // Wake up bodies
                for (i = 0; i !== N; i++) {
                    var bi = bodies[i];
                    if (bi._wakeUpAfterNarrowphase) {
                        bi.wakeUp();
                        bi._wakeUpAfterNarrowphase = false;
                    }
                }

                // Add user-added constraints
                var Nconstraints = constraints.length;
                for (i = 0; i !== Nconstraints; i++) {
                    var c = constraints[i];
                    c.update();
                    for (var j = 0, Neq = c.equations.length; j !== Neq; j++) {
                        var eq = c.equations[j];
                        solver.addEquation(eq);
                    }
                }

                // Solve the constrained system
                solver.solve(dt, this);

                if (doProfiling) {
                    profile.solve = performance.now() - profilingStart;
                }

                // Remove all contacts from solver
                solver.removeAllEquations();

                // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
                var pow = Math.pow;
                for (i = 0; i !== N; i++) {
                    var bi = bodies[i];
                    if (bi.type & DYNAMIC) { // Only for dynamic bodies
                        var ld = pow(1.0 - bi.linearDamping, dt);
                        var v = bi.velocity;
                        v.mult(ld, v);
                        var av = bi.angularVelocity;
                        if (av) {
                            var ad = pow(1.0 - bi.angularDamping, dt);
                            av.mult(ad, av);
                        }
                    }
                }

                this.dispatchEvent(World_step_preStepEvent);

                // Invoke pre-step callbacks
                for (i = 0; i !== N; i++) {
                    var bi = bodies[i];
                    if (bi.preStep) {
                        bi.preStep.call(bi);
                    }
                }

                // Leap frog
                // vnew = v + h*f/m
                // xnew = x + h*vnew
                if (doProfiling) {
                    profilingStart = performance.now();
                }
                var q = World_step_step_q;
                var w = World_step_step_w;
                var wq = World_step_step_wq;
                var stepnumber = this.stepnumber;
                var DYNAMIC_OR_KINEMATIC = Body.DYNAMIC | Body.KINEMATIC;
                var quatNormalize = stepnumber % (this.quatNormalizeSkip + 1) === 0;
                var quatNormalizeFast = this.quatNormalizeFast;
                var half_dt = dt * 0.5;
                var PLANE = Shape.types.PLANE,
                    CONVEX = Shape.types.CONVEXPOLYHEDRON;

                for (i = 0; i !== N; i++) {
                    var b = bodies[i],
                        force = b.force,
                        tau = b.torque;
                    if ((b.type & DYNAMIC_OR_KINEMATIC) && b.sleepState !== Body.SLEEPING) { // Only for dynamic
                        var velo = b.velocity,
                            angularVelo = b.angularVelocity,
                            pos = b.position,
                            quat = b.quaternion,
                            invMass = b.invMass,
                            invInertia = b.invInertiaWorld;

                        velo.x += force.x * invMass * dt;
                        velo.y += force.y * invMass * dt;
                        velo.z += force.z * invMass * dt;

                        if (b.angularVelocity) {
                            invInertia.vmult(tau, invI_tau_dt);
                            invI_tau_dt.mult(dt, invI_tau_dt);
                            invI_tau_dt.vadd(angularVelo, angularVelo);
                        }

                        // Use new velocity  - leap frog
                        pos.x += velo.x * dt;
                        pos.y += velo.y * dt;
                        pos.z += velo.z * dt;

                        if (b.angularVelocity) {
                            w.set(angularVelo.x, angularVelo.y, angularVelo.z, 0);
                            w.mult(quat, wq);
                            quat.x += half_dt * wq.x;
                            quat.y += half_dt * wq.y;
                            quat.z += half_dt * wq.z;
                            quat.w += half_dt * wq.w;
                            if (quatNormalize) {
                                if (quatNormalizeFast) {
                                    quat.normalizeFast();
                                } else {
                                    quat.normalize();
                                }
                            }
                        }

                        if (b.aabb) {
                            b.aabbNeedsUpdate = true;
                        }

                        // Update world inertia
                        if (b.updateInertiaWorld) {
                            b.updateInertiaWorld();
                        }
                    }
                }
                this.clearForces();

                this.broadphase.dirty = true;

                if (doProfiling) {
                    profile.integrate = performance.now() - profilingStart;
                }

                // Update world time
                this.time += dt;
                this.stepnumber += 1;

                this.dispatchEvent(World_step_postStepEvent);

                // Invoke post-step callbacks
                for (i = 0; i !== N; i++) {
                    var bi = bodies[i];
                    var postStep = bi.postStep;
                    if (postStep) {
                        postStep.call(bi);
                    }
                }

                // Sleeping update
                if (this.allowSleep) {
                    for (i = 0; i !== N; i++) {
                        bodies[i].sleepTick(this.time);
                    }
                }
            };

            /**
             * Sets all body forces in the world to zero.
             * @method clearForces
             */
            World.prototype.clearForces = function () {
                var bodies = this.bodies;
                var N = bodies.length;
                for (var i = 0; i !== N; i++) {
                    var b = bodies[i],
                        force = b.force,
                        tau = b.torque;

                    b.force.set(0, 0, 0);
                    b.torque.set(0, 0, 0);
                }
            };

        }, { "../collision/AABB": 3, "../collision/ArrayCollisionMatrix": 4, "../collision/NaiveBroadphase": 7, "../collision/Ray": 9, "../collision/RaycastResult": 10, "../equations/ContactEquation": 19, "../equations/FrictionEquation": 21, "../material/ContactMaterial": 24, "../material/Material": 25, "../math/Quaternion": 28, "../math/Vec3": 30, "../objects/Body": 31, "../shapes/Shape": 43, "../solver/GSSolver": 46, "../utils/EventTarget": 49, "../utils/TupleDictionary": 52, "../utils/Vec3Pool": 54, "./Narrowphase": 55 }]
    }, {}, [2])
        (2)
});
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
module.exports = {
  parse(cmd) {
    let words = cmd.split(" ")
    let args = []
    for (let word of words) {
      if (word) {
        try {
          args.push(JSON.parse(word))
        } catch (error) {
          if (word !== "=")
            args.push(word)
        }
      }
    }
    return args
  },
  stringifyParam(val) {
    return JSON.stringify(val).replaceAll(" ", "\\u0020").replaceAll("\"_", "\"")
  }
}
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvY2Fubm9uV29ya2VyLmpzIiwic3JjL2xpYnMvY2Fubm9uLmpzIiwic3JjL2xpYnMvY21kQ29kZWMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6M2FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKiBnbG9iYWwgQUZSQU1FLCBUSFJFRSwgQ0FOTk9OICovXG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIilcbiAgcmV0dXJuXG5cbmNvbnN0IGNtZCA9IHJlcXVpcmUoXCIuL2xpYnMvY21kQ29kZWNcIilcblxuZ2xvYmFsLkNBTk5PTiA9IHJlcXVpcmUoXCIuL2xpYnMvY2Fubm9uXCIpXG5nbG9iYWwud29ybGQgPSBuZXcgQ0FOTk9OLldvcmxkKClcbmdsb2JhbC5ib2RpZXMgPSBbXVxuZ2xvYmFsLm1vdmluZ0JvZGllcyA9IFtdXG5nbG9iYWwuam9pbnRzID0gW11cblxubGV0IHZlYyA9IG5ldyBDQU5OT04uVmVjMygpXG5sZXQgcXVhdCA9IG5ldyBDQU5OT04uUXVhdGVybmlvbigpXG5sZXQgY3lsb2ZmID0gbmV3IENBTk5PTi5RdWF0ZXJuaW9uKClcbmxldCBsYXN0U3RlcCA9IDBcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgY3lsb2ZmLnNldEZyb21BeGlzQW5nbGUobmV3IENBTk5PTi5WZWMzKDEsIDAsIDApLCBNYXRoLlBJIC8gMilcbiAgYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25NZXNzYWdlKVxufVxuXG5mdW5jdGlvbiBvbk1lc3NhZ2UoZSkge1xuICBpZiAodHlwZW9mIGUuZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgIGxldCBjb21tYW5kID0gY21kLnBhcnNlKGUuZGF0YSlcbiAgICBzd2l0Y2ggKGNvbW1hbmQuc2hpZnQoKSkge1xuICAgICAgY2FzZSBcImxvZ1wiOlxuICAgICAgICBjb25zb2xlLmxvZyguLi5jb21tYW5kKVxuICAgICAgICBicmVha1xuICAgICAgY2FzZSBcIndvcmxkXCI6XG4gICAgICAgIHdvcmxkQ29tbWFuZChjb21tYW5kKVxuICAgICAgICBicmVha1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChlLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkpIHtcbiAgICBsZXQgYnVmZmVyID0gZS5kYXRhXG4gICAgbGV0IG5vdyA9IERhdGUubm93KClcbiAgICBmb3IgKGxldCBtaWQgPSAwOyBtaWQgPCBtb3ZpbmdCb2RpZXMubGVuZ3RoOyBtaWQrKykge1xuICAgICAgbGV0IGJvZHkgPSBtb3ZpbmdCb2RpZXNbbWlkXVxuICAgICAgbGV0IHAgPSBtaWQgKiA4XG4gICAgICBpZiAoIWJvZHkpIGNvbnRpbnVlXG4gICAgICBpZiAoYm9keS50eXBlID09PSBDQU5OT04uQm9keS5LSU5FTUFUSUMpIHtcbiAgICAgICAgdmVjLnNldChidWZmZXJbcCsrXSwgYnVmZmVyW3ArK10sIGJ1ZmZlcltwKytdKVxuICAgICAgICBib2R5LnBvc2l0aW9uLmNvcHkodmVjKVxuICAgICAgICBidWZmZXJbcCsrXSA9IGJvZHkuc2xlZXBTdGF0ZSA9PT0gQ0FOTk9OLkJvZHkuU0xFRVBJTkdcbiAgICAgICAgcXVhdC5zZXQoYnVmZmVyW3ArK10sIGJ1ZmZlcltwKytdLCBidWZmZXJbcCsrXSwgYnVmZmVyW3ArK10pXG4gICAgICAgIGJvZHkucXVhdGVybmlvbi5jb3B5KHF1YXQpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub3cgLSBsYXN0U3RlcCA8IDEyOCkge1xuICAgICAgd29ybGQuc3RlcCgobm93IC0gbGFzdFN0ZXApIC8gMTAwMClcbiAgICB9XG4gICAgZm9yIChsZXQgbWlkID0gMDsgbWlkIDwgbW92aW5nQm9kaWVzLmxlbmd0aDsgbWlkKyspIHtcbiAgICAgIGxldCBib2R5ID0gbW92aW5nQm9kaWVzW21pZF1cbiAgICAgIGxldCBwID0gbWlkICogOFxuICAgICAgaWYgKCFib2R5KSBjb250aW51ZVxuICAgICAgaWYgKGJvZHkudHlwZSAhPT0gQ0FOTk9OLkJvZHkuS0lORU1BVElDKSB7XG4gICAgICAgIGJ1ZmZlcltwKytdID0gYm9keS5wb3NpdGlvbi54XG4gICAgICAgIGJ1ZmZlcltwKytdID0gYm9keS5wb3NpdGlvbi55XG4gICAgICAgIGJ1ZmZlcltwKytdID0gYm9keS5wb3NpdGlvbi56XG4gICAgICAgIGJ1ZmZlcltwKytdID0gYm9keS5zbGVlcFN0YXRlID09PSBDQU5OT04uQm9keS5TTEVFUElOR1xuICAgICAgICBidWZmZXJbcCsrXSA9IGJvZHkucXVhdGVybmlvbi54XG4gICAgICAgIGJ1ZmZlcltwKytdID0gYm9keS5xdWF0ZXJuaW9uLnlcbiAgICAgICAgYnVmZmVyW3ArK10gPSBib2R5LnF1YXRlcm5pb24uelxuICAgICAgICBidWZmZXJbcCsrXSA9IGJvZHkucXVhdGVybmlvbi53XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3RNZXNzYWdlKGJ1ZmZlciwgW2J1ZmZlci5idWZmZXJdKVxuICAgIGxhc3RTdGVwID0gbm93XG4gIH1cbn1cblxuZnVuY3Rpb24gd29ybGRDb21tYW5kKHBhcmFtcykge1xuICBpZiAodHlwZW9mIHBhcmFtc1swXSA9PT0gXCJudW1iZXJcIikge1xuICAgIHBhcmFtcy5zaGlmdCgpXG4gIH1cbiAgc3dpdGNoIChwYXJhbXMuc2hpZnQoKSkge1xuICAgIGNhc2UgXCJib2R5XCI6XG4gICAgICBib2R5Q29tbWFuZChwYXJhbXMpXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJqb2ludFwiOlxuICAgICAgam9pbnRDb21tYW5kKHBhcmFtcylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcImdyYXZpdHlcIjpcbiAgICAgIHdvcmxkLmdyYXZpdHkuY29weShwYXJhbXNbMF0pXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJldmFsXCI6XG4gICAgICBldmFsKHBhcmFtc1swXSlcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxuZnVuY3Rpb24gYm9keUNvbW1hbmQocGFyYW1zKSB7XG4gIGxldCBpZCA9IHBhcmFtcy5zaGlmdCgpXG4gIGxldCBib2R5ID0gYm9kaWVzW2lkXVxuICBpZiAoIWJvZHkgJiYgcGFyYW1zWzBdICE9PSBcImNyZWF0ZVwiKSByZXR1cm5cbiAgc3dpdGNoIChwYXJhbXMuc2hpZnQoKSkge1xuICAgIGNhc2UgXCJzaGFwZVwiOlxuICAgICAgc2hhcGVDb21tYW5kKGJvZHksIHBhcmFtcylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcImNyZWF0ZVwiOlxuICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgd29ybGQucmVtb3ZlQm9keShib2R5KVxuICAgICAgICBpZiAoYm9keS5fbWlkXyAhPT0gbnVsbClcbiAgICAgICAgICBtb3ZpbmdCb2RpZXNbYm9keS5fbWlkX10gPSBudWxsXG4gICAgICB9XG4gICAgICBib2R5ID0gbmV3IENBTk5PTi5Cb2R5KHtcbiAgICAgICAgdHlwZTogcGFyYW1zWzBdLnR5cGUgPT09IFwiZHluYW1pY1wiID8gQ0FOTk9OLkJvZHkuRFlOQU1JQyA6IHBhcmFtc1swXS50eXBlID09PSBcImtpbmVtYXRpY1wiID8gQ0FOTk9OLkJvZHkuS0lORU1BVElDIDogQ0FOTk9OLkJvZHkuU1RBVElDLFxuICAgICAgICBzbGVlcFNwZWVkTGltaXQ6IDEsXG4gICAgICAgIHBvc2l0aW9uOiBuZXcgQ0FOTk9OLlZlYzMoKS5jb3B5KHBhcmFtc1swXS5wb3NpdGlvbiksXG4gICAgICAgIHF1YXRlcm5pb246IG5ldyBDQU5OT04uUXVhdGVybmlvbigpLmNvcHkocGFyYW1zWzBdLnF1YXRlcm5pb24pLFxuICAgICAgfSlcbiAgICAgIGJvZHkuX2lkXyA9IGlkXG4gICAgICBib2R5Ll9taWRfID0gcGFyYW1zWzBdLm1pZFxuICAgICAgaWYgKGJvZHkuX21pZF8gIT09IG51bGwpXG4gICAgICAgIG1vdmluZ0JvZGllc1tib2R5Ll9taWRfXSA9IGJvZHlcbiAgICAgIGJvZHkuX3NoYXBlc18gPSBbXVxuICAgICAgd29ybGQuYWRkQm9keShib2RpZXNbaWRdID0gYm9keSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcInJlbW92ZVwiOlxuICAgICAgd29ybGQucmVtb3ZlQm9keShib2R5KVxuICAgICAgYm9kaWVzW2lkXSA9IG51bGxcbiAgICAgIGlmIChib2R5Ll9taWRfICE9PSBudWxsKVxuICAgICAgICBtb3ZpbmdCb2RpZXNbYm9keS5fbWlkX10gPSBudWxsXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJwb3NpdGlvblwiOlxuICAgICAgYm9keS5wb3NpdGlvbi5jb3B5KHBhcmFtc1swXSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcInF1YXRlcm5pb25cIjpcbiAgICAgIGJvZHkucXVhdGVybmlvbi5jb3B5KHBhcmFtc1swXSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcInR5cGVcIjpcbiAgICAgIGJvZHkudHlwZSA9IHBhcmFtc1swXSA9PT0gXCJkeW5hbWljXCIgPyBDQU5OT04uQm9keS5EWU5BTUlDIDogcGFyYW1zWzBdID09PSBcImtpbmVtYXRpY1wiID8gQ0FOTk9OLkJvZHkuS0lORU1BVElDIDogQ0FOTk9OLkJvZHkuU1RBVElDXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJtYXNzXCI6XG4gICAgICBib2R5Lm1hc3MgPSBib2R5LnR5cGUgPT09IENBTk5PTi5Cb2R5LlNUQVRJQyA/IDAgOiBwYXJhbXNbMF1cbiAgICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiYmVsb25nc1RvXCI6XG4gICAgICBib2R5LmNvbGxpc2lvbkZpbHRlckdyb3VwID0gcGFyYW1zWzBdXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJjb2xsaWRlc1dpdGhcIjpcbiAgICAgIGJvZHkuY29sbGlzaW9uRmlsdGVyTWFzayA9IHBhcmFtc1swXVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiZW1pdHNXaXRoXCI6XG4gICAgICBpZiAocGFyYW1zWzBdICYmICFib2R5Ll9lbWl0c1dpdGhfKSB7XG4gICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImNvbGxpZGVcIiwgb25Db2xsaWRlKVxuICAgICAgfVxuICAgICAgaWYgKGJvZHkuX2VtaXRzV2l0aF8gJiYgIXBhcmFtc1swXSkge1xuICAgICAgICBib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb2xsaWRlXCIsIG9uQ29sbGlkZSlcbiAgICAgIH1cbiAgICAgIGJvZHkuX2VtaXRzV2l0aF8gPSBwYXJhbXNbMF1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcInNsZWVwaW5nXCI6XG4gICAgICBpZiAocGFyYW1zWzBdKSBib2R5LnNsZWVwKClcbiAgICAgIGVsc2UgYm9keS53YWtlVXAoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiZXZhbFwiOlxuICAgICAgZXZhbChcImNvbnN0IGJvZHkgPSBib2RpZXNbXCIgKyBpZCArIFwiXTtcIiArIHBhcmFtc1swXSlcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxuZnVuY3Rpb24gam9pbnRDb21tYW5kKHBhcmFtcykge1xuICBsZXQgaWQgPSBwYXJhbXMuc2hpZnQoKVxuICBsZXQgam9pbnQgPSBqb2ludHNbaWRdXG4gIGlmICgham9pbnQgJiYgcGFyYW1zWzBdICE9PSBcImNyZWF0ZVwiKSByZXR1cm5cbiAgc3dpdGNoIChwYXJhbXMuc2hpZnQoKSkge1xuICAgIGNhc2UgXCJjcmVhdGVcIjpcbiAgICAgIGlmIChqb2ludCkge1xuICAgICAgICB3b3JsZC5yZW1vdmVDb25zdHJhaW50KGpvaW50KVxuICAgICAgfVxuICAgICAgc3dpdGNoIChwYXJhbXNbMF0udHlwZSkge1xuICAgICAgICBjYXNlIFwiaGluZ2VcIjpcbiAgICAgICAgICBqb2ludCA9IG5ldyBDQU5OT04uSGluZ2VDb25zdHJhaW50KFxuICAgICAgICAgICAgYm9kaWVzW3BhcmFtc1swXS5ib2R5MV0sXG4gICAgICAgICAgICBib2RpZXNbcGFyYW1zWzBdLmJvZHkyXSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcGl2b3RBOiBuZXcgQ0FOTk9OLlZlYzMoKS5jb3B5KHBhcmFtc1swXS5waXZvdDEpLFxuICAgICAgICAgICAgICBwaXZvdEI6IG5ldyBDQU5OT04uVmVjMygpLmNvcHkocGFyYW1zWzBdLnBpdm90MiksXG4gICAgICAgICAgICAgIGF4aXNBOiBuZXcgQ0FOTk9OLlZlYzMoKS5jb3B5KHBhcmFtc1swXS5heGlzMSksXG4gICAgICAgICAgICAgIGF4aXNCOiBuZXcgQ0FOTk9OLlZlYzMoKS5jb3B5KHBhcmFtc1swXS5heGlzMilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcImRpc3RhbmNlXCI6XG4gICAgICAgICAgam9pbnQgPSBuZXcgQ0FOTk9OLkRpc3RhbmNlQ29uc3RyYWludChcbiAgICAgICAgICAgIGJvZGllc1twYXJhbXNbMF0uYm9keTFdLFxuICAgICAgICAgICAgYm9kaWVzW3BhcmFtc1swXS5ib2R5Ml1cbiAgICAgICAgICApXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSBcImxvY2tcIjpcbiAgICAgICAgICBqb2ludCA9IG5ldyBDQU5OT04uTG9ja0NvbnN0cmFpbnQoXG4gICAgICAgICAgICBib2RpZXNbcGFyYW1zWzBdLmJvZHkxXSxcbiAgICAgICAgICAgIGJvZGllc1twYXJhbXNbMF0uYm9keTJdXG4gICAgICAgICAgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgam9pbnQgPSBuZXcgQ0FOTk9OLlBvaW50VG9Qb2ludENvbnN0cmFpbnQoXG4gICAgICAgICAgICBib2RpZXNbcGFyYW1zWzBdLmJvZHkxXSxcbiAgICAgICAgICAgIG5ldyBDQU5OT04uVmVjMygpLmNvcHkocGFyYW1zWzBdLnBpdm90MSksXG4gICAgICAgICAgICBib2RpZXNbcGFyYW1zWzBdLmJvZHkyXSxcbiAgICAgICAgICAgIG5ldyBDQU5OT04uVmVjMygpLmNvcHkocGFyYW1zWzBdLnBpdm90MilcbiAgICAgICAgICApXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGpvaW50LmNvbGxpZGVDb25uZWN0ZWQgPSBwYXJhbXNbMF0uY29sbGlzaW9uXG4gICAgICBqb2ludC5faWRfID0gaWRcbiAgICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoam9pbnRzW2lkXSA9IGpvaW50KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICB3b3JsZC5yZW1vdmVDb25zdHJhaW50KGpvaW50KVxuICAgICAgam9pbnRzW2lkXSA9IG51bGxcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcImV2YWxcIjpcbiAgICAgIGV2YWwoXCJjb25zdCBqb2ludCA9IGpvaW50c1tcIiArIGlkICsgXCJdO1wiICsgcGFyYW1zWzBdKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGFwZUNvbW1hbmQoYm9keSwgcGFyYW1zKSB7XG4gIGlmICghYm9keSkgcmV0dXJuXG4gIGxldCBpZCA9IHBhcmFtcy5zaGlmdCgpXG4gIGxldCBzaGFwZSA9IGJvZHkuX3NoYXBlc19baWRdXG4gIGlmICghc2hhcGUgJiYgcGFyYW1zWzBdICE9PSBcImNyZWF0ZVwiKSByZXR1cm5cbiAgc3dpdGNoIChwYXJhbXMuc2hpZnQoKSkge1xuICAgIGNhc2UgXCJjcmVhdGVcIjpcbiAgICAgIGlmIChzaGFwZSlcbiAgICAgICAgYm9keS5yZW1vdmVTaGFwZShzaGFwZSlcbiAgICAgIGxldCBxdWF0ID0gKG5ldyBDQU5OT04uUXVhdGVybmlvbigpKS5jb3B5KHBhcmFtc1swXS5xdWF0ZXJuaW9uKVxuICAgICAgc3dpdGNoIChwYXJhbXNbMF0udHlwZSkge1xuICAgICAgICBjYXNlIFwic3BoZXJlXCI6IHNoYXBlID0gbmV3IENBTk5PTi5TcGhlcmUocGFyYW1zWzBdLnNpemUueCAvIDIpOyBicmVha1xuICAgICAgICBjYXNlIFwiY3lsaW5kZXJcIjogc2hhcGUgPSBuZXcgQ0FOTk9OLkN5bGluZGVyKHBhcmFtc1swXS5zaXplLnggLyAyLCBwYXJhbXNbMF0uc2l6ZS54IC8gMiwgcGFyYW1zWzBdLnNpemUueSwgMTYpOyBxdWF0Lm11bHQoY3lsb2ZmLCBxdWF0KTsgYnJlYWtcbiAgICAgICAgZGVmYXVsdDogc2hhcGUgPSBuZXcgQ0FOTk9OLkJveChuZXcgQ0FOTk9OLlZlYzMoKS5jb3B5KHBhcmFtc1swXS5zaXplKS5zY2FsZSgwLjUpKVxuICAgICAgfVxuICAgICAgc2hhcGUuX2lkXyA9IGlkXG4gICAgICBib2R5LmFkZFNoYXBlKGJvZHkuX3NoYXBlc19baWRdID0gc2hhcGUsIChuZXcgQ0FOTk9OLlZlYzMoKSkuY29weShwYXJhbXNbMF0ucG9zaXRpb24pLCBxdWF0KVxuICAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgIC8vIGJvZHkucmVtb3ZlU2hhcGUoc2hhcGUpXG4gICAgICBsZXQgaSA9IGJvZHkuc2hhcGVzLmluZGV4T2Yoc2hhcGUpXG4gICAgICBpZiAoaSA+PSAwKSBib2R5LnNoYXBlcy5zcGxpY2UoaSwgMSlcbiAgICAgIGJvZHkuX3NoYXBlc19baWRdID0gbnVsbFxuICAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJldmFsXCI6XG4gICAgICBldmFsKFwiY29uc3QgYm9keSA9IGJvZGllc1tcIiArIGJvZHkuX2lkXyArIFwiXSxzaGFwZSA9IGJvZHkuX3NoYXBlc19bXCIgKyBpZCArIFwiXTtcIiArIHBhcmFtc1swXSlcbiAgICAgIGJyZWFrXG4gIH1cbn1cblxuXG5cblxuZnVuY3Rpb24gb25Db2xsaWRlKGUpIHtcbiAgbGV0IGIxID0gZS5jb250YWN0LmJpXG4gIGxldCBiMiA9IGUuY29udGFjdC5ialxuICBpZiAodGhpcyA9PT0gYjEgJiYgKGIxLl9lbWl0c1dpdGhfICYgYjIuY29sbGlzaW9uRmlsdGVyR3JvdXApKSB7XG4gICAgcG9zdE1lc3NhZ2UoXCJ3b3JsZCBib2R5IFwiICsgYjEuX2lkXyArIFwiIGVtaXRzIFwiICsgY21kLnN0cmluZ2lmeVBhcmFtKHtcbiAgICAgIGV2ZW50OiBcImNvbGxpc2lvblwiLFxuICAgICAgYm9keTE6IGIxLl9pZF8sXG4gICAgICBib2R5MjogYjIuX2lkXyxcbiAgICAgIHNoYXBlMTogZS5jb250YWN0LnNpLl9pZF8sXG4gICAgICBzaGFwZTI6IGUuY29udGFjdC5zai5faWRfXG4gICAgfSkpXG4gIH1cbiAgaWYgKHRoaXMgPT09IGIyICYmIChiMi5fZW1pdHNXaXRoXyAmIGIxLmNvbGxpc2lvbkZpbHRlckdyb3VwKSkge1xuICAgIHBvc3RNZXNzYWdlKFwid29ybGQgYm9keSBcIiArIGIyLl9pZF8gKyBcIiBlbWl0cyBcIiArIGNtZC5zdHJpbmdpZnlQYXJhbSh7XG4gICAgICBldmVudDogXCJjb2xsaXNpb25cIixcbiAgICAgIGJvZHkxOiBiMi5faWRfLFxuICAgICAgYm9keTI6IGIxLl9pZF8sXG4gICAgICBzaGFwZTE6IGUuY29udGFjdC5zai5faWRfLFxuICAgICAgc2hhcGUyOiBlLmNvbnRhY3Quc2kuX2lkX1xuICAgIH0pKVxuICB9XG59XG5pbml0KCkiLCIvKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IGNhbm5vbi5qcyBBdXRob3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAqIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXG4gKiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAqIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LFxuICogbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzXG4gKiBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkVcbiAqIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT05cbiAqIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuICogV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cblxuIWZ1bmN0aW9uIChlKSB7IGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBleHBvcnRzICYmIFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIG1vZHVsZSkgbW9kdWxlLmV4cG9ydHMgPSBlKCk7IGVsc2UgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGVmaW5lICYmIGZhbHNlKSBkZWZpbmUoW10sIGUpOyBlbHNlIHsgdmFyIGY7IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyA/IGYgPSB3aW5kb3cgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBnbG9iYWwgPyBmID0gZ2xvYmFsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygc2VsZiAmJiAoZiA9IHNlbGYpLCBmLkNBTk5PTiA9IGUoKSB9IH0oZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZWZpbmUsIG1vZHVsZSwgZXhwb3J0czsgcmV0dXJuIChmdW5jdGlvbiBlKHQsIG4sIHIpIHsgZnVuY3Rpb24gcyhvLCB1KSB7IGlmICghbltvXSkgeyBpZiAoIXRbb10pIHsgdmFyIGEgPSB0eXBlb2YgcmVxdWlyZSA9PSBcImZ1bmN0aW9uXCIgJiYgcmVxdWlyZTsgaWYgKCF1ICYmIGEpIHJldHVybiBhKG8sICEwKTsgaWYgKGkpIHJldHVybiBpKG8sICEwKTsgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIG8gKyBcIidcIikgfSB2YXIgZiA9IG5bb10gPSB7IGV4cG9ydHM6IHt9IH07IHRbb11bMF0uY2FsbChmLmV4cG9ydHMsIGZ1bmN0aW9uIChlKSB7IHZhciBuID0gdFtvXVsxXVtlXTsgcmV0dXJuIHMobiA/IG4gOiBlKSB9LCBmLCBmLmV4cG9ydHMsIGUsIHQsIG4sIHIpIH0gcmV0dXJuIG5bb10uZXhwb3J0cyB9IHZhciBpID0gdHlwZW9mIHJlcXVpcmUgPT0gXCJmdW5jdGlvblwiICYmIHJlcXVpcmU7IGZvciAodmFyIG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKylzKHJbb10pOyByZXR1cm4gcyB9KSh7XG4gICAgICAgIDE6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAgICAgICAgICAgICBcIm5hbWVcIjogXCJjYW5ub25cIixcbiAgICAgICAgICAgICAgICBcInZlcnNpb25cIjogXCIwLjYuMlwiLFxuICAgICAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogXCJBIGxpZ2h0d2VpZ2h0IDNEIHBoeXNpY3MgZW5naW5lIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC5cIixcbiAgICAgICAgICAgICAgICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qc1wiLFxuICAgICAgICAgICAgICAgIFwiYXV0aG9yXCI6IFwiU3RlZmFuIEhlZG1hbiA8c2NodGVwcGVAZ21haWwuY29tPiAoaHR0cDovL3N0ZWZmZS5zZSlcIixcbiAgICAgICAgICAgICAgICBcImtleXdvcmRzXCI6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJjYW5ub24uanNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJjYW5ub25cIixcbiAgICAgICAgICAgICAgICAgICAgXCJwaHlzaWNzXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZW5naW5lXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiM2RcIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgXCJtYWluXCI6IFwiLi9idWlsZC9jYW5ub24uanNcIixcbiAgICAgICAgICAgICAgICBcImVuZ2luZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBcIm5vZGVcIjogXCIqXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgICAgICAgICAgICAgICAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZS9jYW5ub24uanMuZ2l0XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiYnVnc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qcy9pc3N1ZXNcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJsaWNlbnNlc1wiOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwidHlwZVwiOiBcIk1JVFwiXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJqc2hpbnRcIjogXCJsYXRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ1Z2xpZnktanNcIjogXCJsYXRlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgXCJub2RldW5pdFwiOiBcIl4wLjkuMFwiLFxuICAgICAgICAgICAgICAgICAgICBcImdydW50XCI6IFwifjAuNC4wXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCJ+MC4xLjFcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncnVudC1jb250cmliLW5vZGV1bml0XCI6IFwiXjAuNC4xXCIsXG4gICAgICAgICAgICAgICAgICAgIFwiZ3J1bnQtY29udHJpYi1jb25jYXRcIjogXCJ+MC4xLjNcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4wLjUuMVwiLFxuICAgICAgICAgICAgICAgICAgICBcImdydW50LWJyb3dzZXJpZnlcIjogXCJeMi4xLjRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJncnVudC1jb250cmliLXl1aWRvY1wiOiBcIl4wLjUuMlwiLFxuICAgICAgICAgICAgICAgICAgICBcImJyb3dzZXJpZnlcIjogXCIqXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiZGVwZW5kZW5jaWVzXCI6IHt9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSwge31dLCAyOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgLy8gRXhwb3J0IGNsYXNzZXNcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246IF9kZXJlcV8oJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb24sXG5cbiAgICAgICAgICAgICAgICBBQUJCOiBfZGVyZXFfKCcuL2NvbGxpc2lvbi9BQUJCJyksXG4gICAgICAgICAgICAgICAgQXJyYXlDb2xsaXNpb25NYXRyaXg6IF9kZXJlcV8oJy4vY29sbGlzaW9uL0FycmF5Q29sbGlzaW9uTWF0cml4JyksXG4gICAgICAgICAgICAgICAgQm9keTogX2RlcmVxXygnLi9vYmplY3RzL0JvZHknKSxcbiAgICAgICAgICAgICAgICBCb3g6IF9kZXJlcV8oJy4vc2hhcGVzL0JveCcpLFxuICAgICAgICAgICAgICAgIEJyb2FkcGhhc2U6IF9kZXJlcV8oJy4vY29sbGlzaW9uL0Jyb2FkcGhhc2UnKSxcbiAgICAgICAgICAgICAgICBDb25zdHJhaW50OiBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnQnKSxcbiAgICAgICAgICAgICAgICBDb250YWN0RXF1YXRpb246IF9kZXJlcV8oJy4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpLFxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlOiBfZGVyZXFfKCcuL3dvcmxkL05hcnJvd3BoYXNlJyksXG4gICAgICAgICAgICAgICAgQ29uZVR3aXN0Q29uc3RyYWludDogX2RlcmVxXygnLi9jb25zdHJhaW50cy9Db25lVHdpc3RDb25zdHJhaW50JyksXG4gICAgICAgICAgICAgICAgQ29udGFjdE1hdGVyaWFsOiBfZGVyZXFfKCcuL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbCcpLFxuICAgICAgICAgICAgICAgIENvbnZleFBvbHloZWRyb246IF9kZXJlcV8oJy4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKSxcbiAgICAgICAgICAgICAgICBDeWxpbmRlcjogX2RlcmVxXygnLi9zaGFwZXMvQ3lsaW5kZXInKSxcbiAgICAgICAgICAgICAgICBEaXN0YW5jZUNvbnN0cmFpbnQ6IF9kZXJlcV8oJy4vY29uc3RyYWludHMvRGlzdGFuY2VDb25zdHJhaW50JyksXG4gICAgICAgICAgICAgICAgRXF1YXRpb246IF9kZXJlcV8oJy4vZXF1YXRpb25zL0VxdWF0aW9uJyksXG4gICAgICAgICAgICAgICAgRXZlbnRUYXJnZXQ6IF9kZXJlcV8oJy4vdXRpbHMvRXZlbnRUYXJnZXQnKSxcbiAgICAgICAgICAgICAgICBGcmljdGlvbkVxdWF0aW9uOiBfZGVyZXFfKCcuL2VxdWF0aW9ucy9GcmljdGlvbkVxdWF0aW9uJyksXG4gICAgICAgICAgICAgICAgR1NTb2x2ZXI6IF9kZXJlcV8oJy4vc29sdmVyL0dTU29sdmVyJyksXG4gICAgICAgICAgICAgICAgR3JpZEJyb2FkcGhhc2U6IF9kZXJlcV8oJy4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlJyksXG4gICAgICAgICAgICAgICAgSGVpZ2h0ZmllbGQ6IF9kZXJlcV8oJy4vc2hhcGVzL0hlaWdodGZpZWxkJyksXG4gICAgICAgICAgICAgICAgSGluZ2VDb25zdHJhaW50OiBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0hpbmdlQ29uc3RyYWludCcpLFxuICAgICAgICAgICAgICAgIExvY2tDb25zdHJhaW50OiBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JyksXG4gICAgICAgICAgICAgICAgTWF0MzogX2RlcmVxXygnLi9tYXRoL01hdDMnKSxcbiAgICAgICAgICAgICAgICBNYXRlcmlhbDogX2RlcmVxXygnLi9tYXRlcmlhbC9NYXRlcmlhbCcpLFxuICAgICAgICAgICAgICAgIE5haXZlQnJvYWRwaGFzZTogX2RlcmVxXygnLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyksXG4gICAgICAgICAgICAgICAgT2JqZWN0Q29sbGlzaW9uTWF0cml4OiBfZGVyZXFfKCcuL2NvbGxpc2lvbi9PYmplY3RDb2xsaXNpb25NYXRyaXgnKSxcbiAgICAgICAgICAgICAgICBQb29sOiBfZGVyZXFfKCcuL3V0aWxzL1Bvb2wnKSxcbiAgICAgICAgICAgICAgICBQYXJ0aWNsZTogX2RlcmVxXygnLi9zaGFwZXMvUGFydGljbGUnKSxcbiAgICAgICAgICAgICAgICBQbGFuZTogX2RlcmVxXygnLi9zaGFwZXMvUGxhbmUnKSxcbiAgICAgICAgICAgICAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50OiBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKSxcbiAgICAgICAgICAgICAgICBRdWF0ZXJuaW9uOiBfZGVyZXFfKCcuL21hdGgvUXVhdGVybmlvbicpLFxuICAgICAgICAgICAgICAgIFJheTogX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5JyksXG4gICAgICAgICAgICAgICAgUmF5Y2FzdFZlaGljbGU6IF9kZXJlcV8oJy4vb2JqZWN0cy9SYXljYXN0VmVoaWNsZScpLFxuICAgICAgICAgICAgICAgIFJheWNhc3RSZXN1bHQ6IF9kZXJlcV8oJy4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKSxcbiAgICAgICAgICAgICAgICBSaWdpZFZlaGljbGU6IF9kZXJlcV8oJy4vb2JqZWN0cy9SaWdpZFZlaGljbGUnKSxcbiAgICAgICAgICAgICAgICBSb3RhdGlvbmFsRXF1YXRpb246IF9kZXJlcV8oJy4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvbicpLFxuICAgICAgICAgICAgICAgIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uOiBfZGVyZXFfKCcuL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpLFxuICAgICAgICAgICAgICAgIFNBUEJyb2FkcGhhc2U6IF9kZXJlcV8oJy4vY29sbGlzaW9uL1NBUEJyb2FkcGhhc2UnKSxcbiAgICAgICAgICAgICAgICBTUEhTeXN0ZW06IF9kZXJlcV8oJy4vb2JqZWN0cy9TUEhTeXN0ZW0nKSxcbiAgICAgICAgICAgICAgICBTaGFwZTogX2RlcmVxXygnLi9zaGFwZXMvU2hhcGUnKSxcbiAgICAgICAgICAgICAgICBTb2x2ZXI6IF9kZXJlcV8oJy4vc29sdmVyL1NvbHZlcicpLFxuICAgICAgICAgICAgICAgIFNwaGVyZTogX2RlcmVxXygnLi9zaGFwZXMvU3BoZXJlJyksXG4gICAgICAgICAgICAgICAgU3BsaXRTb2x2ZXI6IF9kZXJlcV8oJy4vc29sdmVyL1NwbGl0U29sdmVyJyksXG4gICAgICAgICAgICAgICAgU3ByaW5nOiBfZGVyZXFfKCcuL29iamVjdHMvU3ByaW5nJyksXG4gICAgICAgICAgICAgICAgVHJpbWVzaDogX2RlcmVxXygnLi9zaGFwZXMvVHJpbWVzaCcpLFxuICAgICAgICAgICAgICAgIFZlYzM6IF9kZXJlcV8oJy4vbWF0aC9WZWMzJyksXG4gICAgICAgICAgICAgICAgVmVjM1Bvb2w6IF9kZXJlcV8oJy4vdXRpbHMvVmVjM1Bvb2wnKSxcbiAgICAgICAgICAgICAgICBXb3JsZDogX2RlcmVxXygnLi93b3JsZC9Xb3JsZCcpLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vcGFja2FnZS5qc29uXCI6IDEsIFwiLi9jb2xsaXNpb24vQUFCQlwiOiAzLCBcIi4vY29sbGlzaW9uL0FycmF5Q29sbGlzaW9uTWF0cml4XCI6IDQsIFwiLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOiA1LCBcIi4vY29sbGlzaW9uL0dyaWRCcm9hZHBoYXNlXCI6IDYsIFwiLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlXCI6IDcsIFwiLi9jb2xsaXNpb24vT2JqZWN0Q29sbGlzaW9uTWF0cml4XCI6IDgsIFwiLi9jb2xsaXNpb24vUmF5XCI6IDksIFwiLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOiAxMCwgXCIuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlXCI6IDExLCBcIi4vY29uc3RyYWludHMvQ29uZVR3aXN0Q29uc3RyYWludFwiOiAxMiwgXCIuL2NvbnN0cmFpbnRzL0NvbnN0cmFpbnRcIjogMTMsIFwiLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnRcIjogMTQsIFwiLi9jb25zdHJhaW50cy9IaW5nZUNvbnN0cmFpbnRcIjogMTUsIFwiLi9jb25zdHJhaW50cy9Mb2NrQ29uc3RyYWludFwiOiAxNiwgXCIuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjogMTcsIFwiLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6IDE5LCBcIi4vZXF1YXRpb25zL0VxdWF0aW9uXCI6IDIwLCBcIi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjogMjEsIFwiLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uXCI6IDIyLCBcIi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uXCI6IDIzLCBcIi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6IDI0LCBcIi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjogMjUsIFwiLi9tYXRoL01hdDNcIjogMjcsIFwiLi9tYXRoL1F1YXRlcm5pb25cIjogMjgsIFwiLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi9vYmplY3RzL0JvZHlcIjogMzEsIFwiLi9vYmplY3RzL1JheWNhc3RWZWhpY2xlXCI6IDMyLCBcIi4vb2JqZWN0cy9SaWdpZFZlaGljbGVcIjogMzMsIFwiLi9vYmplY3RzL1NQSFN5c3RlbVwiOiAzNCwgXCIuL29iamVjdHMvU3ByaW5nXCI6IDM1LCBcIi4vc2hhcGVzL0JveFwiOiAzNywgXCIuL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uXCI6IDM4LCBcIi4vc2hhcGVzL0N5bGluZGVyXCI6IDM5LCBcIi4vc2hhcGVzL0hlaWdodGZpZWxkXCI6IDQwLCBcIi4vc2hhcGVzL1BhcnRpY2xlXCI6IDQxLCBcIi4vc2hhcGVzL1BsYW5lXCI6IDQyLCBcIi4vc2hhcGVzL1NoYXBlXCI6IDQzLCBcIi4vc2hhcGVzL1NwaGVyZVwiOiA0NCwgXCIuL3NoYXBlcy9UcmltZXNoXCI6IDQ1LCBcIi4vc29sdmVyL0dTU29sdmVyXCI6IDQ2LCBcIi4vc29sdmVyL1NvbHZlclwiOiA0NywgXCIuL3NvbHZlci9TcGxpdFNvbHZlclwiOiA0OCwgXCIuL3V0aWxzL0V2ZW50VGFyZ2V0XCI6IDQ5LCBcIi4vdXRpbHMvUG9vbFwiOiA1MSwgXCIuL3V0aWxzL1ZlYzNQb29sXCI6IDU0LCBcIi4vd29ybGQvTmFycm93cGhhc2VcIjogNTUsIFwiLi93b3JsZC9Xb3JsZFwiOiA1NiB9XSwgMzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEFBQkI7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy5cbiAgICAgICAgICAgICAqIEBjbGFzcyBBQUJCXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gICBbb3B0aW9ucy51cHBlckJvdW5kXVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSAgIFtvcHRpb25zLmxvd2VyQm91bmRdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIEFBQkIob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGxvd2VyQm91bmRcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmxvd2VyQm91bmQgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmxvd2VyQm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb3dlckJvdW5kLmNvcHkob3B0aW9ucy5sb3dlckJvdW5kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgdXBwZXJCb3VuZFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQuY29weShvcHRpb25zLnVwcGVyQm91bmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRtcCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBBQUJCIGJvdW5kcyBmcm9tIGEgc2V0IG9mIHBvaW50cy5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0RnJvbVBvaW50c1xuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMncy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNraW5TaXplXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtBQUJCfSBUaGUgc2VsZiBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQUFCQi5wcm90b3R5cGUuc2V0RnJvbVBvaW50cyA9IGZ1bmN0aW9uIChwb2ludHMsIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBza2luU2l6ZSkge1xuICAgICAgICAgICAgICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICAgICAgICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kLFxuICAgICAgICAgICAgICAgICAgICBxID0gcXVhdGVybmlvbjtcblxuICAgICAgICAgICAgICAgIC8vIFNldCB0byB0aGUgZmlyc3QgcG9pbnRcbiAgICAgICAgICAgICAgICBsLmNvcHkocG9pbnRzWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAocSkge1xuICAgICAgICAgICAgICAgICAgICBxLnZtdWx0KGwsIGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1LmNvcHkobCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcS52bXVsdChwLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IHRtcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnggPiB1LngpIHsgdS54ID0gcC54OyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnggPCBsLngpIHsgbC54ID0gcC54OyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnkgPiB1LnkpIHsgdS55ID0gcC55OyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnkgPCBsLnkpIHsgbC55ID0gcC55OyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnogPiB1LnopIHsgdS56ID0gcC56OyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwLnogPCBsLnopIHsgbC56ID0gcC56OyB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIG9mZnNldFxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi52YWRkKGwsIGwpO1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbi52YWRkKHUsIHUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChza2luU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICBsLnggLT0gc2tpblNpemU7XG4gICAgICAgICAgICAgICAgICAgIGwueSAtPSBza2luU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgbC56IC09IHNraW5TaXplO1xuICAgICAgICAgICAgICAgICAgICB1LnggKz0gc2tpblNpemU7XG4gICAgICAgICAgICAgICAgICAgIHUueSArPSBza2luU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgdS56ICs9IHNraW5TaXplO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb3B5IGJvdW5kcyBmcm9tIGFuIEFBQkIgdG8gdGhpcyBBQUJCXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvcHlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmIgU291cmNlIHRvIGNvcHkgZnJvbVxuICAgICAgICAgICAgICogQHJldHVybiB7QUFCQn0gVGhlIHRoaXMgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFBQkIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoYWFiYikge1xuICAgICAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZC5jb3B5KGFhYmIubG93ZXJCb3VuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cHBlckJvdW5kLmNvcHkoYWFiYi51cHBlckJvdW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2xvbmUgYW4gQUFCQlxuICAgICAgICAgICAgICogQG1ldGhvZCBjbG9uZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBQUJCLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFBQkIoKS5jb3B5KHRoaXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeHRlbmQgdGhpcyBBQUJCIHNvIHRoYXQgaXQgY292ZXJzIHRoZSBnaXZlbiBBQUJCIHRvby5cbiAgICAgICAgICAgICAqIEBtZXRob2QgZXh0ZW5kXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEFBQkIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uIChhYWJiKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQueDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb3dlckJvdW5kLnggPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZC54ID0gbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcHBlclxuICAgICAgICAgICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kLng7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXBwZXJCb3VuZC54IDwgdSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQueCA9IHU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQueTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb3dlckJvdW5kLnkgPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZC55ID0gbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcHBlclxuICAgICAgICAgICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kLnk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXBwZXJCb3VuZC55IDwgdSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQueSA9IHU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXG4gICAgICAgICAgICAgICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQuejtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb3dlckJvdW5kLnogPiBsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZC56ID0gbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcHBlclxuICAgICAgICAgICAgICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kLno7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXBwZXJCb3VuZC56IDwgdSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQueiA9IHU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgb3ZlcmxhcHMgdGhpcyBBQUJCLlxuICAgICAgICAgICAgICogQG1ldGhvZCBvdmVybGFwc1xuICAgICAgICAgICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQUFCQi5wcm90b3R5cGUub3ZlcmxhcHMgPSBmdW5jdGlvbiAoYWFiYikge1xuICAgICAgICAgICAgICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgICAgICAgICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICAgICAgICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgICAgICAgICAgICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgICAgICAgICAgICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgICAgICAgICAgICAgIC8vIHwtLS0tLS0tLXxcbiAgICAgICAgICAgICAgICAvLyBsMSAgICAgICB1MVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgobDIueCA8PSB1MS54ICYmIHUxLnggPD0gdTIueCkgfHwgKGwxLnggPD0gdTIueCAmJiB1Mi54IDw9IHUxLngpKSAmJlxuICAgICAgICAgICAgICAgICAgICAoKGwyLnkgPD0gdTEueSAmJiB1MS55IDw9IHUyLnkpIHx8IChsMS55IDw9IHUyLnkgJiYgdTIueSA8PSB1MS55KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKChsMi56IDw9IHUxLnogJiYgdTEueiA8PSB1Mi56KSB8fCAobDEueiA8PSB1Mi56ICYmIHUyLnogPD0gdTEueikpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFBQkIgaXMgZnVsbHkgY29udGFpbmVkIGluIHRoaXMgQUFCQi5cbiAgICAgICAgICAgICAqIEBtZXRob2QgY29udGFpbnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QUFCQn0gYWFiYlxuICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQUFCQi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoYWFiYikge1xuICAgICAgICAgICAgICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgICAgICAgICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICAgICAgICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgICAgICAgICAgICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgICAgICAgICAgICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgICAgICAgICAgICAgIC8vIHwtLS0tLS0tLS0tLS0tLS18XG4gICAgICAgICAgICAgICAgLy8gbDEgICAgICAgICAgICAgIHUxXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAobDEueCA8PSBsMi54ICYmIHUxLnggPj0gdTIueCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGwxLnkgPD0gbDIueSAmJiB1MS55ID49IHUyLnkpICYmXG4gICAgICAgICAgICAgICAgICAgIChsMS56IDw9IGwyLnogJiYgdTEueiA+PSB1Mi56KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0Q29ybmVyc1xuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBhXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IGJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gY1xuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gZlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBnXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IGhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQUFCQi5wcm90b3R5cGUuZ2V0Q29ybmVycyA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgICAgICAgICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQ7XG5cbiAgICAgICAgICAgICAgICBhLmNvcHkobCk7XG4gICAgICAgICAgICAgICAgYi5zZXQodS54LCBsLnksIGwueik7XG4gICAgICAgICAgICAgICAgYy5zZXQodS54LCB1LnksIGwueik7XG4gICAgICAgICAgICAgICAgZC5zZXQobC54LCB1LnksIHUueik7XG4gICAgICAgICAgICAgICAgZS5zZXQodS54LCBsLnksIGwueik7XG4gICAgICAgICAgICAgICAgZi5zZXQobC54LCB1LnksIGwueik7XG4gICAgICAgICAgICAgICAgZy5zZXQobC54LCBsLnksIHUueik7XG4gICAgICAgICAgICAgICAgaC5jb3B5KHUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzID0gW1xuICAgICAgICAgICAgICAgIG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgbmV3IFZlYzMoKVxuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gYW5vdGhlciBmcmFtZS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgdG9Mb2NhbEZyYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtUcmFuc2Zvcm19IGZyYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBQUJCfSB0YXJnZXRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0FBQkJ9IFRoZSBcInRhcmdldFwiIEFBQkIgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBQUJCLnByb3RvdHlwZS50b0xvY2FsRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWUsIHRhcmdldCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycztcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGNvcm5lcnNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBjb3JuZXJzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBjID0gY29ybmVyc1syXTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGNvcm5lcnNbM107XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBjb3JuZXJzWzRdO1xuICAgICAgICAgICAgICAgIHZhciBmID0gY29ybmVyc1s1XTtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IGNvcm5lcnNbNl07XG4gICAgICAgICAgICAgICAgdmFyIGggPSBjb3JuZXJzWzddO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNvcm5lcnMgaW4gY3VycmVudCBmcmFtZVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29ybmVycyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcm5lciA9IGNvcm5lcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnBvaW50VG9Mb2NhbChjb3JuZXIsIGNvcm5lcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHJlcHJlc2VudGF0aW9uIG9mIGFuIEFBQkIgaW4gdGhlIGdsb2JhbCBmcmFtZS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgdG9Xb3JsZEZyYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtUcmFuc2Zvcm19IGZyYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBQUJCfSB0YXJnZXRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0FBQkJ9IFRoZSBcInRhcmdldFwiIEFBQkIgb2JqZWN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBQUJCLnByb3RvdHlwZS50b1dvcmxkRnJhbWUgPSBmdW5jdGlvbiAoZnJhbWUsIHRhcmdldCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvcm5lcnMgPSB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycztcbiAgICAgICAgICAgICAgICB2YXIgYSA9IGNvcm5lcnNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGIgPSBjb3JuZXJzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBjID0gY29ybmVyc1syXTtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IGNvcm5lcnNbM107XG4gICAgICAgICAgICAgICAgdmFyIGUgPSBjb3JuZXJzWzRdO1xuICAgICAgICAgICAgICAgIHZhciBmID0gY29ybmVyc1s1XTtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IGNvcm5lcnNbNl07XG4gICAgICAgICAgICAgICAgdmFyIGggPSBjb3JuZXJzWzddO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IGNvcm5lcnMgaW4gY3VycmVudCBmcmFtZVxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q29ybmVycyhhLCBiLCBjLCBkLCBlLCBmLCBnLCBoKTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGVtIHRvIG5ldyBsb2NhbCBmcmFtZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvcm5lciA9IGNvcm5lcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnBvaW50VG9Xb3JsZChjb3JuZXIsIGNvcm5lcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5zZXRGcm9tUG9pbnRzKGNvcm5lcnMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4uL3V0aWxzL1V0aWxzXCI6IDUzIH1dLCA0OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBBcnJheUNvbGxpc2lvbk1hdHJpeDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb2xsaXNpb24gXCJtYXRyaXhcIi4gSXQncyBhY3R1YWxseSBhIHRyaWFuZ3VsYXItc2hhcGVkIGFycmF5IG9mIHdoZXRoZXIgdHdvIGJvZGllcyBhcmUgdG91Y2hpbmcgdGhpcyBzdGVwLCBmb3IgcmVmZXJlbmNlIG5leHQgc3RlcFxuICAgICAgICAgICAgICogQGNsYXNzIEFycmF5Q29sbGlzaW9uTWF0cml4XG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQXJyYXlDb2xsaXNpb25NYXRyaXgoKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgbWF0cml4IHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgbWF0cml4XG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4ID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGFuIGVsZW1lbnRcbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0galxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGksIGopIHtcbiAgICAgICAgICAgICAgICBpID0gaS5pbmRleDtcbiAgICAgICAgICAgICAgICBqID0gai5pbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeFsoaSAqIChpICsgMSkgPj4gMSkgKyBqIC0gMV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCBhbiBlbGVtZW50XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldFxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpLCBqLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGkgPSBpLmluZGV4O1xuICAgICAgICAgICAgICAgIGogPSBqLmluZGV4O1xuICAgICAgICAgICAgICAgIGlmIChqID4gaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICBpID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXhbKGkgKiAoaSArIDEpID4+IDEpICsgaiAtIDFdID0gdmFsdWUgPyAxIDogMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0cyBhbGwgZWxlbWVudHMgdG8gemVyb1xuICAgICAgICAgICAgICogQG1ldGhvZCByZXNldFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBBcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm1hdHJpeC5sZW5ndGg7IGkgIT09IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeFtpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXRzIHRoZSBtYXggbnVtYmVyIG9mIG9iamVjdHNcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0TnVtT2JqZWN0c1xuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldE51bU9iamVjdHMgPSBmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4Lmxlbmd0aCA9IG4gKiAobiAtIDEpID4+IDE7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0sIHt9XSwgNTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIHZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbiAgICAgICAgICAgIHZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xuICAgICAgICAgICAgdmFyIFBsYW5lID0gX2RlcmVxXygnLi4vc2hhcGVzL1BsYW5lJyk7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gQnJvYWRwaGFzZTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYXNlIGNsYXNzIGZvciBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uc1xuICAgICAgICAgICAgICogQGNsYXNzIEJyb2FkcGhhc2VcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBCcm9hZHBoYXNlKCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICogVGhlIHdvcmxkIHRvIHNlYXJjaCBmb3IgY29sbGlzaW9ucyBpbi5cbiAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAgICAgICAgICAgICogQHR5cGUge1dvcmxkfVxuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgdGhlIGJyb2FkcGhhc2UgdXNlcyBib3VuZGluZyBib3hlcyBmb3IgaW50ZXJzZWN0aW9uIHRlc3QsIGVsc2UgaXQgdXNlcyBib3VuZGluZyBzcGhlcmVzLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB1c2VCb3VuZGluZ0JveGVzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy51c2VCb3VuZGluZ0JveGVzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0cyBpbiB0aGUgd29ybGQgbW92ZWQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBkaXJ0eVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgY29sbGlzaW9uIHBhaXJzIGZyb20gdGhlIHdvcmxkXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvbGxpc2lvblBhaXJzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZCBUaGUgd29ybGQgdG8gc2VhcmNoIGluXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwMSBFbXB0eSBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCBib2R5IG9iamVjdHNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHAyIEVtcHR5IGFycmF5IHRvIGJlIGZpbGxlZCB3aXRoIGJvZHkgb2JqZWN0c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCcm9hZHBoYXNlLnByb3RvdHlwZS5jb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uICh3b3JsZCwgcDEsIHAyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhXCIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayBpZiBhIGJvZHkgcGFpciBuZWVkcyB0byBiZSBpbnRlcnNlY3Rpb24gdGVzdGVkIGF0IGFsbC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgbmVlZEJyb2FkcGhhc2VDb2xsaXNpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2x9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBCcm9hZHBoYXNlX25lZWRCcm9hZHBoYXNlQ29sbGlzaW9uX1NUQVRJQ19PUl9LSU5FTUFUSUMgPSBCb2R5LlNUQVRJQyB8IEJvZHkuS0lORU1BVElDO1xuICAgICAgICAgICAgQnJvYWRwaGFzZS5wcm90b3R5cGUubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24gPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBjb2xsaXNpb24gZmlsdGVyIG1hc2tzXG4gICAgICAgICAgICAgICAgaWYgKChib2R5QS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHlCLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAwIHx8IChib2R5Qi5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHlBLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0eXBlc1xuICAgICAgICAgICAgICAgIGlmICgoKGJvZHlBLnR5cGUgJiBCcm9hZHBoYXNlX25lZWRCcm9hZHBoYXNlQ29sbGlzaW9uX1NUQVRJQ19PUl9LSU5FTUFUSUMpICE9PSAwIHx8IGJvZHlBLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpICYmXG4gICAgICAgICAgICAgICAgICAgICgoYm9keUIudHlwZSAmIEJyb2FkcGhhc2VfbmVlZEJyb2FkcGhhc2VDb2xsaXNpb25fU1RBVElDX09SX0tJTkVNQVRJQykgIT09IDAgfHwgYm9keUIuc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQm90aCBib2RpZXMgYXJlIHN0YXRpYywga2luZW1hdGljIG9yIHNsZWVwaW5nLiBTa2lwLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIGlmIHRoZSBib3VuZGluZyB2b2x1bWVzIG9mIHR3byBib2RpZXMgaW50ZXJzZWN0LlxuICAgICAgICAgICAgICogQG1ldGhvZCBpbnRlcnNlY3Rpb25UZXN0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBwYWlyczFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IHBhaXJzMlxuICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnJvYWRwaGFzZS5wcm90b3R5cGUuaW50ZXJzZWN0aW9uVGVzdCA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNlQm91bmRpbmdCb3hlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UoYm9keUEsIGJvZHlCLCBwYWlyczEsIHBhaXJzMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgc3BoZXJlcyBvZiB0d28gYm9kaWVzIGFyZSBpbnRlcnNlY3RpbmcuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlyczEgYm9keUEgaXMgYXBwZW5kZWQgdG8gdGhpcyBhcnJheSBpZiBpbnRlcnNlY3Rpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yID0gbmV3IFZlYzMoKSwgLy8gVGVtcCBvYmplY3RzXG4gICAgICAgICAgICAgICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19ub3JtYWwgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfcXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCksXG4gICAgICAgICAgICAgICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yZWxwb3MgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgQnJvYWRwaGFzZS5wcm90b3R5cGUuZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UgPSBmdW5jdGlvbiAoYm9keUEsIGJvZHlCLCBwYWlyczEsIHBhaXJzMikge1xuICAgICAgICAgICAgICAgIHZhciByID0gQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yO1xuICAgICAgICAgICAgICAgIGJvZHlCLnBvc2l0aW9uLnZzdWIoYm9keUEucG9zaXRpb24sIHIpO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZGluZ1JhZGl1c1N1bTIgPSBNYXRoLnBvdyhib2R5QS5ib3VuZGluZ1JhZGl1cyArIGJvZHlCLmJvdW5kaW5nUmFkaXVzLCAyKTtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybTIgPSByLm5vcm0yKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm0yIDwgYm91bmRpbmdSYWRpdXNTdW0yKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzMS5wdXNoKGJvZHlBKTtcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMyLnB1c2goYm9keUIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIGJveGVzIG9mIHR3byBib2RpZXMgYXJlIGludGVyc2VjdGluZy5cbiAgICAgICAgICAgICAqIEBtZXRob2QgZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2VcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJyb2FkcGhhc2UucHJvdG90eXBlLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlID0gZnVuY3Rpb24gKGJvZHlBLCBib2R5QiwgcGFpcnMxLCBwYWlyczIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuYWFiYk5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLmNvbXB1dGVBQUJCKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChib2R5Qi5hYWJiTmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuY29tcHV0ZUFBQkIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBBQUJCIC8gQUFCQlxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5hYWJiLm92ZXJsYXBzKGJvZHlCLmFhYmIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzMS5wdXNoKGJvZHlBKTtcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMyLnB1c2goYm9keUIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlcyBkdXBsaWNhdGUgcGFpcnMgZnJvbSB0aGUgcGFpciBhcnJheXMuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIG1ha2VQYWlyc1VuaXF1ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAgPSB7IGtleXM6IFtdIH0sXG4gICAgICAgICAgICAgICAgQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDEgPSBbXSxcbiAgICAgICAgICAgICAgICBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMiA9IFtdO1xuICAgICAgICAgICAgQnJvYWRwaGFzZS5wcm90b3R5cGUubWFrZVBhaXJzVW5pcXVlID0gZnVuY3Rpb24gKHBhaXJzMSwgcGFpcnMyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV90ZW1wLFxuICAgICAgICAgICAgICAgICAgICBwMSA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AxLFxuICAgICAgICAgICAgICAgICAgICBwMiA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AyLFxuICAgICAgICAgICAgICAgICAgICBOID0gcGFpcnMxLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcDFbaV0gPSBwYWlyczFbaV07XG4gICAgICAgICAgICAgICAgICAgIHAyW2ldID0gcGFpcnMyW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHBhaXJzMS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHBhaXJzMi5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQxID0gcDFbaV0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDIgPSBwMltpXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGlkMSA8IGlkMiA/IGlkMSArIFwiLFwiICsgaWQyIDogaWQyICsgXCIsXCIgKyBpZDE7XG4gICAgICAgICAgICAgICAgICAgIHRba2V5XSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIHQua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IHQua2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gdC5rZXlzLnBvcCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFpckluZGV4ID0gdFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBwYWlyczEucHVzaChwMVtwYWlySW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMyLnB1c2gocDJbcGFpckluZGV4XSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUbyBiZSBpbXBsZW1lbnRlZCBieSBzdWJjYXNzZXNcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0V29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkKSB7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIGlmIHRoZSBib3VuZGluZyBzcGhlcmVzIG9mIHR3byBib2RpZXMgb3ZlcmxhcC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYm91bmRpbmdTcGhlcmVDaGVja1xuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAgICAgICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGJzY19kaXN0ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIEJyb2FkcGhhc2UuYm91bmRpbmdTcGhlcmVDaGVjayA9IGZ1bmN0aW9uIChib2R5QSwgYm9keUIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGJzY19kaXN0O1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uLnZzdWIoYm9keUIucG9zaXRpb24sIGRpc3QpO1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdyhib2R5QS5zaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIGJvZHlCLnNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzLCAyKSA+IGRpc3Qubm9ybTIoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFhYmJRdWVyeVxuICAgICAgICAgICAgICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24gKHdvcmxkLCBhYWJiLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJy5hYWJiUXVlcnkgaXMgbm90IGltcGxlbWVudGVkIGluIHRoaXMgQnJvYWRwaGFzZSBzdWJjbGFzcy4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6IDI4LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi9vYmplY3RzL0JvZHlcIjogMzEsIFwiLi4vc2hhcGVzL1BsYW5lXCI6IDQyLCBcIi4uL3NoYXBlcy9TaGFwZVwiOiA0MyB9XSwgNjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gR3JpZEJyb2FkcGhhc2U7XG5cbiAgICAgICAgICAgIHZhciBCcm9hZHBoYXNlID0gX2RlcmVxXygnLi9Ccm9hZHBoYXNlJyk7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXhpcyBhbGlnbmVkIHVuaWZvcm0gZ3JpZCBicm9hZHBoYXNlLlxuICAgICAgICAgICAgICogQGNsYXNzIEdyaWRCcm9hZHBoYXNlXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAgICAgICAgICAgICAqIEB0b2RvIE5lZWRzIHN1cHBvcnQgZm9yIG1vcmUgdGhhbiBqdXN0IHBsYW5lcyBhbmQgc3BoZXJlcy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gYWFiYk1pblxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBhYWJiTWF4XG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbnggTnVtYmVyIG9mIGJveGVzIGFsb25nIHhcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBueSBOdW1iZXIgb2YgYm94ZXMgYWxvbmcgeVxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG56IE51bWJlciBvZiBib3hlcyBhbG9uZyB6XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIEdyaWRCcm9hZHBoYXNlKGFhYmJNaW4sIGFhYmJNYXgsIG54LCBueSwgbnopIHtcbiAgICAgICAgICAgICAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMubnggPSBueCB8fCAxMDtcbiAgICAgICAgICAgICAgICB0aGlzLm55ID0gbnkgfHwgMTA7XG4gICAgICAgICAgICAgICAgdGhpcy5ueiA9IG56IHx8IDEwO1xuICAgICAgICAgICAgICAgIHRoaXMuYWFiYk1pbiA9IGFhYmJNaW4gfHwgbmV3IFZlYzMoMTAwLCAxMDAsIDEwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiTWF4ID0gYWFiYk1heCB8fCBuZXcgVmVjMygtMTAwLCAtMTAwLCAtMTAwKTtcbiAgICAgICAgICAgICAgICB2YXIgbmJpbnMgPSB0aGlzLm54ICogdGhpcy5ueSAqIHRoaXMubno7XG4gICAgICAgICAgICAgICAgaWYgKG5iaW5zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJHcmlkQnJvYWRwaGFzZTogRWFjaCBkaW1lbnNpb24ncyBuIG11c3QgYmUgPjBcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5zID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5MZW5ndGhzID0gW107IC8vUmF0aGVyIHRoYW4gY29udGludWFsbHkgcmVzaXppbmcgYXJyYXlzICh0aHJhc2hpbmcgdGhlIG1lbW9yeSksIGp1c3QgcmVjb3JkIGxlbmd0aCBhbmQgYWxsb3cgdGhlbSB0byBncm93XG4gICAgICAgICAgICAgICAgdGhpcy5iaW5zLmxlbmd0aCA9IG5iaW5zO1xuICAgICAgICAgICAgICAgIHRoaXMuYmluTGVuZ3Rocy5sZW5ndGggPSBuYmlucztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5iaW5zOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iaW5zW2ldID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmluTGVuZ3Roc1tpXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbiAgICAgICAgICAgIEdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRCcm9hZHBoYXNlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxuICAgICAgICAgICAgICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICAgICAgICAgICAgICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19kID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19iaW5Qb3MgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24gKHdvcmxkLCBwYWlyczEsIHBhaXJzMikge1xuICAgICAgICAgICAgICAgIHZhciBOID0gd29ybGQubnVtT2JqZWN0cygpLFxuICAgICAgICAgICAgICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gdGhpcy5hYWJiTWF4LFxuICAgICAgICAgICAgICAgICAgICBtaW4gPSB0aGlzLmFhYmJNaW4sXG4gICAgICAgICAgICAgICAgICAgIG54ID0gdGhpcy5ueCxcbiAgICAgICAgICAgICAgICAgICAgbnkgPSB0aGlzLm55LFxuICAgICAgICAgICAgICAgICAgICBueiA9IHRoaXMubno7XG5cbiAgICAgICAgICAgICAgICB2YXIgeHN0ZXAgPSBueSAqIG56O1xuICAgICAgICAgICAgICAgIHZhciB5c3RlcCA9IG56O1xuICAgICAgICAgICAgICAgIHZhciB6c3RlcCA9IDE7XG5cbiAgICAgICAgICAgICAgICB2YXIgeG1heCA9IG1heC54LFxuICAgICAgICAgICAgICAgICAgICB5bWF4ID0gbWF4LnksXG4gICAgICAgICAgICAgICAgICAgIHptYXggPSBtYXgueixcbiAgICAgICAgICAgICAgICAgICAgeG1pbiA9IG1pbi54LFxuICAgICAgICAgICAgICAgICAgICB5bWluID0gbWluLnksXG4gICAgICAgICAgICAgICAgICAgIHptaW4gPSBtaW4uejtcblxuICAgICAgICAgICAgICAgIHZhciB4bXVsdCA9IG54IC8gKHhtYXggLSB4bWluKSxcbiAgICAgICAgICAgICAgICAgICAgeW11bHQgPSBueSAvICh5bWF4IC0geW1pbiksXG4gICAgICAgICAgICAgICAgICAgIHptdWx0ID0gbnogLyAoem1heCAtIHptaW4pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJpbnNpemVYID0gKHhtYXggLSB4bWluKSAvIG54LFxuICAgICAgICAgICAgICAgICAgICBiaW5zaXplWSA9ICh5bWF4IC0geW1pbikgLyBueSxcbiAgICAgICAgICAgICAgICAgICAgYmluc2l6ZVogPSAoem1heCAtIHptaW4pIC8gbno7XG5cbiAgICAgICAgICAgICAgICB2YXIgYmluUmFkaXVzID0gTWF0aC5zcXJ0KGJpbnNpemVYICogYmluc2l6ZVggKyBiaW5zaXplWSAqIGJpbnNpemVZICsgYmluc2l6ZVogKiBiaW5zaXplWikgKiAwLjU7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHlwZXMgPSBTaGFwZS50eXBlcztcbiAgICAgICAgICAgICAgICB2YXIgU1BIRVJFID0gdHlwZXMuU1BIRVJFLFxuICAgICAgICAgICAgICAgICAgICBQTEFORSA9IHR5cGVzLlBMQU5FLFxuICAgICAgICAgICAgICAgICAgICBCT1ggPSB0eXBlcy5CT1gsXG4gICAgICAgICAgICAgICAgICAgIENPTVBPVU5EID0gdHlwZXMuQ09NUE9VTkQsXG4gICAgICAgICAgICAgICAgICAgIENPTlZFWFBPTFlIRURST04gPSB0eXBlcy5DT05WRVhQT0xZSEVEUk9OO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJpbnMgPSB0aGlzLmJpbnMsXG4gICAgICAgICAgICAgICAgICAgIGJpbkxlbmd0aHMgPSB0aGlzLmJpbkxlbmd0aHMsXG4gICAgICAgICAgICAgICAgICAgIE5iaW5zID0gdGhpcy5iaW5zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGJpbnNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJpbnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiaW5MZW5ndGhzW2ldID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY2VpbCA9IE1hdGguY2VpbDtcbiAgICAgICAgICAgICAgICB2YXIgbWluID0gTWF0aC5taW47XG4gICAgICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4O1xuXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkQm94VG9CaW5zKHgwLCB5MCwgejAsIHgxLCB5MSwgejEsIGJpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4b2ZmMCA9ICgoeDAgLSB4bWluKSAqIHhtdWx0KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB5b2ZmMCA9ICgoeTAgLSB5bWluKSAqIHltdWx0KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB6b2ZmMCA9ICgoejAgLSB6bWluKSAqIHptdWx0KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB4b2ZmMSA9IGNlaWwoKHgxIC0geG1pbikgKiB4bXVsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB5b2ZmMSA9IGNlaWwoKHkxIC0geW1pbikgKiB5bXVsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB6b2ZmMSA9IGNlaWwoKHoxIC0gem1pbikgKiB6bXVsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhvZmYwIDwgMCkgeyB4b2ZmMCA9IDA7IH0gZWxzZSBpZiAoeG9mZjAgPj0gbngpIHsgeG9mZjAgPSBueCAtIDE7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHlvZmYwIDwgMCkgeyB5b2ZmMCA9IDA7IH0gZWxzZSBpZiAoeW9mZjAgPj0gbnkpIHsgeW9mZjAgPSBueSAtIDE7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHpvZmYwIDwgMCkgeyB6b2ZmMCA9IDA7IH0gZWxzZSBpZiAoem9mZjAgPj0gbnopIHsgem9mZjAgPSBueiAtIDE7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHhvZmYxIDwgMCkgeyB4b2ZmMSA9IDA7IH0gZWxzZSBpZiAoeG9mZjEgPj0gbngpIHsgeG9mZjEgPSBueCAtIDE7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHlvZmYxIDwgMCkgeyB5b2ZmMSA9IDA7IH0gZWxzZSBpZiAoeW9mZjEgPj0gbnkpIHsgeW9mZjEgPSBueSAtIDE7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHpvZmYxIDwgMCkgeyB6b2ZmMSA9IDA7IH0gZWxzZSBpZiAoem9mZjEgPj0gbnopIHsgem9mZjEgPSBueiAtIDE7IH1cblxuICAgICAgICAgICAgICAgICAgICB4b2ZmMCAqPSB4c3RlcDtcbiAgICAgICAgICAgICAgICAgICAgeW9mZjAgKj0geXN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIHpvZmYwICo9IHpzdGVwO1xuICAgICAgICAgICAgICAgICAgICB4b2ZmMSAqPSB4c3RlcDtcbiAgICAgICAgICAgICAgICAgICAgeW9mZjEgKj0geXN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIHpvZmYxICo9IHpzdGVwO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhvZmYgPSB4b2ZmMDsgeG9mZiA8PSB4b2ZmMTsgeG9mZiArPSB4c3RlcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeW9mZiA9IHlvZmYwOyB5b2ZmIDw9IHlvZmYxOyB5b2ZmICs9IHlzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgem9mZiA9IHpvZmYwOyB6b2ZmIDw9IHpvZmYxOyB6b2ZmICs9IHpzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSB4b2ZmICsgeW9mZiArIHpvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbnNbaWR4XVtiaW5MZW5ndGhzW2lkeF0rK10gPSBiaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBQdXQgYWxsIGJvZGllcyBpbnRvIHRoZSBiaW5zXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaSA9IGJpLnNoYXBlO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc2kudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBTUEhFUkU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHV0IGluIGJpblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIG92ZXJsYXAgd2l0aCBvdGhlciBiaW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBiaS5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ID0gYmkucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeiA9IGJpLnBvc2l0aW9uLno7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSBzaS5yYWRpdXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRCb3hUb0JpbnMoeCAtIHIsIHkgLSByLCB6IC0gciwgeCArIHIsIHkgKyByLCB6ICsgciwgYmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFBMQU5FOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaS53b3JsZE5vcm1hbE5lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpLmNvbXB1dGVXb3JsZE5vcm1hbChiaS5xdWF0ZXJuaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYW5lTm9ybWFsID0gc2kud29ybGROb3JtYWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1JlbGF0aXZlIHBvc2l0aW9uIGZyb20gb3JpZ2luIG9mIHBsYW5lIG9iamVjdCB0byB0aGUgZmlyc3QgYmluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JbmNyZW1lbnRlZCBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGJpbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeHJlc2V0ID0geG1pbiArIGJpbnNpemVYICogMC41IC0gYmkucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeXJlc2V0ID0geW1pbiArIGJpbnNpemVZICogMC41IC0gYmkucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgenJlc2V0ID0gem1pbiArIGJpbnNpemVaICogMC41IC0gYmkucG9zaXRpb24uejtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gR3JpZEJyb2FkcGhhc2VfY29sbGlzaW9uUGFpcnNfZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkLnNldCh4cmVzZXQsIHlyZXNldCwgenJlc2V0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhpID0gMCwgeG9mZiA9IDA7IHhpICE9PSBueDsgeGkrKywgeG9mZiArPSB4c3RlcCwgZC55ID0geXJlc2V0LCBkLnggKz0gYmluc2l6ZVgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeWkgPSAwLCB5b2ZmID0gMDsgeWkgIT09IG55OyB5aSsrLCB5b2ZmICs9IHlzdGVwLCBkLnogPSB6cmVzZXQsIGQueSArPSBiaW5zaXplWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgemkgPSAwLCB6b2ZmID0gMDsgemkgIT09IG56OyB6aSsrLCB6b2ZmICs9IHpzdGVwLCBkLnogKz0gYmluc2l6ZVopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZC5kb3QocGxhbmVOb3JtYWwpIDwgYmluUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSB4b2ZmICsgeW9mZiArIHpvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpbnNbaWR4XVtiaW5MZW5ndGhzW2lkeF0rK10gPSBiaTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpLmFhYmJOZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaS5jb21wdXRlQUFCQigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEJveFRvQmlucyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmkuYWFiYi5sb3dlckJvdW5kLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpLmFhYmIubG93ZXJCb3VuZC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaS5hYWJiLmxvd2VyQm91bmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmkuYWFiYi51cHBlckJvdW5kLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJpLmFhYmIudXBwZXJCb3VuZC55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaS5hYWJiLnVwcGVyQm91bmQueixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgZWFjaCBiaW5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJpbnM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluTGVuZ3RoID0gYmluTGVuZ3Roc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgLy9Ta2lwIGJpbnMgd2l0aCBubyBwb3RlbnRpYWwgY29sbGlzaW9uc1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluTGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpbiA9IGJpbnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIE5eMiBicm9hZHBoYXNlIGluc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeGkgPSAwOyB4aSAhPT0gYmluTGVuZ3RoOyB4aSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJpID0gYmluW3hpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5aSA9IDA7IHlpICE9PSB4aTsgeWkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmogPSBiaW5beWldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSwgYmopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdGlvblRlc3QoYmksIGJqLCBwYWlyczEsIHBhaXJzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL1x0Zm9yICh2YXIgemkgPSAwLCB6b2ZmPTA7IHppIDwgbno7IHppKyssIHpvZmYrPSB6c3RlcCkge1xuICAgICAgICAgICAgICAgIC8vXHRcdGNvbnNvbGUubG9nKFwibGF5ZXIgXCIremkpO1xuICAgICAgICAgICAgICAgIC8vXHRcdGZvciAodmFyIHlpID0gMCwgeW9mZj0wOyB5aSA8IG55OyB5aSsrLCB5b2ZmICs9IHlzdGVwKSB7XG4gICAgICAgICAgICAgICAgLy9cdFx0XHR2YXIgcm93ID0gJyc7XG4gICAgICAgICAgICAgICAgLy9cdFx0XHRmb3IgKHZhciB4aSA9IDAsIHhvZmY9MDsgeGkgPCBueDsgeGkrKywgeG9mZiArPSB4c3RlcCkge1xuICAgICAgICAgICAgICAgIC8vXHRcdFx0XHR2YXIgaWR4ID0geG9mZiArIHlvZmYgKyB6b2ZmO1xuICAgICAgICAgICAgICAgIC8vXHRcdFx0XHRyb3cgKz0gJyAnICsgYmluTGVuZ3Roc1tpZHhdO1xuICAgICAgICAgICAgICAgIC8vXHRcdFx0fVxuICAgICAgICAgICAgICAgIC8vXHRcdFx0Y29uc29sZS5sb2cocm93KTtcbiAgICAgICAgICAgICAgICAvL1x0XHR9XG4gICAgICAgICAgICAgICAgLy9cdH1cblxuICAgICAgICAgICAgICAgIHRoaXMubWFrZVBhaXJzVW5pcXVlKHBhaXJzMSwgcGFpcnMyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi9zaGFwZXMvU2hhcGVcIjogNDMsIFwiLi9Ccm9hZHBoYXNlXCI6IDUgfV0sIDc6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE5haXZlQnJvYWRwaGFzZTtcblxuICAgICAgICAgICAgdmFyIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuL0Jyb2FkcGhhc2UnKTtcbiAgICAgICAgICAgIHZhciBBQUJCID0gX2RlcmVxXygnLi9BQUJCJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTmFpdmUgYnJvYWRwaGFzZSBpbXBsZW1lbnRhdGlvbiwgdXNlZCBpbiBsYWNrIG9mIGJldHRlciBvbmVzLlxuICAgICAgICAgICAgICogQGNsYXNzIE5haXZlQnJvYWRwaGFzZVxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gVGhlIG5haXZlIGJyb2FkcGhhc2UgbG9va3MgYXQgYWxsIHBvc3NpYmxlIHBhaXJzIHdpdGhvdXQgcmVzdHJpY3Rpb24sIHRoZXJlZm9yZSBpdCBoYXMgY29tcGxleGl0eSBOXjIgKHdoaWNoIGlzIGJhZClcbiAgICAgICAgICAgICAqIEBleHRlbmRzIEJyb2FkcGhhc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gTmFpdmVCcm9hZHBoYXNlKCkge1xuICAgICAgICAgICAgICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBOYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbiAgICAgICAgICAgIE5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOYWl2ZUJyb2FkcGhhc2U7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGFsbCB0aGUgY29sbGlzaW9uIHBhaXJzIGluIHRoZSBwaHlzaWNzIHdvcmxkXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvbGxpc2lvblBhaXJzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5jb2xsaXNpb25QYWlycyA9IGZ1bmN0aW9uICh3b3JsZCwgcGFpcnMxLCBwYWlyczIpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICAgICAgICAgICAgICBuID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgaSwgaiwgYmksIGJqO1xuXG4gICAgICAgICAgICAgICAgLy8gTmFpdmUgTl4yIGZ0dyFcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiAhPT0gaTsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSwgYmopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uVGVzdChiaSwgYmosIHBhaXJzMSwgcGFpcnMyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICAgICAgICAgICAgICogQG1ldGhvZCBhYWJiUXVlcnlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICAgICAgICAgICAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbiAod29ybGQsIGFhYmIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29ybGQuYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gd29ybGQuYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLmFhYmJOZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYi5jb21wdXRlQUFCQigpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVWdseSBoYWNrIHVudGlsIEJvZHkgZ2V0cyBhYWJiXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLmFhYmIub3ZlcmxhcHMoYWFiYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL0FBQkJcIjogMywgXCIuL0Jyb2FkcGhhc2VcIjogNSB9XSwgODogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gT2JqZWN0Q29sbGlzaW9uTWF0cml4O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY29yZHMgd2hhdCBvYmplY3RzIGFyZSBjb2xsaWRpbmcgd2l0aCBlYWNoIG90aGVyXG4gICAgICAgICAgICAgKiBAY2xhc3MgT2JqZWN0Q29sbGlzaW9uTWF0cml4XG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gT2JqZWN0Q29sbGlzaW9uTWF0cml4KCkge1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIG1hdHJpeCBzdG9yYWdlXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IG1hdHJpeFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRyaXggPSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldFxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgICAgICAgICAgICAgIGkgPSBpLmlkO1xuICAgICAgICAgICAgICAgIGogPSBqLmlkO1xuICAgICAgICAgICAgICAgIGlmIChqID4gaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICBpID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAnLScgKyBqIGluIHRoaXMubWF0cml4O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldFxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpLCBqLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGkgPSBpLmlkO1xuICAgICAgICAgICAgICAgIGogPSBqLmlkO1xuICAgICAgICAgICAgICAgIGlmIChqID4gaSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICBpID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cml4W2kgKyAnLScgKyBqXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5tYXRyaXhbaSArICctJyArIGpdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW1wdHkgdGhlIG1hdHJpeFxuICAgICAgICAgICAgICogQG1ldGhvZCByZXNldFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0cml4ID0ge307XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCBtYXggbnVtYmVyIG9mIG9iamVjdHNcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0TnVtT2JqZWN0c1xuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXROdW1PYmplY3RzID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwge31dLCA5OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBSYXk7XG5cbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xuICAgICAgICAgICAgdmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4uL21hdGgvVHJhbnNmb3JtJyk7XG4gICAgICAgICAgICB2YXIgQ29udmV4UG9seWhlZHJvbiA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyk7XG4gICAgICAgICAgICB2YXIgQm94ID0gX2RlcmVxXygnLi4vc2hhcGVzL0JveCcpO1xuICAgICAgICAgICAgdmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xuICAgICAgICAgICAgdmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBsaW5lIGluIDNEIHNwYWNlIHRoYXQgaW50ZXJzZWN0cyBib2RpZXMgYW5kIHJldHVybiBwb2ludHMuXG4gICAgICAgICAgICAgKiBAY2xhc3MgUmF5XG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gZnJvbVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0b1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBSYXkoZnJvbSwgdG8pIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGZyb21cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmZyb20gPSBmcm9tID8gZnJvbS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gdG9cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnRvID0gdG8gPyB0by5jbG9uZSgpIDogbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzfSBfZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBwcmVjaXNpb24gb2YgdGhlIHJheS4gVXNlZCB3aGVuIGNoZWNraW5nIHBhcmFsbGVsaXR5IGV0Yy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gcHJlY2lzaW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVjaXNpb24gPSAwLjAwMDE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgUmF5IHRvIHRha2UgLmNvbGxpc2lvblJlc3BvbnNlIGZsYWdzIGludG8gYWNjb3VudCBvbiBib2RpZXMgYW5kIHNoYXBlcy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGNoZWNrQ29sbGlzaW9uUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSByYXkgc2tpcHMgYW55IGhpdHMgd2l0aCBub3JtYWwuZG90KHJheURpcmVjdGlvbikgPCAwLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2tpcEJhY2tmYWNlc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbGxpc2lvbkZpbHRlck1hc2tcbiAgICAgICAgICAgICAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IC0xO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNvbGxpc2lvbkZpbHRlckdyb3VwXG4gICAgICAgICAgICAgICAgICogQGRlZmF1bHQgLTFcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkZpbHRlckdyb3VwID0gLTE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaW50ZXJzZWN0aW9uIG1vZGUuIFNob3VsZCBiZSBSYXkuQU5ZLCBSYXkuQUxMIG9yIFJheS5DTE9TRVNULlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtb2RlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlID0gUmF5LkFOWTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnQgcmVzdWx0IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdpbGwgYmUgc2V0IHRvIHRydWUgZHVyaW5nIGludGVyc2VjdFdvcmxkKCkgaWYgdGhlIHJheSBoaXQgYW55dGhpbmcuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBoYXNIaXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3VycmVudCwgdXNlci1wcm92aWRlZCByZXN1bHQgY2FsbGJhY2suIFdpbGwgYmUgdXNlZCBpZiBtb2RlIGlzIFJheS5BTEwuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gZnVuY3Rpb24gKHJlc3VsdCkgeyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmF5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJheTtcblxuICAgICAgICAgICAgUmF5LkNMT1NFU1QgPSAxO1xuICAgICAgICAgICAgUmF5LkFOWSA9IDI7XG4gICAgICAgICAgICBSYXkuQUxMID0gNDtcblxuICAgICAgICAgICAgdmFyIHRtcEFBQkIgPSBuZXcgQUFCQigpO1xuICAgICAgICAgICAgdmFyIHRtcEFycmF5ID0gW107XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRG8gaXRlcnNlY3Rpb24gYWdhaW5zdCBhbGwgYm9kaWVzIGluIHRoZSBnaXZlbiBXb3JsZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgaW50ZXJzZWN0V29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0V29ybGQgPSBmdW5jdGlvbiAod29ybGQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgUmF5LkFOWTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG9wdGlvbnMucmVzdWx0IHx8IG5ldyBSYXljYXN0UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5za2lwQmFja2ZhY2VzID0gISFvcHRpb25zLnNraXBCYWNrZmFjZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJNYXNrID0gdHlwZW9mIChvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2spICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2YgKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXApICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgOiAtMTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbS5jb3B5KG9wdGlvbnMuZnJvbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG8uY29weShvcHRpb25zLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2sgfHwgZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5yZXNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRBQUJCKHRtcEFBQkIpO1xuICAgICAgICAgICAgICAgIHRtcEFycmF5Lmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgd29ybGQuYnJvYWRwaGFzZS5hYWJiUXVlcnkod29ybGQsIHRtcEFBQkIsIHRtcEFycmF5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdEJvZGllcyh0bXBBcnJheSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdjEgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIHYyID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIEFzIHBlciBcIkJhcnljZW50cmljIFRlY2huaXF1ZVwiIGFzIG5hbWVkIGhlcmUgaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BvaW50aW5wb2x5L2RlZmF1bHQuaHRtbCBCdXQgd2l0aG91dCB0aGUgZGl2aXNpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmF5LnBvaW50SW5UcmlhbmdsZSA9IHBvaW50SW5UcmlhbmdsZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHBvaW50SW5UcmlhbmdsZShwLCBhLCBiLCBjKSB7XG4gICAgICAgICAgICAgICAgYy52c3ViKGEsIHYwKTtcbiAgICAgICAgICAgICAgICBiLnZzdWIoYSwgdjEpO1xuICAgICAgICAgICAgICAgIHAudnN1YihhLCB2Mik7XG5cbiAgICAgICAgICAgICAgICB2YXIgZG90MDAgPSB2MC5kb3QodjApO1xuICAgICAgICAgICAgICAgIHZhciBkb3QwMSA9IHYwLmRvdCh2MSk7XG4gICAgICAgICAgICAgICAgdmFyIGRvdDAyID0gdjAuZG90KHYyKTtcbiAgICAgICAgICAgICAgICB2YXIgZG90MTEgPSB2MS5kb3QodjEpO1xuICAgICAgICAgICAgICAgIHZhciBkb3QxMiA9IHYxLmRvdCh2Mik7XG5cbiAgICAgICAgICAgICAgICB2YXIgdSwgdjtcblxuICAgICAgICAgICAgICAgIHJldHVybiAoKHUgPSBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgPj0gMCkgJiZcbiAgICAgICAgICAgICAgICAgICAgKCh2ID0gZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpID49IDApICYmXG4gICAgICAgICAgICAgICAgICAgICh1ICsgdiA8IChkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAgICAgICAgICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkIC0gc2V0IHRoZSByZXN1bHQgcHJvcGVydHkgb2YgdGhlIFJheSBpbnN0ZWFkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0Qm9keV94aSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0Qm9keV9xaSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICAgICAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAoYm9keSwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIWJvZHkuY29sbGlzaW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICgodGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHkuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09IDAgfHwgKGJvZHkuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgeGkgPSBpbnRlcnNlY3RCb2R5X3hpO1xuICAgICAgICAgICAgICAgIHZhciBxaSA9IGludGVyc2VjdEJvZHlfcWk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgTiA9IGJvZHkuc2hhcGVzLmxlbmd0aDsgaSA8IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBib2R5LnNoYXBlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tDb2xsaXNpb25SZXNwb25zZSAmJiAhc2hhcGUuY29sbGlzaW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBib2R5LnF1YXRlcm5pb24ubXVsdChib2R5LnNoYXBlT3JpZW50YXRpb25zW2ldLCBxaSk7XG4gICAgICAgICAgICAgICAgICAgIGJvZHkucXVhdGVybmlvbi52bXVsdChib2R5LnNoYXBlT2Zmc2V0c1tpXSwgeGkpO1xuICAgICAgICAgICAgICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBxaSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW50ZXJzZWN0Qm9kaWVzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBib2RpZXMgQW4gYXJyYXkgb2YgQm9keSBvYmplY3RzLlxuICAgICAgICAgICAgICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm9kaWVzID0gZnVuY3Rpb24gKGJvZGllcywgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdEJvZHkoYm9kaWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZXMgdGhlIF9kaXJlY3Rpb24gdmVjdG9yLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBtZXRob2QgX3VwZGF0ZURpcmVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXkucHJvdG90eXBlLl91cGRhdGVEaXJlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50by52c3ViKHRoaXMuZnJvbSwgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICAgICAgICAgICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcblxuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmVcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb24oZnJvbSwgdGhpcy5fZGlyZWN0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBpbnRlcnNlY3RNZXRob2QgPSB0aGlzW3NoYXBlLnR5cGVdO1xuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RNZXRob2QpIHtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0TWV0aG9kLmNhbGwodGhpcywgc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdmVjdG9yID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBub3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdFBvaW50ID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgdmFyIGEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGMgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGQgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICB2YXIgdG1wUmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBpbnRlcnNlY3RCb3hcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm94ID0gZnVuY3Rpb24gKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVyc2VjdENvbnZleChzaGFwZS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHF1YXQsIHBvc2l0aW9uLCBib2R5KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdEJveDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGludGVyc2VjdFBsYW5lXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gYm9keVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdFBsYW5lID0gZnVuY3Rpb24gKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSkge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBwbGFuZSBub3JtYWxcbiAgICAgICAgICAgICAgICB2YXIgd29ybGROb3JtYWwgPSBuZXcgVmVjMygwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICBxdWF0LnZtdWx0KHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBmcm9tLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgICAgICAgICAgICAgdmFyIHBsYW5lVG9Gcm9tID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG4gICAgICAgICAgICAgICAgdG8udnN1Yihwb3NpdGlvbiwgbGVuKTtcbiAgICAgICAgICAgICAgICB2YXIgcGxhbmVUb1RvID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGxhbmVUb0Zyb20gKiBwbGFuZVRvVG8gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFwiZnJvbVwiIGFuZCBcInRvXCIgYXJlIG9uIHRoZSBzYW1lIHNpZGUgb2YgdGhlIHBsYW5lLi4uIGJhaWwgb3V0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5kaXN0YW5jZVRvKHRvKSA8IHBsYW5lVG9Gcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbl9kb3RfZGlyID0gd29ybGROb3JtYWwuZG90KGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMobl9kb3RfZGlyKSA8IHRoaXMucHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBsYW5lUG9pbnRUb0Zyb20gPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHZhciBkaXJfc2NhbGVkX3dpdGhfdCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGhpdFBvaW50V29ybGQgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgZnJvbS52c3ViKHBvc2l0aW9uLCBwbGFuZVBvaW50VG9Gcm9tKTtcbiAgICAgICAgICAgICAgICB2YXIgdCA9IC13b3JsZE5vcm1hbC5kb3QocGxhbmVQb2ludFRvRnJvbSkgLyBuX2RvdF9kaXI7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uLnNjYWxlKHQsIGRpcl9zY2FsZWRfd2l0aF90KTtcbiAgICAgICAgICAgICAgICBmcm9tLnZhZGQoZGlyX3NjYWxlZF93aXRoX3QsIGhpdFBvaW50V29ybGQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCAtMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFBsYW5lO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgd29ybGQgQUFCQiBvZiB0aGUgcmF5LlxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRBQUJCXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheS5wcm90b3R5cGUuZ2V0QUFCQiA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sb3dlckJvdW5kLnggPSBNYXRoLm1pbih0by54LCBmcm9tLngpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0by55LCBmcm9tLnkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sb3dlckJvdW5kLnogPSBNYXRoLm1pbih0by56LCBmcm9tLnopO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHBlckJvdW5kLnggPSBNYXRoLm1heCh0by54LCBmcm9tLngpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0by55LCBmcm9tLnkpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0by56LCBmcm9tLnopO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdENvbnZleE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgZmFjZUxpc3Q6IFswXVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGludGVyc2VjdEhlaWdodGZpZWxkXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gYm9keVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdEhlaWdodGZpZWxkID0gZnVuY3Rpb24gKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gc2hhcGUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdyA9IHNoYXBlLmVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICB3b3JsZFBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSByYXkgdG8gbG9jYWwgaGVpZ2h0ZmllbGQgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxSYXkgPSBuZXcgUmF5KHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBsb2NhbFJheS5mcm9tLCBsb2NhbFJheS5mcm9tKTtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGxvY2FsUmF5LnRvLCBsb2NhbFJheS50byk7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgaU1pblggPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBpTWluWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGlNYXhYID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgaU1heFkgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdmFyIGluc2lkZSA9IHNoYXBlLmdldEluZGV4T2ZQb3NpdGlvbihsb2NhbFJheS5mcm9tLngsIGxvY2FsUmF5LmZyb20ueSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlNaW5YID0gaW5kZXhbMF07XG4gICAgICAgICAgICAgICAgICAgIGlNaW5ZID0gaW5kZXhbMV07XG4gICAgICAgICAgICAgICAgICAgIGlNYXhYID0gaW5kZXhbMF07XG4gICAgICAgICAgICAgICAgICAgIGlNYXhZID0gaW5kZXhbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc2lkZSA9IHNoYXBlLmdldEluZGV4T2ZQb3NpdGlvbihsb2NhbFJheS50by54LCBsb2NhbFJheS50by55LCBpbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNaW5YID09PSBudWxsIHx8IGluZGV4WzBdIDwgaU1pblgpIHsgaU1pblggPSBpbmRleFswXTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaU1heFggPT09IG51bGwgfHwgaW5kZXhbMF0gPiBpTWF4WCkgeyBpTWF4WCA9IGluZGV4WzBdOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpTWluWSA9PT0gbnVsbCB8fCBpbmRleFsxXSA8IGlNaW5ZKSB7IGlNaW5ZID0gaW5kZXhbMV07IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNYXhZID09PSBudWxsIHx8IGluZGV4WzFdID4gaU1heFkpIHsgaU1heFkgPSBpbmRleFsxXTsgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpTWluWCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG1pbk1heCA9IFtdO1xuICAgICAgICAgICAgICAgIHNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbiA9IG1pbk1heFswXTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4ID0gbWluTWF4WzFdO1xuXG4gICAgICAgICAgICAgICAgLy8gLy8gQmFpbCBvdXQgaWYgdGhlIHJheSBjYW4ndCB0b3VjaCB0aGUgYm91bmRpbmcgYm94XG4gICAgICAgICAgICAgICAgLy8gLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vIHZhciBhYWJiID0gbmV3IEFBQkIoKTtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmdldEFBQkIoYWFiYik7XG4gICAgICAgICAgICAgICAgLy8gaWYoYWFiYi5pbnRlcnNlY3RzKCkpe1xuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGlNaW5YOyBpIDw9IGlNYXhYOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGlNaW5ZOyBqIDw9IGlNYXhZOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBzaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIGludGVyc2VjdENvbnZleE9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwcGVyIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLkhFSUdIVEZJRUxEXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0SGVpZ2h0ZmllbGQ7XG5cbiAgICAgICAgICAgIHZhciBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBpbnRlcnNlY3RTcGhlcmVcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheS5wcm90b3R5cGUuaW50ZXJzZWN0U3BoZXJlID0gZnVuY3Rpb24gKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSkge1xuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byA9IHRoaXMudG8sXG4gICAgICAgICAgICAgICAgICAgIHIgPSBzaGFwZS5yYWRpdXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgYSA9IE1hdGgucG93KHRvLnggLSBmcm9tLngsIDIpICsgTWF0aC5wb3codG8ueSAtIGZyb20ueSwgMikgKyBNYXRoLnBvdyh0by56IC0gZnJvbS56LCAyKTtcbiAgICAgICAgICAgICAgICB2YXIgYiA9IDIgKiAoKHRvLnggLSBmcm9tLngpICogKGZyb20ueCAtIHBvc2l0aW9uLngpICsgKHRvLnkgLSBmcm9tLnkpICogKGZyb20ueSAtIHBvc2l0aW9uLnkpICsgKHRvLnogLSBmcm9tLnopICogKGZyb20ueiAtIHBvc2l0aW9uLnopKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IE1hdGgucG93KGZyb20ueCAtIHBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3coZnJvbS55IC0gcG9zaXRpb24ueSwgMikgKyBNYXRoLnBvdyhmcm9tLnogLSBwb3NpdGlvbi56LCAyKSAtIE1hdGgucG93KHIsIDIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG5cbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50O1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbDtcblxuICAgICAgICAgICAgICAgIGlmIChkZWx0YSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGVsdGEgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGludGVyc2VjdGlvbiBwb2ludFxuICAgICAgICAgICAgICAgICAgICBmcm9tLmxlcnAodG8sIGRlbHRhLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0aW9uUG9pbnQudnN1Yihwb3NpdGlvbiwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKG5vcm1hbCwgaW50ZXJzZWN0aW9uUG9pbnQsIHNoYXBlLCBib2R5LCAtMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZDEgPSAoLSBiIC0gTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZDIgPSAoLSBiICsgTWF0aC5zcXJ0KGRlbHRhKSkgLyAoMiAqIGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkMSA+PSAwICYmIGQxIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoZDIgPj0gMCAmJiBkMiA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tLmxlcnAodG8sIGQyLCBpbnRlcnNlY3Rpb25Qb2ludCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgc2hhcGUsIGJvZHksIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBSYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRV0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFNwaGVyZTtcblxuXG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0Q29udmV4X25vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0Q29udmV4X21pbkRpc3ROb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdENvbnZleF9taW5EaXN0SW50ZXJzZWN0ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RDb252ZXhfdmVjdG9yID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGludGVyc2VjdENvbnZleFxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmZhY2VMaXN0XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXkucHJvdG90eXBlLmludGVyc2VjdENvbnZleCA9IGZ1bmN0aW9uIGludGVyc2VjdENvbnZleChcbiAgICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgICBxdWF0LFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X25vcm1hbDtcbiAgICAgICAgICAgICAgICB2YXIgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjtcbiAgICAgICAgICAgICAgICB2YXIgbWluRGlzdEludGVyc2VjdCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0SW50ZXJzZWN0O1xuICAgICAgICAgICAgICAgIHZhciBmYWNlTGlzdCA9IChvcHRpb25zICYmIG9wdGlvbnMuZmFjZUxpc3QpIHx8IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvLyBDaGVja2luZyBmYWNlc1xuICAgICAgICAgICAgICAgIHZhciBmYWNlcyA9IHNoYXBlLmZhY2VzLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IHNoYXBlLnZlcnRpY2VzLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzID0gc2hhcGUuZmFjZU5vcm1hbHM7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgICAgICAgICAgICAgdmFyIGZyb21Ub0Rpc3RhbmNlID0gZnJvbS5kaXN0YW5jZVRvKHRvKTtcblxuICAgICAgICAgICAgICAgIHZhciBtaW5EaXN0ID0gLTE7XG4gICAgICAgICAgICAgICAgdmFyIE5mYWNlcyA9IGZhY2VMaXN0ID8gZmFjZUxpc3QubGVuZ3RoIDogZmFjZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyAhcmVzdWx0Ll9zaG91bGRTdG9wICYmIGogPCBOZmFjZXM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdCA/IGZhY2VMaXN0W2pdIDogajtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzW2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhY2VOb3JtYWwgPSBub3JtYWxzW2ZpXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHEgPSBxdWF0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IHBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2VcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90ZTogdGhpcyB3b3JrcyByZWdhcmRsZXNzIG9mIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGZhY2Ugbm9ybWFsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHBsYW5lIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLi4uXG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvci5jb3B5KHZlcnRpY2VzW2ZhY2VbMF1dKTtcbiAgICAgICAgICAgICAgICAgICAgcS52bXVsdCh2ZWN0b3IsIHZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgIHZlY3Rvci52YWRkKHgsIHZlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IG1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIHJheSBmcm9tLiBXZSdsbCBmaXggdGhpcyBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgdmVjdG9yLnZzdWIoZnJvbSwgdmVjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgcGxhbmUgbm9ybWFsXG4gICAgICAgICAgICAgICAgICAgIHEudm11bHQoZmFjZU5vcm1hbCwgbm9ybWFsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90ID0gZGlyZWN0aW9uLmRvdChub3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsXG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkb3QpIDwgdGhpcy5wcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGFyID0gbm9ybWFsLmRvdCh2ZWN0b3IpIC8gZG90O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxhciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGRvdCA8IDApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcnNlY3Rpb24gcG9pbnQgaXMgZnJvbSArIGRpcmVjdGlvbiAqIHNjYWxhclxuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb24ubXVsdChzY2FsYXIsIGludGVyc2VjdFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJzZWN0UG9pbnQudmFkZChmcm9tLCBpbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYSBpcyB0aGUgcG9pbnQgd2UgY29tcGFyZSBwb2ludHMgYiBhbmQgYyB3aXRoLlxuICAgICAgICAgICAgICAgICAgICBhLmNvcHkodmVydGljZXNbZmFjZVswXV0pO1xuICAgICAgICAgICAgICAgICAgICBxLnZtdWx0KGEsIGEpO1xuICAgICAgICAgICAgICAgICAgICB4LnZhZGQoYSwgYSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7ICFyZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGZhY2UubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gMyB2ZXJ0aWNlcyB0byB3b3JsZCBjb29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuY29weSh2ZXJ0aWNlc1tmYWNlW2ldXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjLmNvcHkodmVydGljZXNbZmFjZVtpICsgMV1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHEudm11bHQoYiwgYik7XG4gICAgICAgICAgICAgICAgICAgICAgICBxLnZtdWx0KGMsIGMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeC52YWRkKGIsIGIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeC52YWRkKGMsIGMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnRlcnNlY3RQb2ludC5kaXN0YW5jZVRvKGZyb20pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGMpIHx8IHBvaW50SW5UcmlhbmdsZShpbnRlcnNlY3RQb2ludCwgYiwgYSwgYykpIHx8IGRpc3RhbmNlID4gZnJvbVRvRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3RQb2ludCwgc2hhcGUsIGJvZHksIGZpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdENvbnZleDtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RUcmltZXNoX3dvcmxkSW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCID0gbmV3IEFBQkIoKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGludGVyc2VjdFRyaW1lc2hcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAgICAgKiBAdG9kbyBPcHRpbWl6ZSBieSB0cmFuc2Zvcm1pbmcgdGhlIHdvcmxkIHRvIGxvY2FsIHNwYWNlIGZpcnN0LlxuICAgICAgICAgICAgICogQHRvZG8gVXNlIE9jdHJlZSBsb29rdXBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RUcmltZXNoID0gZnVuY3Rpb24gaW50ZXJzZWN0VHJpbWVzaChcbiAgICAgICAgICAgICAgICBtZXNoLFxuICAgICAgICAgICAgICAgIHF1YXQsXG4gICAgICAgICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gaW50ZXJzZWN0VHJpbWVzaF9ub3JtYWw7XG4gICAgICAgICAgICAgICAgdmFyIHRyaWFuZ2xlcyA9IGludGVyc2VjdFRyaW1lc2hfdHJpYW5nbGVzO1xuICAgICAgICAgICAgICAgIHZhciB0cmVlVHJhbnNmb3JtID0gaW50ZXJzZWN0VHJpbWVzaF90cmVlVHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIHZhciBtaW5EaXN0Tm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X21pbkRpc3ROb3JtYWw7XG4gICAgICAgICAgICAgICAgdmFyIHZlY3RvciA9IGludGVyc2VjdENvbnZleF92ZWN0b3I7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkRpc3RJbnRlcnNlY3QgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdEludGVyc2VjdDtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxBQUJCID0gaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEFBQkI7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsRGlyZWN0aW9uID0gaW50ZXJzZWN0VHJpbWVzaF9sb2NhbERpcmVjdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxGcm9tID0gaW50ZXJzZWN0VHJpbWVzaF9sb2NhbEZyb207XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FsVG8gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsVG87XG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkSW50ZXJzZWN0UG9pbnQgPSBpbnRlcnNlY3RUcmltZXNoX3dvcmxkSW50ZXJzZWN0UG9pbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkTm9ybWFsID0gaW50ZXJzZWN0VHJpbWVzaF93b3JsZE5vcm1hbDtcbiAgICAgICAgICAgICAgICB2YXIgZmFjZUxpc3QgPSAob3B0aW9ucyAmJiBvcHRpb25zLmZhY2VMaXN0KSB8fCBudWxsO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2tpbmcgZmFjZXNcbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IG1lc2guaW5kaWNlcyxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXMgPSBtZXNoLnZlcnRpY2VzLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzID0gbWVzaC5mYWNlTm9ybWFscztcblxuICAgICAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuICAgICAgICAgICAgICAgIHZhciBtaW5EaXN0ID0gLTE7XG4gICAgICAgICAgICAgICAgdHJlZVRyYW5zZm9ybS5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICB0cmVlVHJhbnNmb3JtLnF1YXRlcm5pb24uY29weShxdWF0KTtcblxuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSByYXkgdG8gbG9jYWwgc3BhY2UhXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZGlyZWN0aW9uLCBsb2NhbERpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgLy9ib2R5LnZlY3RvclRvTG9jYWxGcmFtZShkaXJlY3Rpb24sIGxvY2FsRGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIGZyb20sIGxvY2FsRnJvbSk7XG4gICAgICAgICAgICAgICAgLy9ib2R5LnBvaW50VG9Mb2NhbEZyYW1lKGZyb20sIGxvY2FsRnJvbSk7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCB0bywgbG9jYWxUbyk7XG4gICAgICAgICAgICAgICAgLy9ib2R5LnBvaW50VG9Mb2NhbEZyYW1lKHRvLCBsb2NhbFRvKTtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbVRvRGlzdGFuY2VTcXVhcmVkID0gbG9jYWxGcm9tLmRpc3RhbmNlU3F1YXJlZChsb2NhbFRvKTtcblxuICAgICAgICAgICAgICAgIG1lc2gudHJlZS5yYXlRdWVyeSh0aGlzLCB0cmVlVHJhbnNmb3JtLCB0cmlhbmdsZXMpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIE4gPSB0cmlhbmdsZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbmdsZXNJbmRleCA9IHRyaWFuZ2xlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBtZXNoLmdldE5vcm1hbCh0cmlhbmdsZXNJbmRleCwgbm9ybWFsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgaWYgcmF5IGludGVyc2VjdHMgdGhlIHBsYW5lIG9mIHRoZSBmYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBwbGFuZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy4uLlxuICAgICAgICAgICAgICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogM10sIGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC4uLmJ1dCBtYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSByYXkgZnJvbS4gV2UnbGwgZml4IHRoaXMgbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgIGEudnN1Yihsb2NhbEZyb20sIHZlY3Rvcik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHBsYW5lIG5vcm1hbFxuICAgICAgICAgICAgICAgICAgICAvLyBxdWF0LnZtdWx0KG5vcm1hbCwgbm9ybWFsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90ID0gbG9jYWxEaXJlY3Rpb24uZG90KG5vcm1hbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgaWYgcmF5IGFuZCBwbGFuZSBhcmUgcGFyYWxsZWxcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKE1hdGguYWJzKCBkb3QgKSA8IHRoaXMucHJlY2lzaW9uKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZVxuICAgICAgICAgICAgICAgICAgICB2YXIgc2NhbGFyID0gbm9ybWFsLmRvdCh2ZWN0b3IpIC8gZG90O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNjYWxhciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxEaXJlY3Rpb24uc2NhbGUoc2NhbGFyLCBpbnRlcnNlY3RQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQobG9jYWxGcm9tLCBpbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRyaWFuZ2xlIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgIG1lc2guZ2V0VmVydGV4KGluZGljZXNbdHJpYW5nbGVzSW5kZXggKiAzICsgMV0sIGIpO1xuICAgICAgICAgICAgICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDJdLCBjKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgc3F1YXJlZERpc3RhbmNlID0gaW50ZXJzZWN0UG9pbnQuZGlzdGFuY2VTcXVhcmVkKGxvY2FsRnJvbSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGMpKSB8fCBzcXVhcmVkRGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtIGludGVyc2VjdHBvaW50IGFuZCBub3JtYWwgdG8gd29ybGRcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZShxdWF0LCBub3JtYWwsIHdvcmxkTm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgLy9ib2R5LnZlY3RvclRvV29ybGRGcmFtZShub3JtYWwsIHdvcmxkTm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBpbnRlcnNlY3RQb2ludCwgd29ybGRJbnRlcnNlY3RQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIC8vYm9keS5wb2ludFRvV29ybGRGcmFtZShpbnRlcnNlY3RQb2ludCwgd29ybGRJbnRlcnNlY3RQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0SW50ZXJzZWN0aW9uKHdvcmxkTm9ybWFsLCB3b3JsZEludGVyc2VjdFBvaW50LCBtZXNoLCBib2R5LCB0cmlhbmdsZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuVFJJTUVTSF0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdFRyaW1lc2g7XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlcG9ydEludGVyc2VjdGlvblxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IG5vcm1hbFxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gaGl0UG9pbnRXb3JsZFxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBpbnRlcnNlY3Rpb25zIHNob3VsZCBjb250aW51ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXkucHJvdG90eXBlLnJlcG9ydEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChub3JtYWwsIGhpdFBvaW50V29ybGQsIHNoYXBlLCBib2R5LCBoaXRGYWNlSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICAgICAgICAgICAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAvLyBTa2lwIGJhY2sgZmFjZXM/XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2tpcEJhY2tmYWNlcyAmJiBub3JtYWwuZG90KHRoaXMuX2RpcmVjdGlvbikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXN1bHQuaGl0RmFjZUluZGV4ID0gdHlwZW9mIChoaXRGYWNlSW5kZXgpICE9PSAndW5kZWZpbmVkJyA/IGhpdEZhY2VJbmRleCA6IC0xO1xuXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgUmF5LkNMT1NFU1Q6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlIHx8ICFyZXN1bHQuaGFzSGl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFJheS5BTlk6XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5oYXNIaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuX3Nob3VsZFN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHYwID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3QgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgZnVuY3Rpb24gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIGRpcmVjdGlvbiwgcG9zaXRpb24pIHtcblxuICAgICAgICAgICAgICAgIC8vIHYwIGlzIHZlY3RvciBmcm9tIGZyb20gdG8gcG9zaXRpb25cbiAgICAgICAgICAgICAgICBwb3NpdGlvbi52c3ViKGZyb20sIHYwKTtcbiAgICAgICAgICAgICAgICB2YXIgZG90ID0gdjAuZG90KGRpcmVjdGlvbik7XG5cbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3QgPSBkaXJlY3Rpb24qZG90ICsgZnJvbVxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbi5tdWx0KGRvdCwgaW50ZXJzZWN0KTtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3QudmFkZChmcm9tLCBpbnRlcnNlY3QpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlID0gcG9zaXRpb24uZGlzdGFuY2VUbyhpbnRlcnNlY3QpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgfSwgeyBcIi4uL2NvbGxpc2lvbi9BQUJCXCI6IDMsIFwiLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHRcIjogMTAsIFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6IDI4LCBcIi4uL21hdGgvVHJhbnNmb3JtXCI6IDI5LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi9zaGFwZXMvQm94XCI6IDM3LCBcIi4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uXCI6IDM4LCBcIi4uL3NoYXBlcy9TaGFwZVwiOiA0MyB9XSwgMTA6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgZGF0YS5cbiAgICAgICAgICAgICAqIEBjbGFzcyBSYXljYXN0UmVzdWx0XG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gUmF5Y2FzdFJlc3VsdCgpIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcmF5RnJvbVdvcmxkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5yYXlGcm9tV29ybGQgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzfSByYXlUb1dvcmxkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5yYXlUb1dvcmxkID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaGl0Tm9ybWFsV29ybGRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmhpdE5vcm1hbFdvcmxkID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaGl0UG9pbnRXb3JsZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc0hpdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzSGl0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaGl0IHNoYXBlLCBvciBudWxsLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7U2hhcGV9IHNoYXBlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaGl0IGJvZHksIG9yIG51bGwuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5ID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBpbmRleCBvZiB0aGUgaGl0IHRyaWFuZ2xlLCBpZiB0aGUgaGl0IHNoYXBlIHdhcyBhIHRyaW1lc2guXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGhpdEZhY2VJbmRleFxuICAgICAgICAgICAgICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERpc3RhbmNlIHRvIHRoZSBoaXQuIFdpbGwgYmUgc2V0IHRvIC0xIGlmIHRoZXJlIHdhcyBubyBoaXQuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICogQGRlZmF1bHQgLTFcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3RhbmNlID0gLTE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgcmF5IHNob3VsZCBzdG9wIHRyYXZlcnNpbmcgdGhlIGJvZGllcy5cbiAgICAgICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gX3Nob3VsZFN0b3BcbiAgICAgICAgICAgICAgICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNldCBhbGwgcmVzdWx0IGRhdGEuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlc2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmF5RnJvbVdvcmxkLnNldFplcm8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJheVRvV29ybGQuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGl0Tm9ybWFsV29ybGQuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGl0UG9pbnRXb3JsZC5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuaGl0RmFjZUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0YW5jZSA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBhYm9ydFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXljYXN0UmVzdWx0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG91bGRTdG9wID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gcmF5RnJvbVdvcmxkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHJheVRvV29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gaGl0Tm9ybWFsV29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gaGl0UG9pbnRXb3JsZFxuICAgICAgICAgICAgICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgICAgICByYXlGcm9tV29ybGQsXG4gICAgICAgICAgICAgICAgcmF5VG9Xb3JsZCxcbiAgICAgICAgICAgICAgICBoaXROb3JtYWxXb3JsZCxcbiAgICAgICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmF5RnJvbVdvcmxkLmNvcHkocmF5RnJvbVdvcmxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJheVRvV29ybGQuY29weShyYXlUb1dvcmxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpdE5vcm1hbFdvcmxkLmNvcHkoaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGl0UG9pbnRXb3JsZC5jb3B5KGhpdFBvaW50V29ybGQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGUgPSBzaGFwZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuLi9tYXRoL1ZlYzNcIjogMzAgfV0sIDExOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgdmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJyk7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gU0FQQnJvYWRwaGFzZTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1dvcmxkfSBbd29ybGRdXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNBUEJyb2FkcGhhc2Uod29ybGQpIHtcbiAgICAgICAgICAgICAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTGlzdCBvZiBib2RpZXMgY3VycmVudGx5IGluIHRoZSBicm9hZHBoYXNlLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBheGlzTGlzdFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmF4aXNMaXN0ID0gW107XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgd29ybGQgdG8gc2VhcmNoIGluLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB3b3JsZFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEF4aXMgdG8gc29ydCB0aGUgYm9kaWVzIGFsb25nLiBTZXQgdG8gMCBmb3IgeCBheGlzLCBhbmQgMSBmb3IgeSBheGlzLiBGb3IgYmVzdCBwZXJmb3JtYW5jZSwgY2hvb3NlIGFuIGF4aXMgdGhhdCB0aGUgYm9kaWVzIGFyZSBzcHJlYWQgb3V0IG1vcmUgb24uXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGF4aXNJbmRleFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5heGlzSW5kZXggPSAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXhpc0xpc3QucHVzaChlLmJvZHkpO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpZHggPSBheGlzTGlzdC5pbmRleE9mKGUuYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGlzTGlzdC5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAod29ybGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRXb3JsZCh3b3JsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUgPSBuZXcgQnJvYWRwaGFzZSgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoYW5nZSB0aGUgd29ybGRcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0V29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCkge1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgICAgICAgICAgICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29ybGQuYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXhpc0xpc3QucHVzaCh3b3JsZC5ib2RpZXNbaV0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBvbGQgaGFuZGxlcnMsIGlmIGFueVxuICAgICAgICAgICAgICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB3b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVtb3ZlQm9keVwiLCB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cbiAgICAgICAgICAgICAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKFwiYWRkQm9keVwiLCB0aGlzLl9hZGRCb2R5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZUJvZHlcIiwgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGluc2VydGlvblNvcnRYXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gYVxuICAgICAgICAgICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFggPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxLCBsID0gYS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYVtqXS5hYWJiLmxvd2VyQm91bmQueCA8PSB2LmFhYmIubG93ZXJCb3VuZC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhW2ogKyAxXSA9IGFbal07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYVtqICsgMV0gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQG1ldGhvZCBpbnNlcnRpb25Tb3J0WVxuICAgICAgICAgICAgICogQHBhcmFtICB7QXJyYXl9IGFcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMSwgbCA9IGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gYVtpXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFbal0uYWFiYi5sb3dlckJvdW5kLnkgPD0gdi5hYWJiLmxvd2VyQm91bmQueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYVtqICsgMV0gPSBhW2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFbaiArIDFdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBtZXRob2QgaW5zZXJ0aW9uU29ydFpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0FycmF5fSBhXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WiA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDEsIGwgPSBhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGFbaV07XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhW2pdLmFhYmIubG93ZXJCb3VuZC56IDw9IHYuYWFiYi5sb3dlckJvdW5kLnopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFbaiArIDFdID0gYVtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhW2ogKyAxXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb2xsZWN0IGFsbCBjb2xsaXNpb24gcGFpcnNcbiAgICAgICAgICAgICAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICogQHBhcmFtICB7QXJyYXl9IHAxXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbiAod29ybGQsIHAxLCBwMikge1xuICAgICAgICAgICAgICAgIHZhciBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgICAgICAgICAgICAgICAgICBOID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGksIGo7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvcnRMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBMb29rIHRocm91Z2ggdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgTjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSwgYmopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyhiaSwgYmosIGF4aXNJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLCBiaiwgcDEsIHAyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNvcnRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzTGlzdCA9IHRoaXMuYXhpc0xpc3Q7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4O1xuICAgICAgICAgICAgICAgIHZhciBOID0gYXhpc0xpc3QubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIEFBQkJzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmkgPSBheGlzTGlzdFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpLmFhYmJOZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmkuY29tcHV0ZUFBQkIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNvcnQgdGhlIGxpc3RcbiAgICAgICAgICAgICAgICBpZiAoYXhpc0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFgoYXhpc0xpc3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXhpc0luZGV4ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFkoYXhpc0xpc3QpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXhpc0luZGV4ID09PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFooYXhpc0xpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIGJvdW5kcyBvZiB0d28gYm9kaWVzIG92ZXJsYXAsIGFsb25nIHRoZSBnaXZlbiBTQVAgYXhpcy5cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBtZXRob2QgY2hlY2tCb3VuZHNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9IGJpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSBialxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBheGlzSW5kZXhcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNBUEJyb2FkcGhhc2UuY2hlY2tCb3VuZHMgPSBmdW5jdGlvbiAoYmksIGJqLCBheGlzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYmlQb3M7XG4gICAgICAgICAgICAgICAgdmFyIGJqUG9zO1xuXG4gICAgICAgICAgICAgICAgaWYgKGF4aXNJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24ueDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLnk7XG4gICAgICAgICAgICAgICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF4aXNJbmRleCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLno7XG4gICAgICAgICAgICAgICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24uejtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmkgPSBiaS5ib3VuZGluZ1JhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgcmogPSBiai5ib3VuZGluZ1JhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRBMSA9IGJpUG9zIC0gcmksXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLFxuICAgICAgICAgICAgICAgICAgICBib3VuZEIxID0gYmpQb3MgLSByaixcbiAgICAgICAgICAgICAgICAgICAgYm91bmRCMiA9IGJqUG9zICsgcmo7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYm91bmRCMSA8IGJvdW5kQTI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbXB1dGVzIHRoZSB2YXJpYW5jZSBvZiB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIGVzdGltYXRlcyB0aGUgYmVzdFxuICAgICAgICAgICAgICogYXhpcyB0byB1c2UuIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgLmF4aXNJbmRleC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYXV0b0RldGVjdEF4aXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYXV0b0RldGVjdEF4aXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bVggPSAwLFxuICAgICAgICAgICAgICAgICAgICBzdW1YMiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1bVkgPSAwLFxuICAgICAgICAgICAgICAgICAgICBzdW1ZMiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1bVogPSAwLFxuICAgICAgICAgICAgICAgICAgICBzdW1aMiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgICAgICAgICAgICAgICAgIE4gPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpbnZOID0gMSAvIE47XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJYID0gYi5wb3NpdGlvbi54O1xuICAgICAgICAgICAgICAgICAgICBzdW1YICs9IGNlbnRlclg7XG4gICAgICAgICAgICAgICAgICAgIHN1bVgyICs9IGNlbnRlclggKiBjZW50ZXJYO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJZID0gYi5wb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgICAgICBzdW1ZICs9IGNlbnRlclk7XG4gICAgICAgICAgICAgICAgICAgIHN1bVkyICs9IGNlbnRlclkgKiBjZW50ZXJZO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjZW50ZXJaID0gYi5wb3NpdGlvbi56O1xuICAgICAgICAgICAgICAgICAgICBzdW1aICs9IGNlbnRlclo7XG4gICAgICAgICAgICAgICAgICAgIHN1bVoyICs9IGNlbnRlclogKiBjZW50ZXJaO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB2YXJpYW5jZVggPSBzdW1YMiAtIHN1bVggKiBzdW1YICogaW52TixcbiAgICAgICAgICAgICAgICAgICAgdmFyaWFuY2VZID0gc3VtWTIgLSBzdW1ZICogc3VtWSAqIGludk4sXG4gICAgICAgICAgICAgICAgICAgIHZhcmlhbmNlWiA9IHN1bVoyIC0gc3VtWiAqIHN1bVogKiBpbnZOO1xuXG4gICAgICAgICAgICAgICAgaWYgKHZhcmlhbmNlWCA+IHZhcmlhbmNlWSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFyaWFuY2VYID4gdmFyaWFuY2VaKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhcmlhbmNlWSA+IHZhcmlhbmNlWikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF4aXNJbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5heGlzSW5kZXggPSAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gYW4gQUFCQi5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBbiBhcnJheSB0byBzdG9yZSByZXN1bHRpbmcgYm9kaWVzIGluLlxuICAgICAgICAgICAgICogQHJldHVybiB7YXJyYXl9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNBUEJyb2FkcGhhc2UucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uICh3b3JsZCwgYWFiYiwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb3J0TGlzdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4LCBheGlzID0gJ3gnO1xuICAgICAgICAgICAgICAgIGlmIChheGlzSW5kZXggPT09IDEpIHsgYXhpcyA9ICd5JzsgfVxuICAgICAgICAgICAgICAgIGlmIChheGlzSW5kZXggPT09IDIpIHsgYXhpcyA9ICd6JzsgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcbiAgICAgICAgICAgICAgICB2YXIgbG93ZXIgPSBhYWJiLmxvd2VyQm91bmRbYXhpc107XG4gICAgICAgICAgICAgICAgdmFyIHVwcGVyID0gYWFiYi51cHBlckJvdW5kW2F4aXNdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhpc0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5hYWJiTmVlZHNVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIuY29tcHV0ZUFBQkIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLmFhYmIub3ZlcmxhcHMoYWFiYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOiA1LCBcIi4uL3NoYXBlcy9TaGFwZVwiOiA0MyB9XSwgMTI6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IENvbmVUd2lzdENvbnN0cmFpbnQ7XG5cbiAgICAgICAgICAgIHZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XG4gICAgICAgICAgICB2YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IF9kZXJlcV8oJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xuICAgICAgICAgICAgdmFyIENvbmVFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db25lRXF1YXRpb24nKTtcbiAgICAgICAgICAgIHZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XG4gICAgICAgICAgICB2YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2xhc3MgQ29uZVR3aXN0Q29uc3RyYWludFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90QV1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RCXVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICAgICAgICAgICAgICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBDb25lVHdpc3RDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZiAob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgdmFyIHBpdm90QSA9IG9wdGlvbnMucGl2b3RBID8gb3B0aW9ucy5waXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBpdm90QiA9IG9wdGlvbnMucGl2b3RCID8gb3B0aW9ucy5waXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5heGlzQSA9IG9wdGlvbnMuYXhpc0EgPyBvcHRpb25zLmF4aXNBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgcGl2b3RBLCBib2R5QiwgcGl2b3RCLCBtYXhGb3JjZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSAhIW9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDtcblxuICAgICAgICAgICAgICAgIHRoaXMuYW5nbGUgPSB0eXBlb2YgKG9wdGlvbnMuYW5nbGUpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtDb25lRXF1YXRpb259IGNvbmVFcXVhdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5jb25lRXF1YXRpb24gPSBuZXcgQ29uZUVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gdHdpc3RFcXVhdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB0ID0gdGhpcy50d2lzdEVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMudHdpc3RBbmdsZSA9IHR5cGVvZiAob3B0aW9ucy50d2lzdEFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnR3aXN0QW5nbGUgOiAwO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgY29uZSBlcXVhdGlvbiBwdXNoIHRoZSBib2RpZXMgdG93YXJkIHRoZSBjb25lIGF4aXMsIG5vdCBvdXR3YXJkXG4gICAgICAgICAgICAgICAgYy5tYXhGb3JjZSA9IDA7XG4gICAgICAgICAgICAgICAgYy5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcblxuICAgICAgICAgICAgICAgIC8vIE1ha2UgdGhlIHR3aXN0IGVxdWF0aW9uIGFkZCB0b3JxdWUgdG93YXJkIHRoZSBpbml0aWFsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdC5tYXhGb3JjZSA9IDA7XG4gICAgICAgICAgICAgICAgdC5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goYywgdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDb25lVHdpc3RDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XG4gICAgICAgICAgICBDb25lVHdpc3RDb25zdHJhaW50LmNvbnN0cnVjdG9yID0gQ29uZVR3aXN0Q29uc3RyYWludDtcblxuICAgICAgICAgICAgdmFyIENvbmVUd2lzdENvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIENvbmVUd2lzdENvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICBDb25lVHdpc3RDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgICAgICAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgICAgICAgICBjb25lID0gdGhpcy5jb25lRXF1YXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHR3aXN0ID0gdGhpcy50d2lzdEVxdWF0aW9uO1xuXG4gICAgICAgICAgICAgICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGF4ZXMgdG8gdGhlIGNvbmUgY29uc3RyYWludFxuICAgICAgICAgICAgICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNBLCBjb25lLmF4aXNBKTtcbiAgICAgICAgICAgICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodGhpcy5heGlzQiwgY29uZS5heGlzQik7XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHdvcmxkIGF4ZXMgaW4gdGhlIHR3aXN0IGNvbnN0cmFpbnRcbiAgICAgICAgICAgICAgICB0aGlzLmF4aXNBLnRhbmdlbnRzKHR3aXN0LmF4aXNBLCB0d2lzdC5heGlzQSk7XG4gICAgICAgICAgICAgICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKHR3aXN0LmF4aXNBLCB0d2lzdC5heGlzQSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmF4aXNCLnRhbmdlbnRzKHR3aXN0LmF4aXNCLCB0d2lzdC5heGlzQik7XG4gICAgICAgICAgICAgICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKHR3aXN0LmF4aXNCLCB0d2lzdC5heGlzQik7XG5cbiAgICAgICAgICAgICAgICBjb25lLmFuZ2xlID0gdGhpcy5hbmdsZTtcbiAgICAgICAgICAgICAgICB0d2lzdC5tYXhBbmdsZSA9IHRoaXMudHdpc3RBbmdsZTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICB9LCB7IFwiLi4vZXF1YXRpb25zL0NvbmVFcXVhdGlvblwiOiAxOCwgXCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6IDE5LCBcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb25cIjogMjIsIFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4vQ29uc3RyYWludFwiOiAxMywgXCIuL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjogMTcgfV0sIDEzOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBDb25zdHJhaW50O1xuXG4gICAgICAgICAgICB2YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cmFpbnQgYmFzZSBjbGFzc1xuICAgICAgICAgICAgICogQGNsYXNzIENvbnN0cmFpbnRcbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGVcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jb2xsaWRlQ29ubmVjdGVkPXRydWVdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndha2VVcEJvZGllcz10cnVlXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHdha2VVcEJvZGllczogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEVxdWF0aW9ucyB0byBiZSBzb2x2ZWQgaW4gdGhpcyBjb25zdHJhaW50XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb2R5fSBib2R5QVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keUEgPSBib2R5QTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keUJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlCID0gYm9keUI7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gaWRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gQ29uc3RyYWludC5pZENvdW50ZXIrKztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRoZSBib2RpZXMgdG8gY29sbGlkZSB3aGVuIHRoZXkgYXJlIGNvbm5lY3RlZC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgY29sbGlkZUNvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlkZUNvbm5lY3RlZCA9IG9wdGlvbnMuY29sbGlkZUNvbm5lY3RlZDtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndha2VVcEJvZGllcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChib2R5Qikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIud2FrZVVwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIGFsbCB0aGUgZXF1YXRpb25zIHdpdGggZGF0YS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgdXBkYXRlKCkgbm90IGltcGxtZW1lbnRlZCBpbiB0aGlzIENvbnN0cmFpbnQgc3ViY2xhc3MhXCIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbmFibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGVuYWJsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVxc1tpXS5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpc2FibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGRpc2FibGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXFzID0gdGhpcy5lcXVhdGlvbnM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXFzW2ldLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBDb25zdHJhaW50LmlkQ291bnRlciA9IDA7XG5cbiAgICAgICAgfSwgeyBcIi4uL3V0aWxzL1V0aWxzXCI6IDUzIH1dLCAxNDogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VDb25zdHJhaW50O1xuXG4gICAgICAgICAgICB2YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpO1xuICAgICAgICAgICAgdmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25zdHJhaW5zIHR3byBib2RpZXMgdG8gYmUgYXQgYSBjb25zdGFudCBkaXN0YW5jZSBmcm9tIGVhY2ggb3RoZXJzIGNlbnRlciBvZiBtYXNzLlxuICAgICAgICAgICAgICogQGNsYXNzIERpc3RhbmNlQ29uc3RyYWludFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW2Rpc3RhbmNlXSBUaGUgZGlzdGFuY2UgdG8ga2VlcC4gSWYgdW5kZWZpbmVkLCBpdCB3aWxsIGJlIHNldCB0byB0aGUgY3VycmVudCBkaXN0YW5jZSBiZXR3ZWVuIGJvZHlBIGFuZCBib2R5QlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhGb3JjZT0xZTZdXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIERpc3RhbmNlQ29uc3RyYWludChib2R5QSwgYm9keUIsIGRpc3RhbmNlLCBtYXhGb3JjZSkge1xuICAgICAgICAgICAgICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLCBib2R5QSwgYm9keUIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZGlzdGFuY2UpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gYm9keUEucG9zaXRpb24uZGlzdGFuY2VUbyhib2R5Qi5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobWF4Rm9yY2UpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heEZvcmNlID0gMWU2O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXN0YW5jZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBkaXN0YW5jZUVxdWF0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGVxID0gdGhpcy5kaXN0YW5jZUVxdWF0aW9uID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBpdCBiaWRpcmVjdGlvbmFsXG4gICAgICAgICAgICAgICAgZXEubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgICAgICAgICAgICAgZXEubWF4Rm9yY2UgPSBtYXhGb3JjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIERpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuXG4gICAgICAgICAgICBEaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBO1xuICAgICAgICAgICAgICAgIHZhciBib2R5QiA9IHRoaXMuYm9keUI7XG4gICAgICAgICAgICAgICAgdmFyIGVxID0gdGhpcy5kaXN0YW5jZUVxdWF0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBoYWxmRGlzdCA9IHRoaXMuZGlzdGFuY2UgKiAwLjU7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IGVxLm5pO1xuXG4gICAgICAgICAgICAgICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbiwgbm9ybWFsKTtcbiAgICAgICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgbm9ybWFsLm11bHQoaGFsZkRpc3QsIGVxLnJpKTtcbiAgICAgICAgICAgICAgICBub3JtYWwubXVsdCgtaGFsZkRpc3QsIGVxLnJqKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6IDE5LCBcIi4vQ29uc3RyYWludFwiOiAxMyB9XSwgMTU6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEhpbmdlQ29uc3RyYWludDtcblxuICAgICAgICAgICAgdmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKTtcbiAgICAgICAgICAgIHZhciBQb2ludFRvUG9pbnRDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50Jyk7XG4gICAgICAgICAgICB2YXIgUm90YXRpb25hbEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvbicpO1xuICAgICAgICAgICAgdmFyIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uJyk7XG4gICAgICAgICAgICB2YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIaW5nZSBjb25zdHJhaW50LiBUaGluayBvZiBpdCBhcyBhIGRvb3IgaGluZ2UuIEl0IHRyaWVzIHRvIGtlZXAgdGhlIGRvb3IgaW4gdGhlIGNvcnJlY3QgcGxhY2UgYW5kIHdpdGggdGhlIGNvcnJlY3Qgb3JpZW50YXRpb24uXG4gICAgICAgICAgICAgKiBAY2xhc3MgSGluZ2VDb25zdHJhaW50XG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RBXSBBIHBvaW50IGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS4gVGhpcyBkZWZpbmVzIHRoZSBvZmZzZXQgb2YgYXhpc0EuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXSBBbiBheGlzIHRoYXQgYm9keUEgY2FuIHJvdGF0ZSBhcm91bmQsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5QS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RCXVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQl1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIEhpbmdlQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2YgKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG4gICAgICAgICAgICAgICAgdmFyIHBpdm90QSA9IG9wdGlvbnMucGl2b3RBID8gb3B0aW9ucy5waXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBpdm90QiA9IG9wdGlvbnMucGl2b3RCID8gb3B0aW9ucy5waXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUm90YXRpb24gYXhpcywgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgYXhpc0EgPSB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIGF4aXNBLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUm90YXRpb24gYXhpcywgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0JcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgYXhpc0IgPSB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIGF4aXNCLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjFcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbE1vdG9yRXF1YXRpb259IG1vdG9yRXF1YXRpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgbW90b3IgPSB0aGlzLm1vdG9yRXF1YXRpb24gPSBuZXcgUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSk7XG4gICAgICAgICAgICAgICAgbW90b3IuZW5hYmxlZCA9IGZhbHNlOyAvLyBOb3QgZW5hYmxlZCBieSBkZWZhdWx0XG5cbiAgICAgICAgICAgICAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICAgICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICByMSwgLy8gcm90YXRpb25hbDFcbiAgICAgICAgICAgICAgICAgICAgcjIsIC8vIHJvdGF0aW9uYWwyXG4gICAgICAgICAgICAgICAgICAgIG1vdG9yXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludCgpO1xuICAgICAgICAgICAgSGluZ2VDb25zdHJhaW50LmNvbnN0cnVjdG9yID0gSGluZ2VDb25zdHJhaW50O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgZW5hYmxlTW90b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZS5lbmFibGVNb3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNwZWVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubW90b3JFcXVhdGlvbi50YXJnZXRWZWxvY2l0eSA9IHNwZWVkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldE1vdG9yTWF4Rm9yY2VcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhGb3JjZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBIaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1vdG9yTWF4Rm9yY2UgPSBmdW5jdGlvbiAobWF4Rm9yY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICBIaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgICAgICAgICAgICAgIG1vdG9yID0gdGhpcy5tb3RvckVxdWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSxcbiAgICAgICAgICAgICAgICAgICAgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIsXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkQXhpc0EgPSBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEsXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkQXhpc0IgPSBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzI7XG5cbiAgICAgICAgICAgICAgICB2YXIgYXhpc0EgPSB0aGlzLmF4aXNBO1xuICAgICAgICAgICAgICAgIHZhciBheGlzQiA9IHRoaXMuYXhpc0I7XG5cbiAgICAgICAgICAgICAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB3b3JsZCBheGVzXG4gICAgICAgICAgICAgICAgYm9keUEucXVhdGVybmlvbi52bXVsdChheGlzQSwgd29ybGRBeGlzQSk7XG4gICAgICAgICAgICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdChheGlzQiwgd29ybGRBeGlzQik7XG5cbiAgICAgICAgICAgICAgICB3b3JsZEF4aXNBLnRhbmdlbnRzKHIxLmF4aXNBLCByMi5heGlzQSk7XG4gICAgICAgICAgICAgICAgcjEuYXhpc0IuY29weSh3b3JsZEF4aXNCKTtcbiAgICAgICAgICAgICAgICByMi5heGlzQi5jb3B5KHdvcmxkQXhpc0IpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQSwgbW90b3IuYXhpc0EpO1xuICAgICAgICAgICAgICAgICAgICBib2R5Qi5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMuYXhpc0IsIG1vdG9yLmF4aXNCKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgfSwgeyBcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjogMTksIFwiLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOiAyMiwgXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb25cIjogMjMsIFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4vQ29uc3RyYWludFwiOiAxMywgXCIuL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjogMTcgfV0sIDE2OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBMb2NrQ29uc3RyYWludDtcblxuICAgICAgICAgICAgdmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKTtcbiAgICAgICAgICAgIHZhciBQb2ludFRvUG9pbnRDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Qb2ludFRvUG9pbnRDb25zdHJhaW50Jyk7XG4gICAgICAgICAgICB2YXIgUm90YXRpb25hbEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvbicpO1xuICAgICAgICAgICAgdmFyIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL1JvdGF0aW9uYWxNb3RvckVxdWF0aW9uJyk7XG4gICAgICAgICAgICB2YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBMb2NrIGNvbnN0cmFpbnQuIFdpbGwgcmVtb3ZlIGFsbCBkZWdyZWVzIG9mIGZyZWVkb20gYmV0d2VlbiB0aGUgYm9kaWVzLlxuICAgICAgICAgICAgICogQGNsYXNzIExvY2tDb25zdHJhaW50XG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIExvY2tDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZiAob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBwaXZvdCBwb2ludCBpbiBiZXR3ZWVuXG4gICAgICAgICAgICAgICAgdmFyIHBpdm90QSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBpdm90QiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGhhbGZXYXkgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvc2l0aW9uLnZhZGQoYm9keUIucG9zaXRpb24sIGhhbGZXYXkpO1xuICAgICAgICAgICAgICAgIGhhbGZXYXkuc2NhbGUoMC41LCBoYWxmV2F5KTtcbiAgICAgICAgICAgICAgICBib2R5Qi5wb2ludFRvTG9jYWxGcmFtZShoYWxmV2F5LCBwaXZvdEIpO1xuICAgICAgICAgICAgICAgIGJvZHlBLnBvaW50VG9Mb2NhbEZyYW1lKGhhbGZXYXksIHBpdm90QSk7XG4gICAgICAgICAgICAgICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5jYWxsKHRoaXMsIGJvZHlBLCBwaXZvdEEsIGJvZHlCLCBwaXZvdEIsIG1heEZvcmNlKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Um90YXRpb25hbEVxdWF0aW9ufSByb3RhdGlvbmFsRXF1YXRpb24xXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHIxID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24xID0gbmV3IFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uM1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2gocjEsIHIyLCByMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2NrQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludCgpO1xuICAgICAgICAgICAgTG9ja0NvbnN0cmFpbnQuY29uc3RydWN0b3IgPSBMb2NrQ29uc3RyYWludDtcblxuICAgICAgICAgICAgdmFyIExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBMb2NrQ29uc3RyYWludF91cGRhdGVfdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIExvY2tDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgICAgICAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICAgICAgICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEsXG4gICAgICAgICAgICAgICAgICAgIHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yLFxuICAgICAgICAgICAgICAgICAgICByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyxcbiAgICAgICAgICAgICAgICAgICAgd29ybGRBeGlzQSA9IExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxuICAgICAgICAgICAgICAgICAgICB3b3JsZEF4aXNCID0gTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzI7XG5cbiAgICAgICAgICAgICAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZShWZWMzLlVOSVRfWCwgcjEuYXhpc0EpO1xuICAgICAgICAgICAgICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZShWZWMzLlVOSVRfWSwgcjEuYXhpc0IpO1xuXG4gICAgICAgICAgICAgICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKFZlYzMuVU5JVF9ZLCByMi5heGlzQSk7XG4gICAgICAgICAgICAgICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKFZlYzMuVU5JVF9aLCByMi5heGlzQik7XG5cbiAgICAgICAgICAgICAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUoVmVjMy5VTklUX1osIHIzLmF4aXNBKTtcbiAgICAgICAgICAgICAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUoVmVjMy5VTklUX1gsIHIzLmF4aXNCKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICB9LCB7IFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOiAxOSwgXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uXCI6IDIyLCBcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvblwiOiAyMywgXCIuLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi9Db25zdHJhaW50XCI6IDEzLCBcIi4vUG9pbnRUb1BvaW50Q29uc3RyYWludFwiOiAxNyB9XSwgMTc6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFBvaW50VG9Qb2ludENvbnN0cmFpbnQ7XG5cbiAgICAgICAgICAgIHZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XG4gICAgICAgICAgICB2YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25uZWN0cyB0d28gYm9kaWVzIGF0IGdpdmVuIG9mZnNldCBwb2ludHMuXG4gICAgICAgICAgICAgKiBAY2xhc3MgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICAgICAgICAgICAgICogQGV4dGVuZHMgQ29uc3RyYWludFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHBpdm90QSBUaGUgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiBtYXNzIG9mIGJvZHlBIHdoaWNoIGJvZHlBIGlzIGNvbnN0cmFpbmVkIHRvLlxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QiBCb2R5IHRoYXQgd2lsbCBiZSBjb25zdHJhaW5lZCBpbiBhIHNpbWlsYXIgd2F5IHRvIHRoZSBzYW1lIHBvaW50IGFzIGJvZHlBLiBXZSB3aWxsIHRoZXJlZm9yZSBnZXQgYSBsaW5rIGJldHdlZW4gYm9keUEgYW5kIGJvZHlCLiBJZiBub3Qgc3BlY2lmaWVkLCBib2R5QSB3aWxsIGJlIGNvbnN0cmFpbmVkIHRvIGEgc3RhdGljIHBvaW50LlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBwaXZvdEIgU2VlIHBpdm90QS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZSBUaGUgbWF4aW11bSBmb3JjZSB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNvbnN0cmFpbiB0aGUgYm9kaWVzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAgdmFyIGJvZHlBID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xuICAgICAgICAgICAgICogICAgIHZhciBib2R5QiA9IG5ldyBCb2R5KHsgbWFzczogMSB9KTtcbiAgICAgICAgICAgICAqICAgICBib2R5QS5wb3NpdGlvbi5zZXQoLTEsIDAsIDApO1xuICAgICAgICAgICAgICogICAgIGJvZHlCLnBvc2l0aW9uLnNldCgxLCAwLCAwKTtcbiAgICAgICAgICAgICAqICAgICBib2R5QS5hZGRTaGFwZShzaGFwZUEpO1xuICAgICAgICAgICAgICogICAgIGJvZHlCLmFkZFNoYXBlKHNoYXBlQik7XG4gICAgICAgICAgICAgKiAgICAgd29ybGQuYWRkQm9keShib2R5QSk7XG4gICAgICAgICAgICAgKiAgICAgd29ybGQuYWRkQm9keShib2R5Qik7XG4gICAgICAgICAgICAgKiAgICAgdmFyIGxvY2FsUGl2b3RBID0gbmV3IFZlYzMoMSwgMCwgMCk7XG4gICAgICAgICAgICAgKiAgICAgdmFyIGxvY2FsUGl2b3RCID0gbmV3IFZlYzMoLTEsIDAsIDApO1xuICAgICAgICAgICAgICogICAgIHZhciBjb25zdHJhaW50ID0gbmV3IFBvaW50VG9Qb2ludENvbnN0cmFpbnQoYm9keUEsIGxvY2FsUGl2b3RBLCBib2R5QiwgbG9jYWxQaXZvdEIpO1xuICAgICAgICAgICAgICogICAgIHdvcmxkLmFkZENvbnN0cmFpbnQoY29uc3RyYWludCk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFBvaW50VG9Qb2ludENvbnN0cmFpbnQoYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpIHtcbiAgICAgICAgICAgICAgICBDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIGJvZHlCKTtcblxuICAgICAgICAgICAgICAgIG1heEZvcmNlID0gdHlwZW9mIChtYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gbWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcGl2b3RBXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5waXZvdEEgPSBwaXZvdEEgPyBwaXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcGl2b3RCXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5waXZvdEIgPSBwaXZvdEIgPyBwaXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25YXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uWCA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBlcXVhdGlvbllcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB2YXIgeSA9IHRoaXMuZXF1YXRpb25ZID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSwgYm9keUIpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGVxdWF0aW9uWlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHZhciB6ID0gdGhpcy5lcXVhdGlvblogPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7XG5cbiAgICAgICAgICAgICAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICAgICAgICAgICAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHopO1xuXG4gICAgICAgICAgICAgICAgLy8gTWFrZSB0aGUgZXF1YXRpb25zIGJpZGlyZWN0aW9uYWxcbiAgICAgICAgICAgICAgICB4Lm1pbkZvcmNlID0geS5taW5Gb3JjZSA9IHoubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgICAgICAgICAgICAgeC5tYXhGb3JjZSA9IHkubWF4Rm9yY2UgPSB6Lm1heEZvcmNlID0gbWF4Rm9yY2U7XG5cbiAgICAgICAgICAgICAgICB4Lm5pLnNldCgxLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB5Lm5pLnNldCgwLCAxLCAwKTtcbiAgICAgICAgICAgICAgICB6Lm5pLnNldCgwLCAwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlID0gbmV3IENvbnN0cmFpbnQoKTtcblxuICAgICAgICAgICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBib2R5QSA9IHRoaXMuYm9keUE7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlCID0gdGhpcy5ib2R5QjtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMuZXF1YXRpb25YO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy5lcXVhdGlvblk7XG4gICAgICAgICAgICAgICAgdmFyIHogPSB0aGlzLmVxdWF0aW9uWjtcblxuICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSB0aGUgcGl2b3RzIHRvIHdvcmxkIHNwYWNlXG4gICAgICAgICAgICAgICAgYm9keUEucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90QSwgeC5yaSk7XG4gICAgICAgICAgICAgICAgYm9keUIucXVhdGVybmlvbi52bXVsdCh0aGlzLnBpdm90QiwgeC5yaik7XG5cbiAgICAgICAgICAgICAgICB5LnJpLmNvcHkoeC5yaSk7XG4gICAgICAgICAgICAgICAgeS5yai5jb3B5KHgucmopO1xuICAgICAgICAgICAgICAgIHoucmkuY29weSh4LnJpKTtcbiAgICAgICAgICAgICAgICB6LnJqLmNvcHkoeC5yaik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOiAxOSwgXCIuLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi9Db25zdHJhaW50XCI6IDEzIH1dLCAxODogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gQ29uZUVxdWF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIE1hdDMgPSBfZGVyZXFfKCcuLi9tYXRoL01hdDMnKTtcbiAgICAgICAgICAgIHZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25lIGVxdWF0aW9uLiBXb3JrcyB0byBrZWVwIHRoZSBnaXZlbiBib2R5IHdvcmxkIHZlY3RvcnMgYWxpZ25lZCwgb3IgdGlsdGVkIHdpdGhpbiBhIGdpdmVuIGFuZ2xlIGZyb20gZWFjaCBvdGhlci5cbiAgICAgICAgICAgICAqIEBjbGFzcyBDb25lRXF1YXRpb25cbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV0gTG9jYWwgYXhpcyBpbiBBXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXSBMb2NhbCBheGlzIGluIEJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5nbGVdIFRoZSBcImNvbmUgYW5nbGVcIiB0byBrZWVwXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICAgICAgICAgICAgICogQGV4dGVuZHMgRXF1YXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQ29uZUVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZiAob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcblxuICAgICAgICAgICAgICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAtbWF4Rm9yY2UsIG1heEZvcmNlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBjb25lIGFuZ2xlIHRvIGtlZXBcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlID0gdHlwZW9mIChvcHRpb25zLmFuZ2xlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ2xlIDogMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQ29uZUVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuICAgICAgICAgICAgQ29uZUVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVFcXVhdGlvbjtcblxuICAgICAgICAgICAgdmFyIHRtcFZlYzEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHRtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICBDb25lRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVCID0gZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuYixcblxuICAgICAgICAgICAgICAgICAgICBuaSA9IHRoaXMuYXhpc0EsXG4gICAgICAgICAgICAgICAgICAgIG5qID0gdGhpcy5heGlzQixcblxuICAgICAgICAgICAgICAgICAgICBuaXhuaiA9IHRtcFZlYzEsXG4gICAgICAgICAgICAgICAgICAgIG5qeG5pID0gdG1wVmVjMixcblxuICAgICAgICAgICAgICAgICAgICBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgICAgICAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG5cbiAgICAgICAgICAgICAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICAgICAgICAgICAgICBuaS5jcm9zcyhuaiwgbml4bmopO1xuICAgICAgICAgICAgICAgIG5qLmNyb3NzKG5pLCBuanhuaSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yIGlzOlxuICAgICAgICAgICAgICAgIC8vIGNvcyh0aGV0YSkgPSBhICogYiAvIChsZW5ndGgoYSkgKiBsZW5ndGgoYikgPSB7IGxlbihhKSA9IGxlbihiKSA9IDEgfSA9IGEgKiBiXG5cbiAgICAgICAgICAgICAgICAvLyBnID0gYSAqIGJcbiAgICAgICAgICAgICAgICAvLyBnZG90ID0gKGIgeCBhKSAqIHdpICsgKGEgeCBiKSAqIHdqXG4gICAgICAgICAgICAgICAgLy8gRyA9IFswIGJ4YSAwIGF4Yl1cbiAgICAgICAgICAgICAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXVxuICAgICAgICAgICAgICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XG4gICAgICAgICAgICAgICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTtcblxuICAgICAgICAgICAgICAgIHZhciBnID0gTWF0aC5jb3ModGhpcy5hbmdsZSkgLSBuaS5kb3QobmopLFxuICAgICAgICAgICAgICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgICAgICAgICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBCO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgIH0sIHsgXCIuLi9tYXRoL01hdDNcIjogMjcsIFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4vRXF1YXRpb25cIjogMjAgfV0sIDE5OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBDb250YWN0RXF1YXRpb247XG5cbiAgICAgICAgICAgIHZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKTtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnRhY3Qvbm9uLXBlbmV0cmF0aW9uIGNvbnN0cmFpbnQgZXF1YXRpb25cbiAgICAgICAgICAgICAqIEBjbGFzcyBDb250YWN0RXF1YXRpb25cbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAgICAgICAgICogQGV4dGVuZHMgRXF1YXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5QiwgbWF4Rm9yY2UpIHtcbiAgICAgICAgICAgICAgICBtYXhGb3JjZSA9IHR5cGVvZiAobWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG1heEZvcmNlIDogMWU2O1xuICAgICAgICAgICAgICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7IC8vIFwiYm91bmNpbmVzc1wiOiB1MSA9IC1lKnUwXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBnb2VzIGZyb20gdGhlIGNlbnRlciBvZiBiaSB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHJpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBzdGFydHMgaW4gYm9keSBqIHBvc2l0aW9uIGFuZCBnb2VzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcmpcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnJqID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvbnRhY3Qgbm9ybWFsLCBwb2ludGluZyBvdXQgb2YgYm9keSBpLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbmlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm5pID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuICAgICAgICAgICAgQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcblxuICAgICAgICAgICAgdmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMSA9IG5ldyBWZWMzKCk7IC8vIFRlbXAgdmVjdG9yc1xuICAgICAgICAgICAgdmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAzID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIENvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbiAoaCkge1xuICAgICAgICAgICAgICAgIHZhciBhID0gdGhpcy5hLFxuICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5iLFxuICAgICAgICAgICAgICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgICAgICAgICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgICAgICAgICAgICAgcmkgPSB0aGlzLnJpLFxuICAgICAgICAgICAgICAgICAgICByaiA9IHRoaXMucmosXG4gICAgICAgICAgICAgICAgICAgIHJpeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDEsXG4gICAgICAgICAgICAgICAgICAgIHJqeG4gPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDIsXG5cbiAgICAgICAgICAgICAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIGZpID0gYmkuZm9yY2UsXG4gICAgICAgICAgICAgICAgICAgIHRhdWkgPSBiaS50b3JxdWUsXG5cbiAgICAgICAgICAgICAgICAgICAgdmogPSBiai52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIGZqID0gYmouZm9yY2UsXG4gICAgICAgICAgICAgICAgICAgIHRhdWogPSBiai50b3JxdWUsXG5cbiAgICAgICAgICAgICAgICAgICAgcGVuZXRyYXRpb25WZWMgPSBDb250YWN0RXF1YXRpb25fY29tcHV0ZUJfdGVtcDMsXG5cbiAgICAgICAgICAgICAgICAgICAgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgICAgICAgICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuXG4gICAgICAgICAgICAgICAgICAgIG4gPSB0aGlzLm5pO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgICAgICAgICAgICAgcmkuY3Jvc3Mobiwgcml4bik7XG4gICAgICAgICAgICAgICAgcmouY3Jvc3Mobiwgcmp4bik7XG5cbiAgICAgICAgICAgICAgICAvLyBnID0geGorcmogLSh4aStyaSlcbiAgICAgICAgICAgICAgICAvLyBHID0gWyAtbmkgIC1yaXhuICBuaSAgcmp4biBdXG4gICAgICAgICAgICAgICAgbi5uZWdhdGUoR0Euc3BhdGlhbCk7XG4gICAgICAgICAgICAgICAgcml4bi5uZWdhdGUoR0Eucm90YXRpb25hbCk7XG4gICAgICAgICAgICAgICAgR0Iuc3BhdGlhbC5jb3B5KG4pO1xuICAgICAgICAgICAgICAgIEdCLnJvdGF0aW9uYWwuY29weShyanhuKTtcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGVuZXRyYXRpb24gdmVjdG9yXG4gICAgICAgICAgICAgICAgcGVuZXRyYXRpb25WZWMuY29weShiai5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgcGVuZXRyYXRpb25WZWMudmFkZChyaiwgcGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgICAgIHBlbmV0cmF0aW9uVmVjLnZzdWIoYmkucG9zaXRpb24sIHBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgICAgICBwZW5ldHJhdGlvblZlYy52c3ViKHJpLCBwZW5ldHJhdGlvblZlYyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZyA9IG4uZG90KHBlbmV0cmF0aW9uVmVjKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGVQbHVzT25lID0gdGhpcy5yZXN0aXR1dGlvbiArIDE7XG4gICAgICAgICAgICAgICAgdmFyIEdXID0gZVBsdXNPbmUgKiB2ai5kb3QobikgLSBlUGx1c09uZSAqIHZpLmRvdChuKSArIHdqLmRvdChyanhuKSAtIHdpLmRvdChyaXhuKTtcbiAgICAgICAgICAgICAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgICAgICAgICAgICAgIHZhciBCID0gLSBnICogYSAtIEdXICogYiAtIGggKiBHaU1mO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmkgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZqID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGogPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3JlbFZlbCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHJlbGF0aXZlIHZlbG9jaXR5IGluIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92aTtcbiAgICAgICAgICAgICAgICB2YXIgdmogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF92ajtcbiAgICAgICAgICAgICAgICB2YXIgeGkgPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aTtcbiAgICAgICAgICAgICAgICB2YXIgeGogPSBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94ajtcbiAgICAgICAgICAgICAgICB2YXIgcmVsVmVsID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfcmVsVmVsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5iaS5wb3NpdGlvbi52YWRkKHRoaXMucmksIHhpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJqLnBvc2l0aW9uLnZhZGQodGhpcy5yaiwgeGopO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5iaS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh4aSwgdmkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmouZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGosIHZqKTtcblxuICAgICAgICAgICAgICAgIHZpLnZzdWIodmosIHJlbFZlbCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uaS5kb3QocmVsVmVsKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICB9LCB7IFwiLi4vbWF0aC9NYXQzXCI6IDI3LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuL0VxdWF0aW9uXCI6IDIwIH1dLCAyMDogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRXF1YXRpb247XG5cbiAgICAgICAgICAgIHZhciBKYWNvYmlhbkVsZW1lbnQgPSBfZGVyZXFfKCcuLi9tYXRoL0phY29iaWFuRWxlbWVudCcpLFxuICAgICAgICAgICAgICAgIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFcXVhdGlvbiBiYXNlIGNsYXNzXG4gICAgICAgICAgICAgKiBAY2xhc3MgRXF1YXRpb25cbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBiaVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBialxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1pbkZvcmNlIE1pbmltdW0gKHJlYWQ6IG5lZ2F0aXZlIG1heCkgZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIChyZWFkOiBwb3NpdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIEVxdWF0aW9uKGJpLCBiaiwgbWluRm9yY2UsIG1heEZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IEVxdWF0aW9uLmlkKys7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluRm9yY2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm1pbkZvcmNlID0gdHlwZW9mIChtaW5Gb3JjZSkgPT09IFwidW5kZWZpbmVkXCIgPyAtMWU2IDogbWluRm9yY2U7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4Rm9yY2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm1heEZvcmNlID0gdHlwZW9mIChtYXhGb3JjZSkgPT09IFwidW5kZWZpbmVkXCIgPyAxZTYgOiBtYXhGb3JjZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBiaVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYmkgPSBiaTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBialxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtCb2R5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYmogPSBiajtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFNQT09LIHBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5hID0gMC4wO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU1BPT0sgcGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmIgPSAwLjA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTUE9PSyBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZXBzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5lcHMgPSAwLjA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0phY29iaWFuRWxlbWVudH0gamFjb2JpYW5FbGVtZW50QVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuamFjb2JpYW5FbGVtZW50QSA9IG5ldyBKYWNvYmlhbkVsZW1lbnQoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7SmFjb2JpYW5FbGVtZW50fSBqYWNvYmlhbkVsZW1lbnRCXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRCID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBlbmFibGVkXG4gICAgICAgICAgICAgICAgICogQGRlZmF1bHQgdHJ1ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBTZXQgdHlwaWNhbCBzcG9vayBwYXJhbXNcbiAgICAgICAgICAgICAgICB0aGlzLnNldFNwb29rUGFyYW1zKDFlNywgNCwgMSAvIDYwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVxdWF0aW9uO1xuXG4gICAgICAgICAgICBFcXVhdGlvbi5pZCA9IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVjYWxjdWxhdGVzIGEsYixlcHMuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldFNwb29rUGFyYW1zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEVxdWF0aW9uLnByb3RvdHlwZS5zZXRTcG9va1BhcmFtcyA9IGZ1bmN0aW9uIChzdGlmZm5lc3MsIHJlbGF4YXRpb24sIHRpbWVTdGVwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGQgPSByZWxheGF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBrID0gc3RpZmZuZXNzLFxuICAgICAgICAgICAgICAgICAgICBoID0gdGltZVN0ZXA7XG4gICAgICAgICAgICAgICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5iID0gKDQuMCAqIGQpIC8gKDEgKyA0ICogZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lcHMgPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBjb21wdXRlQlxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbiAoYSwgYiwgaCkge1xuICAgICAgICAgICAgICAgIHZhciBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgICAgICAgICAgICAgIEdxID0gdGhpcy5jb21wdXRlR3EoKSxcbiAgICAgICAgICAgICAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gLSBHcSAqIGEgLSBHVyAqIGIgLSBHaU1mICogaDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcHV0ZXMgRypxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBjb21wdXRlR3FcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgICAgICAgICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICAgICAgICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgICAgICAgICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgICAgICAgICAgICAgeGkgPSBiaS5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgeGogPSBiai5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gR0Euc3BhdGlhbC5kb3QoeGkpICsgR0Iuc3BhdGlhbC5kb3QoeGopO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHplcm8gPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbXB1dGVzIEcqVywgd2hlcmUgVyBhcmUgdGhlIGJvZHkgdmVsb2NpdGllc1xuICAgICAgICAgICAgICogQG1ldGhvZCBjb21wdXRlR1dcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHVyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgICAgICAgICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICAgICAgICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgICAgICAgICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgICAgICAgICAgICAgdmkgPSBiaS52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgdmogPSBiai52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgd2kgPSBiaS5hbmd1bGFyVmVsb2NpdHkgfHwgemVybyxcbiAgICAgICAgICAgICAgICAgICAgd2ogPSBiai5hbmd1bGFyVmVsb2NpdHkgfHwgemVybztcbiAgICAgICAgICAgICAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKHZpLCB3aSkgKyBHQi5tdWx0aXBseVZlY3RvcnModmosIHdqKTtcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb21wdXRlcyBHKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgY29tcHV0ZUdXbGFtYmRhXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1dsYW1iZGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICAgICAgICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgICAgICAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICAgICAgICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgICAgICAgICAgICAgIHZpID0gYmkudmxhbWJkYSxcbiAgICAgICAgICAgICAgICAgICAgdmogPSBiai52bGFtYmRhLFxuICAgICAgICAgICAgICAgICAgICB3aSA9IGJpLndsYW1iZGEgfHwgemVybyxcbiAgICAgICAgICAgICAgICAgICAgd2ogPSBiai53bGFtYmRhIHx8IHplcm87XG4gICAgICAgICAgICAgICAgcmV0dXJuIEdBLm11bHRpcGx5VmVjdG9ycyh2aSwgd2kpICsgR0IubXVsdGlwbHlWZWN0b3JzKHZqLCB3aik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbXB1dGVzIEcqaW52KE0pKmYsIHdoZXJlIE0gaXMgdGhlIG1hc3MgbWF0cml4IHdpdGggZGlhZ29uYWwgYmxvY2tzIGZvciBlYWNoIGJvZHksIGFuZCBmIGFyZSB0aGUgZm9yY2VzIG9uIHRoZSBib2RpZXMuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvbXB1dGVHaU1mXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBpTWZpID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBpTWZqID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBpbnZJaV92bXVsdF90YXVpID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBpbnZJal92bXVsdF90YXVqID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR2lNZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgICAgICAgICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICAgICAgICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgICAgICAgICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgICAgICAgICAgICAgZmkgPSBiaS5mb3JjZSxcbiAgICAgICAgICAgICAgICAgICAgdGkgPSBiaS50b3JxdWUsXG4gICAgICAgICAgICAgICAgICAgIGZqID0gYmouZm9yY2UsXG4gICAgICAgICAgICAgICAgICAgIHRqID0gYmoudG9ycXVlLFxuICAgICAgICAgICAgICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmU7XG5cbiAgICAgICAgICAgICAgICBpZiAoYmkuaW52SW5lcnRpYVdvcmxkU29sdmUpIHsgYmkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQodGksIGludklpX3ZtdWx0X3RhdWkpOyB9XG4gICAgICAgICAgICAgICAgZWxzZSB7IGludklpX3ZtdWx0X3RhdWkuc2V0KDAsIDAsIDApOyB9XG4gICAgICAgICAgICAgICAgaWYgKGJqLmludkluZXJ0aWFXb3JsZFNvbHZlKSB7IGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRqLCBpbnZJal92bXVsdF90YXVqKTsgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyBpbnZJal92bXVsdF90YXVqLnNldCgwLCAwLCAwKTsgfVxuXG4gICAgICAgICAgICAgICAgZmkubXVsdChpbnZNYXNzaSwgaU1maSk7XG4gICAgICAgICAgICAgICAgZmoubXVsdChpbnZNYXNzaiwgaU1maik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKGlNZmksIGludklpX3ZtdWx0X3RhdWkpICsgR0IubXVsdGlwbHlWZWN0b3JzKGlNZmosIGludklqX3ZtdWx0X3RhdWopO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb21wdXRlcyBHKmludihNKSpHJ1xuICAgICAgICAgICAgICogQG1ldGhvZCBjb21wdXRlR2lNR3RcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHRtcCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUdpTUd0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgICAgICAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgICAgICAgICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgICAgICAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICAgICAgICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgICAgICAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmUsXG4gICAgICAgICAgICAgICAgICAgIGludklpID0gYmkuaW52SW5lcnRpYVdvcmxkU29sdmUsXG4gICAgICAgICAgICAgICAgICAgIGludklqID0gYmouaW52SW5lcnRpYVdvcmxkU29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGludk1hc3NpICsgaW52TWFzc2o7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW52SWkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW52SWkudm11bHQoR0Eucm90YXRpb25hbCwgdG1wKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRtcC5kb3QoR0Eucm90YXRpb25hbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGludklqKSB7XG4gICAgICAgICAgICAgICAgICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsIHRtcCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0bXAuZG90KEdCLnJvdGF0aW9uYWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYWRkVG9XbGFtYmRhX3RlbXAgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIGFkZFRvV2xhbWJkYV9HaSA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgYWRkVG9XbGFtYmRhX0dqID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBhZGRUb1dsYW1iZGFfcmkgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIGFkZFRvV2xhbWJkYV9yaiA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgYWRkVG9XbGFtYmRhX01kaWFnID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLlxuICAgICAgICAgICAgICogQG1ldGhvZCBhZGRUb1dsYW1iZGFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBFcXVhdGlvbi5wcm90b3R5cGUuYWRkVG9XbGFtYmRhID0gZnVuY3Rpb24gKGRlbHRhbGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICAgICAgICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgICAgICAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICAgICAgICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgICAgICAgICAgICAgIHRlbXAgPSBhZGRUb1dsYW1iZGFfdGVtcDtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBsaW5lYXIgdmVsb2NpdHlcbiAgICAgICAgICAgICAgICAvLyB2X2xhbWJkYSArPSBpbnYoTSkgKiBkZWx0YV9sYW1iYSAqIEdcbiAgICAgICAgICAgICAgICBHQS5zcGF0aWFsLm11bHQoYmkuaW52TWFzc1NvbHZlICogZGVsdGFsYW1iZGEsIHRlbXApO1xuICAgICAgICAgICAgICAgIGJpLnZsYW1iZGEudmFkZCh0ZW1wLCBiaS52bGFtYmRhKTtcblxuICAgICAgICAgICAgICAgIEdCLnNwYXRpYWwubXVsdChiai5pbnZNYXNzU29sdmUgKiBkZWx0YWxhbWJkYSwgdGVtcCk7XG4gICAgICAgICAgICAgICAgYmoudmxhbWJkYS52YWRkKHRlbXAsIGJqLnZsYW1iZGEpO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGFuZ3VsYXIgdmVsb2NpdHlcbiAgICAgICAgICAgICAgICBpZiAoYmkuaW52SW5lcnRpYVdvcmxkU29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoR0Eucm90YXRpb25hbCwgdGVtcCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAubXVsdChkZWx0YWxhbWJkYSwgdGVtcCk7XG4gICAgICAgICAgICAgICAgICAgIGJpLndsYW1iZGEudmFkZCh0ZW1wLCBiaS53bGFtYmRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoYmouaW52SW5lcnRpYVdvcmxkU29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmouaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoR0Iucm90YXRpb25hbCwgdGVtcCk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXAubXVsdChkZWx0YWxhbWJkYSwgdGVtcCk7XG4gICAgICAgICAgICAgICAgICAgIGJqLndsYW1iZGEudmFkZCh0ZW1wLCBiai53bGFtYmRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbXB1dGUgdGhlIGRlbm9taW5hdG9yIHBhcnQgb2YgdGhlIFNQT09LIGVxdWF0aW9uOiBDID0gRyppbnYoTSkqRycgKyBlcHNcbiAgICAgICAgICAgICAqIEBtZXRob2QgY29tcHV0ZUludkNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gZXBzXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb21wdXRlR2lNR3QoKSArIHRoaXMuZXBzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vbWF0aC9KYWNvYmlhbkVsZW1lbnRcIjogMjYsIFwiLi4vbWF0aC9WZWMzXCI6IDMwIH1dLCAyMTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvbjtcblxuICAgICAgICAgICAgdmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbiAgICAgICAgICAgIHZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxuICAgICAgICAgICAgICogQGNsYXNzIEZyaWN0aW9uRXF1YXRpb25cbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBFcXVhdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKSB7XG4gICAgICAgICAgICAgICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1zbGlwRm9yY2UsIHNsaXBGb3JjZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yaiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50ID0gbmV3IFZlYzMoKTsgLy8gdGFuZ2VudFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBGcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuICAgICAgICAgICAgRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGcmljdGlvbkVxdWF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBGcmljdGlvbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgICAgICAgICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgICAgICAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICAgICAgICAgICAgICByaSA9IHRoaXMucmksXG4gICAgICAgICAgICAgICAgICAgIHJqID0gdGhpcy5yaixcbiAgICAgICAgICAgICAgICAgICAgcml4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEsXG4gICAgICAgICAgICAgICAgICAgIHJqeHQgPSBGcmljdGlvbkVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyLFxuICAgICAgICAgICAgICAgICAgICB0ID0gdGhpcy50O1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgICAgICAgICAgICAgcmkuY3Jvc3ModCwgcml4dCk7XG4gICAgICAgICAgICAgICAgcmouY3Jvc3ModCwgcmp4dCk7XG5cbiAgICAgICAgICAgICAgICAvLyBHID0gWy10IC1yaXh0IHQgcmp4dF1cbiAgICAgICAgICAgICAgICAvLyBBbmQgcmVtZW1iZXIsIHRoaXMgaXMgYSBwdXJlIHZlbG9jaXR5IGNvbnN0cmFpbnQsIGcgaXMgYWx3YXlzIHplcm8hXG4gICAgICAgICAgICAgICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICAgICAgICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcbiAgICAgICAgICAgICAgICB0Lm5lZ2F0ZShHQS5zcGF0aWFsKTtcbiAgICAgICAgICAgICAgICByaXh0Lm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcbiAgICAgICAgICAgICAgICBHQi5zcGF0aWFsLmNvcHkodCk7XG4gICAgICAgICAgICAgICAgR0Iucm90YXRpb25hbC5jb3B5KHJqeHQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICAgICAgICAgICAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgICAgICAgICAgICAgIHZhciBCID0gLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgICAgICAgICAgICAgIHJldHVybiBCO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vbWF0aC9NYXQzXCI6IDI3LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuL0VxdWF0aW9uXCI6IDIwIH1dLCAyMjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gUm90YXRpb25hbEVxdWF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIE1hdDMgPSBfZGVyZXFfKCcuLi9tYXRoL01hdDMnKTtcbiAgICAgICAgICAgIHZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSb3RhdGlvbmFsIGNvbnN0cmFpbnQuIFdvcmtzIHRvIGtlZXAgdGhlIGxvY2FsIHZlY3RvcnMgb3J0aG9nb25hbCB0byBlYWNoIG90aGVyIGluIHdvcmxkIHNwYWNlLlxuICAgICAgICAgICAgICogQGNsYXNzIFJvdGF0aW9uYWxFcXVhdGlvblxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQl1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZV1cbiAgICAgICAgICAgICAqIEBleHRlbmRzIEVxdWF0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFJvdGF0aW9uYWxFcXVhdGlvbihib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2YgKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAgICAgICAgICAgICBFcXVhdGlvbi5jYWxsKHRoaXMsIGJvZHlBLCBib2R5QiwgLW1heEZvcmNlLCBtYXhGb3JjZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1heEFuZ2xlID0gTWF0aC5QSSAvIDI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbiAgICAgICAgICAgIFJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsRXF1YXRpb247XG5cbiAgICAgICAgICAgIHZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgUm90YXRpb25hbEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLmIsXG5cbiAgICAgICAgICAgICAgICAgICAgbmkgPSB0aGlzLmF4aXNBLFxuICAgICAgICAgICAgICAgICAgICBuaiA9IHRoaXMuYXhpc0IsXG5cbiAgICAgICAgICAgICAgICAgICAgbml4bmogPSB0bXBWZWMxLFxuICAgICAgICAgICAgICAgICAgICBuanhuaSA9IHRtcFZlYzIsXG5cbiAgICAgICAgICAgICAgICAgICAgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgICAgICAgICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FsdWNsYXRlIGNyb3NzIHByb2R1Y3RzXG4gICAgICAgICAgICAgICAgbmkuY3Jvc3MobmosIG5peG5qKTtcbiAgICAgICAgICAgICAgICBuai5jcm9zcyhuaSwgbmp4bmkpO1xuXG4gICAgICAgICAgICAgICAgLy8gZyA9IG5pICogbmpcbiAgICAgICAgICAgICAgICAvLyBnZG90ID0gKG5qIHggbmkpICogd2kgKyAobmkgeCBuaikgKiB3alxuICAgICAgICAgICAgICAgIC8vIEcgPSBbMCBuanhuaSAwIG5peG5qXVxuICAgICAgICAgICAgICAgIC8vIFcgPSBbdmkgd2kgdmogd2pdXG4gICAgICAgICAgICAgICAgR0Eucm90YXRpb25hbC5jb3B5KG5qeG5pKTtcbiAgICAgICAgICAgICAgICBHQi5yb3RhdGlvbmFsLmNvcHkobml4bmopO1xuXG4gICAgICAgICAgICAgICAgdmFyIGcgPSBNYXRoLmNvcyh0aGlzLm1heEFuZ2xlKSAtIG5pLmRvdChuaiksXG4gICAgICAgICAgICAgICAgICAgIEdXID0gdGhpcy5jb21wdXRlR1coKSxcbiAgICAgICAgICAgICAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgICAgICAgICAgICAgIHZhciBCID0gLSBnICogYSAtIEdXICogYiAtIGggKiBHaU1mO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgfSwgeyBcIi4uL21hdGgvTWF0M1wiOiAyNywgXCIuLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi9FcXVhdGlvblwiOiAyMCB9XSwgMjM6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIE1hdDMgPSBfZGVyZXFfKCcuLi9tYXRoL01hdDMnKTtcbiAgICAgICAgICAgIHZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnQuIFRyaWVzIHRvIGtlZXAgdGhlIHJlbGF0aXZlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZGllcyB0byBhIGdpdmVuIHZhbHVlLlxuICAgICAgICAgICAgICogQGNsYXNzIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZVxuICAgICAgICAgICAgICogQGV4dGVuZHMgRXF1YXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSkge1xuICAgICAgICAgICAgICAgIG1heEZvcmNlID0gdHlwZW9mIChtYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gbWF4Rm9yY2UgOiAxZTY7XG4gICAgICAgICAgICAgICAgRXF1YXRpb24uY2FsbCh0aGlzLCBib2R5QSwgYm9keUIsIC1tYXhGb3JjZSwgbWF4Rm9yY2UpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzfSBheGlzQVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYXhpc0EgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzfSBheGlzQlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYXhpc0IgPSBuZXcgVmVjMygpOyAvLyBXb3JsZCBvcmllbnRlZCByb3RhdGlvbmFsIGF4aXNcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE1vdG9yIHZlbG9jaXR5XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHRhcmdldFZlbG9jaXR5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXRWZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuICAgICAgICAgICAgUm90YXRpb25hbE1vdG9yRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUm90YXRpb25hbE1vdG9yRXF1YXRpb247XG5cbiAgICAgICAgICAgIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uIChoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmEsXG4gICAgICAgICAgICAgICAgICAgIGIgPSB0aGlzLmIsXG4gICAgICAgICAgICAgICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgICAgICAgICAgICAgYmogPSB0aGlzLmJqLFxuXG4gICAgICAgICAgICAgICAgICAgIGF4aXNBID0gdGhpcy5heGlzQSxcbiAgICAgICAgICAgICAgICAgICAgYXhpc0IgPSB0aGlzLmF4aXNCLFxuXG4gICAgICAgICAgICAgICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICAgICAgICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcblxuICAgICAgICAgICAgICAgIC8vIGcgPSAwXG4gICAgICAgICAgICAgICAgLy8gZ2RvdCA9IGF4aXNBICogd2kgLSBheGlzQiAqIHdqXG4gICAgICAgICAgICAgICAgLy8gZ2RvdCA9IEcgKiBXID0gRyAqIFt2aSB3aSB2aiB3al1cbiAgICAgICAgICAgICAgICAvLyA9PlxuICAgICAgICAgICAgICAgIC8vIEcgPSBbMCBheGlzQSAwIC1heGlzQl1cblxuICAgICAgICAgICAgICAgIEdBLnJvdGF0aW9uYWwuY29weShheGlzQSk7XG4gICAgICAgICAgICAgICAgYXhpc0IubmVnYXRlKEdCLnJvdGF0aW9uYWwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSAtIHRoaXMudGFyZ2V0VmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgQiA9IC0gR1cgKiBiIC0gaCAqIEdpTWY7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gQjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4uL21hdGgvTWF0M1wiOiAyNywgXCIuLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi9FcXVhdGlvblwiOiAyMCB9XSwgMjQ6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICB2YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RNYXRlcmlhbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHR3byBtYXRlcmlhbHMgbWVldC5cbiAgICAgICAgICAgICAqIEBjbGFzcyBDb250YWN0TWF0ZXJpYWxcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtNYXRlcmlhbH0gbTFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb249MC4zXVxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnJlc3RpdHV0aW9uPTAuM11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb250YWN0RXF1YXRpb25TdGlmZm5lc3M9MWU3XVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb249M11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mcmljdGlvbkVxdWF0aW9uU3RpZmZuZXNzPTFlN11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbj0zXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBDb250YWN0TWF0ZXJpYWwobTEsIG0yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb246IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdGl0dXRpb246IDAuMyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246IDMsXG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M6IDFlNyxcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb246IDNcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElkZW50aWZpZXIgb2YgdGhpcyBtYXRlcmlhbFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyKys7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBQYXJ0aWNpcGF0aW5nIG1hdGVyaWFsc1xuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG1hdGVyaWFsc1xuICAgICAgICAgICAgICAgICAqIEB0b2RvICBTaG91bGQgYmUgLm1hdGVyaWFsQSBhbmQgLm1hdGVyaWFsQiBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbHMgPSBbbTEsIG0yXTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEZyaWN0aW9uIGNvZWZmaWNpZW50XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb247XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXN0aXR1dGlvbiBjb2VmZmljaWVudFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZXN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3RpZmZuZXNzIG9mIHRoZSBwcm9kdWNlZCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25TdGlmZm5lc3NcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVsYXhhdGlvbiB0aW1lIG9mIHRoZSBwcm9kdWNlZCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uID0gb3B0aW9ucy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3RpZmZuZXNzIG9mIHRoZSBwcm9kdWNlZCBmcmljdGlvbiBlcXVhdGlvbnNcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzc1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIENvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG4gICAgICAgIH0sIHsgXCIuLi91dGlscy9VdGlsc1wiOiA1MyB9XSwgMjU6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE1hdGVyaWFsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlZmluZXMgYSBwaHlzaWNzIG1hdGVyaWFsLlxuICAgICAgICAgICAgICogQGNsYXNzIE1hdGVyaWFsXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gTWF0ZXJpYWwob3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gJyc7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmaXhcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgbmFtZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIG1hdGVyaWFsIGlkLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5pZCA9IE1hdGVyaWFsLmlkQ291bnRlcisrO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRnJpY3Rpb24gZm9yIHRoaXMgbWF0ZXJpYWwuIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGZyaWN0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCBpbiB0aGUgV29ybGQgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmljdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb24gPSB0eXBlb2YgKG9wdGlvbnMuZnJpY3Rpb24pICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZnJpY3Rpb24gOiAtMTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlc3RpdHV0aW9uIGZvciB0aGlzIG1hdGVyaWFsLiBJZiBub24tbmVnYXRpdmUsIGl0IHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSByZXN0aXR1dGlvbiBnaXZlbiBieSBDb250YWN0TWF0ZXJpYWxzLiBJZiB0aGVyZSdzIG5vIG1hdGNoaW5nIENvbnRhY3RNYXRlcmlhbCwgdGhlIHZhbHVlIGZyb20gLmRlZmF1bHRDb250YWN0TWF0ZXJpYWwgaW4gdGhlIFdvcmxkIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVzdGl0dXRpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3RpdHV0aW9uID0gdHlwZW9mIChvcHRpb25zLnJlc3RpdHV0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJlc3RpdHV0aW9uIDogLTE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE1hdGVyaWFsLmlkQ291bnRlciA9IDA7XG5cbiAgICAgICAgfSwge31dLCAyNjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gSmFjb2JpYW5FbGVtZW50O1xuXG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4vVmVjMycpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFuIGVsZW1lbnQgY29udGFpbmluZyA2IGVudHJpZXMsIDMgc3BhdGlhbCBhbmQgMyByb3RhdGlvbmFsIGRlZ3JlZXMgb2YgZnJlZWRvbS5cbiAgICAgICAgICAgICAqIEBjbGFzcyBKYWNvYmlhbkVsZW1lbnRcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBKYWNvYmlhbkVsZW1lbnQoKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHNwYXRpYWxcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNwYXRpYWwgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzfSByb3RhdGlvbmFsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGlvbmFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNdWx0aXBseSB3aXRoIG90aGVyIEphY29iaWFuRWxlbWVudFxuICAgICAgICAgICAgICogQG1ldGhvZCBtdWx0aXBseUVsZW1lbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0phY29iaWFuRWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBKYWNvYmlhbkVsZW1lbnQucHJvdG90eXBlLm11bHRpcGx5RWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuc3BhdGlhbC5kb3QodGhpcy5zcGF0aWFsKSArIGVsZW1lbnQucm90YXRpb25hbC5kb3QodGhpcy5yb3RhdGlvbmFsKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTXVsdGlwbHkgd2l0aCB0d28gdmVjdG9yc1xuICAgICAgICAgICAgICogQG1ldGhvZCBtdWx0aXBseVZlY3RvcnNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHNwYXRpYWxcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHJvdGF0aW9uYWxcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgSmFjb2JpYW5FbGVtZW50LnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcnMgPSBmdW5jdGlvbiAoc3BhdGlhbCwgcm90YXRpb25hbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGF0aWFsLmRvdCh0aGlzLnNwYXRpYWwpICsgcm90YXRpb25hbC5kb3QodGhpcy5yb3RhdGlvbmFsKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4vVmVjM1wiOiAzMCB9XSwgMjc6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IE1hdDM7XG5cbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi9WZWMzJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSAzeDMgbWF0cml4LlxuICAgICAgICAgICAgICogQGNsYXNzIE1hdDNcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIGFycmF5IGVsZW1lbnRzIEFycmF5IG9mIG5pbmUgZWxlbWVudHMuIE9wdGlvbmFsLlxuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHA6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIE1hdDMoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBIHZlY3RvciBvZiBsZW5ndGggOSwgY29udGFpbmluZyBhbGwgbWF0cml4IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMgPSBbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldHMgdGhlIG1hdHJpeCB0byBpZGVudGl0eVxuICAgICAgICAgICAgICogQG1ldGhvZCBpZGVudGl0eVxuICAgICAgICAgICAgICogQHRvZG8gU2hvdWxkIHBlcmhhcHMgYmUgcmVuYW1lZCB0byBzZXRJZGVudGl0eSgpIHRvIGJlIG1vcmUgY2xlYXIuXG4gICAgICAgICAgICAgKiBAdG9kbyBDcmVhdGUgYW5vdGhlciBmdW5jdGlvbiB0aGF0IGltbWVkaWF0ZWx5IGNyZWF0ZXMgYW4gaWRlbnRpdHkgbWF0cml4IGVnLiBleWUoKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXQzLnByb3RvdHlwZS5pZGVudGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgZVswXSA9IDE7XG4gICAgICAgICAgICAgICAgZVsxXSA9IDA7XG4gICAgICAgICAgICAgICAgZVsyXSA9IDA7XG5cbiAgICAgICAgICAgICAgICBlWzNdID0gMDtcbiAgICAgICAgICAgICAgICBlWzRdID0gMTtcbiAgICAgICAgICAgICAgICBlWzVdID0gMDtcblxuICAgICAgICAgICAgICAgIGVbNl0gPSAwO1xuICAgICAgICAgICAgICAgIGVbN10gPSAwO1xuICAgICAgICAgICAgICAgIGVbOF0gPSAxO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgYWxsIGVsZW1lbnRzIHRvIHplcm9cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0WmVyb1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXQzLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgICAgICAgICBlWzBdID0gMDtcbiAgICAgICAgICAgICAgICBlWzFdID0gMDtcbiAgICAgICAgICAgICAgICBlWzJdID0gMDtcbiAgICAgICAgICAgICAgICBlWzNdID0gMDtcbiAgICAgICAgICAgICAgICBlWzRdID0gMDtcbiAgICAgICAgICAgICAgICBlWzVdID0gMDtcbiAgICAgICAgICAgICAgICBlWzZdID0gMDtcbiAgICAgICAgICAgICAgICBlWzddID0gMDtcbiAgICAgICAgICAgICAgICBlWzhdID0gMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0cyB0aGUgbWF0cml4IGRpYWdvbmFsIGVsZW1lbnRzIGZyb20gYSBWZWMzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldFRyYWNlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHZlYzNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWF0My5wcm90b3R5cGUuc2V0VHJhY2UgPSBmdW5jdGlvbiAodmVjMykge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5lbGVtZW50cztcbiAgICAgICAgICAgICAgICBlWzBdID0gdmVjMy54O1xuICAgICAgICAgICAgICAgIGVbNF0gPSB2ZWMzLnk7XG4gICAgICAgICAgICAgICAgZVs4XSA9IHZlYzMuejtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0cyB0aGUgbWF0cml4IGRpYWdvbmFsIGVsZW1lbnRzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldFRyYWNlXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXQzLnByb3RvdHlwZS5nZXRUcmFjZSA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgICAgICAgICAgICAgIHRhcmdldC54ID0gZVswXTtcbiAgICAgICAgICAgICAgICB0YXJnZXQueSA9IGVbNF07XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnogPSBlWzhdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXRyaXgtVmVjdG9yIG11bHRpcGxpY2F0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHZtdWx0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbCwgdGFyZ2V0IHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWF0My5wcm90b3R5cGUudm11bHQgPSBmdW5jdGlvbiAodiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHggPSB2LngsXG4gICAgICAgICAgICAgICAgICAgIHkgPSB2LnksXG4gICAgICAgICAgICAgICAgICAgIHogPSB2Lno7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnggPSBlWzBdICogeCArIGVbMV0gKiB5ICsgZVsyXSAqIHo7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSBlWzNdICogeCArIGVbNF0gKiB5ICsgZVs1XSAqIHo7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnogPSBlWzZdICogeCArIGVbN10gKiB5ICsgZVs4XSAqIHo7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXRyaXgtc2NhbGFyIG11bHRpcGxpY2F0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNtdWx0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXQzLnByb3RvdHlwZS5zbXVsdCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0gKj0gcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBtbXVsdFxuICAgICAgICAgICAgICogQHBhcmFtIHtNYXQzfSBtIE1hdHJpeCB0byBtdWx0aXBseSB3aXRoIGZyb20gbGVmdCBzaWRlLlxuICAgICAgICAgICAgICogQHJldHVybiB7TWF0M30gVGhlIHJlc3VsdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWF0My5wcm90b3R5cGUubW11bHQgPSBmdW5jdGlvbiAobSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgMzsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IG0uZWxlbWVudHNbaSArIGsgKiAzXSAqIHRoaXMuZWxlbWVudHNbayArIGogKiAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHIuZWxlbWVudHNbaSArIGogKiAzXSA9IHN1bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2NhbGUgZWFjaCBjb2x1bW4gb2YgdGhlIG1hdHJpeFxuICAgICAgICAgICAgICogQG1ldGhvZCBzY2FsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB2XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtNYXQzfSBUaGUgcmVzdWx0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXQzLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uICh2LCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0YXJnZXQuZWxlbWVudHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0WzMgKiBpICsgMF0gPSB2LnggKiBlWzMgKiBpICsgMF07XG4gICAgICAgICAgICAgICAgICAgIHRbMyAqIGkgKyAxXSA9IHYueSAqIGVbMyAqIGkgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgdFszICogaSArIDJdID0gdi56ICogZVszICogaSArIDJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb2x2ZSBBeD1iXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNvbHZlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IGIgVGhlIHJpZ2h0IGhhbmQgc2lkZVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCB2ZWN0b3IgdG8gc2F2ZSBpbi5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IFRoZSBzb2x1dGlvbiB4XG4gICAgICAgICAgICAgKiBAdG9kbyBzaG91bGQgcmV1c2UgYXJyYXlzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1hdDMucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKGIsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBuciA9IDM7IC8vIG51bSByb3dzXG4gICAgICAgICAgICAgICAgdmFyIG5jID0gNDsgLy8gbnVtIGNvbHNcbiAgICAgICAgICAgICAgICB2YXIgZXFucyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnIgKiBuYzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGVxbnMucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGksIGo7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcW5zW2kgKyBuYyAqIGpdID0gdGhpcy5lbGVtZW50c1tpICsgMyAqIGpdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVxbnNbMyArIDQgKiAwXSA9IGIueDtcbiAgICAgICAgICAgICAgICBlcW5zWzMgKyA0ICogMV0gPSBiLnk7XG4gICAgICAgICAgICAgICAgZXFuc1szICsgNCAqIDJdID0gYi56O1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSByaWdodCB1cHBlciB0cmlhbmd1bGFyIHZlcnNpb24gb2YgdGhlIG1hdHJpeCAtIEdhdXNzIGVsaW1pbmF0aW9uXG4gICAgICAgICAgICAgICAgdmFyIG4gPSAzLCBrID0gbiwgbnA7XG4gICAgICAgICAgICAgICAgdmFyIGtwID0gNDsgLy8gbnVtIHJvd3NcbiAgICAgICAgICAgICAgICB2YXIgcCwgZWxzO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGsgLSBuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBpdm90IGlzIG51bGwsIHN3YXAgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVxbnNbaSArIG5jICogal0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8geyAgLy8gZG8gbGlnbmUoIGkgKSA9IGxpZ25lKCBpICkgKyBsaWduZSggayApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCArIG5jICogaV0gKz0gZXFuc1twICsgbmMgKiBqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBpXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaSArIG5jICogal0gLyBlcW5zW2kgKyBuYyAqIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5wID0ga3A7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8geyAgLy8gZG8gbGlnbmUoIGsgKSA9IGxpZ25lKCBrICkgLSBtdWx0aXBsaWVyICogbGlnbmUoIGkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3AgKyBuYyAqIGpdIC0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBzb2x1dGlvblxuICAgICAgICAgICAgICAgIHRhcmdldC56ID0gZXFuc1syICogbmMgKyAzXSAvIGVxbnNbMiAqIG5jICsgMl07XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSAoZXFuc1sxICogbmMgKyAzXSAtIGVxbnNbMSAqIG5jICsgMl0gKiB0YXJnZXQueikgLyBlcW5zWzEgKiBuYyArIDFdO1xuICAgICAgICAgICAgICAgIHRhcmdldC54ID0gKGVxbnNbMCAqIG5jICsgM10gLSBlcW5zWzAgKiBuYyArIDJdICogdGFyZ2V0LnogLSBlcW5zWzAgKiBuYyArIDFdICogdGFyZ2V0LnkpIC8gZXFuc1swICogbmMgKyAwXTtcblxuICAgICAgICAgICAgICAgIGlmIChpc05hTih0YXJnZXQueCkgfHwgaXNOYU4odGFyZ2V0LnkpIHx8IGlzTmFOKHRhcmdldC56KSB8fCB0YXJnZXQueCA9PT0gSW5maW5pdHkgfHwgdGFyZ2V0LnkgPT09IEluZmluaXR5IHx8IHRhcmdldC56ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBzb2x2ZSBlcXVhdGlvbiEgR290IHg9W1wiICsgdGFyZ2V0LnRvU3RyaW5nKCkgKyBcIl0sIGI9W1wiICsgYi50b1N0cmluZygpICsgXCJdLCBBPVtcIiArIHRoaXMudG9TdHJpbmcoKSArIFwiXVwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbiBlbGVtZW50IGluIHRoZSBtYXRyaXggYnkgaW5kZXguIEluZGV4IHN0YXJ0cyBhdCAwLCBub3QgMSEhIVxuICAgICAgICAgICAgICogQG1ldGhvZCBlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcm93XG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gY29sdW1uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgT3B0aW9uYWwuIElmIHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnQgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWF0My5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uIChyb3csIGNvbHVtbiwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1tjb2x1bW4gKyAzICogcm93XTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tjb2x1bW4gKyAzICogcm93XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29weSBhbm90aGVyIG1hdHJpeCBpbnRvIHRoaXMgbWF0cml4IG9iamVjdC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgY29weVxuICAgICAgICAgICAgICogQHBhcmFtIHtNYXQzfSBzb3VyY2VcbiAgICAgICAgICAgICAqIEByZXR1cm4ge01hdDN9IHRoaXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWF0My5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZS5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldID0gc291cmNlLmVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4LlxuICAgICAgICAgICAgICogQG1ldGhvZCB0b1N0cmluZ1xuICAgICAgICAgICAgICogQHJldHVybiBzdHJpbmdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWF0My5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHZhciBzZXAgPSBcIixcIjtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByICs9IHRoaXMuZWxlbWVudHNbaV0gKyBzZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZXZlcnNlIHRoZSBtYXRyaXhcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmV2ZXJzZVxuICAgICAgICAgICAgICogQHBhcmFtIHtNYXQzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCBtYXRyaXggdG8gc2F2ZSBpbi5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge01hdDN9IFRoZSBzb2x1dGlvbiB4XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE1hdDMucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnNcbiAgICAgICAgICAgICAgICB2YXIgbnIgPSAzOyAvLyBudW0gcm93c1xuICAgICAgICAgICAgICAgIHZhciBuYyA9IDY7IC8vIG51bSBjb2xzXG4gICAgICAgICAgICAgICAgdmFyIGVxbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5yICogbmM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBlcW5zLnB1c2goMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpLCBqO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXFuc1tpICsgbmMgKiBqXSA9IHRoaXMuZWxlbWVudHNbaSArIDMgKiBqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcW5zWzMgKyA2ICogMF0gPSAxO1xuICAgICAgICAgICAgICAgIGVxbnNbMyArIDYgKiAxXSA9IDA7XG4gICAgICAgICAgICAgICAgZXFuc1szICsgNiAqIDJdID0gMDtcbiAgICAgICAgICAgICAgICBlcW5zWzQgKyA2ICogMF0gPSAwO1xuICAgICAgICAgICAgICAgIGVxbnNbNCArIDYgKiAxXSA9IDE7XG4gICAgICAgICAgICAgICAgZXFuc1s0ICsgNiAqIDJdID0gMDtcbiAgICAgICAgICAgICAgICBlcW5zWzUgKyA2ICogMF0gPSAwO1xuICAgICAgICAgICAgICAgIGVxbnNbNSArIDYgKiAxXSA9IDA7XG4gICAgICAgICAgICAgICAgZXFuc1s1ICsgNiAqIDJdID0gMTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvblxuICAgICAgICAgICAgICAgIHZhciBuID0gMywgayA9IG4sIG5wO1xuICAgICAgICAgICAgICAgIHZhciBrcCA9IG5jOyAvLyBudW0gcm93c1xuICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGsgLSBuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXFuc1tpICsgbmMgKiBpXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHBpdm90IGlzIG51bGwsIHN3YXAgbGluZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVxbnNbaSArIG5jICogal0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG8geyAvLyBkbyBsaW5lKCBpICkgPSBsaW5lKCBpICkgKyBsaW5lKCBrIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBrcCAtIG5wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBpXSArPSBlcW5zW3AgKyBuYyAqIGpdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcW5zW2kgKyBuYyAqIGldICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gZXFuc1tpICsgbmMgKiBqXSAvIGVxbnNbaSArIG5jICogaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbyB7IC8vIGRvIGxpbmUoIGsgKSA9IGxpbmUoIGsgKSAtIG11bHRpcGxpZXIgKiBsaW5lKCBpIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCArIG5jICogal0gPSBwIDw9IGkgPyAwIDogZXFuc1twICsgbmMgKiBqXSAtIGVxbnNbcCArIG5jICogaV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1uKTtcblxuICAgICAgICAgICAgICAgIC8vIGVsaW1pbmF0ZSB0aGUgdXBwZXIgbGVmdCB0cmlhbmdsZSBvZiB0aGUgbWF0cml4XG4gICAgICAgICAgICAgICAgaSA9IDI7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBqID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gZXFuc1tpICsgbmMgKiBqXSAvIGVxbnNbaSArIG5jICogaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBucCA9IG5jO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuYyAtIG5wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCArIG5jICogal0gPSBlcW5zW3AgKyBuYyAqIGpdIC0gZXFuc1twICsgbmMgKiBpXSAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoai0tKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWkpO1xuXG4gICAgICAgICAgICAgICAgLy8gb3BlcmF0aW9ucyBvbiB0aGUgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICBpID0gMjtcbiAgICAgICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gMSAvIGVxbnNbaSArIG5jICogaV07XG4gICAgICAgICAgICAgICAgICAgIG5wID0gbmM7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAgPSBuYyAtIG5wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXFuc1twICsgbmMgKiBpXSA9IGVxbnNbcCArIG5jICogaV0gKiBtdWx0aXBsaWVyO1xuICAgICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgICAgICAgICAgICAgaSA9IDI7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBqID0gMjtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcCA9IGVxbnNbbnIgKyBqICsgbmMgKiBpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihwKSB8fCBwID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHJldmVyc2UhIEE9W1wiICsgdGhpcy50b1N0cmluZygpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuZShpLCBqLCBwKTtcbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoai0tKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBtYXRyaXggZnJvbSBhIHF1YXRlcmlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTWF0My5wcm90b3R5cGUuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiA9IGZ1bmN0aW9uIChxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBxLngsIHkgPSBxLnksIHogPSBxLnosIHcgPSBxLncsXG4gICAgICAgICAgICAgICAgICAgIHgyID0geCArIHgsIHkyID0geSArIHksIHoyID0geiArIHosXG4gICAgICAgICAgICAgICAgICAgIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejIsXG4gICAgICAgICAgICAgICAgICAgIHl5ID0geSAqIHkyLCB5eiA9IHkgKiB6MiwgenogPSB6ICogejIsXG4gICAgICAgICAgICAgICAgICAgIHd4ID0gdyAqIHgyLCB3eSA9IHcgKiB5Miwgd3ogPSB3ICogejIsXG4gICAgICAgICAgICAgICAgICAgIGUgPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgZVszICogMCArIDBdID0gMSAtICh5eSArIHp6KTtcbiAgICAgICAgICAgICAgICBlWzMgKiAwICsgMV0gPSB4eSAtIHd6O1xuICAgICAgICAgICAgICAgIGVbMyAqIDAgKyAyXSA9IHh6ICsgd3k7XG5cbiAgICAgICAgICAgICAgICBlWzMgKiAxICsgMF0gPSB4eSArIHd6O1xuICAgICAgICAgICAgICAgIGVbMyAqIDEgKyAxXSA9IDEgLSAoeHggKyB6eik7XG4gICAgICAgICAgICAgICAgZVszICogMSArIDJdID0geXogLSB3eDtcblxuICAgICAgICAgICAgICAgIGVbMyAqIDIgKyAwXSA9IHh6IC0gd3k7XG4gICAgICAgICAgICAgICAgZVszICogMiArIDFdID0geXogKyB3eDtcbiAgICAgICAgICAgICAgICBlWzMgKiAyICsgMl0gPSAxIC0gKHh4ICsgeXkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRyYW5zcG9zZSB0aGUgbWF0cml4XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHRyYW5zcG9zZVxuICAgICAgICAgICAgICogQHBhcmFtICB7TWF0M30gdGFyZ2V0IFdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHQuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtNYXQzfSBUaGUgdGFyZ2V0IE1hdDMsIG9yIGEgbmV3IE1hdDMgaWYgdGFyZ2V0IHdhcyBvbWl0dGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBNYXQzLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgTXQgPSB0YXJnZXQuZWxlbWVudHMsXG4gICAgICAgICAgICAgICAgICAgIE0gPSB0aGlzLmVsZW1lbnRzO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gMzsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNdFszICogaSArIGpdID0gTVszICogaiArIGldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4vVmVjM1wiOiAzMCB9XSwgMjg6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFF1YXRlcm5pb247XG5cbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi9WZWMzJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBRdWF0ZXJuaW9uIGRlc2NyaWJlcyBhIHJvdGF0aW9uIGluIDNEIHNwYWNlLiBUaGUgUXVhdGVybmlvbiBpcyBtYXRoZW1hdGljYWxseSBkZWZpbmVkIGFzIFEgPSB4KmkgKyB5KmogKyB6KmsgKyB3LCB3aGVyZSAoaSxqLGspIGFyZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9ycy4gKHgseSx6KSBjYW4gYmUgc2VlbiBhcyBhIHZlY3RvciByZWxhdGVkIHRvIHRoZSBheGlzIG9mIHJvdGF0aW9uLCB3aGlsZSB0aGUgcmVhbCBtdWx0aXBsaWVyLCB3LCBpcyByZWxhdGVkIHRvIHRoZSBhbW91bnQgb2Ygcm90YXRpb24uXG4gICAgICAgICAgICAgKiBAY2xhc3MgUXVhdGVybmlvblxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geCBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geSBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGouXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geiBNdWx0aXBsaWVyIG9mIHRoZSBpbWFnaW5hcnkgYmFzaXMgdmVjdG9yIGsuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdyBNdWx0aXBsaWVyIG9mIHRoZSByZWFsIHBhcnQuXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUXVhdGVybmlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBRdWF0ZXJuaW9uKHgsIHksIHosIHcpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0geFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHggIT09IHVuZGVmaW5lZCA/IHggOiAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB6XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy56ID0geiAhPT0gdW5kZWZpbmVkID8geiA6IDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgbXVsdGlwbGllciBvZiB0aGUgcmVhbCBxdWF0ZXJuaW9uIGJhc2lzIHZlY3Rvci5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gd1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudyA9IHcgIT09IHVuZGVmaW5lZCA/IHcgOiAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgdmFsdWUgb2YgdGhlIHF1YXRlcm5pb24uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldFxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gelxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHdcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHgsIHksIHosIHcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgICAgICAgICAgdGhpcy56ID0gejtcbiAgICAgICAgICAgICAgICB0aGlzLncgPSB3O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0IHRvIGEgcmVhZGFibGUgZm9ybWF0XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHRvU3RyaW5nXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHN0cmluZ1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBRdWF0ZXJuaW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIixcIiArIHRoaXMueiArIFwiLFwiICsgdGhpcy53O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0IHRvIGFuIEFycmF5XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHRvQXJyYXlcbiAgICAgICAgICAgICAqIEByZXR1cm4gQXJyYXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUXVhdGVybmlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMud107XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgcXVhdGVybmlvbiBjb21wb25lbnRzIGdpdmVuIGFuIGF4aXMgYW5kIGFuIGFuZ2xlLlxuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRGcm9tQXhpc0FuZ2xlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IGF4aXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBhbmdsZSBpbiByYWRpYW5zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFF1YXRlcm5pb24ucHJvdG90eXBlLnNldEZyb21BeGlzQW5nbGUgPSBmdW5jdGlvbiAoYXhpcywgYW5nbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IE1hdGguc2luKGFuZ2xlICogMC41KTtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSBheGlzLnggKiBzO1xuICAgICAgICAgICAgICAgIHRoaXMueSA9IGF4aXMueSAqIHM7XG4gICAgICAgICAgICAgICAgdGhpcy56ID0gYXhpcy56ICogcztcbiAgICAgICAgICAgICAgICB0aGlzLncgPSBNYXRoLmNvcyhhbmdsZSAqIDAuNSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIHRoZSBxdWF0ZXJuaW9uIHRvIGF4aXMvYW5nbGUgcmVwcmVzZW50YXRpb24uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHRvQXhpc0FuZ2xlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldEF4aXMgT3B0aW9uYWwuIEEgdmVjdG9yIG9iamVjdCB0byByZXVzZSBmb3Igc3RvcmluZyB0aGUgYXhpcy5cbiAgICAgICAgICAgICAqIEByZXR1cm4gQXJyYXkgQW4gYXJyYXksIGZpcnN0IGVsZW1udCBpcyB0aGUgYXhpcyBhbmQgdGhlIHNlY29uZCBpcyB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUXVhdGVybmlvbi5wcm90b3R5cGUudG9BeGlzQW5nbGUgPSBmdW5jdGlvbiAodGFyZ2V0QXhpcykge1xuICAgICAgICAgICAgICAgIHRhcmdldEF4aXMgPSB0YXJnZXRBeGlzIHx8IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemUoKTsgLy8gaWYgdz4xIGFjb3MgYW5kIHNxcnQgd2lsbCBwcm9kdWNlIGVycm9ycywgdGhpcyBjYW50IGhhcHBlbiBpZiBxdWF0ZXJuaW9uIGlzIG5vcm1hbGlzZWRcbiAgICAgICAgICAgICAgICB2YXIgYW5nbGUgPSAyICogTWF0aC5hY29zKHRoaXMudyk7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMSAtIHRoaXMudyAqIHRoaXMudyk7IC8vIGFzc3VtaW5nIHF1YXRlcm5pb24gbm9ybWFsaXNlZCB0aGVuIHcgaXMgbGVzcyB0aGFuIDEsIHNvIHRlcm0gYWx3YXlzIHBvc2l0aXZlLlxuICAgICAgICAgICAgICAgIGlmIChzIDwgMC4wMDEpIHsgLy8gdGVzdCB0byBhdm9pZCBkaXZpZGUgYnkgemVybywgcyBpcyBhbHdheXMgcG9zaXRpdmUgZHVlIHRvIHNxcnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgcyBjbG9zZSB0byB6ZXJvIHRoZW4gZGlyZWN0aW9uIG9mIGF4aXMgbm90IGltcG9ydGFudFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLng7IC8vIGlmIGl0IGlzIGltcG9ydGFudCB0aGF0IGF4aXMgaXMgbm9ybWFsaXNlZCB0aGVuIHJlcGxhY2Ugd2l0aCB4PTE7IHk9ej0wO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMuejtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLnggLyBzOyAvLyBub3JtYWxpc2UgYXhpc1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnkgLyBzO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRBeGlzLnogPSB0aGlzLnogLyBzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW3RhcmdldEF4aXMsIGFuZ2xlXTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBzZnZfdDEgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIHNmdl90MiA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBxdWF0ZXJuaW9uIHZhbHVlIGdpdmVuIHR3byB2ZWN0b3JzLiBUaGUgcmVzdWx0aW5nIHJvdGF0aW9uIHdpbGwgYmUgdGhlIG5lZWRlZCByb3RhdGlvbiB0byByb3RhdGUgdSB0byB2LlxuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRGcm9tVmVjdG9yc1xuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB1XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHZcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUXVhdGVybmlvbi5wcm90b3R5cGUuc2V0RnJvbVZlY3RvcnMgPSBmdW5jdGlvbiAodSwgdikge1xuICAgICAgICAgICAgICAgIGlmICh1LmlzQW50aXBhcmFsbGVsVG8odikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQxID0gc2Z2X3QxO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdDIgPSBzZnZfdDI7XG5cbiAgICAgICAgICAgICAgICAgICAgdS50YW5nZW50cyh0MSwgdDIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21BeGlzQW5nbGUodDEsIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhID0gdS5jcm9zcyh2KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYS54O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBhLnk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IGEuejtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ID0gTWF0aC5zcXJ0KE1hdGgucG93KHUubm9ybSgpLCAyKSAqIE1hdGgucG93KHYubm9ybSgpLCAyKSkgKyB1LmRvdCh2KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFF1YXRlcm5pb24gbXVsdGlwbGljYXRpb25cbiAgICAgICAgICAgICAqIEBtZXRob2QgbXVsdFxuICAgICAgICAgICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldCBPcHRpb25hbC5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge1F1YXRlcm5pb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBRdWF0ZXJuaW9uX211bHRfdmEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIFF1YXRlcm5pb25fbXVsdF92YiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgUXVhdGVybmlvbl9tdWx0X3ZheHZiID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIFF1YXRlcm5pb24ucHJvdG90eXBlLm11bHQgPSBmdW5jdGlvbiAocSwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSB0aGlzLncsXG4gICAgICAgICAgICAgICAgICAgIHZhID0gUXVhdGVybmlvbl9tdWx0X3ZhLFxuICAgICAgICAgICAgICAgICAgICB2YiA9IFF1YXRlcm5pb25fbXVsdF92YixcbiAgICAgICAgICAgICAgICAgICAgdmF4dmIgPSBRdWF0ZXJuaW9uX211bHRfdmF4dmI7XG5cbiAgICAgICAgICAgICAgICB2YS5zZXQodGhpcy54LCB0aGlzLnksIHRoaXMueik7XG4gICAgICAgICAgICAgICAgdmIuc2V0KHEueCwgcS55LCBxLnopO1xuICAgICAgICAgICAgICAgIHRhcmdldC53ID0gdyAqIHEudyAtIHZhLmRvdCh2Yik7XG4gICAgICAgICAgICAgICAgdmEuY3Jvc3ModmIsIHZheHZiKTtcblxuICAgICAgICAgICAgICAgIHRhcmdldC54ID0gdyAqIHZiLnggKyBxLncgKiB2YS54ICsgdmF4dmIueDtcbiAgICAgICAgICAgICAgICB0YXJnZXQueSA9IHcgKiB2Yi55ICsgcS53ICogdmEueSArIHZheHZiLnk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnogPSB3ICogdmIueiArIHEudyAqIHZhLnogKyB2YXh2Yi56O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBpbnZlcnNlIHF1YXRlcm5pb24gcm90YXRpb24uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGludmVyc2VcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdGFyZ2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBRdWF0ZXJuaW9uLnByb3RvdHlwZS5pbnZlcnNlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56LCB3ID0gdGhpcy53O1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jb25qdWdhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5vcm0yID0gMSAvICh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdyk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnggKj0gaW5vcm0yO1xuICAgICAgICAgICAgICAgIHRhcmdldC55ICo9IGlub3JtMjtcbiAgICAgICAgICAgICAgICB0YXJnZXQueiAqPSBpbm9ybTI7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LncgKj0gaW5vcm0yO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBxdWF0ZXJuaW9uIGNvbmp1Z2F0ZVxuICAgICAgICAgICAgICogQG1ldGhvZCBjb25qdWdhdGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdGFyZ2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtRdWF0ZXJuaW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBRdWF0ZXJuaW9uLnByb3RvdHlwZS5jb25qdWdhdGUgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQueCA9IC10aGlzLng7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSAtdGhpcy55O1xuICAgICAgICAgICAgICAgIHRhcmdldC56ID0gLXRoaXMuejtcbiAgICAgICAgICAgICAgICB0YXJnZXQudyA9IHRoaXMudztcblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbi4gTm90ZSB0aGF0IHRoaXMgY2hhbmdlcyB0aGUgdmFsdWVzIG9mIHRoZSBxdWF0ZXJuaW9uLlxuICAgICAgICAgICAgICogQG1ldGhvZCBub3JtYWxpemVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUXVhdGVybmlvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBsID0gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudyk7XG4gICAgICAgICAgICAgICAgaWYgKGwgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsID0gMSAvIGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCAqPSBsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgKj0gbDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56ICo9IGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudyAqPSBsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwcm94aW1hdGlvbiBvZiBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24uIFdvcmtzIGJlc3Qgd2hlbiBxdWF0IGlzIGFscmVhZHkgYWxtb3N0LW5vcm1hbGl6ZWQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIG5vcm1hbGl6ZUZhc3RcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZmFzdC1xdWF0ZXJuaW9uLW5vcm1hbGl6YXRpb25cbiAgICAgICAgICAgICAqIEBhdXRob3IgdW5waGFzZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS91bnBoYXNlZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBRdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemVGYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gKDMuMCAtICh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKyB0aGlzLncgKiB0aGlzLncpKSAvIDIuMDtcbiAgICAgICAgICAgICAgICBpZiAoZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnogPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLncgPSAwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCAqPSBmO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgKj0gZjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56ICo9IGY7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudyAqPSBmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTXVsdGlwbHkgdGhlIHF1YXRlcm5pb24gYnkgYSB2ZWN0b3JcbiAgICAgICAgICAgICAqIEBtZXRob2Qgdm11bHRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWxcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFF1YXRlcm5pb24ucHJvdG90eXBlLnZtdWx0ID0gZnVuY3Rpb24gKHYsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHggPSB2LngsXG4gICAgICAgICAgICAgICAgICAgIHkgPSB2LnksXG4gICAgICAgICAgICAgICAgICAgIHogPSB2Lno7XG5cbiAgICAgICAgICAgICAgICB2YXIgcXggPSB0aGlzLngsXG4gICAgICAgICAgICAgICAgICAgIHF5ID0gdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICBxeiA9IHRoaXMueixcbiAgICAgICAgICAgICAgICAgICAgcXcgPSB0aGlzLnc7XG5cbiAgICAgICAgICAgICAgICAvLyBxKnZcbiAgICAgICAgICAgICAgICB2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgICAgICAgICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICAgICAgICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgICAgICAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnggPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgICAgICAgICAgICAgIHRhcmdldC55ID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICAgICAgICAgICAgICB0YXJnZXQueiA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb3BpZXMgdmFsdWUgb2Ygc291cmNlIHRvIHRoaXMgcXVhdGVybmlvbi5cbiAgICAgICAgICAgICAqIEBtZXRob2QgY29weVxuICAgICAgICAgICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBzb3VyY2VcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1F1YXRlcm5pb259IHRoaXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUXVhdGVybmlvbi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBzb3VyY2UueTtcbiAgICAgICAgICAgICAgICB0aGlzLnogPSBzb3VyY2UuejtcbiAgICAgICAgICAgICAgICB0aGlzLncgPSBzb3VyY2UudztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydCB0aGUgcXVhdGVybmlvbiB0byBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbi4gT3JkZXI6IFlaWCwgYXMgdGhpcyBwYWdlIGRlc2NyaWJlczogaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvc3RhbmRhcmRzL2luZGV4Lmh0bVxuICAgICAgICAgICAgICogQG1ldGhvZCB0b0V1bGVyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICAgICAgICAgICAgICogQHBhcmFtIHN0cmluZyBvcmRlciBUaHJlZS1jaGFyYWN0ZXIgc3RyaW5nIGUuZy4gXCJZWlhcIiwgd2hpY2ggYWxzbyBpcyBkZWZhdWx0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBRdWF0ZXJuaW9uLnByb3RvdHlwZS50b0V1bGVyID0gZnVuY3Rpb24gKHRhcmdldCwgb3JkZXIpIHtcbiAgICAgICAgICAgICAgICBvcmRlciA9IG9yZGVyIHx8IFwiWVpYXCI7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGVhZGluZywgYXR0aXR1ZGUsIGJhbms7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJZWlhcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0ID0geCAqIHkgKyB6ICogdztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZXN0ID4gMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgbm9ydGggcG9sZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRpbmcgPSAyICogTWF0aC5hdGFuMih4LCB3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRpdHVkZSA9IE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhbmsgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlc3QgPCAtMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRpbmcgPSAtMiAqIE1hdGguYXRhbjIoeCwgdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0aXR1ZGUgPSAtIE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhbmsgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKGhlYWRpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNxeCA9IHggKiB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcXkgPSB5ICogeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3F6ID0geiAqIHo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGluZyA9IE1hdGguYXRhbjIoMiAqIHkgKiB3IC0gMiAqIHggKiB6LCAxIC0gMiAqIHNxeSAtIDIgKiBzcXopOyAvLyBIZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0aXR1ZGUgPSBNYXRoLmFzaW4oMiAqIHRlc3QpOyAvLyBhdHRpdHVkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhbmsgPSBNYXRoLmF0YW4yKDIgKiB4ICogdyAtIDIgKiB5ICogeiwgMSAtIDIgKiBzcXggLSAyICogc3F6KTsgLy8gYmFua1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdWxlciBvcmRlciBcIiArIG9yZGVyICsgXCIgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRhcmdldC55ID0gaGVhZGluZztcbiAgICAgICAgICAgICAgICB0YXJnZXQueiA9IGF0dGl0dWRlO1xuICAgICAgICAgICAgICAgIHRhcmdldC54ID0gYmFuaztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VlIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS8yMDY5Ni1mdW5jdGlvbi10by1jb252ZXJ0LWJldHdlZW4tZGNtLWV1bGVyLWFuZ2xlcy1xdWF0ZXJuaW9ucy1hbmQtZXVsZXItdmVjdG9ycy9jb250ZW50L1NwaW5DYWxjLm1cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0RnJvbUV1bGVyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geFxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3JkZXIgVGhlIG9yZGVyIHRvIGFwcGx5IGFuZ2xlczogJ1hZWicgb3IgJ1lYWicgb3IgYW55IG90aGVyIGNvbWJpbmF0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFF1YXRlcm5pb24ucHJvdG90eXBlLnNldEZyb21FdWxlciA9IGZ1bmN0aW9uICh4LCB5LCB6LCBvcmRlcikge1xuICAgICAgICAgICAgICAgIG9yZGVyID0gb3JkZXIgfHwgXCJYWVpcIjtcblxuICAgICAgICAgICAgICAgIHZhciBjMSA9IE1hdGguY29zKHggLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgYzIgPSBNYXRoLmNvcyh5IC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIGMzID0gTWF0aC5jb3MoeiAvIDIpO1xuICAgICAgICAgICAgICAgIHZhciBzMSA9IE1hdGguc2luKHggLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgczIgPSBNYXRoLnNpbih5IC8gMik7XG4gICAgICAgICAgICAgICAgdmFyIHMzID0gTWF0aC5zaW4oeiAvIDIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyID09PSAnWFlaJykge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWFonKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1pYWScpIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9yZGVyID09PSAnWllYJykge1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAob3JkZXIgPT09ICdZWlgnKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcmRlciA9PT0gJ1haWScpIHtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUXVhdGVybmlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0ZXJuaW9uKHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi9WZWMzXCI6IDMwIH1dLCAyOTogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4vUXVhdGVybmlvbicpO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2xhc3MgVHJhbnNmb3JtXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5xdWF0ZXJuaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wUXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQG1ldGhvZCBwb2ludFRvTG9jYUZyYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRlcm5pb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gd29ybGRQb2ludFxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSByZXN1bHRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFBvaW50LCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgd29ybGRQb2ludC52c3ViKHBvc2l0aW9uLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHF1YXRlcm5pb24uY29uanVnYXRlKHRtcFF1YXQpO1xuICAgICAgICAgICAgICAgIHRtcFF1YXQudm11bHQocmVzdWx0LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIGdsb2JhbCBwb2ludCBpbiBsb2NhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBvaW50VG9Mb2NhbFxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gcG9pbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICAgICAgICAgICAgICogQHJldHVybiB7VmVjM30gVGhlIFwicmVzdWx0XCIgdmVjdG9yIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmFuc2Zvcm0ucHJvdG90eXBlLnBvaW50VG9Mb2NhbCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50LCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgd29ybGRQb2ludCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQG1ldGhvZCBwb2ludFRvV29ybGRGcmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBwb3NpdGlvblxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBxdWF0ZXJuaW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IGxvY2FsUG9pbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gcmVzdWx0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgcXVhdGVybmlvbiwgbG9jYWxQb2ludCwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFkZChwb3NpdGlvbiwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYSBsb2NhbCBwb2ludCBpbiBnbG9iYWwgdHJhbnNmb3JtIGNvb3JkaW5hdGVzLlxuICAgICAgICAgICAgICogQG1ldGhvZCBwb2ludFRvV29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHBvaW50XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInJlc3VsdFwiIHZlY3RvciBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJhbnNmb3JtLnByb3RvdHlwZS5wb2ludFRvV29ybGQgPSBmdW5jdGlvbiAobG9jYWxQb2ludCwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIGxvY2FsUG9pbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIFRyYW5zZm9ybS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24gKGxvY2FsVmVjdG9yLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24gKHF1YXRlcm5pb24sIGxvY2FsVmVjdG9yLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBxdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCB3b3JsZFZlY3RvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHF1YXRlcm5pb24udyAqPSAtMTtcbiAgICAgICAgICAgICAgICBxdWF0ZXJuaW9uLnZtdWx0KHdvcmxkVmVjdG9yLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHF1YXRlcm5pb24udyAqPSAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi9RdWF0ZXJuaW9uXCI6IDI4LCBcIi4vVmVjM1wiOiAzMCB9XSwgMzA6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFZlYzM7XG5cbiAgICAgICAgICAgIHZhciBNYXQzID0gX2RlcmVxXygnLi9NYXQzJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogMy1kaW1lbnNpb25hbCB2ZWN0b3JcbiAgICAgICAgICAgICAqIEBjbGFzcyBWZWMzXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGVcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAgdmFyIHYgPSBuZXcgVmVjMygxLCAyLCAzKTtcbiAgICAgICAgICAgICAqICAgICBjb25zb2xlLmxvZygneD0nICsgdi54KTsgLy8geD0xXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFZlYzMoeCwgeSwgeikge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB4XG4gICAgICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnggPSB4IHx8IDAuMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB5XG4gICAgICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnkgPSB5IHx8IDAuMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB6XG4gICAgICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnogPSB6IHx8IDAuMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1ZlYzN9IFpFUk9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5aRVJPID0gbmV3IFZlYzMoMCwgMCwgMCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzfSBVTklUX1hcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5VTklUX1ggPSBuZXcgVmVjMygxLCAwLCAwKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge1ZlYzN9IFVOSVRfWVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLlVOSVRfWSA9IG5ldyBWZWMzKDAsIDEsIDApO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gVU5JVF9aXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMuVU5JVF9aID0gbmV3IFZlYzMoMCwgMCwgMSk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVjdG9yIGNyb3NzIHByb2R1Y3RcbiAgICAgICAgICAgICAqIEBtZXRob2QgY3Jvc3NcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuIFRhcmdldCB0byBzYXZlIGluLlxuICAgICAgICAgICAgICogQHJldHVybiB7VmVjM31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUuY3Jvc3MgPSBmdW5jdGlvbiAodiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZ4ID0gdi54LCB2eSA9IHYueSwgdnogPSB2LnosIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICB0YXJnZXQueCA9ICh5ICogdnopIC0gKHogKiB2eSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSAoeiAqIHZ4KSAtICh4ICogdnopO1xuICAgICAgICAgICAgICAgIHRhcmdldC56ID0gKHggKiB2eSkgLSAoeSAqIHZ4KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgdmVjdG9ycycgMyBlbGVtZW50c1xuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0geVxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAgICAgICAgICAgICAqIEByZXR1cm4gVmVjM1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoeCwgeSwgeikge1xuICAgICAgICAgICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgICAgICAgICAgdGhpcy55ID0geTtcbiAgICAgICAgICAgICAgICB0aGlzLnogPSB6O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgYWxsIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB0byB6ZXJvLlxuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRaZXJvXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy54ID0gdGhpcy55ID0gdGhpcy56ID0gMDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVjdG9yIGFkZGl0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHZhZGRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS52YWRkID0gZnVuY3Rpb24gKHYsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnggPSB2LnggKyB0aGlzLng7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC55ID0gdi55ICsgdGhpcy55O1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQueiA9IHYueiArIHRoaXMuejtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54ICsgdi54LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy56ICsgdi56KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFZlY3RvciBzdWJ0cmFjdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCB2c3ViXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHZcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdG8gc2F2ZSBpbi5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLnZzdWIgPSBmdW5jdGlvbiAodiwgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQueCA9IHRoaXMueCAtIHYueDtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSB0aGlzLnkgLSB2Lnk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC56ID0gdGhpcy56IC0gdi56O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggLSB2LngsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnkgLSB2LnksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnogLSB2LnopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBjcm9zcyBwcm9kdWN0IG1hdHJpeCBhX2Nyb3NzIGZyb20gYSB2ZWN0b3IsIHN1Y2ggdGhhdCBhIHggYiA9IGFfY3Jvc3MgKiBiID0gY1xuICAgICAgICAgICAgICogQG1ldGhvZCBjcm9zc21hdFxuICAgICAgICAgICAgICogQHNlZSBodHRwOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyL1REQkQyNC9WVDA2L2xlY3R1cmVzL0xlY3R1cmU2LnBkZlxuICAgICAgICAgICAgICogQHJldHVybiB7TWF0M31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUuY3Jvc3NtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQzKFswLCAtdGhpcy56LCB0aGlzLnksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueiwgMCwgLXRoaXMueCxcbiAgICAgICAgICAgICAgICAgICAgLXRoaXMueSwgdGhpcy54LCAwXSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vcm1hbGl6ZSB0aGUgdmVjdG9yLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgaW4gdGhlIHZlY3Rvci5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgbm9ybWFsaXplXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIG5vcm0gb2YgdGhlIHZlY3RvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICAgICAgICAgICAgICBpZiAobiA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW52TiA9IDEgLyBuO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnggKj0gaW52TjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICo9IGludk47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueiAqPSBpbnZOO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc29tZXRoaW5nIHVwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHZlcnNpb24gb2YgdGhpcyB2ZWN0b3IgdGhhdCBpcyBvZiBsZW5ndGggMS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgdW5pdFxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgT3B0aW9uYWwgdGFyZ2V0IHRvIHNhdmUgaW5cbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IFJldHVybnMgdGhlIHVuaXQgdmVjdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLnVuaXQgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XG4gICAgICAgICAgICAgICAgdmFyIG5pbnYgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICAgICAgICAgICAgICBpZiAobmludiA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICBuaW52ID0gMS4wIC8gbmludjtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnggPSB4ICogbmludjtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSB5ICogbmludjtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnogPSB6ICogbmludjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQueCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC55ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnogPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yXG4gICAgICAgICAgICAgKiBAbWV0aG9kIG5vcm1cbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSAubGVuZ3RoKCkgaW5zdGVhZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS5ub3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxuICAgICAgICAgICAgICogQG1ldGhvZCBsZW5ndGhcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUubGVuZ3RoID0gVmVjMy5wcm90b3R5cGUubm9ybTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcbiAgICAgICAgICAgICAqIEBtZXRob2Qgbm9ybTJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSAubGVuZ3RoU3F1YXJlZCgpIGluc3RlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLm5vcm0yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdCh0aGlzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGUgdmVjdG9yLlxuICAgICAgICAgICAgICogQG1ldGhvZCBsZW5ndGhTcXVhcmVkXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLmxlbmd0aFNxdWFyZWQgPSBWZWMzLnByb3RvdHlwZS5ub3JtMjtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnRcbiAgICAgICAgICAgICAqIEBtZXRob2QgZGlzdGFuY2VUb1xuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gcFxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS5kaXN0YW5jZVRvID0gZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcbiAgICAgICAgICAgICAgICB2YXIgcHggPSBwLngsIHB5ID0gcC55LCBweiA9IHAuejtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KChweCAtIHgpICogKHB4IC0geCkgK1xuICAgICAgICAgICAgICAgICAgICAocHkgLSB5KSAqIChweSAtIHkpICtcbiAgICAgICAgICAgICAgICAgICAgKHB6IC0geikgKiAocHogLSB6KSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBzcXVhcmVkIGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XG4gICAgICAgICAgICAgKiBAbWV0aG9kIGRpc3RhbmNlU3F1YXJlZFxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gcFxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS5kaXN0YW5jZVNxdWFyZWQgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xuICAgICAgICAgICAgICAgIHZhciBweCA9IHAueCwgcHkgPSBwLnksIHB6ID0gcC56O1xuICAgICAgICAgICAgICAgIHJldHVybiAocHggLSB4KSAqIChweCAtIHgpICsgKHB5IC0geSkgKiAocHkgLSB5KSArIChweiAtIHopICogKHB6IC0geik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE11bHRpcGx5IGFsbCB0aGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIHdpdGggYSBzY2FsYXIuXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLnNjYWxlIGluc3RlYWRcbiAgICAgICAgICAgICAqIEBtZXRob2QgbXVsdFxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIC5zY2FsZSgpIGluc3RlYWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uIChzY2FsYXIsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICAgICAgICAgICAgICB5ID0gdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICB6ID0gdGhpcy56O1xuICAgICAgICAgICAgICAgIHRhcmdldC54ID0gc2NhbGFyICogeDtcbiAgICAgICAgICAgICAgICB0YXJnZXQueSA9IHNjYWxhciAqIHk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnogPSBzY2FsYXIgKiB6O1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE11bHRpcGx5IHRoZSB2ZWN0b3Igd2l0aCBhIHNjYWxhci5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2NhbGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS5zY2FsZSA9IFZlYzMucHJvdG90eXBlLm11bHQ7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2FsY3VsYXRlIGRvdCBwcm9kdWN0XG4gICAgICAgICAgICAgKiBAbWV0aG9kIGRvdFxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB2XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBpc1plcm9cbiAgICAgICAgICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueCA9PT0gMCAmJiB0aGlzLnkgPT09IDAgJiYgdGhpcy56ID09PSAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYWtlIHRoZSB2ZWN0b3IgcG9pbnQgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAqIEBtZXRob2QgbmVnYXRlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbCB0YXJnZXQgdG8gc2F2ZSBpblxuICAgICAgICAgICAgICogQHJldHVybiB7VmVjM31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHRhcmdldC54ID0gLXRoaXMueDtcbiAgICAgICAgICAgICAgICB0YXJnZXQueSA9IC10aGlzLnk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnogPSAtdGhpcy56O1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbXB1dGUgdHdvIGFydGlmaWNpYWwgdGFuZ2VudHMgdG8gdGhlIHZlY3RvclxuICAgICAgICAgICAgICogQG1ldGhvZCB0YW5nZW50c1xuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0MSBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIGZpcnN0IHRhbmdlbnQgaW5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdDIgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBzZWNvbmQgdGFuZ2VudCBpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgVmVjM190YW5nZW50c19uID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBWZWMzX3RhbmdlbnRzX3JhbmRWZWMgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUudGFuZ2VudHMgPSBmdW5jdGlvbiAodDEsIHQyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vcm0gPSB0aGlzLm5vcm0oKTtcbiAgICAgICAgICAgICAgICBpZiAobm9ybSA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFZlYzNfdGFuZ2VudHNfbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlub3JtID0gMSAvIG5vcm07XG4gICAgICAgICAgICAgICAgICAgIG4uc2V0KHRoaXMueCAqIGlub3JtLCB0aGlzLnkgKiBpbm9ybSwgdGhpcy56ICogaW5vcm0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmFuZFZlYyA9IFZlYzNfdGFuZ2VudHNfcmFuZFZlYztcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKG4ueCkgPCAwLjkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhbmRWZWMuc2V0KDEsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgbi5jcm9zcyhyYW5kVmVjLCB0MSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5kVmVjLnNldCgwLCAxLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYywgdDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG4uY3Jvc3ModDEsIHQyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9ybWFsIGxlbmd0aCBpcyB6ZXJvLCBtYWtlIHNvbWV0aGluZyB1cFxuICAgICAgICAgICAgICAgICAgICB0MS5zZXQoMSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHQyLnNldCgwLCAxLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnRzIHRvIGEgbW9yZSByZWFkYWJsZSBmb3JtYXRcbiAgICAgICAgICAgICAqIEBtZXRob2QgdG9TdHJpbmdcbiAgICAgICAgICAgICAqIEByZXR1cm4gc3RyaW5nXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiLFwiICsgdGhpcy56O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0cyB0byBhbiBhcnJheVxuICAgICAgICAgICAgICogQG1ldGhvZCB0b0FycmF5XG4gICAgICAgICAgICAgKiBAcmV0dXJuIEFycmF5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy56XTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29waWVzIHZhbHVlIG9mIHNvdXJjZSB0byB0aGlzIHZlY3Rvci5cbiAgICAgICAgICAgICAqIEBtZXRob2QgY29weVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBzb3VyY2VcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IHRoaXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICAgICAgICAgICAgICB0aGlzLnkgPSBzb3VyY2UueTtcbiAgICAgICAgICAgICAgICB0aGlzLnogPSBzb3VyY2UuejtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEbyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlY3RvcnNcbiAgICAgICAgICAgICAqIEBtZXRob2QgbGVycFxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB2XG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gdCBBIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuIDAgd2lsbCBtYWtlIHRoaXMgZnVuY3Rpb24gcmV0dXJuIHUsIGFuZCAxIHdpbGwgbWFrZSBpdCByZXR1cm4gdi4gTnVtYmVycyBpbiBiZXR3ZWVuIHdpbGwgZ2VuZXJhdGUgYSB2ZWN0b3IgaW4gYmV0d2VlbiB0aGVtLlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUubGVycCA9IGZ1bmN0aW9uICh2LCB0LCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcbiAgICAgICAgICAgICAgICB0YXJnZXQueCA9IHggKyAodi54IC0geCkgKiB0O1xuICAgICAgICAgICAgICAgIHRhcmdldC55ID0geSArICh2LnkgLSB5KSAqIHQ7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnogPSB6ICsgKHYueiAtIHopICogdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgaWYgYSB2ZWN0b3IgZXF1YWxzIGlzIGFsbW9zdCBlcXVhbCB0byBhbm90aGVyIG9uZS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYWxtb3N0RXF1YWxzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHZcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cbiAgICAgICAgICAgICAqIEByZXR1cm4gYm9vbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBWZWMzLnByb3RvdHlwZS5hbG1vc3RFcXVhbHMgPSBmdW5jdGlvbiAodiwgcHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IDFlLTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnggLSB2LngpID4gcHJlY2lzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMueSAtIHYueSkgPiBwcmVjaXNpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy56IC0gdi56KSA+IHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayBpZiBhIHZlY3RvciBpcyBhbG1vc3QgemVyb1xuICAgICAgICAgICAgICogQG1ldGhvZCBhbG1vc3RaZXJvXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLmFsbW9zdFplcm8gPSBmdW5jdGlvbiAocHJlY2lzaW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWNpc2lvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNpc2lvbiA9IDFlLTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh0aGlzLngpID4gcHJlY2lzaW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMueSkgPiBwcmVjaXNpb24gfHxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy56KSA+IHByZWNpc2lvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGFudGlwX25lZyA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ2hlY2sgaWYgdGhlIHZlY3RvciBpcyBhbnRpLXBhcmFsbGVsIHRvIGFub3RoZXIgdmVjdG9yLlxuICAgICAgICAgICAgICogQG1ldGhvZCBpc0FudGlwYXJhbGxlbFRvXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgdlxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSAgcHJlY2lzaW9uIFNldCB0byB6ZXJvIGZvciBleGFjdCBjb21wYXJpc29uc1xuICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjMy5wcm90b3R5cGUuaXNBbnRpcGFyYWxsZWxUbyA9IGZ1bmN0aW9uICh2LCBwcmVjaXNpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZ2F0ZShhbnRpcF9uZWcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbnRpcF9uZWcuYWxtb3N0RXF1YWxzKHYsIHByZWNpc2lvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsb25lIHRoZSB2ZWN0b3JcbiAgICAgICAgICAgICAqIEBtZXRob2QgY2xvbmVcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFZlYzMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLngsIHRoaXMueSwgdGhpcy56KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHsgXCIuL01hdDNcIjogMjcgfV0sIDMxOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBCb2R5O1xuXG4gICAgICAgICAgICB2YXIgRXZlbnRUYXJnZXQgPSBfZGVyZXFfKCcuLi91dGlscy9FdmVudFRhcmdldCcpO1xuICAgICAgICAgICAgdmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIE1hdDMgPSBfZGVyZXFfKCcuLi9tYXRoL01hdDMnKTtcbiAgICAgICAgICAgIHZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG4gICAgICAgICAgICB2YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xuICAgICAgICAgICAgdmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuICAgICAgICAgICAgdmFyIEJveCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Cb3gnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYXNlIGNsYXNzIGZvciBhbGwgYm9keSB0eXBlcy5cbiAgICAgICAgICAgICAqIEBjbGFzcyBCb2R5XG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBleHRlbmRzIEV2ZW50VGFyZ2V0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy52ZWxvY2l0eV1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYW5ndWxhclZlbG9jaXR5XVxuICAgICAgICAgICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBbb3B0aW9ucy5xdWF0ZXJuaW9uXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1hc3NdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBbb3B0aW9ucy5tYXRlcmlhbF1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy50eXBlXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxpbmVhckRhbXBpbmc9MC4wMV1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5hbmd1bGFyRGFtcGluZz0wLjAxXVxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd1NsZWVwPXRydWVdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2xlZXBTcGVlZExpbWl0PTAuMV1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zbGVlcFRpbWVMaW1pdD0xXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPTFdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0xXVxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5maXhlZFJvdGF0aW9uPWZhbHNlXVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5zaGFwZV1cbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAgdmFyIGJvZHkgPSBuZXcgQm9keSh7XG4gICAgICAgICAgICAgKiAgICAgICAgIG1hc3M6IDFcbiAgICAgICAgICAgICAqICAgICB9KTtcbiAgICAgICAgICAgICAqICAgICB2YXIgc2hhcGUgPSBuZXcgU3BoZXJlKDEpO1xuICAgICAgICAgICAgICogICAgIGJvZHkuYWRkU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICogICAgIHdvcmxkLmFkZChib2R5KTtcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQm9keShvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaWQgPSBCb2R5LmlkQ291bnRlcisrO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSB3b3JsZCB0aGUgYm9keSBpcyBsaXZpbmcgaW5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7V29ybGR9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgQkVGT1JFIHN0ZXBwaW5nIHRoZSBzeXN0ZW0uIFVzZSBpdCB0byBhcHBseSBmb3JjZXMsIGZvciBleGFtcGxlLiBJbnNpZGUgdGhlIGZ1bmN0aW9uLCBcInRoaXNcIiB3aWxsIHJlZmVyIHRvIHRoaXMgQm9keSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHByZVN0ZXBcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVTdGVwID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCBBRlRFUiBzdGVwcGluZyB0aGUgc3lzdGVtLiBJbnNpZGUgdGhlIGZ1bmN0aW9uLCBcInRoaXNcIiB3aWxsIHJlZmVyIHRvIHRoaXMgQm9keSBvYmplY3QuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHBvc3RTdGVwXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBXb3JsZCBldmVudHMgaW5zdGVhZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucG9zdFN0ZXAgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgdGhpcy52bGFtYmRhID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJHcm91cFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2YgKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXApID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXAgOiAxO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvbkZpbHRlck1hc2tcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSB0eXBlb2YgKG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaykgPT09ICdudW1iZXInID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrIDogMTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcHJldmlvdXNQb3NpdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGluaXRQb3NpdGlvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudmVsb2NpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS5jb3B5KG9wdGlvbnMudmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpbml0VmVsb2NpdHlcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmluaXRWZWxvY2l0eSA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBMaW5lYXIgZm9yY2Ugb24gdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgZm9yY2VcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIHZhciBtYXNzID0gdHlwZW9mIChvcHRpb25zLm1hc3MpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubWFzcyA6IDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMubWFzcyA9IG1hc3M7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbCB8fCBudWxsO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGxpbmVhckRhbXBpbmdcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMubGluZWFyRGFtcGluZyA9IHR5cGVvZiAob3B0aW9ucy5saW5lYXJEYW1waW5nKSA9PT0gJ251bWJlcicgPyBvcHRpb25zLmxpbmVhckRhbXBpbmcgOiAwLjAxO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogT25lIG9mOiBCb2R5LkRZTkFNSUMsIEJvZHkuU1RBVElDIGFuZCBCb2R5LktJTkVNQVRJQy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgdHlwZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gKG1hc3MgPD0gMC4wID8gQm9keS5TVEFUSUMgOiBCb2R5LkRZTkFNSUMpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbnMudHlwZSkgPT09IHR5cGVvZiAoQm9keS5TVEFUSUMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0cnVlLCB0aGUgYm9keSB3aWxsIGF1dG9tYXRpY2FsbHkgZmFsbCB0byBzbGVlcC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgYWxsb3dTbGVlcFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAgICAgICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmFsbG93U2xlZXAgPSB0eXBlb2YgKG9wdGlvbnMuYWxsb3dTbGVlcCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbGxvd1NsZWVwIDogdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnQgc2xlZXAgc3RhdGUuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHNsZWVwU3RhdGVcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgc3BlZWQgKHRoZSBub3JtIG9mIHRoZSB2ZWxvY2l0eSkgaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXB5LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzbGVlcFNwZWVkTGltaXRcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gdHlwZW9mIChvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5zbGVlcFNwZWVkTGltaXQgOiAwLjE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgYm9keSBoYXMgYmVlbiBzbGVlcHkgZm9yIHRoaXMgc2xlZXBUaW1lTGltaXQgc2Vjb25kcywgaXQgaXMgY29uc2lkZXJlZCBzbGVlcGluZy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgc2xlZXBUaW1lTGltaXRcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICAgICAqIEBkZWZhdWx0IDFcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNsZWVwVGltZUxpbWl0ID0gdHlwZW9mIChvcHRpb25zLnNsZWVwVGltZUxpbWl0KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwVGltZUxpbWl0IDogMTtcblxuICAgICAgICAgICAgICAgIHRoaXMudGltZUxhc3RTbGVlcHkgPSAwO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSA9IGZhbHNlO1xuXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSb3RhdGlvbmFsIGZvcmNlIG9uIHRoZSBib2R5LCBhcm91bmQgY2VudGVyIG9mIG1hc3NcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHRvcnF1ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudG9ycXVlID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9yaWVudGF0aW9uIG9mIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHF1YXRlcm5pb25cbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7UXVhdGVybmlvbn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVhdGVybmlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29weShvcHRpb25zLnF1YXRlcm5pb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpbml0UXVhdGVybmlvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtRdWF0ZXJuaW9ufVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGFuZ3VsYXJWZWxvY2l0eVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgaW5pdEFuZ3VsYXJWZWxvY2l0eVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdEFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmludGVycG9sYXRlZFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHNoYXBlc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHNoYXBlT2Zmc2V0c1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlT2Zmc2V0cyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHNoYXBlT3JpZW50YXRpb25zXG4gICAgICAgICAgICAgICAgICogQHR5cGUge2FycmF5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1ZlYzN9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5pbmVydGlhID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYSA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge01hdDN9IGludkluZXJ0aWFXb3JsZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkID0gbmV3IE1hdDMoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVNvbHZlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtNYXQzfSBpbnZJbmVydGlhV29ybGRTb2x2ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUgPSBuZXcgTWF0MygpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU2V0IHRvIHRydWUgaWYgeW91IGRvbid0IHdhbnQgdGhlIGJvZHkgdG8gcm90YXRlLiBNYWtlIHN1cmUgdG8gcnVuIC51cGRhdGVNYXNzUHJvcGVydGllcygpIGFmdGVyIGNoYW5naW5nIHRoaXMuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFJvdGF0aW9uXG4gICAgICAgICAgICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmZpeGVkUm90YXRpb24gPSB0eXBlb2YgKG9wdGlvbnMuZml4ZWRSb3RhdGlvbikgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmZpeGVkUm90YXRpb24gOiBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBhbmd1bGFyRGFtcGluZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhckRhbXBpbmcgPSB0eXBlb2YgKG9wdGlvbnMuYW5ndWxhckRhbXBpbmcpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5ndWxhckRhbXBpbmcgOiAwLjAxO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGFhYmJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QUFCQn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSW5kaWNhdGVzIGlmIHRoZSBBQUJCIG5lZWRzIHRvIGJlIHVwZGF0ZWQgYmVmb3JlIHVzZS5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgYWFiYk5lZWRzVXBkYXRlXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy53bGFtYmRhID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkU2hhcGUob3B0aW9ucy5zaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNYXNzUHJvcGVydGllcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQm9keS5wcm90b3R5cGUgPSBuZXcgRXZlbnRUYXJnZXQoKTtcbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm9keTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGR5bmFtaWMgYm9keSBpcyBmdWxseSBzaW11bGF0ZWQuIENhbiBiZSBtb3ZlZCBtYW51YWxseSBieSB0aGUgdXNlciwgYnV0IG5vcm1hbGx5IHRoZXkgbW92ZSBhY2NvcmRpbmcgdG8gZm9yY2VzLiBBIGR5bmFtaWMgYm9keSBjYW4gY29sbGlkZSB3aXRoIGFsbCBib2R5IHR5cGVzLiBBIGR5bmFtaWMgYm9keSBhbHdheXMgaGFzIGZpbml0ZSwgbm9uLXplcm8gbWFzcy5cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBEWU5BTUlDXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb2R5LkRZTkFNSUMgPSAxO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgc3RhdGljIGJvZHkgZG9lcyBub3QgbW92ZSBkdXJpbmcgc2ltdWxhdGlvbiBhbmQgYmVoYXZlcyBhcyBpZiBpdCBoYXMgaW5maW5pdGUgbWFzcy4gU3RhdGljIGJvZGllcyBjYW4gYmUgbW92ZWQgbWFudWFsbHkgYnkgc2V0dGluZyB0aGUgcG9zaXRpb24gb2YgdGhlIGJvZHkuIFRoZSB2ZWxvY2l0eSBvZiBhIHN0YXRpYyBib2R5IGlzIGFsd2F5cyB6ZXJvLiBTdGF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgU1RBVElDXG4gICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb2R5LlNUQVRJQyA9IDI7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBraW5lbWF0aWMgYm9keSBtb3ZlcyB1bmRlciBzaW11bGF0aW9uIGFjY29yZGluZyB0byBpdHMgdmVsb2NpdHkuIFRoZXkgZG8gbm90IHJlc3BvbmQgdG8gZm9yY2VzLiBUaGV5IGNhbiBiZSBtb3ZlZCBtYW51YWxseSwgYnV0IG5vcm1hbGx5IGEga2luZW1hdGljIGJvZHkgaXMgbW92ZWQgYnkgc2V0dGluZyBpdHMgdmVsb2NpdHkuIEEga2luZW1hdGljIGJvZHkgYmVoYXZlcyBhcyBpZiBpdCBoYXMgaW5maW5pdGUgbWFzcy4gS2luZW1hdGljIGJvZGllcyBkbyBub3QgY29sbGlkZSB3aXRoIG90aGVyIHN0YXRpYyBvciBraW5lbWF0aWMgYm9kaWVzLlxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQHByb3BlcnR5IEtJTkVNQVRJQ1xuICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQm9keS5LSU5FTUFUSUMgPSA0O1xuXG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgQVdBS0VcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkuQVdBS0UgPSAwO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBTTEVFUFlcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkuU0xFRVBZID0gMTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgU0xFRVBJTkdcbiAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkuU0xFRVBJTkcgPSAyO1xuXG4gICAgICAgICAgICBCb2R5LmlkQ291bnRlciA9IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2FrZSB0aGUgYm9keSB1cC5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgd2FrZVVwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLndha2VVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSAwO1xuICAgICAgICAgICAgICAgIGlmIChzID09PSBCb2R5LlNMRUVQSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh7IHR5cGU6IFwid2FrZXVwXCIgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGb3JjZSBib2R5IHNsZWVwXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNsZWVwXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLnNsZWVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2xlZXBTdGF0ZSA9IEJvZHkuU0xFRVBJTkc7XG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsIDAsIDApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgQm9keS5zbGVlcHlFdmVudCA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNsZWVweVwiXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBCb2R5LnNsZWVwRXZlbnQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzbGVlcFwiXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGxlZCBldmVyeSB0aW1lc3RlcCB0byB1cGRhdGUgaW50ZXJuYWwgc2xlZXAgdGltZXIgYW5kIGNoYW5nZSBzbGVlcCBzdGF0ZSBpZiBuZWVkZWQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNsZWVwVGlja1xuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgVGhlIHdvcmxkIHRpbWUgaW4gc2Vjb25kc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb2R5LnByb3RvdHlwZS5zbGVlcFRpY2sgPSBmdW5jdGlvbiAodGltZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93U2xlZXApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWQgPSB0aGlzLnZlbG9jaXR5Lm5vcm0yKCkgKyB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwgMik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmIHNwZWVkU3F1YXJlZCA8IHNwZWVkTGltaXRTcXVhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNsZWVwU3RhdGUgPSBCb2R5LlNMRUVQWTsgLy8gU2xlZXB5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChCb2R5LnNsZWVweUV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQWSAmJiBzcGVlZFNxdWFyZWQgPiBzcGVlZExpbWl0U3F1YXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53YWtlVXAoKTsgLy8gV2FrZSB1cFxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBZICYmICh0aW1lIC0gdGhpcy50aW1lTGFzdFNsZWVweSkgPiB0aGlzLnNsZWVwVGltZUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNsZWVwKCk7IC8vIFNsZWVwaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcEV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcsIGl0IHNob3VsZCBiZSBpbW1vdmFibGUgLyBoYXZlIGluZmluaXRlIG1hc3MgZHVyaW5nIHNvbHZlLiBXZSBzb2x2ZSBpdCBieSBoYXZpbmcgYSBzZXBhcmF0ZSBcInNvbHZlIG1hc3NcIi5cbiAgICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlU29sdmVNYXNzUHJvcGVydGllc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlLnNldFplcm8oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhV29ybGRTb2x2ZS5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZNYXNzU29sdmUgPSB0aGlzLmludk1hc3M7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW52SW5lcnRpYVNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZJbmVydGlhV29ybGRTb2x2ZS5jb3B5KHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnQgYSB3b3JsZCBwb2ludCB0byBsb2NhbCBib2R5IGZyYW1lLlxuICAgICAgICAgICAgICogQG1ldGhvZCBwb2ludFRvTG9jYWxGcmFtZVxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludFxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb2R5LnByb3RvdHlwZS5wb2ludFRvTG9jYWxGcmFtZSA9IGZ1bmN0aW9uICh3b3JsZFBvaW50LCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHJlc3VsdCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb252ZXJ0IGEgd29ybGQgdmVjdG9yIHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHZlY3RvclRvTG9jYWxGcmFtZVxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludFxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb2R5LnByb3RvdHlwZS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbiAod29ybGRWZWN0b3IsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24uY29uanVnYXRlKCkudm11bHQod29ybGRWZWN0b3IsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydCBhIGxvY2FsIGJvZHkgcG9pbnQgdG8gd29ybGQgZnJhbWUuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBvaW50VG9Xb3JsZEZyYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFBvaW50XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLnBvaW50VG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24gKGxvY2FsUG9pbnQsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFkZCh0aGlzLnBvc2l0aW9uLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnZlcnQgYSBsb2NhbCBib2R5IHBvaW50IHRvIHdvcmxkIGZyYW1lLlxuICAgICAgICAgICAgICogQG1ldGhvZCB2ZWN0b3JUb1dvcmxkRnJhbWVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsVmVjdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uIChsb2NhbFZlY3RvciwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRtcFZlYyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wUXVhdCA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGEgc2hhcGUgdG8gdGhlIGJvZHkgd2l0aCBhIGxvY2FsIG9mZnNldCBhbmQgb3JpZW50YXRpb24uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFkZFNoYXBlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBvZmZzZXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICAgICAgICAgICAgICogQHJldHVybiB7Qm9keX0gVGhlIGJvZHkgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb2R5LnByb3RvdHlwZS5hZGRTaGFwZSA9IGZ1bmN0aW9uIChzaGFwZSwgX29mZnNldCwgX29yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWVudGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgICAgICAgICAgICAgIGlmIChfb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldC5jb3B5KF9vZmZzZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX29yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWVudGF0aW9uLmNvcHkoX29yaWVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlcy5wdXNoKHNoYXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXBlT2Zmc2V0cy5wdXNoKG9mZnNldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFwZU9yaWVudGF0aW9ucy5wdXNoKG9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1JhZGl1cygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgYm91bmRpbmcgcmFkaXVzIG9mIHRoZSBib2R5LiBTaG91bGQgYmUgZG9uZSBpZiBhbnkgb2YgdGhlIHNoYXBlcyBhcmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdSYWRpdXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQm9keS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICAgICAgICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgICAgICAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1cyA9IDA7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IHNoYXBlT2Zmc2V0c1tpXS5ub3JtKCksXG4gICAgICAgICAgICAgICAgICAgICAgICByID0gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgKyByID4gcmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSBvZmZzZXQgKyByO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1JhZGl1cyA9IHJhZGl1cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjb21wdXRlQUFCQl9zaGFwZUFBQkIgPSBuZXcgQUFCQigpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZXMgdGhlIC5hYWJiXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvbXB1dGVBQUJCXG4gICAgICAgICAgICAgKiBAdG9kbyByZW5hbWUgdG8gdXBkYXRlQUFCQigpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLmNvbXB1dGVBQUJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZXMgPSB0aGlzLnNoYXBlcyxcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVPZmZzZXRzID0gdGhpcy5zaGFwZU9mZnNldHMsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlT3JpZW50YXRpb25zID0gdGhpcy5zaGFwZU9yaWVudGF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRtcFZlYyxcbiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb24gPSB0bXBRdWF0LFxuICAgICAgICAgICAgICAgICAgICBib2R5UXVhdCA9IHRoaXMucXVhdGVybmlvbixcbiAgICAgICAgICAgICAgICAgICAgYWFiYiA9IHRoaXMuYWFiYixcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVBQUJCID0gY29tcHV0ZUFBQkJfc2hhcGVBQUJCO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHF1YXRlcm5pb25cbiAgICAgICAgICAgICAgICAgICAgc2hhcGVPcmllbnRhdGlvbnNbaV0ubXVsdChib2R5UXVhdCwgb3JpZW50YXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBzaGFwZSB3b3JsZCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbi52bXVsdChzaGFwZU9mZnNldHNbaV0sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldC52YWRkKHRoaXMucG9zaXRpb24sIG9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdmVjMi5yb3RhdGUob2Zmc2V0LCBzaGFwZU9mZnNldHNbaV0sIGJvZHlBbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZlYzIuYWRkKG9mZnNldCwgb2Zmc2V0LCB0aGlzLnBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgc2hhcGUgQUFCQlxuICAgICAgICAgICAgICAgICAgICBzaGFwZS5jYWxjdWxhdGVXb3JsZEFBQkIob2Zmc2V0LCBvcmllbnRhdGlvbiwgc2hhcGVBQUJCLmxvd2VyQm91bmQsIHNoYXBlQUFCQi51cHBlckJvdW5kKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYWJiLmV4dGVuZChzaGFwZUFBQkIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB1aXdfbTEgPSBuZXcgTWF0MygpLFxuICAgICAgICAgICAgICAgIHVpd19tMiA9IG5ldyBNYXQzKCksXG4gICAgICAgICAgICAgICAgdWl3X20zID0gbmV3IE1hdDMoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgLmluZXJ0aWFXb3JsZCBhbmQgLmludkluZXJ0aWFXb3JsZFxuICAgICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVJbmVydGlhV29ybGRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQm9keS5wcm90b3R5cGUudXBkYXRlSW5lcnRpYVdvcmxkID0gZnVuY3Rpb24gKGZvcmNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIEkgPSB0aGlzLmludkluZXJ0aWE7XG4gICAgICAgICAgICAgICAgaWYgKEkueCA9PT0gSS55ICYmIEkueSA9PT0gSS56ICYmICFmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpbmVydGlhIE0gPSBzKkksIHdoZXJlIEkgaXMgaWRlbnRpdHkgYW5kIHMgYSBzY2FsYXIsIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgUipNKlInID0gUioocypJKSpSJyA9IHMqUipJKlInID0gcypSKlInID0gcypJID0gTVxuICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSBSIGlzIHRoZSByb3RhdGlvbiBtYXRyaXguXG4gICAgICAgICAgICAgICAgICAgIC8vIEluIG90aGVyIHdvcmRzLCB3ZSBkb24ndCBoYXZlIHRvIHRyYW5zZm9ybSB0aGUgaW5lcnRpYSBpZiBhbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5lcnRpYSBkaWFnb25hbCBlbnRyaWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbTEgPSB1aXdfbTEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtMiA9IHVpd19tMixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0zID0gdWl3X20zO1xuICAgICAgICAgICAgICAgICAgICBtMS5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKHRoaXMucXVhdGVybmlvbik7XG4gICAgICAgICAgICAgICAgICAgIG0xLnRyYW5zcG9zZShtMik7XG4gICAgICAgICAgICAgICAgICAgIG0xLnNjYWxlKEksIG0xKTtcbiAgICAgICAgICAgICAgICAgICAgbTEubW11bHQobTIsIHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcbiAgICAgICAgICAgICAgICAgICAgLy9tMy5nZXRUcmFjZSh0aGlzLmludkluZXJ0aWFXb3JsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQodGhpcy5pbmVydGlhLHRoaXMuaW5lcnRpYVdvcmxkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnF1YXRlcm5pb24udm11bHQodGhpcy5pbnZJbmVydGlhLHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBmb3JjZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQXBwbHlpbmcgZm9yY2UgdGhpcyB3YXkgd2lsbCBhZGQgdG8gQm9keS5mb3JjZSBhbmQgQm9keS50b3JxdWUuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGZvcmNlIFRoZSBhbW91bnQgb2YgZm9yY2UgdG8gYWRkLlxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludCBBIHdvcmxkIHBvaW50IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIEJvZHlfYXBwbHlGb3JjZV9yID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBCb2R5X2FwcGx5Rm9yY2Vfcm90Rm9yY2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgQm9keS5wcm90b3R5cGUuYXBwbHlGb3JjZSA9IGZ1bmN0aW9uIChmb3JjZSwgd29ybGRQb2ludCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBwb2ludCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXJcbiAgICAgICAgICAgICAgICB2YXIgciA9IEJvZHlfYXBwbHlGb3JjZV9yO1xuICAgICAgICAgICAgICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLCByKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBmb3JjZVxuICAgICAgICAgICAgICAgIHZhciByb3RGb3JjZSA9IEJvZHlfYXBwbHlGb3JjZV9yb3RGb3JjZTtcbiAgICAgICAgICAgICAgICByLmNyb3NzKGZvcmNlLCByb3RGb3JjZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgbGluZWFyIGZvcmNlXG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZS52YWRkKGZvcmNlLCB0aGlzLmZvcmNlKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgICAgICAgICAgICAgdGhpcy50b3JxdWUudmFkZChyb3RGb3JjZSwgdGhpcy50b3JxdWUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBmb3JjZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LlxuICAgICAgICAgICAgICogQG1ldGhvZCBhcHBseUxvY2FsRm9yY2VcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYXBwbHksIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keSBmcmFtZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZFBvaW50ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLmFwcGx5TG9jYWxGb3JjZSA9IGZ1bmN0aW9uIChsb2NhbEZvcmNlLCBsb2NhbFBvaW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgd29ybGRGb3JjZSA9IEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkRm9yY2U7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZFBvaW50O1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBmb3JjZSB2ZWN0b3IgdG8gd29ybGQgc3BhY2VcbiAgICAgICAgICAgICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEZvcmNlLCB3b3JsZEZvcmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvaW50VG9Xb3JsZEZyYW1lKGxvY2FsUG9pbnQsIHdvcmxkUG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBseUZvcmNlKHdvcmxkRm9yY2UsIHdvcmxkUG9pbnQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBpbXB1bHNlIHRvIGEgd29ybGQgcG9pbnQuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBbiBpbXB1bHNlIGlzIGEgZm9yY2UgYWRkZWQgdG8gYSBib2R5IGR1cmluZyBhIHNob3J0IHBlcmlvZCBvZiB0aW1lIChpbXB1bHNlID0gZm9yY2UgKiB0aW1lKS4gSW1wdWxzZXMgd2lsbCBiZSBhZGRlZCB0byBCb2R5LnZlbG9jaXR5IGFuZCBCb2R5LmFuZ3VsYXJWZWxvY2l0eS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYXBwbHlJbXB1bHNlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSBpbXB1bHNlIFRoZSBhbW91bnQgb2YgaW1wdWxzZSB0byBhZGQuXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50IEEgd29ybGQgcG9pbnQgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2VfciA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2VfdmVsbyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgQm9keV9hcHBseUltcHVsc2Vfcm90VmVsbyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBCb2R5LnByb3RvdHlwZS5hcHBseUltcHVsc2UgPSBmdW5jdGlvbiAoaW1wdWxzZSwgd29ybGRQb2ludCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBwb2ludCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXJcbiAgICAgICAgICAgICAgICB2YXIgciA9IEJvZHlfYXBwbHlJbXB1bHNlX3I7XG4gICAgICAgICAgICAgICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24sIHIpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCBjZW50cmFsIGltcHVsc2UgdmVsb2NpdHlcbiAgICAgICAgICAgICAgICB2YXIgdmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG87XG4gICAgICAgICAgICAgICAgdmVsby5jb3B5KGltcHVsc2UpO1xuICAgICAgICAgICAgICAgIHZlbG8ubXVsdCh0aGlzLmludk1hc3MsIHZlbG8pO1xuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGxpbmVhciBpbXB1bHNlXG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS52YWRkKHZlbG8sIHRoaXMudmVsb2NpdHkpO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGltcHVsc2UgdmVsb2NpdHlcbiAgICAgICAgICAgICAgICB2YXIgcm90VmVsbyA9IEJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG87XG4gICAgICAgICAgICAgICAgci5jcm9zcyhpbXB1bHNlLCByb3RWZWxvKTtcblxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgcm90VmVsby54ICo9IHRoaXMuaW52SW5lcnRpYS54O1xuICAgICAgICAgICAgICAgIHJvdFZlbG8ueSAqPSB0aGlzLmludkluZXJ0aWEueTtcbiAgICAgICAgICAgICAgICByb3RWZWxvLnogKj0gdGhpcy5pbnZJbmVydGlhLno7XG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZC52bXVsdChyb3RWZWxvLCByb3RWZWxvKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCByb3RhdGlvbmFsIEltcHVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS52YWRkKHJvdFZlbG8sIHRoaXMuYW5ndWxhclZlbG9jaXR5KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgbG9jYWxseS1kZWZpbmVkIGltcHVsc2UgdG8gYSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYXBwbHlMb2NhbEltcHVsc2VcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGZvcmNlIFRoZSBmb3JjZSB2ZWN0b3IgdG8gYXBwbHksIGRlZmluZWQgbG9jYWxseSBpbiB0aGUgYm9keSBmcmFtZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGxvY2FsUG9pbnQgQSBsb2NhbCBwb2ludCBpbiB0aGUgYm9keSB0byBhcHBseSB0aGUgZm9yY2Ugb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkSW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZFBvaW50ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLmFwcGx5TG9jYWxJbXB1bHNlID0gZnVuY3Rpb24gKGxvY2FsSW1wdWxzZSwgbG9jYWxQb2ludCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgIT09IEJvZHkuRFlOQU1JQykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkSW1wdWxzZSA9IEJvZHlfYXBwbHlMb2NhbEltcHVsc2Vfd29ybGRJbXB1bHNlO1xuICAgICAgICAgICAgICAgIHZhciB3b3JsZFBvaW50ID0gQm9keV9hcHBseUxvY2FsSW1wdWxzZV93b3JsZFBvaW50O1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBmb3JjZSB2ZWN0b3IgdG8gd29ybGQgc3BhY2VcbiAgICAgICAgICAgICAgICB0aGlzLnZlY3RvclRvV29ybGRGcmFtZShsb2NhbEltcHVsc2UsIHdvcmxkSW1wdWxzZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2ludFRvV29ybGRGcmFtZShsb2NhbFBvaW50LCB3b3JsZFBvaW50KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlJbXB1bHNlKHdvcmxkSW1wdWxzZSwgd29ybGRQb2ludCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cyA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciB5b3UgY2hhbmdlIHRoZSBib2R5IHNoYXBlIG9yIG1hc3MuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZU1hc3NQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJvZHkucHJvdG90eXBlLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBoYWxmRXh0ZW50cyA9IEJvZHlfdXBkYXRlTWFzc1Byb3BlcnRpZXNfaGFsZkV4dGVudHM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmludk1hc3MgPSB0aGlzLm1hc3MgPiAwID8gMS4wIC8gdGhpcy5tYXNzIDogMDtcbiAgICAgICAgICAgICAgICB2YXIgSSA9IHRoaXMuaW5lcnRpYTtcbiAgICAgICAgICAgICAgICB2YXIgZml4ZWQgPSB0aGlzLmZpeGVkUm90YXRpb247XG5cbiAgICAgICAgICAgICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIEFBQkIgYm94XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlQUFCQigpO1xuICAgICAgICAgICAgICAgIGhhbGZFeHRlbnRzLnNldChcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuYWFiYi51cHBlckJvdW5kLnggLSB0aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLmFhYmIudXBwZXJCb3VuZC55IC0gdGhpcy5hYWJiLmxvd2VyQm91bmQueSkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5hYWJiLnVwcGVyQm91bmQueiAtIHRoaXMuYWFiYi5sb3dlckJvdW5kLnopIC8gMlxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEoaGFsZkV4dGVudHMsIHRoaXMubWFzcywgSSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmludkluZXJ0aWEuc2V0KFxuICAgICAgICAgICAgICAgICAgICBJLnggPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueCA6IDAsXG4gICAgICAgICAgICAgICAgICAgIEkueSA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS55IDogMCxcbiAgICAgICAgICAgICAgICAgICAgSS56ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnogOiAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUluZXJ0aWFXb3JsZCh0cnVlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHdvcmxkIHZlbG9jaXR5IG9mIGEgcG9pbnQgaW4gdGhlIGJvZHkuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldFZlbG9jaXR5QXRXb3JsZFBvaW50XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IFRoZSByZXN1bHQgdmVjdG9yLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb2R5LnByb3RvdHlwZS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCA9IGZ1bmN0aW9uICh3b3JsZFBvaW50LCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24sIHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgdGhpcy52ZWxvY2l0eS52YWRkKHJlc3VsdCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vY29sbGlzaW9uL0FBQkJcIjogMywgXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOiAyNSwgXCIuLi9tYXRoL01hdDNcIjogMjcsIFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6IDI4LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi9zaGFwZXMvQm94XCI6IDM3LCBcIi4uL3NoYXBlcy9TaGFwZVwiOiA0MywgXCIuLi91dGlscy9FdmVudFRhcmdldFwiOiA0OSB9XSwgMzI6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICB2YXIgQm9keSA9IF9kZXJlcV8oJy4vQm9keScpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbiAgICAgICAgICAgIHZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG4gICAgICAgICAgICB2YXIgUmF5Y2FzdFJlc3VsdCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0Jyk7XG4gICAgICAgICAgICB2YXIgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpO1xuICAgICAgICAgICAgdmFyIFdoZWVsSW5mbyA9IF9kZXJlcV8oJy4uL29iamVjdHMvV2hlZWxJbmZvJyk7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gUmF5Y2FzdFZlaGljbGU7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVmVoaWNsZSBoZWxwZXIgY2xhc3MgdGhhdCBjYXN0cyByYXlzIGZyb20gdGhlIHdoZWVsIHBvc2l0aW9ucyB0b3dhcmRzIHRoZSBncm91bmQgYW5kIGFwcGxpZXMgZm9yY2VzLlxuICAgICAgICAgICAgICogQGNsYXNzIFJheWNhc3RWZWhpY2xlXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gW29wdGlvbnMuY2hhc3Npc0JvZHldIFRoZSBjYXIgY2hhc3NpcyBib2R5LlxuICAgICAgICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleFJpZ2h0QXhpc10gQXhpcyB0byB1c2UgZm9yIHJpZ2h0LiB4PTAsIHk9MSwgej0yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmluZGV4TGVmdEF4aXNdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IFtvcHRpb25zLmluZGV4VXBBeGlzXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBSYXljYXN0VmVoaWNsZShvcHRpb25zKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBbiBhcnJheSBvZiBXaGVlbEluZm8gb2JqZWN0cy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge2FycmF5fSB3aGVlbEluZm9zXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy53aGVlbEluZm9zID0gW107XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNsaWRpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7V29ybGR9IHdvcmxkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJbmRleCBvZiB0aGUgcmlnaHQgYXhpcywgMD14LCAxPXksIDI9elxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhSaWdodEF4aXNcbiAgICAgICAgICAgICAgICAgKiBAZGVmYXVsdCAxXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFJpZ2h0QXhpcyA9IHR5cGVvZiAob3B0aW9ucy5pbmRleFJpZ2h0QXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleFJpZ2h0QXhpcyA6IDE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJbmRleCBvZiB0aGUgZm9yd2FyZCBheGlzLCAwPXgsIDE9eSwgMj16XG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBpbmRleEZvcndhcmRBeGlzXG4gICAgICAgICAgICAgICAgICogQGRlZmF1bHQgMFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhGb3J3YXJkQXhpcyA9IHR5cGVvZiAob3B0aW9ucy5pbmRleEZvcndhcmRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4Rm9yd2FyZEF4aXMgOiAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSW5kZXggb2YgdGhlIHVwIGF4aXMsIDA9eCwgMT15LCAyPXpcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGluZGV4VXBBeGlzXG4gICAgICAgICAgICAgICAgICogQGRlZmF1bHQgMlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhVcEF4aXMgPSB0eXBlb2YgKG9wdGlvbnMuaW5kZXhVcEF4aXMpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhVcEF4aXMgOiAyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wVmVjMyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wVmVjNCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wVmVjNSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wVmVjNiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wUmF5ID0gbmV3IFJheSgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhIHdoZWVsLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMsIHNlZSBXaGVlbEluZm8uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFkZFdoZWVsXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IG5ldyBXaGVlbEluZm8ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy53aGVlbEluZm9zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0aGlzLndoZWVsSW5mb3MucHVzaChpbmZvKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBzdGVlcmluZyB2YWx1ZSBvZiBhIHdoZWVsLlxuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRTdGVlcmluZ1ZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0U3RlZXJpbmdWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSwgd2hlZWxJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciB3aGVlbCA9IHRoaXMud2hlZWxJbmZvc1t3aGVlbEluZGV4XTtcbiAgICAgICAgICAgICAgICB3aGVlbC5zdGVlcmluZyA9IHZhbHVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSB3aGVlbCBmb3JjZSB0byBhcHBseSBvbiBvbmUgb2YgdGhlIHdoZWVscyBlYWNoIHRpbWUgc3RlcFxuICAgICAgICAgICAgICogQG1ldGhvZCBhcHBseUVuZ2luZUZvcmNlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hcHBseUVuZ2luZUZvcmNlID0gZnVuY3Rpb24gKHZhbHVlLCB3aGVlbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmVuZ2luZUZvcmNlID0gdmFsdWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgYnJha2luZyBmb3JjZSBvZiBhIHdoZWVsXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldEJyYWtlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYnJha2VcbiAgICAgICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0QnJha2UgPSBmdW5jdGlvbiAoYnJha2UsIHdoZWVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0uYnJha2UgPSBicmFrZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgdG8gdGhlIHdvcmxkLlxuICAgICAgICAgICAgICogQG1ldGhvZCBhZGRUb1dvcmxkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgICAgICAgICAgICAgd29ybGQuYWRkKHRoaXMuY2hhc3Npc0JvZHkpO1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLnByZVN0ZXBDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC51cGRhdGVWZWhpY2xlKHdvcmxkLmR0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgb25lIG9mIHRoZSB3aGVlbCBheGxlcywgd29ybGQtb3JpZW50ZWQuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRWZWhpY2xlQXhpc1dvcmxkXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSBheGlzSW5kZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuZ2V0VmVoaWNsZUF4aXNXb3JsZCA9IGZ1bmN0aW9uIChheGlzSW5kZXgsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAgICAgICAgIGF4aXNJbmRleCA9PT0gMCA/IDEgOiAwLFxuICAgICAgICAgICAgICAgICAgICBheGlzSW5kZXggPT09IDEgPyAxIDogMCxcbiAgICAgICAgICAgICAgICAgICAgYXhpc0luZGV4ID09PSAyID8gMSA6IDBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhc3Npc0JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHJlc3VsdCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS51cGRhdGVWZWhpY2xlID0gZnVuY3Rpb24gKHRpbWVTdGVwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XG4gICAgICAgICAgICAgICAgdmFyIG51bVdoZWVscyA9IHdoZWVsSW5mb3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm0oaSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyID0gMy42ICogY2hhc3Npc0JvZHkudmVsb2NpdHkubm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZvcndhcmRXb3JsZCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRWZWhpY2xlQXhpc1dvcmxkKHRoaXMuaW5kZXhGb3J3YXJkQXhpcywgZm9yd2FyZFdvcmxkKTtcblxuICAgICAgICAgICAgICAgIGlmIChmb3J3YXJkV29ybGQuZG90KGNoYXNzaXNCb2R5LnZlbG9jaXR5KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VmVoaWNsZVNwZWVkS21Ib3VyICo9IC0xO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHNpbXVsYXRlIHN1c3BlbnNpb25cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FzdFJheSh3aGVlbEluZm9zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVN1c3BlbnNpb24odGltZVN0ZXApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHZhciByZWxwb3MgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy9hcHBseSBzdXNwZW5zaW9uIGZvcmNlXG4gICAgICAgICAgICAgICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdXNwZW5zaW9uRm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdXNwZW5zaW9uRm9yY2UgPiB3aGVlbC5tYXhTdXNwZW5zaW9uRm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1c3BlbnNpb25Gb3JjZSA9IHdoZWVsLm1heFN1c3BlbnNpb25Gb3JjZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkLnNjYWxlKHN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwLCBpbXB1bHNlKTtcblxuICAgICAgICAgICAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQudnN1YihjaGFzc2lzQm9keS5wb3NpdGlvbiwgcmVscG9zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhc3Npc0JvZHkuYXBwbHlJbXB1bHNlKGltcHVsc2UsIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC8qcmVscG9zKi8pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRnJpY3Rpb24odGltZVN0ZXApO1xuXG4gICAgICAgICAgICAgICAgdmFyIGhpdE5vcm1hbFdvcmxkU2NhbGVkV2l0aFByb2ogPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHZhciBmd2QgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHZhciB2ZWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciByZWxwb3MgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgICAgICAvL3doZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZC52c3ViKGNoYXNzaXNCb2R5LnBvc2l0aW9uLCByZWxwb3MpO1xuICAgICAgICAgICAgICAgICAgICBjaGFzc2lzQm9keS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludCh3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQsIHZlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSGFjayB0byBnZXQgdGhlIHJvdGF0aW9uIGluIHRoZSBjb3JyZWN0IGRpcmVjdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5pbmRleFVwQXhpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh3aGVlbC5pc0luQ29udGFjdCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmd2QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2ogPSBmd2QuZG90KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShwcm9qLCBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZndkLnZzdWIoaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiwgZndkKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2oyID0gZndkLmRvdCh2ZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9IG0gKiBwcm9qMiAqIHRpbWVTdGVwIC8gd2hlZWwucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCh3aGVlbC5zbGlkaW5nIHx8ICF3aGVlbC5pc0luQ29udGFjdCkgJiYgd2hlZWwuZW5naW5lRm9yY2UgIT09IDAgJiYgd2hlZWwudXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgY3VzdG9tIHJvdGF0aW9uIHdoZW4gYWNjZWxlcmF0aW5nIGFuZCBzbGlkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gKHdoZWVsLmVuZ2luZUZvcmNlID4gMCA/IDEgOiAtMSkgKiB3aGVlbC5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkICogdGltZVN0ZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBMb2NrIHdoZWVsc1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMod2hlZWwuYnJha2UpID4gTWF0aC5hYnMod2hlZWwuZW5naW5lRm9yY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5kZWx0YVJvdGF0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLnJvdGF0aW9uICs9IHdoZWVsLmRlbHRhUm90YXRpb247IC8vIFVzZSB0aGUgb2xkIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gKj0gMC45OTsgLy8gZGFtcGluZyBvZiByb3RhdGlvbiB3aGVuIG5vdCBpbiBjb250YWN0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVN1c3BlbnNpb24gPSBmdW5jdGlvbiAoZGVsdGFUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhc3Npc01hc3MgPSBjaGFzc2lzQm9keS5tYXNzO1xuICAgICAgICAgICAgICAgIHZhciB3aGVlbEluZm9zID0gdGhpcy53aGVlbEluZm9zO1xuICAgICAgICAgICAgICAgIHZhciBudW1XaGVlbHMgPSB3aGVlbEluZm9zLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHdfaXQgPSAwOyB3X2l0IDwgbnVtV2hlZWxzOyB3X2l0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1t3X2l0XTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmb3JjZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ByaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3VzcF9sZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50X2xlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25MZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoX2RpZmYgPSAoc3VzcF9sZW5ndGggLSBjdXJyZW50X2xlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlID0gd2hlZWwuc3VzcGVuc2lvblN0aWZmbmVzcyAqIGxlbmd0aF9kaWZmICogd2hlZWwuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEYW1wZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRfcmVsX3ZlbCA9IHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1c3BfZGFtcGluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0ZWRfcmVsX3ZlbCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdXNwX2RhbXBpbmcgPSB3aGVlbC5kYW1waW5nQ29tcHJlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdSZWxheGF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgLT0gc3VzcF9kYW1waW5nICogcHJvamVjdGVkX3JlbF92ZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IGZvcmNlICogY2hhc3Npc01hc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkZvcmNlIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmUgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyBmcm9tIHRoZSB3b3JsZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRnJvbVdvcmxkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSYXljYXN0VmVoaWNsZS5wcm90b3R5cGUucmVtb3ZlRnJvbVdvcmxkID0gZnVuY3Rpb24gKHdvcmxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgICAgICAgICAgICB3b3JsZC5yZW1vdmUodGhpcy5jaGFzc2lzQm9keSk7XG4gICAgICAgICAgICAgICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkID0gbnVsbDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjYXN0UmF5X3JheXZlY3RvciA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgY2FzdFJheV90YXJnZXQgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmNhc3RSYXkgPSBmdW5jdGlvbiAod2hlZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmF5dmVjdG9yID0gY2FzdFJheV9yYXl2ZWN0b3I7XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IGNhc3RSYXlfdGFyZ2V0O1xuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhc3Npc0JvZHkgPSB0aGlzLmNoYXNzaXNCb2R5O1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gLTE7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmF5bGVuID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggKyB3aGVlbC5yYWRpdXM7XG5cbiAgICAgICAgICAgICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZShyYXlsZW4sIHJheXZlY3Rvcik7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZDtcbiAgICAgICAgICAgICAgICBzb3VyY2UudmFkZChyYXl2ZWN0b3IsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIHJheWNhc3RSZXN1bHQgPSB3aGVlbC5yYXljYXN0UmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgdmFyIHBhcmFtID0gMDtcblxuICAgICAgICAgICAgICAgIHJheWNhc3RSZXN1bHQucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAvLyBUdXJuIG9mZiByYXkgY29sbGlzaW9uIHdpdGggdGhlIGNoYXNzaXMgdGVtcG9yYXJpbHlcbiAgICAgICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSBjaGFzc2lzQm9keS5jb2xsaXNpb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICBjaGFzc2lzQm9keS5jb2xsaXNpb25SZXNwb25zZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2FzdCByYXkgYWdhaW5zdCB3b3JsZFxuICAgICAgICAgICAgICAgIHRoaXMud29ybGQucmF5VGVzdChzb3VyY2UsIHRhcmdldCwgcmF5Y2FzdFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgY2hhc3Npc0JvZHkuY29sbGlzaW9uUmVzcG9uc2UgPSBvbGRTdGF0ZTtcblxuICAgICAgICAgICAgICAgIHZhciBvYmplY3QgPSByYXljYXN0UmVzdWx0LmJvZHk7XG5cbiAgICAgICAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0Lmdyb3VuZE9iamVjdCA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoID0gcmF5Y2FzdFJlc3VsdC5kaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7XG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaGl0RGlzdGFuY2UgPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gaGl0RGlzdGFuY2UgLSB3aGVlbC5yYWRpdXM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsXG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5TdXNwZW5zaW9uTGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggLSB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPCBtaW5TdXNwZW5zaW9uTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWluU3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA+IG1heFN1c3BlbnNpb25MZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBtYXhTdXNwZW5zaW9uTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3Qod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9qVmVsID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZW5vbWluYXRvciA+PSAtMC4xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxIC8gMC4xO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludiA9IC0xIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IHByb2pWZWwgKiBpbnY7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSBpbnY7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9wdXQgd2hlZWwgaW5mbyBhcyBpbiByZXN0IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCArIDAgKiB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsO1xuICAgICAgICAgICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgd2hlZWwuZGlyZWN0aW9uV29ybGQuc2NhbGUoLTEsIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICAgICAgICAgICAgICB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb24gPSAxLjA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVdoZWVsVHJhbnNmb3JtV29ybGQgPSBmdW5jdGlvbiAod2hlZWwpIHtcbiAgICAgICAgICAgICAgICB3aGVlbC5pc0luQ29udGFjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgICAgICAgICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpO1xuICAgICAgICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5kaXJlY3Rpb25Mb2NhbCwgd2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgICAgICAgICAgICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5heGxlTG9jYWwsIHdoZWVsLmF4bGVXb3JsZCk7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLlxuICAgICAgICAgICAgICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVdoZWVsVHJhbnNmb3JtXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXggVGhlIHdoZWVsIGluZGV4IHRvIHVwZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVdoZWVsVHJhbnNmb3JtID0gZnVuY3Rpb24gKHdoZWVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXAgPSB0bXBWZWM0O1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IHRtcFZlYzU7XG4gICAgICAgICAgICAgICAgdmFyIGZ3ZCA9IHRtcFZlYzY7XG5cbiAgICAgICAgICAgICAgICB2YXIgd2hlZWwgPSB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF07XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybVdvcmxkKHdoZWVsKTtcblxuICAgICAgICAgICAgICAgIHdoZWVsLmRpcmVjdGlvbkxvY2FsLnNjYWxlKC0xLCB1cCk7XG4gICAgICAgICAgICAgICAgcmlnaHQuY29weSh3aGVlbC5heGxlTG9jYWwpO1xuICAgICAgICAgICAgICAgIHVwLmNyb3NzKHJpZ2h0LCBmd2QpO1xuICAgICAgICAgICAgICAgIGZ3ZC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICByaWdodC5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSBhcm91bmQgc3RlZXJpbmcgb3ZlciB0aGUgd2hlZWxBeGxlXG4gICAgICAgICAgICAgICAgdmFyIHN0ZWVyaW5nID0gd2hlZWwuc3RlZXJpbmc7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZWVyaW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICAgICAgICAgICAgICBzdGVlcmluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHVwLCBzdGVlcmluZyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcm90YXRpbmdPcm4gPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgICAgICAgICAgIHJvdGF0aW5nT3JuLnNldEZyb21BeGlzQW5nbGUocmlnaHQsIHdoZWVsLnJvdGF0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHJvdGF0aW9uIG9mIHRoZSB3aGVlbFxuICAgICAgICAgICAgICAgIHZhciBxID0gd2hlZWwud29ybGRUcmFuc2Zvcm0ucXVhdGVybmlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXNzaXNCb2R5LnF1YXRlcm5pb24ubXVsdChzdGVlcmluZ09ybiwgcSk7XG4gICAgICAgICAgICAgICAgcS5tdWx0KHJvdGF0aW5nT3JuLCBxKTtcblxuICAgICAgICAgICAgICAgIHEubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAvLyB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgd2hlZWxcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHAuY29weSh3aGVlbC5kaXJlY3Rpb25Xb3JsZCk7XG4gICAgICAgICAgICAgICAgcC5zY2FsZSh3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoLCBwKTtcbiAgICAgICAgICAgICAgICBwLnZhZGQod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLCBwKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb25zID0gW1xuICAgICAgICAgICAgICAgIG5ldyBWZWMzKDEsIDAsIDApLFxuICAgICAgICAgICAgICAgIG5ldyBWZWMzKDAsIDEsIDApLFxuICAgICAgICAgICAgICAgIG5ldyBWZWMzKDAsIDAsIDEpXG4gICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgd29ybGQgdHJhbnNmb3JtIG9mIG9uZSBvZiB0aGUgd2hlZWxzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldFdoZWVsVHJhbnNmb3JtV29ybGRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1RyYW5zZm9ybX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmdldFdoZWVsVHJhbnNmb3JtV29ybGQgPSBmdW5jdGlvbiAod2hlZWxJbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0ud29ybGRUcmFuc2Zvcm07XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIHZhciB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZUZyaWN0aW9uX2F4bGUgPSBbXTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTtcbiAgICAgICAgICAgIHZhciBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTtcbiAgICAgICAgICAgIFJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS51cGRhdGVGcmljdGlvbiA9IGZ1bmN0aW9uICh0aW1lU3RlcCkge1xuICAgICAgICAgICAgICAgIHZhciBzdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2o7XG5cbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgaW1wdWxzZSwgc28gdGhhdCB0aGUgd2hlZWxzIGRvbid0IG1vdmUgc2lkZXdhcmRzXG4gICAgICAgICAgICAgICAgdmFyIHdoZWVsSW5mb3MgPSB0aGlzLndoZWVsSW5mb3M7XG4gICAgICAgICAgICAgICAgdmFyIG51bVdoZWVscyA9IHdoZWVsSW5mb3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgICAgICAgICAgICAgdmFyIGZvcndhcmRXUyA9IHVwZGF0ZUZyaWN0aW9uX2ZvcndhcmRXUztcbiAgICAgICAgICAgICAgICB2YXIgYXhsZSA9IHVwZGF0ZUZyaWN0aW9uX2F4bGU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbnVtV2hlZWxzT25Hcm91bmQgPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bVdoZWVsc09uR3JvdW5kKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3J3YXJkV1NbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRXU1tpXSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFheGxlW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBheGxlaSA9IGF4bGVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2hlZWxUcmFucyA9IHRoaXMuZ2V0V2hlZWxUcmFuc2Zvcm1Xb3JsZChpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGF4bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsVHJhbnMudmVjdG9yVG9Xb3JsZEZyYW1lKGRpcmVjdGlvbnNbdGhpcy5pbmRleFJpZ2h0QXhpc10sIGF4bGVpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN1cmZOb3JtYWxXUyA9IHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvaiA9IGF4bGVpLmRvdChzdXJmTm9ybWFsV1MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VyZk5vcm1hbFdTLnNjYWxlKHByb2osIHN1cmZOb3JtYWxXU19zY2FsZWRfcHJvaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBheGxlaS52c3ViKHN1cmZOb3JtYWxXU19zY2FsZWRfcHJvaiwgYXhsZWkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhsZWkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHN1cmZOb3JtYWxXUy5jcm9zcyhheGxlaSwgZm9yd2FyZFdTW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRXU1tpXS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYXNzaXNCb2R5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91bmRPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF4bGVpXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSAqPSBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHNpZGVGYWN0b3IgPSAxO1xuICAgICAgICAgICAgICAgIHZhciBmd2RGYWN0b3IgPSAwLjU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvbGxpbmdGcmljdGlvbiA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgd2hlZWwuc2xpcEluZm8gPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVmYXVsdFJvbGxpbmdGcmljdGlvbkltcHVsc2UgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1heEltcHVsc2UgPSB3aGVlbC5icmFrZSA/IHdoZWVsLmJyYWtlIDogZGVmYXVsdFJvbGxpbmdGcmljdGlvbkltcHVsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ0V2hlZWxDb250YWN0UG9pbnQgY29udGFjdFB0KGNoYXNzaXNCb2R5LGdyb3VuZE9iamVjdCx3aGVlbEluZnJheWNhc3RJbmZvLmhpdFBvaW50V29ybGQsZm9yd2FyZFdTW3doZWVsXSxtYXhJbXB1bHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJvbGxpbmdGcmljdGlvbiA9IGNhbGNSb2xsaW5nRnJpY3Rpb24oY29udGFjdFB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGxpbmdGcmljdGlvbiA9IGNhbGNSb2xsaW5nRnJpY3Rpb24oY2hhc3Npc0JvZHksIGdyb3VuZE9iamVjdCwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLCBmb3J3YXJkV1NbaV0sIG1heEltcHVsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByb2xsaW5nRnJpY3Rpb24gKz0gd2hlZWwuZW5naW5lRm9yY2UgKiB0aW1lU3RlcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm9sbGluZ0ZyaWN0aW9uID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBtYXhJbXB1bHNlIC8gcm9sbGluZ0ZyaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hlZWwuc2xpcEluZm8gKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9zd2l0Y2ggYmV0d2VlbiBhY3RpdmUgcm9sbGluZyAodGhyb3R0bGUpLCBicmFraW5nIGFuZCBub24tYWN0aXZlIHJvbGxpbmcgZnJpY3Rpb24gKG50aHJvdHRsZS9icmVhaylcblxuICAgICAgICAgICAgICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdW5kT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5za2lkSW5mbyA9IDE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhpbXAgPSB3aGVlbC5zdXNwZW5zaW9uRm9yY2UgKiB0aW1lU3RlcCAqIHdoZWVsLmZyaWN0aW9uU2xpcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhpbXBTaWRlID0gbWF4aW1wO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4aW1wU3F1YXJlZCA9IG1heGltcCAqIG1heGltcFNpZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gcm9sbGluZ0ZyaWN0aW9uOy8vd2hlZWxJbmZvLmVuZ2luZUZvcmNlKiB0aW1lU3RlcDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB3aGVlbC5mb3J3YXJkSW1wdWxzZSAqIGZ3ZEZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB5ID0gd2hlZWwuc2lkZUltcHVsc2UgKiBzaWRlRmFjdG9yO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZVNxdWFyZWQgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW1wdWxzZVNxdWFyZWQgPiBtYXhpbXBTcXVhcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGlkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5zbGlkaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWN0b3IgPSBtYXhpbXAgLyBNYXRoLnNxcnQoaW1wdWxzZVNxdWFyZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlZWwuc2tpZEluZm8gKj0gZmFjdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2xpZGluZykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdoZWVsLnNpZGVJbXB1bHNlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdoZWVsLnNraWRJbmZvIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSAqPSB3aGVlbC5za2lkSW5mbztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgKj0gd2hlZWwuc2tpZEluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgdGhlIGltcHVsc2VzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWxfcG9zID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICAgICAgLy93aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQudnN1YihjaGFzc2lzQm9keS5wb3NpdGlvbiwgcmVsX3Bvcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbm5vbnMgYXBwbHlpbXB1bHNlIGlzIHVzaW5nIHdvcmxkIGNvb3JkIGZvciB0aGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgcmVsX3Bvcy5jb3B5KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoZWVsLmZvcndhcmRJbXB1bHNlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW1wdWxzZSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkV1NbaV0uc2NhbGUod2hlZWwuZm9yd2FyZEltcHVsc2UsIGltcHVsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhc3Npc0JvZHkuYXBwbHlJbXB1bHNlKGltcHVsc2UsIHJlbF9wb3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHdoZWVsLnNpZGVJbXB1bHNlICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy93aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQudnN1Yihncm91bmRPYmplY3QucG9zaXRpb24sIHJlbF9wb3MyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWRlSW1wID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTY2FsZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIHVwIGRpcmVjdGlvbiB3aXRoIHJvbGxJbmZsdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLlxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb0xvY2FsRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxfcG9zWyd4eXonW3RoaXMuaW5kZXhVcEF4aXNdXSAqPSB3aGVlbC5yb2xsSW5mbHVlbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3Bvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vYXBwbHkgZnJpY3Rpb24gaW1wdWxzZSBvbiB0aGUgZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlSW1wLnNjYWxlKC0xLCBzaWRlSW1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VuZE9iamVjdC5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3BvczIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGNSb2xsaW5nRnJpY3Rpb24oYm9keTAsIGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkLCBtYXhJbXB1bHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGoxID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgY29udGFjdFBvc1dvcmxkID0gZnJpY3Rpb25Qb3NXb3JsZDtcblxuICAgICAgICAgICAgICAgIC8vIHZhciByZWxfcG9zMSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgLy8gdmFyIHJlbF9wb3MyID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICB2YXIgdmVsMSA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMTtcbiAgICAgICAgICAgICAgICB2YXIgdmVsMiA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMjtcbiAgICAgICAgICAgICAgICB2YXIgdmVsID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWw7XG4gICAgICAgICAgICAgICAgLy8gY29udGFjdFBvc1dvcmxkLnZzdWIoYm9keTAucG9zaXRpb24sIHJlbF9wb3MxKTtcbiAgICAgICAgICAgICAgICAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MS5wb3NpdGlvbiwgcmVsX3BvczIpO1xuXG4gICAgICAgICAgICAgICAgYm9keTAuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoY29udGFjdFBvc1dvcmxkLCB2ZWwxKTtcbiAgICAgICAgICAgICAgICBib2R5MS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChjb250YWN0UG9zV29ybGQsIHZlbDIpO1xuICAgICAgICAgICAgICAgIHZlbDEudnN1Yih2ZWwyLCB2ZWwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHZyZWwgPSBmcmljdGlvbkRpcmVjdGlvbldvcmxkLmRvdCh2ZWwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRlbm9tMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTAsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xuICAgICAgICAgICAgICAgIHZhciBkZW5vbTEgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yKGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXhhdGlvbiA9IDE7XG4gICAgICAgICAgICAgICAgdmFyIGphY0RpYWdBQkludiA9IHJlbGF4YXRpb24gLyAoZGVub20wICsgZGVub20xKTtcblxuICAgICAgICAgICAgICAgIC8vIGNhbGN1bGF0ZSBqIHRoYXQgbW92ZXMgdXMgdG8gemVybyByZWxhdGl2ZSB2ZWxvY2l0eVxuICAgICAgICAgICAgICAgIGoxID0gLXZyZWwgKiBqYWNEaWFnQUJJbnY7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4SW1wdWxzZSA8IGoxKSB7XG4gICAgICAgICAgICAgICAgICAgIGoxID0gbWF4SW1wdWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGoxIDwgLW1heEltcHVsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgajEgPSAtbWF4SW1wdWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gajE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keSwgcG9zLCBub3JtYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgcjAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwO1xuICAgICAgICAgICAgICAgIHZhciBjMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzA7XG4gICAgICAgICAgICAgICAgdmFyIHZlYyA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfdmVjO1xuICAgICAgICAgICAgICAgIHZhciBtID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tO1xuXG4gICAgICAgICAgICAgICAgcG9zLnZzdWIoYm9keS5wb3NpdGlvbiwgcjApO1xuICAgICAgICAgICAgICAgIHIwLmNyb3NzKG5vcm1hbCwgYzApO1xuICAgICAgICAgICAgICAgIGJvZHkuaW52SW5lcnRpYVdvcmxkLnZtdWx0KGMwLCBtKTtcbiAgICAgICAgICAgICAgICBtLmNyb3NzKHIwLCB2ZWMpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJvZHkuaW52TWFzcyArIG5vcm1hbC5kb3QodmVjKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwxID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLy9iaWxhdGVyYWwgY29uc3RyYWludCBiZXR3ZWVuIHR3byBkeW5hbWljIG9iamVjdHNcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoYm9keTEsIHBvczEsIGJvZHkyLCBwb3MyLCBub3JtYWwsIGltcHVsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9ybWFsTGVuU3FyID0gbm9ybWFsLm5vcm0yKCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbExlblNxciA+IDEuMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDsgLy8gbm8gaW1wdWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB2YXIgcmVsX3BvczEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIC8vIHZhciByZWxfcG9zMiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgLy8gcG9zMS52c3ViKGJvZHkxLnBvc2l0aW9uLCByZWxfcG9zMSk7XG4gICAgICAgICAgICAgICAgLy8gcG9zMi52c3ViKGJvZHkyLnBvc2l0aW9uLCByZWxfcG9zMik7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVsMSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMTtcbiAgICAgICAgICAgICAgICB2YXIgdmVsMiA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsMjtcbiAgICAgICAgICAgICAgICB2YXIgdmVsID0gcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWw7XG4gICAgICAgICAgICAgICAgYm9keTEuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMSwgdmVsMSk7XG4gICAgICAgICAgICAgICAgYm9keTIuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocG9zMiwgdmVsMik7XG5cbiAgICAgICAgICAgICAgICB2ZWwxLnZzdWIodmVsMiwgdmVsKTtcblxuICAgICAgICAgICAgICAgIHZhciByZWxfdmVsID0gbm9ybWFsLmRvdCh2ZWwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRhY3REYW1waW5nID0gMC4yO1xuICAgICAgICAgICAgICAgIHZhciBtYXNzVGVybSA9IDEgLyAoYm9keTEuaW52TWFzcyArIGJvZHkyLmludk1hc3MpO1xuICAgICAgICAgICAgICAgIHZhciBpbXB1bHNlID0gLSBjb250YWN0RGFtcGluZyAqIHJlbF92ZWwgKiBtYXNzVGVybTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBpbXB1bHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7IFwiLi4vY29sbGlzaW9uL1JheVwiOiA5LCBcIi4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6IDEwLCBcIi4uL21hdGgvUXVhdGVybmlvblwiOiAyOCwgXCIuLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi4vb2JqZWN0cy9XaGVlbEluZm9cIjogMzYsIFwiLi9Cb2R5XCI6IDMxIH1dLCAzMzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIHZhciBCb2R5ID0gX2RlcmVxXygnLi9Cb2R5Jyk7XG4gICAgICAgICAgICB2YXIgU3BoZXJlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NwaGVyZScpO1xuICAgICAgICAgICAgdmFyIEJveCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Cb3gnKTtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgSGluZ2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50Jyk7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gUmlnaWRWZWhpY2xlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNpbXBsZSB2ZWhpY2xlIGhlbHBlciBjbGFzcyB3aXRoIHNwaGVyaWNhbCByaWdpZCBib2R5IHdoZWVscy5cbiAgICAgICAgICAgICAqIEBjbGFzcyBSaWdpZFZlaGljbGVcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gUmlnaWRWZWhpY2xlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndoZWVsQm9kaWVzID0gW107XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgY29vcmRpbmF0ZVN5c3RlbVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29vcmRpbmF0ZVN5c3RlbSA9IHR5cGVvZiAob3B0aW9ucy5jb29yZGluYXRlU3lzdGVtKSA9PT0gJ3VuZGVmaW5lZCcgPyBuZXcgVmVjMygxLCAyLCAzKSA6IG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbS5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb2R5fSBjaGFzc2lzQm9keVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhc3Npc0JvZHkgPSBvcHRpb25zLmNoYXNzaXNCb2R5O1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoYXNzaXNCb2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vIGNoYXNzaXMgYm9keSBnaXZlbi4gQ3JlYXRlIGl0IVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhc3Npc1NoYXBlID0gbmV3IEJveChuZXcgVmVjMyg1LCAyLCAwLjUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFzc2lzQm9keSA9IG5ldyBCb2R5KDEsIGNoYXNzaXNTaGFwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIHRoaXMud2hlZWxBeGVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy53aGVlbEZvcmNlcyA9IFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhIHdoZWVsXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFkZFdoZWVsXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Zyb250V2hlZWxdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXSBQb3NpdGlvbiBvZiB0aGUgd2hlZWwsIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uXSBTbGlkZSBkaXJlY3Rpb24gb2YgdGhlIHdoZWVsIGFsb25nIHRoZSBzdXNwZW5zaW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzXSBBeGlzIG9mIHJvdGF0aW9uIG9mIHRoZSB3aGVlbCwgbG9jYWxseSBkZWZpbmVkIGluIHRoZSBjaGFzc2lzLlxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5ib2R5XSBUaGUgd2hlZWwgYm9keS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIHdoZWVsQm9keSA9IG9wdGlvbnMuYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoIXdoZWVsQm9keSkge1xuICAgICAgICAgICAgICAgICAgICB3aGVlbEJvZHkgPSBuZXcgQm9keSgxLCBuZXcgU3BoZXJlKDEuMikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLndoZWVsQm9kaWVzLnB1c2god2hlZWxCb2R5KTtcbiAgICAgICAgICAgICAgICB0aGlzLndoZWVsRm9yY2VzLnB1c2goMCk7XG5cbiAgICAgICAgICAgICAgICAvLyBQb3NpdGlvbiBjb25zdHJhaW4gd2hlZWxzXG4gICAgICAgICAgICAgICAgdmFyIHplcm8gPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IHR5cGVvZiAob3B0aW9ucy5wb3NpdGlvbikgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5wb3NpdGlvbi5jbG9uZSgpIDogbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgIC8vIFNldCBwb3NpdGlvbiBsb2NhbGx5IHRvIHRoZSBjaGFzc2lzXG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkUG9zaXRpb24gPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHdvcmxkUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIHdoZWVsQm9keS5wb3NpdGlvbi5zZXQod29ybGRQb3NpdGlvbi54LCB3b3JsZFBvc2l0aW9uLnksIHdvcmxkUG9zaXRpb24ueik7XG5cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJhaW4gd2hlZWxcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHR5cGVvZiAob3B0aW9ucy5heGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmF4aXMuY2xvbmUoKSA6IG5ldyBWZWMzKDAsIDEsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMud2hlZWxBeGVzLnB1c2goYXhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgaGluZ2VDb25zdHJhaW50ID0gbmV3IEhpbmdlQ29uc3RyYWludCh0aGlzLmNoYXNzaXNCb2R5LCB3aGVlbEJvZHksIHtcbiAgICAgICAgICAgICAgICAgICAgcGl2b3RBOiBwb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgYXhpc0E6IGF4aXMsXG4gICAgICAgICAgICAgICAgICAgIHBpdm90QjogVmVjMy5aRVJPLFxuICAgICAgICAgICAgICAgICAgICBheGlzQjogYXhpcyxcbiAgICAgICAgICAgICAgICAgICAgY29sbGlkZUNvbm5lY3RlZDogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goaGluZ2VDb25zdHJhaW50KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndoZWVsQm9kaWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0U3RlZXJpbmdWYWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAgICAgICAgICAgICAqIEB0b2RvIGNoZWNrIGNvb3JkaW5hdGVTeXN0ZW1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5zZXRTdGVlcmluZ1ZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCB3aGVlbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGFuZ2xlIG9mIHRoZSBoaW5nZSBheGlzXG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcblxuICAgICAgICAgICAgICAgIHZhciBjID0gTWF0aC5jb3ModmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBzID0gTWF0aC5zaW4odmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICB4ID0gYXhpcy54LFxuICAgICAgICAgICAgICAgICAgICB5ID0gYXhpcy55O1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF0uYXhpc0Euc2V0KFxuICAgICAgICAgICAgICAgICAgICBjICogeCAtIHMgKiB5LFxuICAgICAgICAgICAgICAgICAgICBzICogeCArIGMgKiB5LFxuICAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgaGluZ2UgY29uc3RyYWludC5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0TW90b3JTcGVlZFxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5zZXRNb3RvclNwZWVkID0gZnVuY3Rpb24gKHZhbHVlLCB3aGVlbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XG4gICAgICAgICAgICAgICAgaGluZ2VDb25zdHJhaW50LmVuYWJsZU1vdG9yKCk7XG4gICAgICAgICAgICAgICAgaGluZ2VDb25zdHJhaW50Lm1vdG9yVGFyZ2V0VmVsb2NpdHkgPSB2YWx1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSB0YXJnZXQgcm90YXRpb25hbCBzcGVlZCBvZiB0aGUgaGluZ2UgY29uc3RyYWludC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSaWdpZFZlaGljbGUucHJvdG90eXBlLmRpc2FibGVNb3RvciA9IGZ1bmN0aW9uICh3aGVlbEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XG4gICAgICAgICAgICAgICAgaGluZ2VDb25zdHJhaW50LmRpc2FibGVNb3RvcigpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSB3aGVlbCBmb3JjZSB0byBhcHBseSBvbiBvbmUgb2YgdGhlIHdoZWVscyBlYWNoIHRpbWUgc3RlcFxuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRXaGVlbEZvcmNlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0V2hlZWxGb3JjZSA9IGZ1bmN0aW9uICh2YWx1ZSwgd2hlZWxJbmRleCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2hlZWxGb3JjZXNbd2hlZWxJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgYSB0b3JxdWUgb24gb25lIG9mIHRoZSB3aGVlbHMuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFwcGx5V2hlZWxGb3JjZVxuICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB2YWx1ZVxuICAgICAgICAgICAgICogQHBhcmFtICB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSaWdpZFZlaGljbGUucHJvdG90eXBlLmFwcGx5V2hlZWxGb3JjZSA9IGZ1bmN0aW9uICh2YWx1ZSwgd2hlZWxJbmRleCkge1xuICAgICAgICAgICAgICAgIHZhciBheGlzID0gdGhpcy53aGVlbEF4ZXNbd2hlZWxJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIHdoZWVsQm9keSA9IHRoaXMud2hlZWxCb2RpZXNbd2hlZWxJbmRleF07XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlUb3JxdWUgPSB3aGVlbEJvZHkudG9ycXVlO1xuXG4gICAgICAgICAgICAgICAgYXhpcy5zY2FsZSh2YWx1ZSwgdG9ycXVlKTtcbiAgICAgICAgICAgICAgICB3aGVlbEJvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKHRvcnF1ZSwgdG9ycXVlKTtcbiAgICAgICAgICAgICAgICBib2R5VG9ycXVlLnZhZGQodG9ycXVlLCBib2R5VG9ycXVlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgdG8gdGhlIHdvcmxkLlxuICAgICAgICAgICAgICogQG1ldGhvZCBhZGRUb1dvcmxkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSaWdpZFZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbiAod29ybGQpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICAgICAgICAgIHZhciBib2RpZXMgPSB0aGlzLndoZWVsQm9kaWVzLmNvbmNhdChbdGhpcy5jaGFzc2lzQm9keV0pO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgd29ybGQuYWRkKGJvZGllc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB3aGVlbEZvcmNlcyA9IHRoaXMud2hlZWxGb3JjZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3aGVlbEZvcmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGx5V2hlZWxGb3JjZSh3aGVlbEZvcmNlc1tpXSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmUgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyBmcm9tIHRoZSB3b3JsZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRnJvbVdvcmxkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBSaWdpZFZlaGljbGUucHJvdG90eXBlLnJlbW92ZUZyb21Xb3JsZCA9IGZ1bmN0aW9uICh3b3JsZCkge1xuICAgICAgICAgICAgICAgIHZhciBjb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgICAgICAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMud2hlZWxCb2RpZXMuY29uY2F0KFt0aGlzLmNoYXNzaXNCb2R5XSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB3b3JsZC5yZW1vdmUoYm9kaWVzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnN0cmFpbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkLnJlbW92ZUNvbnN0cmFpbnQoY29uc3RyYWludHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB3b3JsZEF4aXMgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBjdXJyZW50IHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgYSB3aGVlbFxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRXaGVlbFNwZWVkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5nZXRXaGVlbFNwZWVkID0gZnVuY3Rpb24gKHdoZWVsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciB3aGVlbEJvZHkgPSB0aGlzLndoZWVsQm9kaWVzW3doZWVsSW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciB3ID0gd2hlZWxCb2R5LmFuZ3VsYXJWZWxvY2l0eTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShheGlzLCB3b3JsZEF4aXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB3LmRvdCh3b3JsZEF4aXMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50XCI6IDE1LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi9zaGFwZXMvQm94XCI6IDM3LCBcIi4uL3NoYXBlcy9TcGhlcmVcIjogNDQsIFwiLi9Cb2R5XCI6IDMxIH1dLCAzNDogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gU1BIU3lzdGVtO1xuXG4gICAgICAgICAgICB2YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xuICAgICAgICAgICAgdmFyIFBhcnRpY2xlID0gX2RlcmVxXygnLi4vc2hhcGVzL1BhcnRpY2xlJyk7XG4gICAgICAgICAgICB2YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuICAgICAgICAgICAgdmFyIE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTbW9vdGhlZC1wYXJ0aWNsZSBoeWRyb2R5bmFtaWNzIHN5c3RlbVxuICAgICAgICAgICAgICogQGNsYXNzIFNQSFN5c3RlbVxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNQSFN5c3RlbSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGVuc2l0eSBvZiB0aGUgc3lzdGVtIChrZy9tMykuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRlbnNpdHlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmRlbnNpdHkgPSAxO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRGlzdGFuY2UgYmVsb3cgd2hpY2ggdHdvIHBhcnRpY2xlcyBhcmUgY29uc2lkZXJlZCB0byBiZSBuZWlnaGJvcnMuXG4gICAgICAgICAgICAgICAgICogSXQgc2hvdWxkIGJlIGFkanVzdGVkIHNvIHRoZXJlIGFyZSBhYm91dCAxNS0yMCBuZWlnaGJvciBwYXJ0aWNsZXMgd2l0aGluIHRoaXMgcmFkaXVzLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbW9vdGhpbmdSYWRpdXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNtb290aGluZ1JhZGl1cyA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlZE9mU291bmQgPSAxO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVmlzY29zaXR5IG9mIHRoZSBzeXN0ZW0uXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZpc2Nvc2l0eVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudmlzY29zaXR5ID0gMC4wMTtcbiAgICAgICAgICAgICAgICB0aGlzLmVwcyA9IDAuMDAwMDAxO1xuXG4gICAgICAgICAgICAgICAgLy8gU3R1ZmYgQ29tcHV0ZWQgcGVyIHBhcnRpY2xlXG4gICAgICAgICAgICAgICAgdGhpcy5wcmVzc3VyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbnNpdGllcyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMubmVpZ2hib3JzID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGEgcGFydGljbGUgdG8gdGhlIHN5c3RlbS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYWRkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNQSFN5c3RlbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHBhcnRpY2xlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmVpZ2hib3JzLmxlbmd0aCA8IHRoaXMucGFydGljbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5laWdoYm9ycy5wdXNoKFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlbW92ZSBhIHBhcnRpY2xlIGZyb20gdGhlIHN5c3RlbS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNQSFN5c3RlbS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHBhcnRpY2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHRoaXMucGFydGljbGVzLmluZGV4T2YocGFydGljbGUpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydGljbGVzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZWlnaGJvcnMubGVuZ3RoID4gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5laWdoYm9ycy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IG5laWdoYm9ycyB3aXRoaW4gc21vb3RoaW5nIHZvbHVtZSwgc2F2ZSBpbiB0aGUgYXJyYXkgbmVpZ2hib3JzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldE5laWdoYm9yc1xuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBwYXJ0aWNsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gbmVpZ2hib3JzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBTUEhTeXN0ZW1fZ2V0TmVpZ2hib3JzX2Rpc3QgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgU1BIU3lzdGVtLnByb3RvdHlwZS5nZXROZWlnaGJvcnMgPSBmdW5jdGlvbiAocGFydGljbGUsIG5laWdoYm9ycykge1xuICAgICAgICAgICAgICAgIHZhciBOID0gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBpZCA9IHBhcnRpY2xlLmlkLFxuICAgICAgICAgICAgICAgICAgICBSMiA9IHRoaXMuc21vb3RoaW5nUmFkaXVzICogdGhpcy5zbW9vdGhpbmdSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgIGRpc3QgPSBTUEhTeXN0ZW1fZ2V0TmVpZ2hib3JzX2Rpc3Q7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcCA9IHRoaXMucGFydGljbGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBwLnBvc2l0aW9uLnZzdWIocGFydGljbGUucG9zaXRpb24sIGRpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWQgIT09IHAuaWQgJiYgZGlzdC5ub3JtMigpIDwgUjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5laWdoYm9ycy5wdXNoKHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVGVtcCB2ZWN0b3JzIGZvciBjYWxjdWxhdGlvblxuICAgICAgICAgICAgdmFyIFNQSFN5c3RlbV91cGRhdGVfZGlzdCA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgU1BIU3lzdGVtX3VwZGF0ZV9hX3ByZXNzdXJlID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBTUEhTeXN0ZW1fdXBkYXRlX2FfdmlzYyA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgU1BIU3lzdGVtX3VwZGF0ZV9ncmFkVyA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgU1BIU3lzdGVtX3VwZGF0ZV9yX3ZlYyA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgU1BIU3lzdGVtX3VwZGF0ZV91ID0gbmV3IFZlYzMoKTsgLy8gUmVsYXRpdmUgdmVsb2NpdHlcbiAgICAgICAgICAgIFNQSFN5c3RlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBOID0gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX3VwZGF0ZV9kaXN0LFxuICAgICAgICAgICAgICAgICAgICBjcyA9IHRoaXMuc3BlZWRPZlNvdW5kLFxuICAgICAgICAgICAgICAgICAgICBlcHMgPSB0aGlzLmVwcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTsgLy8gQ3VycmVudCBwYXJ0aWNsZVxuICAgICAgICAgICAgICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG5laWdoYm9yc1xuICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXROZWlnaGJvcnMocCwgbmVpZ2hib3JzKTtcbiAgICAgICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2godGhpcy5wYXJ0aWNsZXNbaV0pOyAvLyBBZGQgY3VycmVudCB0b29cbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZSBkZW5zaXR5IGZvciB0aGUgcGFydGljbGVcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IG51bU5laWdoYm9yczsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vcHJpbnRmKFwiQ3VycmVudCBwYXJ0aWNsZSBoYXMgcG9zaXRpb24gJWYgJWYgJWZcXG5cIixvYmplY3RzW2lkXS5wb3MueCgpLG9iamVjdHNbaWRdLnBvcy55KCksb2JqZWN0c1tpZF0ucG9zLnooKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnBvc2l0aW9uLnZzdWIobmVpZ2hib3JzW2pdLnBvc2l0aW9uLCBkaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBkaXN0Lm5vcm0oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IHRoaXMudyhsZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3VtICs9IG5laWdoYm9yc1tqXS5tYXNzICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbnNpdGllc1tpXSA9IHN1bTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmVzc3VyZXNbaV0gPSBjcyAqIGNzICogKHRoaXMuZGVuc2l0aWVzW2ldIC0gdGhpcy5kZW5zaXR5KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgZm9yY2VzXG5cbiAgICAgICAgICAgICAgICAvLyBTdW0gdG8gdGhlc2UgYWNjZWxlcmF0aW9uc1xuICAgICAgICAgICAgICAgIHZhciBhX3ByZXNzdXJlID0gU1BIU3lzdGVtX3VwZGF0ZV9hX3ByZXNzdXJlO1xuICAgICAgICAgICAgICAgIHZhciBhX3Zpc2MgPSBTUEhTeXN0ZW1fdXBkYXRlX2FfdmlzYztcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZFcgPSBTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXO1xuICAgICAgICAgICAgICAgIHZhciByX3ZlYyA9IFNQSFN5c3RlbV91cGRhdGVfcl92ZWM7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSBTUEhTeXN0ZW1fdXBkYXRlX3U7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRpY2xlID0gdGhpcy5wYXJ0aWNsZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgYV9wcmVzc3VyZS5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGFfdmlzYy5zZXQoMCwgMCwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSW5pdCB2YXJzXG4gICAgICAgICAgICAgICAgICAgIHZhciBQaWo7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYWJsYTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFZpajtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTdW0gdXAgZm9yIGFsbCBvdGhlciBuZWlnaGJvcnNcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5laWdoYm9ycyA9IHRoaXMubmVpZ2hib3JzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAvL3ByaW50ZihcIk5laWdoYm9yczogXCIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gbnVtTmVpZ2hib3JzOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5laWdoYm9yID0gbmVpZ2hib3JzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9wcmludGYoXCIlZCBcIixuaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCByIG9uY2UgZm9yIGFsbC4uXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5wb3NpdGlvbi52c3ViKG5laWdoYm9yLnBvc2l0aW9uLCByX3ZlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHJfdmVjLm5vcm0oKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJlc3N1cmUgY29udHJpYnV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBQaWogPSAtbmVpZ2hib3IubWFzcyAqICh0aGlzLnByZXNzdXJlc1tpXSAvICh0aGlzLmRlbnNpdGllc1tpXSAqIHRoaXMuZGVuc2l0aWVzW2ldICsgZXBzKSArIHRoaXMucHJlc3N1cmVzW2pdIC8gKHRoaXMuZGVuc2l0aWVzW2pdICogdGhpcy5kZW5zaXRpZXNbal0gKyBlcHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ3JhZHcocl92ZWMsIGdyYWRXKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBwcmVzc3VyZSBhY2NlbGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGdyYWRXLm11bHQoUGlqLCBncmFkVyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhX3ByZXNzdXJlLnZhZGQoZ3JhZFcsIGFfcHJlc3N1cmUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBWaXNjb3NpdHkgY29udHJpYnV0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBuZWlnaGJvci52ZWxvY2l0eS52c3ViKHBhcnRpY2xlLnZlbG9jaXR5LCB1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUubXVsdCgxLjAgLyAoMC4wMDAxICsgdGhpcy5kZW5zaXRpZXNbaV0gKiB0aGlzLmRlbnNpdGllc1tqXSkgKiB0aGlzLnZpc2Nvc2l0eSAqIG5laWdoYm9yLm1hc3MsIHUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFibGEgPSB0aGlzLm5hYmxhdyhyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUubXVsdChuYWJsYSwgdSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gdmlzY29zaXR5IGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgYV92aXNjLnZhZGQodSwgYV92aXNjKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBmb3JjZVxuICAgICAgICAgICAgICAgICAgICBhX3Zpc2MubXVsdChwYXJ0aWNsZS5tYXNzLCBhX3Zpc2MpO1xuICAgICAgICAgICAgICAgICAgICBhX3ByZXNzdXJlLm11bHQocGFydGljbGUubWFzcywgYV9wcmVzc3VyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGZvcmNlIHRvIHBhcnRpY2xlc1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5mb3JjZS52YWRkKGFfdmlzYywgcGFydGljbGUuZm9yY2UpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5mb3JjZS52YWRkKGFfcHJlc3N1cmUsIHBhcnRpY2xlLmZvcmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHdlaWdodCB1c2luZyB0aGUgVyhyKSB3ZWlnaHRmdW5jdGlvblxuICAgICAgICAgICAgU1BIU3lzdGVtLnByb3RvdHlwZS53ID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICAvLyAzMTVcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgICAgICAgICAgICAgIHJldHVybiAzMTUuMCAvICg2NC4wICogTWF0aC5QSSAqIE1hdGgucG93KGgsIDkpKSAqIE1hdGgucG93KGggKiBoIC0gciAqIHIsIDMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlIGdyYWRpZW50IG9mIHRoZSB3ZWlnaHQgZnVuY3Rpb25cbiAgICAgICAgICAgIFNQSFN5c3RlbS5wcm90b3R5cGUuZ3JhZHcgPSBmdW5jdGlvbiAoclZlYywgcmVzdWx0VmVjKSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSByVmVjLm5vcm0oKSxcbiAgICAgICAgICAgICAgICAgICAgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgICAgICAgICAgICAgIHJWZWMubXVsdCg5NDUuMCAvICgzMi4wICogTWF0aC5QSSAqIE1hdGgucG93KGgsIDkpKSAqIE1hdGgucG93KChoICogaCAtIHIgKiByKSwgMiksIHJlc3VsdFZlYyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgbmFibGEoVylcbiAgICAgICAgICAgIFNQSFN5c3RlbS5wcm90b3R5cGUubmFibGF3ID0gZnVuY3Rpb24gKHIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgICAgICAgICAgICAgIHZhciBuYWJsYSA9IDk0NS4wIC8gKDMyLjAgKiBNYXRoLlBJICogTWF0aC5wb3coaCwgOSkpICogKGggKiBoIC0gciAqIHIpICogKDcgKiByICogciAtIDMgKiBoICogaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hYmxhO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjogMjUsIFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6IDI4LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi9vYmplY3RzL0JvZHlcIjogMzEsIFwiLi4vc2hhcGVzL1BhcnRpY2xlXCI6IDQxLCBcIi4uL3NoYXBlcy9TaGFwZVwiOiA0MyB9XSwgMzU6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFNwcmluZztcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHNwcmluZywgY29ubmVjdGluZyB0d28gYm9kaWVzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBjbGFzcyBTcHJpbmdcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJlc3RMZW5ndGhdICAgQSBudW1iZXIgPiAwLiBEZWZhdWx0OiAxXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3RpZmZuZXNzXSAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxMDBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5kYW1waW5nXSAgICAgIEEgbnVtYmVyID49IDAuIERlZmF1bHQ6IDFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gIFtvcHRpb25zLndvcmxkQW5jaG9yQV0gV2hlcmUgdG8gaG9vayB0aGUgc3ByaW5nIHRvIGJvZHkgQSwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckJdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckFdIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIGxvY2FsIGJvZHkgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy5sb2NhbEFuY2hvckJdXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNwcmluZyhib2R5QSwgYm9keUIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlc3QgbGVuZ3RoIG9mIHRoZSBzcHJpbmcuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHJlc3RMZW5ndGhcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdExlbmd0aCA9IHR5cGVvZiAob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHNwcmluZy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN0aWZmbmVzcyA9IG9wdGlvbnMuc3RpZmZuZXNzIHx8IDEwMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIERhbXBpbmcgb2YgdGhlIHNwcmluZy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5kYW1waW5nID0gb3B0aW9ucy5kYW1waW5nIHx8IDE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0JvZHl9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1ZlYzN9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1ZlYzN9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWxBbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxBbmNob3JBLmNvcHkob3B0aW9ucy5sb2NhbEFuY2hvckEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbEFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbEFuY2hvckIuY29weShvcHRpb25zLmxvY2FsQW5jaG9yQik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndvcmxkQW5jaG9yQSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLndvcmxkQW5jaG9yQikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQihvcHRpb25zLndvcmxkQW5jaG9yQik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQSwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB3b3JsZEFuY2hvckFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckEgPSBmdW5jdGlvbiAod29ybGRBbmNob3JBKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5QS5wb2ludFRvTG9jYWxGcmFtZSh3b3JsZEFuY2hvckEsIHRoaXMubG9jYWxBbmNob3JBKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCB1c2luZyB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0V29ybGRBbmNob3JCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHdvcmxkQW5jaG9yQlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcHJpbmcucHJvdG90eXBlLnNldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uICh3b3JsZEFuY2hvckIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkQW5jaG9yQiwgdGhpcy5sb2NhbEFuY2hvckIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRXb3JsZEFuY2hvckFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gcmVzdWx0IFRoZSB2ZWN0b3IgdG8gc3RvcmUgdGhlIHJlc3VsdCBpbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU3ByaW5nLnByb3RvdHlwZS5nZXRXb3JsZEFuY2hvckEgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2R5QS5wb2ludFRvV29ybGRGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQSwgcmVzdWx0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBCLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JCID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm9keUIucG9pbnRUb1dvcmxkRnJhbWUodGhpcy5sb2NhbEFuY2hvckIsIHJlc3VsdCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYXBwbHlGb3JjZV9yID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBhcHBseUZvcmNlX3JfdW5pdCA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgYXBwbHlGb3JjZV91ID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBhcHBseUZvcmNlX2YgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQiA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgYXBwbHlGb3JjZV9yaSA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgYXBwbHlGb3JjZV9yaiA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgYXBwbHlGb3JjZV9yaV94X2YgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIGFwcGx5Rm9yY2VfcmpfeF9mID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBhcHBseUZvcmNlX3RtcCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgdGhlIHNwcmluZyBmb3JjZSB0byB0aGUgY29ubmVjdGVkIGJvZGllcy5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcHJpbmcucHJvdG90eXBlLmFwcGx5Rm9yY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGsgPSB0aGlzLnN0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgZCA9IHRoaXMuZGFtcGluZyxcbiAgICAgICAgICAgICAgICAgICAgbCA9IHRoaXMucmVzdExlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICAgICAgICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgICAgICAgICAgICAgIHIgPSBhcHBseUZvcmNlX3IsXG4gICAgICAgICAgICAgICAgICAgIHJfdW5pdCA9IGFwcGx5Rm9yY2Vfcl91bml0LFxuICAgICAgICAgICAgICAgICAgICB1ID0gYXBwbHlGb3JjZV91LFxuICAgICAgICAgICAgICAgICAgICBmID0gYXBwbHlGb3JjZV9mLFxuICAgICAgICAgICAgICAgICAgICB0bXAgPSBhcHBseUZvcmNlX3RtcDtcblxuICAgICAgICAgICAgICAgIHZhciB3b3JsZEFuY2hvckEgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQSxcbiAgICAgICAgICAgICAgICAgICAgd29ybGRBbmNob3JCID0gYXBwbHlGb3JjZV93b3JsZEFuY2hvckIsXG4gICAgICAgICAgICAgICAgICAgIHJpID0gYXBwbHlGb3JjZV9yaSxcbiAgICAgICAgICAgICAgICAgICAgcmogPSBhcHBseUZvcmNlX3JqLFxuICAgICAgICAgICAgICAgICAgICByaV94X2YgPSBhcHBseUZvcmNlX3JpX3hfZixcbiAgICAgICAgICAgICAgICAgICAgcmpfeF9mID0gYXBwbHlGb3JjZV9yal94X2Y7XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgd29ybGQgYW5jaG9yc1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRBbmNob3JBKHdvcmxkQW5jaG9yQSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JsZEFuY2hvckIod29ybGRBbmNob3JCKTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBvZmZzZXQgcG9pbnRzXG4gICAgICAgICAgICAgICAgd29ybGRBbmNob3JBLnZzdWIoYm9keUEucG9zaXRpb24sIHJpKTtcbiAgICAgICAgICAgICAgICB3b3JsZEFuY2hvckIudnN1Yihib2R5Qi5wb3NpdGlvbiwgcmopO1xuXG4gICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXG4gICAgICAgICAgICAgICAgd29ybGRBbmNob3JCLnZzdWIod29ybGRBbmNob3JBLCByKTtcbiAgICAgICAgICAgICAgICB2YXIgcmxlbiA9IHIubm9ybSgpO1xuICAgICAgICAgICAgICAgIHJfdW5pdC5jb3B5KHIpO1xuICAgICAgICAgICAgICAgIHJfdW5pdC5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgcmVsYXRpdmUgdmVsb2NpdHkgb2YgdGhlIGFuY2hvciBwb2ludHMsIHVcbiAgICAgICAgICAgICAgICBib2R5Qi52ZWxvY2l0eS52c3ViKGJvZHlBLnZlbG9jaXR5LCB1KTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgcm90YXRpb25hbCB2ZWxvY2l0eVxuXG4gICAgICAgICAgICAgICAgYm9keUIuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHJqLCB0bXApO1xuICAgICAgICAgICAgICAgIHUudmFkZCh0bXAsIHUpO1xuICAgICAgICAgICAgICAgIGJvZHlBLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhyaSwgdG1wKTtcbiAgICAgICAgICAgICAgICB1LnZzdWIodG1wLCB1KTtcblxuICAgICAgICAgICAgICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICAgICAgICAgICAgICByX3VuaXQubXVsdCgtayAqIChybGVuIC0gbCkgLSBkICogdS5kb3Qocl91bml0KSwgZik7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgICAgICAgICAgICAgIGJvZHlBLmZvcmNlLnZzdWIoZiwgYm9keUEuZm9yY2UpO1xuICAgICAgICAgICAgICAgIGJvZHlCLmZvcmNlLnZhZGQoZiwgYm9keUIuZm9yY2UpO1xuXG4gICAgICAgICAgICAgICAgLy8gQW5ndWxhciBmb3JjZVxuICAgICAgICAgICAgICAgIHJpLmNyb3NzKGYsIHJpX3hfZik7XG4gICAgICAgICAgICAgICAgcmouY3Jvc3MoZiwgcmpfeF9mKTtcbiAgICAgICAgICAgICAgICBib2R5QS50b3JxdWUudnN1YihyaV94X2YsIGJvZHlBLnRvcnF1ZSk7XG4gICAgICAgICAgICAgICAgYm9keUIudG9ycXVlLnZhZGQocmpfeF9mLCBib2R5Qi50b3JxdWUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vbWF0aC9WZWMzXCI6IDMwIH1dLCAzNjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbiAgICAgICAgICAgIHZhciBSYXljYXN0UmVzdWx0ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbiAgICAgICAgICAgIHZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gV2hlZWxJbmZvO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBjbGFzcyBXaGVlbEluZm9cbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsXVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGRdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmRpcmVjdGlvbkxvY2FsXVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5kaXJlY3Rpb25Xb3JsZF1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhsZUxvY2FsXVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGxlV29ybGRdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg9MV1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoPTJdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcz0xMDBdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uPTEwXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uPTEwXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uU2xpcD0xMDAwMF1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVlcmluZz0wXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTBdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGVsdGFSb3RhdGlvbj0wXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvbGxJbmZsdWVuY2U9MC4wMV1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2VdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzRnJvbnRXaGVlbD10cnVlXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbj0xXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5PTBdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvbkZvcmNlPTBdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpZEluZm89MF1cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTGVuZ3RoPTBdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbD0xXVxuICAgICAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkPWZhbHNlXVxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ9LTAuMV1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gV2hlZWxJbmZvKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWw6IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZDogbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uTG9jYWw6IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbldvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgICAgICBheGxlTG9jYWw6IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgICAgIGF4bGVXb3JsZDogbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2lvblJlc3RMZW5ndGg6IDEsXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNpb25NYXhMZW5ndGg6IDIsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogMSxcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2lvblN0aWZmbmVzczogMTAwLFxuICAgICAgICAgICAgICAgICAgICBkYW1waW5nQ29tcHJlc3Npb246IDEwLFxuICAgICAgICAgICAgICAgICAgICBkYW1waW5nUmVsYXhhdGlvbjogMTAsXG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uU2xpcDogMTAwMDAsXG4gICAgICAgICAgICAgICAgICAgIHN0ZWVyaW5nOiAwLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFSb3RhdGlvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgcm9sbEluZmx1ZW5jZTogMC4wMSxcbiAgICAgICAgICAgICAgICAgICAgbWF4U3VzcGVuc2lvbkZvcmNlOiBOdW1iZXIuTUFYX1ZBTFVFLFxuICAgICAgICAgICAgICAgICAgICBpc0Zyb250V2hlZWw6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbjogMSxcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNpb25Gb3JjZTogMCxcbiAgICAgICAgICAgICAgICAgICAgc2tpZEluZm86IDAsXG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNpb25MZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgICAgIG1heFN1c3BlbnNpb25UcmF2ZWw6IDEsXG4gICAgICAgICAgICAgICAgICAgIHVzZUN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkOiAtMC4xXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBNYXggdHJhdmVsIGRpc3RhbmNlIG9mIHRoZSBzdXNwZW5zaW9uLCBpbiBtZXRlcnMuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFN1c3BlbnNpb25UcmF2ZWxcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm1heFN1c3BlbnNpb25UcmF2ZWwgPSBvcHRpb25zLm1heFN1c3BlbnNpb25UcmF2ZWw7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTcGVlZCB0byBhcHBseSB0byB0aGUgd2hlZWwgcm90YXRpb24gd2hlbiB0aGUgd2hlZWwgaXMgc2xpZGluZy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCA9IG9wdGlvbnMuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkIHNob3VsZCBiZSB1c2VkLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gdXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCA9IG9wdGlvbnMudXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gc2xpZGluZ1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ29ubmVjdGlvbiBwb2ludCwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBjaGFzc2lzIGJvZHkgZnJhbWUuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzfSBjaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWxcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbCA9IG9wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkID0gb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gZGlyZWN0aW9uTG9jYWxcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmRpcmVjdGlvbkxvY2FsID0gb3B0aW9ucy5kaXJlY3Rpb25Mb2NhbC5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzfSBkaXJlY3Rpb25Xb3JsZFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZGlyZWN0aW9uV29ybGQgPSBvcHRpb25zLmRpcmVjdGlvbldvcmxkLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGF4bGVMb2NhbFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYXhsZUxvY2FsID0gb3B0aW9ucy5heGxlTG9jYWwuY2xvbmUoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhsZVdvcmxkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5heGxlV29ybGQgPSBvcHRpb25zLmF4bGVXb3JsZC5jbG9uZSgpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25SZXN0TGVuZ3RoXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdXNwZW5zaW9uUmVzdExlbmd0aCA9IG9wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvbk1heExlbmd0aFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3VzcGVuc2lvbk1heExlbmd0aCA9IG9wdGlvbnMuc3VzcGVuc2lvbk1heExlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByYWRpdXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25TdGlmZm5lc3NcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25TdGlmZm5lc3MgPSBvcHRpb25zLnN1c3BlbnNpb25TdGlmZm5lc3M7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGFtcGluZ0NvbXByZXNzaW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5kYW1waW5nQ29tcHJlc3Npb24gPSBvcHRpb25zLmRhbXBpbmdDb21wcmVzc2lvbjtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYW1waW5nUmVsYXhhdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZGFtcGluZ1JlbGF4YXRpb24gPSBvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZyaWN0aW9uU2xpcFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25TbGlwID0gb3B0aW9ucy5mcmljdGlvblNsaXA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3RlZXJpbmdcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN0ZWVyaW5nID0gMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJvdGF0aW9uIHZhbHVlLCBpbiByYWRpYW5zLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByb3RhdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRlbHRhUm90YXRpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmRlbHRhUm90YXRpb24gPSAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJvbGxJbmZsdWVuY2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnJvbGxJbmZsdWVuY2UgPSBvcHRpb25zLnJvbGxJbmZsdWVuY2U7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4U3VzcGVuc2lvbkZvcmNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5tYXhTdXNwZW5zaW9uRm9yY2UgPSBvcHRpb25zLm1heFN1c3BlbnNpb25Gb3JjZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbmdpbmVGb3JjZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZW5naW5lRm9yY2UgPSAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJyYWtlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5icmFrZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXNGcm9udFdoZWVsXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5pc0Zyb250V2hlZWwgPSBvcHRpb25zLmlzRnJvbnRXaGVlbDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb25cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uRm9yY2VcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25Gb3JjZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2tpZEluZm9cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNraWRJbmZvID0gMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uTGVuZ3RoXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdXNwZW5zaW9uTGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWRlSW1wdWxzZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc2lkZUltcHVsc2UgPSAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGZvcndhcmRJbXB1bHNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkSW1wdWxzZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgcmVzdWx0IGZyb20gcmF5Y2FzdGluZ1xuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7UmF5Y2FzdFJlc3VsdH0gcmF5Y2FzdFJlc3VsdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucmF5Y2FzdFJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGVlbCB3b3JsZCB0cmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1RyYW5zZm9ybX0gd29ybGRUcmFuc2Zvcm1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkVHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBpc0luQ29udGFjdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaXNJbkNvbnRhY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciByZWxwb3MgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIFdoZWVsSW5mby5wcm90b3R5cGUudXBkYXRlV2hlZWwgPSBmdW5jdGlvbiAoY2hhc3Npcykge1xuICAgICAgICAgICAgICAgIHZhciByYXljYXN0UmVzdWx0ID0gdGhpcy5yYXljYXN0UmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNJbkNvbnRhY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2plY3QgPSByYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkLmRvdChyYXljYXN0UmVzdWx0LmRpcmVjdGlvbldvcmxkKTtcbiAgICAgICAgICAgICAgICAgICAgcmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npcy5wb3NpdGlvbiwgcmVscG9zKTtcbiAgICAgICAgICAgICAgICAgICAgY2hhc3Npcy5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChyZWxwb3MsIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2pWZWwgPSByYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkLmRvdChjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0ID49IC0wLjEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMCAvIDAuMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpbnYgPSAtMSAvIHByb2plY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gaW52O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3QgaW4gY29udGFjdCA6IHBvc2l0aW9uIHdoZWVsIGluIGEgbmljZSAocmVzdCBsZW5ndGgpIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHJheWNhc3RSZXN1bHQuc3VzcGVuc2lvbkxlbmd0aCA9IHRoaXMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgICAgICAgICAgICAgIHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQuc2NhbGUoLTEsIHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHRcIjogMTAsIFwiLi4vbWF0aC9UcmFuc2Zvcm1cIjogMjksIFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4uL3V0aWxzL1V0aWxzXCI6IDUzIH1dLCAzNzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gQm94O1xuXG4gICAgICAgICAgICB2YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIENvbnZleFBvbHloZWRyb24gPSBfZGVyZXFfKCcuL0NvbnZleFBvbHloZWRyb24nKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIDNkIGJveCBzaGFwZS5cbiAgICAgICAgICAgICAqIEBjbGFzcyBCb3hcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBoYWxmRXh0ZW50c1xuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZVxuICAgICAgICAgICAgICogQGV4dGVuZHMgU2hhcGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQm94KGhhbGZFeHRlbnRzKSB7XG4gICAgICAgICAgICAgICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLkJPWDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBoYWxmRXh0ZW50c1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuaGFsZkV4dGVudHMgPSBoYWxmRXh0ZW50cztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFVzZWQgYnkgdGhlIGNvbnRhY3QgZ2VuZXJhdG9yIHRvIG1ha2UgY29udGFjdHMgd2l0aCBvdGhlciBjb252ZXggcG9seWhlZHJhIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtDb252ZXhQb2x5aGVkcm9ufVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQm94LnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuICAgICAgICAgICAgQm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBjb252ZXggcG9seWhlZHJvbiByZXByZXNlbnRhdGlvbiB1c2VkIGZvciBzb21lIGNvbGxpc2lvbnMuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBCb3gucHJvdG90eXBlLnVwZGF0ZUNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSB0aGlzLmhhbGZFeHRlbnRzLng7XG4gICAgICAgICAgICAgICAgdmFyIHN5ID0gdGhpcy5oYWxmRXh0ZW50cy55O1xuICAgICAgICAgICAgICAgIHZhciBzeiA9IHRoaXMuaGFsZkV4dGVudHMuejtcbiAgICAgICAgICAgICAgICB2YXIgViA9IFZlYzM7XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWKC1zeCwgLXN5LCAtc3opLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVihzeCwgLXN5LCAtc3opLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVihzeCwgc3ksIC1zeiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWKC1zeCwgc3ksIC1zeiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWKC1zeCwgLXN5LCBzeiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWKHN4LCAtc3ksIHN6KSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFYoc3gsIHN5LCBzeiksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWKC1zeCwgc3ksIHN6KVxuICAgICAgICAgICAgICAgIF07XG5cbiAgICAgICAgICAgICAgICB2YXIgaW5kaWNlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgWzMsIDIsIDEsIDBdLCAvLyAtelxuICAgICAgICAgICAgICAgICAgICBbNCwgNSwgNiwgN10sIC8vICt6XG4gICAgICAgICAgICAgICAgICAgIFs1LCA0LCAwLCAxXSwgLy8gLXlcbiAgICAgICAgICAgICAgICAgICAgWzIsIDMsIDcsIDZdLCAvLyAreVxuICAgICAgICAgICAgICAgICAgICBbMCwgNCwgNywgM10sIC8vIC14XG4gICAgICAgICAgICAgICAgICAgIFsxLCAyLCA2LCA1XSwgLy8gK3hcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGF4ZXMgPSBbXG4gICAgICAgICAgICAgICAgICAgIG5ldyBWKDAsIDAsIDEpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgVigwLCAxLCAwKSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IFYoMSwgMCwgMClcbiAgICAgICAgICAgICAgICBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIGggPSBuZXcgQ29udmV4UG9seWhlZHJvbih2ZXJ0aWNlcywgaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24gPSBoO1xuICAgICAgICAgICAgICAgIGgubWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIEJveC5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24gKG1hc3MsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIEJveC5jYWxjdWxhdGVJbmVydGlhKHRoaXMuaGFsZkV4dGVudHMsIG1hc3MsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEJveC5jYWxjdWxhdGVJbmVydGlhID0gZnVuY3Rpb24gKGhhbGZFeHRlbnRzLCBtYXNzLCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IGhhbGZFeHRlbnRzO1xuICAgICAgICAgICAgICAgIHRhcmdldC54ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIGUueSAqIDIgKiBlLnkgKyAyICogZS56ICogMiAqIGUueik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogZS54ICogMiAqIGUueCArIDIgKiBlLnogKiAyICogZS56KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiBlLnkgKiAyICogZS55ICsgMiAqIGUueCAqIDIgKiBlLngpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGJveCA2IHNpZGUgbm9ybWFsc1xuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRTaWRlTm9ybWFsc1xuICAgICAgICAgICAgICogQHBhcmFtIHthcnJheX0gICAgICBzaXhUYXJnZXRWZWN0b3JzIEFuIGFycmF5IG9mIDYgdmVjdG9ycywgdG8gc3RvcmUgdGhlIHJlc3VsdGluZyBzaWRlIG5vcm1hbHMgaW4uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXQgICAgICAgICAgICAgT3JpZW50YXRpb24gdG8gYXBwbHkgdG8gdGhlIG5vcm1hbCB2ZWN0b3JzLiBJZiBub3QgcHJvdmlkZWQsIHRoZSB2ZWN0b3JzIHdpbGwgYmUgaW4gcmVzcGVjdCB0byB0aGUgbG9jYWwgZnJhbWUuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHthcnJheX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQm94LnByb3RvdHlwZS5nZXRTaWRlTm9ybWFscyA9IGZ1bmN0aW9uIChzaXhUYXJnZXRWZWN0b3JzLCBxdWF0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNpZGVzID0gc2l4VGFyZ2V0VmVjdG9ycztcbiAgICAgICAgICAgICAgICB2YXIgZXggPSB0aGlzLmhhbGZFeHRlbnRzO1xuICAgICAgICAgICAgICAgIHNpZGVzWzBdLnNldChleC54LCAwLCAwKTtcbiAgICAgICAgICAgICAgICBzaWRlc1sxXS5zZXQoMCwgZXgueSwgMCk7XG4gICAgICAgICAgICAgICAgc2lkZXNbMl0uc2V0KDAsIDAsIGV4LnopO1xuICAgICAgICAgICAgICAgIHNpZGVzWzNdLnNldCgtZXgueCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgc2lkZXNbNF0uc2V0KDAsIC1leC55LCAwKTtcbiAgICAgICAgICAgICAgICBzaWRlc1s1XS5zZXQoMCwgMCwgLWV4LnopO1xuXG4gICAgICAgICAgICAgICAgaWYgKHF1YXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gc2lkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YXQudm11bHQoc2lkZXNbaV0sIHNpZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBzaWRlcztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEJveC5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA4LjAgKiB0aGlzLmhhbGZFeHRlbnRzLnggKiB0aGlzLmhhbGZFeHRlbnRzLnkgKiB0aGlzLmhhbGZFeHRlbnRzLno7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBCb3gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLmhhbGZFeHRlbnRzLm5vcm0oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB3b3JsZENvcm5lclRlbXBQb3MgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHdvcmxkQ29ybmVyVGVtcE5lZyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBCb3gucHJvdG90eXBlLmZvckVhY2hXb3JsZENvcm5lciA9IGZ1bmN0aW9uIChwb3MsIHF1YXQsIGNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMuaGFsZkV4dGVudHM7XG4gICAgICAgICAgICAgICAgdmFyIGNvcm5lcnMgPSBbW2UueCwgZS55LCBlLnpdLFxuICAgICAgICAgICAgICAgIFstZS54LCBlLnksIGUuel0sXG4gICAgICAgICAgICAgICAgWy1lLngsIC1lLnksIGUuel0sXG4gICAgICAgICAgICAgICAgWy1lLngsIC1lLnksIC1lLnpdLFxuICAgICAgICAgICAgICAgIFtlLngsIC1lLnksIC1lLnpdLFxuICAgICAgICAgICAgICAgIFtlLngsIGUueSwgLWUuel0sXG4gICAgICAgICAgICAgICAgWy1lLngsIGUueSwgLWUuel0sXG4gICAgICAgICAgICAgICAgW2UueCwgLWUueSwgZS56XV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3JuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyVGVtcFBvcy5zZXQoY29ybmVyc1tpXVswXSwgY29ybmVyc1tpXVsxXSwgY29ybmVyc1tpXVsyXSk7XG4gICAgICAgICAgICAgICAgICAgIHF1YXQudm11bHQod29ybGRDb3JuZXJUZW1wUG9zLCB3b3JsZENvcm5lclRlbXBQb3MpO1xuICAgICAgICAgICAgICAgICAgICBwb3MudmFkZCh3b3JsZENvcm5lclRlbXBQb3MsIHdvcmxkQ29ybmVyVGVtcFBvcyk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHdvcmxkQ29ybmVyVGVtcFBvcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZENvcm5lclRlbXBQb3Mueik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHdvcmxkQ29ybmVyc1RlbXAgPSBbXG4gICAgICAgICAgICAgICAgbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBuZXcgVmVjMygpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgQm94LnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbiAocG9zLCBxdWF0LCBtaW4sIG1heCkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLmhhbGZFeHRlbnRzO1xuICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyc1RlbXBbMF0uc2V0KGUueCwgZS55LCBlLnopO1xuICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyc1RlbXBbMV0uc2V0KC1lLngsIGUueSwgZS56KTtcbiAgICAgICAgICAgICAgICB3b3JsZENvcm5lcnNUZW1wWzJdLnNldCgtZS54LCAtZS55LCBlLnopO1xuICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyc1RlbXBbM10uc2V0KC1lLngsIC1lLnksIC1lLnopO1xuICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyc1RlbXBbNF0uc2V0KGUueCwgLWUueSwgLWUueik7XG4gICAgICAgICAgICAgICAgd29ybGRDb3JuZXJzVGVtcFs1XS5zZXQoZS54LCBlLnksIC1lLnopO1xuICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyc1RlbXBbNl0uc2V0KC1lLngsIGUueSwgLWUueik7XG4gICAgICAgICAgICAgICAgd29ybGRDb3JuZXJzVGVtcFs3XS5zZXQoZS54LCAtZS55LCBlLnopO1xuXG4gICAgICAgICAgICAgICAgdmFyIHdjID0gd29ybGRDb3JuZXJzVGVtcFswXTtcbiAgICAgICAgICAgICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7XG4gICAgICAgICAgICAgICAgcG9zLnZhZGQod2MsIHdjKTtcbiAgICAgICAgICAgICAgICBtYXguY29weSh3Yyk7XG4gICAgICAgICAgICAgICAgbWluLmNvcHkod2MpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbaV07XG4gICAgICAgICAgICAgICAgICAgIHF1YXQudm11bHQod2MsIHdjKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zLnZhZGQod2MsIHdjKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSB3Yy54O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHdjLnk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB6ID0gd2MuejtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHggPiBtYXgueCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4LnggPSB4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID4gbWF4LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heC55ID0geTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoeiA+IG1heC56KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgueiA9IHo7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoeCA8IG1pbi54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4ueCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPCBtaW4ueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluLnkgPSB5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh6IDwgbWluLnopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbi56ID0gejtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4XG4gICAgICAgICAgICAgICAgLy8gbWluLnNldChJbmZpbml0eSxJbmZpbml0eSxJbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgLy8gbWF4LnNldCgtSW5maW5pdHksLUluZmluaXR5LC1JbmZpbml0eSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5mb3JFYWNoV29ybGRDb3JuZXIocG9zLHF1YXQsZnVuY3Rpb24oeCx5LHope1xuICAgICAgICAgICAgICAgIC8vICAgICBpZih4ID4gbWF4Lngpe1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbWF4LnggPSB4O1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmKHkgPiBtYXgueSl7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBtYXgueSA9IHk7XG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgaWYoeiA+IG1heC56KXtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIG1heC56ID0gejtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gICAgIGlmKHggPCBtaW4ueCl7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBtaW4ueCA9IHg7XG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgICAgaWYoeSA8IG1pbi55KXtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIG1pbi55ID0geTtcbiAgICAgICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICBpZih6IDwgbWluLnope1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbWluLnogPSB6O1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0sIHsgXCIuLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi9Db252ZXhQb2x5aGVkcm9uXCI6IDM4LCBcIi4vU2hhcGVcIjogNDMgfV0sIDM4OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBDb252ZXhQb2x5aGVkcm9uO1xuXG4gICAgICAgICAgICB2YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbiAgICAgICAgICAgIHZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgc2V0IG9mIHBvbHlnb25zIGRlc2NyaWJpbmcgYSBjb252ZXggc2hhcGUuXG4gICAgICAgICAgICAgKiBAY2xhc3MgQ29udmV4UG9seWhlZHJvblxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBTaGFwZVxuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIFRoZSBzaGFwZSBNVVNUIGJlIGNvbnZleCBmb3IgdGhlIGNvZGUgdG8gd29yayBwcm9wZXJseS4gTm8gcG9seWdvbnMgbWF5IGJlIGNvcGxhbmFyIChjb250YWluZWRcbiAgICAgICAgICAgICAqIGluIHRoZSBzYW1lIDNEIHBsYW5lKSwgaW5zdGVhZCB0aGVzZSBzaG91bGQgYmUgbWVyZ2VkIGludG8gb25lIHBvbHlnb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHthcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMnc1xuICAgICAgICAgICAgICogQHBhcmFtIHthcnJheX0gZmFjZXMgQXJyYXkgb2YgaW50ZWdlciBhcnJheXMsIGRlc2NyaWJpbmcgd2hpY2ggdmVydGljZXMgdGhhdCBpcyBpbmNsdWRlZCBpbiBlYWNoIGZhY2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW8gKG9yaWdpbmFsIGF1dGhvciwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvL3RocmVlLmpzL2NvbW1pdC84NTAyNmYwYzc2OWU0MDAwMTQ4YTY3ZDQ1YTllOWI5YzUxMDg4MzZmKVxuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxuICAgICAgICAgICAgICogQHNlZSBodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXG4gICAgICAgICAgICAgKiBAc2VlIGh0dHA6Ly9idWxsZXQuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NyYy9CdWxsZXRDb2xsaXNpb24vTmFycm93UGhhc2VDb2xsaXNpb24vYnRQb2x5aGVkcmFsQ29udGFjdENsaXBwaW5nLmNwcFxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEB0b2RvIE1vdmUgdGhlIGNsaXBwaW5nIGZ1bmN0aW9ucyB0byBDb250YWN0R2VuZXJhdG9yP1xuICAgICAgICAgICAgICogQHRvZG8gQXV0b21hdGljYWxseSBtZXJnZSBjb3BsYW5hciBwb2x5Z29ucyBpbiBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQ29udmV4UG9seWhlZHJvbihwb2ludHMsIGZhY2VzLCB1bmlxdWVBeGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTjtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IHBvaW50cyB8fCBbXTtcblxuICAgICAgICAgICAgICAgIHRoaXMud29ybGRWZXJ0aWNlcyA9IFtdOyAvLyBXb3JsZCB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIC52ZXJ0aWNlc1xuICAgICAgICAgICAgICAgIHRoaXMud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFycmF5IG9mIGludGVnZXIgYXJyYXlzLCBpbmRpY2F0aW5nIHdoaWNoIHZlcnRpY2VzIGVhY2ggZmFjZSBjb25zaXN0cyBvZlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBmYWNlc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmZhY2VzID0gZmFjZXMgfHwgW107XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBcnJheSBvZiBWZWMzXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGZhY2VOb3JtYWxzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZmFjZU5vcm1hbHMgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVOb3JtYWxzKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHNOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzID0gW107IC8vIFdvcmxkIHRyYW5zZm9ybWVkIHZlcnNpb24gb2YgLmZhY2VOb3JtYWxzXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBcnJheSBvZiBWZWMzXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHVuaXF1ZUVkZ2VzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudW5pcXVlRWRnZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIGdpdmVuLCB0aGVzZSBsb2NhbGx5IGRlZmluZWQsIG5vcm1hbGl6ZWQgYXhlcyBhcmUgdGhlIG9ubHkgb25lcyBiZWluZyBjaGVja2VkIHdoZW4gZG9pbmcgc2VwYXJhdGluZyBheGlzIGNoZWNrLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHVuaXF1ZUF4ZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnVuaXF1ZUF4ZXMgPSB1bmlxdWVBeGVzID8gdW5pcXVlQXhlcy5zbGljZSgpIDogbnVsbDtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUVkZ2VzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29udmV4UG9seWhlZHJvbjtcblxuICAgICAgICAgICAgdmFyIGNvbXB1dGVFZGdlc190bXBFZGdlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcHV0ZXMgdW5pcXVlRWRnZXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgY29tcHV0ZUVkZ2VzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgICAgICAgICAgdmFyIG52ID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBlZGdlcyA9IHRoaXMudW5pcXVlRWRnZXM7XG5cbiAgICAgICAgICAgICAgICBlZGdlcy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkZ2UgPSBjb21wdXRlRWRnZXNfdG1wRWRnZTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBmYWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmFjZSA9IGZhY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtVmVydGljZXMgPSBmYWNlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IG51bVZlcnRpY2VzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrID0gKGogKyAxKSAlIG51bVZlcnRpY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbZmFjZVtqXV0udnN1Yih2ZXJ0aWNlc1tmYWNlW2tdXSwgZWRnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBwID0gMDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZXNbcF0uYWxtb3N0RXF1YWxzKGVkZ2UpIHx8IGVkZ2VzW3BdLmFsbW9zdEVxdWFscyhlZGdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuIFdpbGwgcmV1c2UgZXhpc3RpbmcgVmVjMyBvYmplY3RzIGluIHRoZSAuZmFjZU5vcm1hbHMgYXJyYXkgaWYgdGhleSBleGlzdC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbHNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZU5vcm1hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWNlTm9ybWFscy5sZW5ndGggPSB0aGlzLmZhY2VzLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIG5vcm1hbHNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBzbyBhbGwgdmVydGljZXMgZXhpc3RzIGZvciB0aGlzIGZhY2VcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmZhY2VzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWZXJ0ZXggXCIgKyB0aGlzLmZhY2VzW2ldW2pdICsgXCIgbm90IGZvdW5kIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy5mYWNlTm9ybWFsc1tpXSB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldEZhY2VOb3JtYWwoaSwgbik7XG4gICAgICAgICAgICAgICAgICAgIG4ubmVnYXRlKG4pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhY2VOb3JtYWxzW2ldID0gbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVswXV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLmRvdCh2ZXJ0ZXgpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIi5mYWNlTm9ybWFsc1tcIiArIGkgKyBcIl0gPSBWZWMzKFwiICsgbi50b1N0cmluZygpICsgXCIpIGxvb2tzIGxpa2UgaXQgcG9pbnRzIGludG8gdGhlIHNoYXBlPyBUaGUgdmVydGljZXMgZm9sbG93LiBNYWtlIHN1cmUgdGhleSBhcmUgb3JkZXJlZCBDQ1cgYXJvdW5kIHRoZSBub3JtYWwsIHVzaW5nIHRoZSByaWdodCBoYW5kIHJ1bGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLmZhY2VzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiLnZlcnRpY2VzW1wiICsgdGhpcy5mYWNlc1tpXVtqXSArIFwiXSA9IFZlYzMoXCIgKyB0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bal1dLnRvU3RyaW5nKCkgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldEZhY2VOb3JtYWxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdmFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdmJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdmNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBjYiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgYWIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgQ29udmV4UG9seWhlZHJvbi5jb21wdXRlTm9ybWFsID0gZnVuY3Rpb24gKHZhLCB2YiwgdmMsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZiLnZzdWIodmEsIGFiKTtcbiAgICAgICAgICAgICAgICB2Yy52c3ViKHZiLCBjYik7XG4gICAgICAgICAgICAgICAgY2IuY3Jvc3MoYWIsIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Lm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIGEgZmFjZSBmcm9tIGl0cyB2ZXJ0aWNlc1xuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRGYWNlTm9ybWFsXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5nZXRGYWNlTm9ybWFsID0gZnVuY3Rpb24gKGksIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBmID0gdGhpcy5mYWNlc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgdmEgPSB0aGlzLnZlcnRpY2VzW2ZbMF1dO1xuICAgICAgICAgICAgICAgIHZhciB2YiA9IHRoaXMudmVydGljZXNbZlsxXV07XG4gICAgICAgICAgICAgICAgdmFyIHZjID0gdGhpcy52ZXJ0aWNlc1tmWzJdXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29udmV4UG9seWhlZHJvbi5jb21wdXRlTm9ybWFsKHZhLCB2YiwgdmMsIHRhcmdldCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgY2xpcEFnYWluc3RIdWxsXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHBvc0FcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gcG9zQlxuICAgICAgICAgICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBzZXBhcmF0aW5nTm9ybWFsXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluRGlzdCBDbGFtcCBkaXN0YW5jZVxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heERpc3RcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBUaGUgYW4gYXJyYXkgb2YgY29udGFjdCBwb2ludCBvYmplY3RzLCBzZWUgY2xpcEZhY2VBZ2FpbnN0SHVsbFxuICAgICAgICAgICAgICogQHNlZSBodHRwOi8vYnVsbGV0Lmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9zcmMvQnVsbGV0Q29sbGlzaW9uL05hcnJvd1BoYXNlQ29sbGlzaW9uL2J0UG9seWhlZHJhbENvbnRhY3RDbGlwcGluZy5jcHBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGNhaF9Xb3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBDb252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jbGlwQWdhaW5zdEh1bGwgPSBmdW5jdGlvbiAocG9zQSwgcXVhdEEsIGh1bGxCLCBwb3NCLCBxdWF0Qiwgc2VwYXJhdGluZ05vcm1hbCwgbWluRGlzdCwgbWF4RGlzdCwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIFdvcmxkTm9ybWFsID0gY2FoX1dvcmxkTm9ybWFsO1xuICAgICAgICAgICAgICAgIHZhciBodWxsQSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGN1ck1heERpc3QgPSBtYXhEaXN0O1xuICAgICAgICAgICAgICAgIHZhciBjbG9zZXN0RmFjZUIgPSAtMTtcbiAgICAgICAgICAgICAgICB2YXIgZG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZhY2UgPSAwOyBmYWNlIDwgaHVsbEIuZmFjZXMubGVuZ3RoOyBmYWNlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgV29ybGROb3JtYWwuY29weShodWxsQi5mYWNlTm9ybWFsc1tmYWNlXSk7XG4gICAgICAgICAgICAgICAgICAgIHF1YXRCLnZtdWx0KFdvcmxkTm9ybWFsLCBXb3JsZE5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIC8vcG9zQi52YWRkKFdvcmxkTm9ybWFsLFdvcmxkTm9ybWFsKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBXb3JsZE5vcm1hbC5kb3Qoc2VwYXJhdGluZ05vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkID4gZG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG1heCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RmFjZUIgPSBmYWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB3b3JsZFZlcnRzQjEgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgcG9seUIgPSBodWxsQi5mYWNlc1tjbG9zZXN0RmFjZUJdO1xuICAgICAgICAgICAgICAgIHZhciBudW1WZXJ0aWNlcyA9IHBvbHlCLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlMCA9IDA7IGUwIDwgbnVtVmVydGljZXM7IGUwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBodWxsQi52ZXJ0aWNlc1twb2x5QltlMF1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd29ybGRiID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICAgICAgd29ybGRiLmNvcHkoYik7XG4gICAgICAgICAgICAgICAgICAgIHF1YXRCLnZtdWx0KHdvcmxkYiwgd29ybGRiKTtcbiAgICAgICAgICAgICAgICAgICAgcG9zQi52YWRkKHdvcmxkYiwgd29ybGRiKTtcbiAgICAgICAgICAgICAgICAgICAgd29ybGRWZXJ0c0IxLnB1c2god29ybGRiKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEZhY2VCID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwRmFjZUFnYWluc3RIdWxsKHNlcGFyYXRpbmdOb3JtYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NBLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVhdEEsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRzQjEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5EaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4RGlzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGaW5kIHRoZSBzZXBhcmF0aW5nIGF4aXMgYmV0d2VlbiB0aGlzIGh1bGwgYW5kIGFub3RoZXJcbiAgICAgICAgICAgICAqIEBtZXRob2QgZmluZFNlcGFyYXRpbmdBeGlzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZleFBvbHloZWRyb259IGh1bGxCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHBvc0FcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gcG9zQlxuICAgICAgICAgICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHRhcmdldCB2ZWN0b3IgdG8gc2F2ZSB0aGUgYXhpcyBpblxuICAgICAgICAgICAgICogQHJldHVybiB7Ym9vbH0gUmV0dXJucyBmYWxzZSBpZiBhIHNlcGFyYXRpb24gaXMgZm91bmQsIGVsc2UgdHJ1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgZnNhX2ZhY2VBTm9ybWFsV1MzID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBmc2FfV29ybGRub3JtYWwxID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBmc2FfZGVsdGFDID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBmc2Ffd29ybGRFZGdlMCA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgZnNhX3dvcmxkRWRnZTEgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIGZzYV9Dcm9zcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBDb252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5maW5kU2VwYXJhdGluZ0F4aXMgPSBmdW5jdGlvbiAoaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0QiwgdGFyZ2V0LCBmYWNlTGlzdEEsIGZhY2VMaXN0Qikge1xuICAgICAgICAgICAgICAgIHZhciBmYWNlQU5vcm1hbFdTMyA9IGZzYV9mYWNlQU5vcm1hbFdTMyxcbiAgICAgICAgICAgICAgICAgICAgV29ybGRub3JtYWwxID0gZnNhX1dvcmxkbm9ybWFsMSxcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFDID0gZnNhX2RlbHRhQyxcbiAgICAgICAgICAgICAgICAgICAgd29ybGRFZGdlMCA9IGZzYV93b3JsZEVkZ2UwLFxuICAgICAgICAgICAgICAgICAgICB3b3JsZEVkZ2UxID0gZnNhX3dvcmxkRWRnZTEsXG4gICAgICAgICAgICAgICAgICAgIENyb3NzID0gZnNhX0Nyb3NzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIHZhciBodWxsQSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIGN1clBsYW5lVGVzdHMgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFodWxsQS51bmlxdWVBeGVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG51bUZhY2VzQSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QS5sZW5ndGggOiBodWxsQS5mYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUZhY2VzQTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEEgPyBmYWNlTGlzdEFbaV0gOiBpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgd29ybGQgZmFjZSBub3JtYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MzLCBmYWNlQU5vcm1hbFdTMyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gaHVsbEEudGVzdFNlcEF4aXMoZmFjZUFOb3JtYWxXUzMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGRtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCB1bmlxdWUgYXhlc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gaHVsbEEudW5pcXVlQXhlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgd29ybGQgYXhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhdEEudm11bHQoaHVsbEEudW5pcXVlQXhlc1tpXSwgZmFjZUFOb3JtYWxXUzMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKGZhY2VBTm9ybWFsV1MzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBkbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoZmFjZUFOb3JtYWxXUzMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFodWxsQi51bmlxdWVBeGVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQlxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtRmFjZXNCID0gZmFjZUxpc3RCID8gZmFjZUxpc3RCLmxlbmd0aCA6IGh1bGxCLmZhY2VzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1GYWNlc0I7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEJbaV0gOiBpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBXb3JsZG5vcm1hbDEuY29weShodWxsQi5mYWNlTm9ybWFsc1tmaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhdEIudm11bHQoV29ybGRub3JtYWwxLCBXb3JsZG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyUGxhbmVUZXN0cysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhXb3JsZG5vcm1hbDEsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZCA8IGRtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY29weShXb3JsZG5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUZXN0IHVuaXF1ZSBheGVzIGluIEJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGh1bGxCLnVuaXF1ZUF4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YXRCLnZtdWx0KGh1bGxCLnVuaXF1ZUF4ZXNbaV0sIFdvcmxkbm9ybWFsMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1clBsYW5lVGVzdHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkID0gaHVsbEEudGVzdFNlcEF4aXMoV29ybGRub3JtYWwxLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCBkbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoV29ybGRub3JtYWwxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRlc3QgZWRnZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBlMCA9IDA7IGUwICE9PSBodWxsQS51bmlxdWVFZGdlcy5sZW5ndGg7IGUwKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgd29ybGQgZWRnZVxuICAgICAgICAgICAgICAgICAgICBxdWF0QS52bXVsdChodWxsQS51bmlxdWVFZGdlc1tlMF0sIHdvcmxkRWRnZTApO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGUxID0gMDsgZTEgIT09IGh1bGxCLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTErKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgd29ybGQgZWRnZSAyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWF0Qi52bXVsdChodWxsQi51bmlxdWVFZGdlc1tlMV0sIHdvcmxkRWRnZTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRFZGdlMC5jcm9zcyh3b3JsZEVkZ2UxLCBDcm9zcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghQ3Jvc3MuYWxtb3N0WmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3Jvc3Mubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBodWxsQS50ZXN0U2VwQXhpcyhDcm9zcywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPCBkbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRtaW4gPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY29weShDcm9zcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcG9zQi52c3ViKHBvc0EsIGRlbHRhQyk7XG4gICAgICAgICAgICAgICAgaWYgKChkZWx0YUMuZG90KHRhcmdldCkpID4gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5uZWdhdGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBtYXhtaW5BID0gW10sIG1heG1pbkIgPSBbXTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUZXN0IHNlcGFyYXRpbmcgYXhpcyBhZ2FpbnN0IHR3byBodWxscy4gQm90aCBodWxscyBhcmUgcHJvamVjdGVkIG9udG8gdGhlIGF4aXMgYW5kIHRoZSBvdmVybGFwIHNpemUgaXMgcmV0dXJuZWQgaWYgdGhlcmUgaXMgb25lLlxuICAgICAgICAgICAgICogQG1ldGhvZCB0ZXN0U2VwQXhpc1xuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBheGlzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZleFBvbHloZWRyb259IGh1bGxCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHBvc0FcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEFcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gcG9zQlxuICAgICAgICAgICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QlxuICAgICAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgb3ZlcmxhcCBkZXB0aCwgb3IgRkFMU0UgaWYgbm8gcGVuZXRyYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnRlc3RTZXBBeGlzID0gZnVuY3Rpb24gKGF4aXMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpIHtcbiAgICAgICAgICAgICAgICB2YXIgaHVsbEEgPSB0aGlzO1xuICAgICAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQSwgYXhpcywgcG9zQSwgcXVhdEEsIG1heG1pbkEpO1xuICAgICAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQiwgYXhpcywgcG9zQiwgcXVhdEIsIG1heG1pbkIpO1xuICAgICAgICAgICAgICAgIHZhciBtYXhBID0gbWF4bWluQVswXTtcbiAgICAgICAgICAgICAgICB2YXIgbWluQSA9IG1heG1pbkFbMV07XG4gICAgICAgICAgICAgICAgdmFyIG1heEIgPSBtYXhtaW5CWzBdO1xuICAgICAgICAgICAgICAgIHZhciBtaW5CID0gbWF4bWluQlsxXTtcbiAgICAgICAgICAgICAgICBpZiAobWF4QSA8IG1pbkIgfHwgbWF4QiA8IG1pbkEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTZXBhcmF0ZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGQwID0gbWF4QSAtIG1pbkI7XG4gICAgICAgICAgICAgICAgdmFyIGQxID0gbWF4QiAtIG1pbkE7XG4gICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gZDAgPCBkMSA/IGQwIDogZDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNsaV9hYWJibWluID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBjbGlfYWFiYm1heCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uIChtYXNzLCB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhXG4gICAgICAgICAgICAgICAgLy8gRXhhY3QgaW5lcnRpYSBjYWxjdWxhdGlvbiBpcyBvdmVya2lsbCwgYnV0IHNlZSBodHRwOi8vZ2VvbWV0cmljdG9vbHMuY29tL0RvY3VtZW50YXRpb24vUG9seWhlZHJhbE1hc3NQcm9wZXJ0aWVzLnBkZiBmb3IgdGhlIGNvcnJlY3Qgd2F5IHRvIGRvIGl0XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlTG9jYWxBQUJCKGNsaV9hYWJibWluLCBjbGlfYWFiYm1heCk7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBjbGlfYWFiYm1heC54IC0gY2xpX2FhYmJtaW4ueCxcbiAgICAgICAgICAgICAgICAgICAgeSA9IGNsaV9hYWJibWF4LnkgLSBjbGlfYWFiYm1pbi55LFxuICAgICAgICAgICAgICAgICAgICB6ID0gY2xpX2FhYmJtYXgueiAtIGNsaV9hYWJibWluLno7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnggPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHogKiAyICogeik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogeCAqIDIgKiB4ICsgMiAqIHogKiAyICogeik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnogPSAxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHggKiAyICogeCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0UGxhbmVDb25zdGFudE9mRmFjZVxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBmYWNlX2kgSW5kZXggb2YgdGhlIGZhY2VcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuZ2V0UGxhbmVDb25zdGFudE9mRmFjZSA9IGZ1bmN0aW9uIChmYWNlX2kpIHtcbiAgICAgICAgICAgICAgICB2YXIgZiA9IHRoaXMuZmFjZXNbZmFjZV9pXTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMuZmFjZU5vcm1hbHNbZmFjZV9pXTtcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHRoaXMudmVydGljZXNbZlswXV07XG4gICAgICAgICAgICAgICAgdmFyIGMgPSAtbi5kb3Qodik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsaXAgYSBmYWNlIGFnYWluc3QgYSBodWxsLlxuICAgICAgICAgICAgICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RIdWxsXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IHNlcGFyYXRpbmdOb3JtYWxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICAgICAgICAgICAgICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29ybGRWZXJ0c0IxIEFuIGFycmF5IG9mIFZlYzMgd2l0aCB2ZXJ0aWNlcyBpbiB0aGUgd29ybGQgZnJhbWUuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gbWluRGlzdCBEaXN0YW5jZSBjbGFtcGluZ1xuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heERpc3RcbiAgICAgICAgICAgICAqIEBwYXJhbSBBcnJheSByZXN1bHQgQXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGNvbnRhY3QgcG9pbnRzIGluLiBXaWxsIGJlIG9iamVjdHMgd2l0aCBwcm9wZXJ0aWVzOiBwb2ludCwgZGVwdGgsIG5vcm1hbC4gVGhlc2UgYXJlIHJlcHJlc2VudGVkIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgY2ZhaF9mYWNlQU5vcm1hbFdTID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBjZmFoX2VkZ2UwID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBjZmFoX1dvcmxkRWRnZTAgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIGNmYWhfd29ybGRQbGFuZUFub3JtYWwxID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBjZmFoX3BsYW5lTm9ybWFsV1MxID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBjZmFoX3dvcmxkQTEgPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIGNmYWhfbG9jYWxQbGFuZU5vcm1hbCA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgY2ZhaF9wbGFuZU5vcm1hbFdTID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBGYWNlQWdhaW5zdEh1bGwgPSBmdW5jdGlvbiAoc2VwYXJhdGluZ05vcm1hbCwgcG9zQSwgcXVhdEEsIHdvcmxkVmVydHNCMSwgbWluRGlzdCwgbWF4RGlzdCwgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhY2VBTm9ybWFsV1MgPSBjZmFoX2ZhY2VBTm9ybWFsV1MsXG4gICAgICAgICAgICAgICAgICAgIGVkZ2UwID0gY2ZhaF9lZGdlMCxcbiAgICAgICAgICAgICAgICAgICAgV29ybGRFZGdlMCA9IGNmYWhfV29ybGRFZGdlMCxcbiAgICAgICAgICAgICAgICAgICAgd29ybGRQbGFuZUFub3JtYWwxID0gY2ZhaF93b3JsZFBsYW5lQW5vcm1hbDEsXG4gICAgICAgICAgICAgICAgICAgIHBsYW5lTm9ybWFsV1MxID0gY2ZhaF9wbGFuZU5vcm1hbFdTMSxcbiAgICAgICAgICAgICAgICAgICAgd29ybGRBMSA9IGNmYWhfd29ybGRBMSxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxQbGFuZU5vcm1hbCA9IGNmYWhfbG9jYWxQbGFuZU5vcm1hbCxcbiAgICAgICAgICAgICAgICAgICAgcGxhbmVOb3JtYWxXUyA9IGNmYWhfcGxhbmVOb3JtYWxXUztcblxuICAgICAgICAgICAgICAgIHZhciBodWxsQSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkVmVydHNCMiA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBwVnR4SW4gPSB3b3JsZFZlcnRzQjE7XG4gICAgICAgICAgICAgICAgdmFyIHBWdHhPdXQgPSB3b3JsZFZlcnRzQjI7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgZmFjZSB3aXRoIG5vcm1hbCBjbG9zZXN0IHRvIHRoZSBzZXBhcmF0aW5nIGF4aXNcbiAgICAgICAgICAgICAgICB2YXIgY2xvc2VzdEZhY2VBID0gLTE7XG4gICAgICAgICAgICAgICAgdmFyIGRtaW4gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGZhY2UgPSAwOyBmYWNlIDwgaHVsbEEuZmFjZXMubGVuZ3RoOyBmYWNlKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZmFjZUFOb3JtYWxXUy5jb3B5KGh1bGxBLmZhY2VOb3JtYWxzW2ZhY2VdKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhdEEudm11bHQoZmFjZUFOb3JtYWxXUywgZmFjZUFOb3JtYWxXUyk7XG4gICAgICAgICAgICAgICAgICAgIC8vcG9zQS52YWRkKGZhY2VBTm9ybWFsV1MsZmFjZUFOb3JtYWxXUyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkID0gZmFjZUFOb3JtYWxXUy5kb3Qoc2VwYXJhdGluZ05vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkIDwgZG1pbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0RmFjZUEgPSBmYWNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0RmFjZUEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiLS0tIGRpZCBub3QgZmluZCBhbnkgY2xvc2VzdCBmYWNlLi4uIC0tLVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiY2xvc2VzdCBBOiBcIixjbG9zZXN0RmFjZUEpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgZmFjZSBhbmQgY29uc3RydWN0IGNvbm5lY3RlZCBmYWNlc1xuICAgICAgICAgICAgICAgIHZhciBwb2x5QSA9IGh1bGxBLmZhY2VzW2Nsb3Nlc3RGYWNlQV07XG4gICAgICAgICAgICAgICAgcG9seUEuY29ubmVjdGVkRmFjZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGh1bGxBLmZhY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaHVsbEEuZmFjZXNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2x5QS5pbmRleE9mKGh1bGxBLmZhY2VzW2ldW2pdKSAhPT0gLTEgLyogU2hhcmluZyBhIHZlcnRleCovICYmIGkgIT09IGNsb3Nlc3RGYWNlQSAvKiBOb3QgdGhlIG9uZSB3ZSBhcmUgbG9va2luZyBmb3IgY29ubmVjdGlvbnMgZnJvbSAqLyAmJiBwb2x5QS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKGkpID09PSAtMSAvKiBOb3QgYWxyZWFkeSBhZGRlZCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlBLmNvbm5lY3RlZEZhY2VzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2xpcCB0aGUgcG9seWdvbiB0byB0aGUgYmFjayBvZiB0aGUgcGxhbmVzIG9mIGFsbCBmYWNlcyBvZiBodWxsIEEsIHRoYXQgYXJlIGFkamFjZW50IHRvIHRoZSB3aXRuZXNzIGZhY2VcbiAgICAgICAgICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSBwVnR4SW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBudW1WZXJ0aWNlc0EgPSBwb2x5QS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGUwID0gMDsgZTAgPCBudW1WZXJ0aWNlc0E7IGUwKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVtlMF1dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGh1bGxBLnZlcnRpY2VzW3BvbHlBWyhlMCArIDEpICUgbnVtVmVydGljZXNBXV07XG4gICAgICAgICAgICAgICAgICAgIGEudnN1YihiLCBlZGdlMCk7XG4gICAgICAgICAgICAgICAgICAgIFdvcmxkRWRnZTAuY29weShlZGdlMCk7XG4gICAgICAgICAgICAgICAgICAgIHF1YXRBLnZtdWx0KFdvcmxkRWRnZTAsIFdvcmxkRWRnZTApO1xuICAgICAgICAgICAgICAgICAgICBwb3NBLnZhZGQoV29ybGRFZGdlMCwgV29ybGRFZGdlMCk7XG4gICAgICAgICAgICAgICAgICAgIHdvcmxkUGxhbmVBbm9ybWFsMS5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7Ly90cmFuc0EuZ2V0QmFzaXMoKSogYnRWZWN0b3IzKHBvbHlBLm1fcGxhbmVbMF0scG9seUEubV9wbGFuZVsxXSxwb2x5QS5tX3BsYW5lWzJdKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhdEEudm11bHQod29ybGRQbGFuZUFub3JtYWwxLCB3b3JsZFBsYW5lQW5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBwb3NBLnZhZGQod29ybGRQbGFuZUFub3JtYWwxLCB3b3JsZFBsYW5lQW5vcm1hbDEpO1xuICAgICAgICAgICAgICAgICAgICBXb3JsZEVkZ2UwLmNyb3NzKHdvcmxkUGxhbmVBbm9ybWFsMSwgcGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICAgICAgICAgICAgICBwbGFuZU5vcm1hbFdTMS5uZWdhdGUocGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICAgICAgICAgICAgICB3b3JsZEExLmNvcHkoYSk7XG4gICAgICAgICAgICAgICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkQTEsIHdvcmxkQTEpO1xuICAgICAgICAgICAgICAgICAgICBwb3NBLnZhZGQod29ybGRBMSwgd29ybGRBMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFuZUVxV1MxID0gLXdvcmxkQTEuZG90KHBsYW5lTm9ybWFsV1MxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYW5lRXFXUztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvdGhlckZhY2UgPSBwb2x5QS5jb25uZWN0ZWRGYWNlc1tlMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFBsYW5lTm9ybWFsLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tvdGhlckZhY2VdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbFBsYW5lRXEgPSB0aGlzLmdldFBsYW5lQ29uc3RhbnRPZkZhY2Uob3RoZXJGYWNlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcGxhbmVOb3JtYWxXUy5jb3B5KGxvY2FsUGxhbmVOb3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhdEEudm11bHQocGxhbmVOb3JtYWxXUywgcGxhbmVOb3JtYWxXUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL3Bvc0EudmFkZChwbGFuZU5vcm1hbFdTLHBsYW5lTm9ybWFsV1MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBsYW5lRXFXUyA9IGxvY2FsUGxhbmVFcSAtIHBsYW5lTm9ybWFsV1MuZG90KHBvc0EpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhbmVOb3JtYWxXUy5jb3B5KHBsYW5lTm9ybWFsV1MxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYW5lRXFXUyA9IHBsYW5lRXFXUzE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDbGlwIGZhY2UgYWdhaW5zdCBvdXIgY29uc3RydWN0ZWQgcGxhbmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGlwRmFjZUFnYWluc3RQbGFuZShwVnR4SW4sIHBWdHhPdXQsIHBsYW5lTm9ybWFsV1MsIHBsYW5lRXFXUyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBhbGwgY2xpcHBlZCBwb2ludHMsIGJ1dCBzYXZlIHRoZSByZWFtaW5pbmcgdW50aWwgbmV4dCBjbGlwXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwVnR4SW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwVnR4SW4uc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAocFZ0eE91dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBWdHhJbi5wdXNoKHBWdHhPdXQuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiUmVzdWx0aW5nIHBvaW50cyBhZnRlciBjbGlwOlwiLHBWdHhJbik7XG5cbiAgICAgICAgICAgICAgICAvLyBvbmx5IGtlZXAgY29udGFjdCBwb2ludHMgdGhhdCBhcmUgYmVoaW5kIHRoZSB3aXRuZXNzIGZhY2VcbiAgICAgICAgICAgICAgICBsb2NhbFBsYW5lTm9ybWFsLmNvcHkodGhpcy5mYWNlTm9ybWFsc1tjbG9zZXN0RmFjZUFdKTtcblxuICAgICAgICAgICAgICAgIHZhciBsb2NhbFBsYW5lRXEgPSB0aGlzLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UoY2xvc2VzdEZhY2VBKTtcbiAgICAgICAgICAgICAgICBwbGFuZU5vcm1hbFdTLmNvcHkobG9jYWxQbGFuZU5vcm1hbCk7XG4gICAgICAgICAgICAgICAgcXVhdEEudm11bHQocGxhbmVOb3JtYWxXUywgcGxhbmVOb3JtYWxXUyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGxhbmVFcVdTID0gbG9jYWxQbGFuZUVxIC0gcGxhbmVOb3JtYWxXUy5kb3QocG9zQSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwVnR4SW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHRoID0gcGxhbmVOb3JtYWxXUy5kb3QocFZ0eEluW2ldKSArIHBsYW5lRXFXUzsgLy8/Pz9cbiAgICAgICAgICAgICAgICAgICAgLypjb25zb2xlLmxvZyhcImRlcHRoIGNhbGMgZnJvbSBub3JtYWw9XCIscGxhbmVOb3JtYWxXUy50b1N0cmluZygpLFwiIGFuZCBjb25zdGFudCBcIitwbGFuZUVxV1MrXCIgYW5kIHZlcnRleCBcIixwVnR4SW5baV0udG9TdHJpbmcoKSxcIiBnaXZlcyBcIitkZXB0aCk7Ki9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2xhbXBlZDogZGVwdGg9XCIgKyBkZXB0aCArIFwiIHRvIG1pbkRpc3Q9XCIgKyAobWluRGlzdCArIFwiXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gbWluRGlzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkZXB0aCA8PSBtYXhEaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBwVnR4SW5baV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qY29uc29sZS5sb2coXCJHb3QgY29udGFjdCBwb2ludCBcIixwb2ludC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIsIGRlcHRoPVwiLGRlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJjb250YWN0IG5vcm1hbD1cIixzZXBhcmF0aW5nTm9ybWFsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInBsYW5lXCIscGxhbmVOb3JtYWxXUy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwbGFuZUNvbnN0YW50XCIscGxhbmVFcVdTKTsqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludDogcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbDogcGxhbmVOb3JtYWxXUyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVwdGg6IGRlcHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENsaXAgYSBmYWNlIGluIGEgaHVsbCBhZ2FpbnN0IHRoZSBiYWNrIG9mIGEgcGxhbmUuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNsaXBGYWNlQWdhaW5zdFBsYW5lXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpblZlcnRpY2VzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBvdXRWZXJ0aWNlc1xuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBwbGFuZU5vcm1hbFxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHBsYW5lQ29uc3RhbnQgVGhlIGNvbnN0YW50IGluIHRoZSBtYXRoZW1hdGljYWwgcGxhbmUgZXF1YXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2xpcEZhY2VBZ2FpbnN0UGxhbmUgPSBmdW5jdGlvbiAoaW5WZXJ0aWNlcywgb3V0VmVydGljZXMsIHBsYW5lTm9ybWFsLCBwbGFuZUNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIG5fZG90X2ZpcnN0LCBuX2RvdF9sYXN0O1xuICAgICAgICAgICAgICAgIHZhciBudW1WZXJ0cyA9IGluVmVydGljZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKG51bVZlcnRzIDwgMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0VmVydGljZXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0VmVydGV4ID0gaW5WZXJ0aWNlc1tpblZlcnRpY2VzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgICAgICAgICBsYXN0VmVydGV4ID0gaW5WZXJ0aWNlc1swXTtcblxuICAgICAgICAgICAgICAgIG5fZG90X2ZpcnN0ID0gcGxhbmVOb3JtYWwuZG90KGZpcnN0VmVydGV4KSArIHBsYW5lQ29uc3RhbnQ7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB2aSA9IDA7IHZpIDwgbnVtVmVydHM7IHZpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFZlcnRleCA9IGluVmVydGljZXNbdmldO1xuICAgICAgICAgICAgICAgICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5fZG90X2ZpcnN0IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5fZG90X2xhc3QgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgPCAwLCBlbmQgPCAwLCBzbyBvdXRwdXQgbGFzdFZlcnRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXd2LmNvcHkobGFzdFZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RhcnQgPCAwLCBlbmQgPj0gMCwgc28gb3V0cHV0IGludGVyc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFZlcnRleC5sZXJwKGxhc3RWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5fZG90X2ZpcnN0IC8gKG5fZG90X2ZpcnN0IC0gbl9kb3RfbGFzdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobl9kb3RfbGFzdCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCA+PSAwLCBlbmQgPCAwIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24gYW5kIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFZlcnRleC5sZXJwKGxhc3RWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5fZG90X2ZpcnN0IC8gKG5fZG90X2ZpcnN0IC0gbl9kb3RfbGFzdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld3YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dFZlcnRpY2VzLnB1c2gobmV3dik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChsYXN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaXJzdFZlcnRleCA9IGxhc3RWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgIG5fZG90X2ZpcnN0ID0gbl9kb3RfbGFzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dFZlcnRpY2VzO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlcyAud29ybGRWZXJ0aWNlcyBhbmQgc2V0cyAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlIHRvIGZhbHNlLlxuICAgICAgICAgICAgQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZVdvcmxkVmVydGljZXMgPSBmdW5jdGlvbiAocG9zaXRpb24sIHF1YXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgTiA9IHRoaXMudmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLndvcmxkVmVydGljZXMubGVuZ3RoIDwgTikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmxkVmVydGljZXMucHVzaChuZXcgVmVjMygpKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzLFxuICAgICAgICAgICAgICAgICAgICB3b3JsZFZlcnRzID0gdGhpcy53b3JsZFZlcnRpY2VzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcXVhdC52bXVsdCh2ZXJ0c1tpXSwgd29ybGRWZXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uLnZhZGQod29ybGRWZXJ0c1tpXSwgd29ybGRWZXJ0c1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBDb252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlTG9jYWxBQUJCID0gZnVuY3Rpb24gKGFhYmJtaW4sIGFhYmJtYXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydCA9IGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0O1xuXG4gICAgICAgICAgICAgICAgYWFiYm1pbi5zZXQoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgICAgICAgICAgYWFiYm1heC5zZXQoLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHZlcnRpY2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodi54IDwgYWFiYm1pbi54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYWJibWluLnggPSB2Lng7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodi54ID4gYWFiYm1heC54KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYWJibWF4LnggPSB2Lng7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHYueSA8IGFhYmJtaW4ueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYm1pbi55ID0gdi55O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYueSA+IGFhYmJtYXgueSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWFiYm1heC55ID0gdi55O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2LnogPCBhYWJibWluLnopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhYmJtaW4ueiA9IHYuejtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnogPiBhYWJibWF4LnopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhYmJtYXgueiA9IHYuejtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlcyAud29ybGRWZXJ0aWNlcyBhbmQgc2V0cyAud29ybGRWZXJ0aWNlc05lZWRzVXBkYXRlIHRvIGZhbHNlLlxuICAgICAgICAgICAgICogQG1ldGhvZCBjb21wdXRlV29ybGRGYWNlTm9ybWFsc1xuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlV29ybGRGYWNlTm9ybWFscyA9IGZ1bmN0aW9uIChxdWF0KSB7XG4gICAgICAgICAgICAgICAgdmFyIE4gPSB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy53b3JsZEZhY2VOb3JtYWxzLmxlbmd0aCA8IE4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzLnB1c2gobmV3IFZlYzMoKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzLFxuICAgICAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbHMgPSB0aGlzLndvcmxkRmFjZU5vcm1hbHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBxdWF0LnZtdWx0KG5vcm1hbHNbaV0sIHdvcmxkTm9ybWFsc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWUgcG9pbnRzIGFyZSBkaXN0cmlidXRlZCB3aXRoIGxvY2FsICgwLDAsMCkgYXMgY2VudGVyXG4gICAgICAgICAgICAgICAgdmFyIG1heDIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIE4gPSB2ZXJ0cy5sZW5ndGg7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybTIgPSB2ZXJ0c1tpXS5ub3JtMigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9ybTIgPiBtYXgyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXgyID0gbm9ybTI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE1hdGguc3FydChtYXgyKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0ZW1wV29ybGRWZXJ0ZXggPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgY2FsY3VsYXRlV29ybGRBQUJCXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBwb3NcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gIHF1YXRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1pblxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWF4XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uIChwb3MsIHF1YXQsIG1pbiwgbWF4KSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCwgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgICAgICAgICAgICAgIHZhciBtaW54LCBtaW55LCBtaW56LCBtYXh4LCBtYXh5LCBtYXh6O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBXb3JsZFZlcnRleC5jb3B5KHZlcnRzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgcXVhdC52bXVsdCh0ZW1wV29ybGRWZXJ0ZXgsIHRlbXBXb3JsZFZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgIHBvcy52YWRkKHRlbXBXb3JsZFZlcnRleCwgdGVtcFdvcmxkVmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB0ZW1wV29ybGRWZXJ0ZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2LnggPCBtaW54IHx8IG1pbnggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlueCA9IHYueDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnggPiBtYXh4IHx8IG1heHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4eCA9IHYueDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2LnkgPCBtaW55IHx8IG1pbnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlueSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnkgPiBtYXh5IHx8IG1heHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4eSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2LnogPCBtaW56IHx8IG1pbnogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlueiA9IHYuejtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnogPiBtYXh6IHx8IG1heHogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4eiA9IHYuejtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaW4uc2V0KG1pbngsIG1pbnksIG1pbnopO1xuICAgICAgICAgICAgICAgIG1heC5zZXQobWF4eCwgbWF4eSwgbWF4eik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhcHByb3hpbWF0ZSBjb252ZXggdm9sdW1lXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHZvbHVtZVxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzIC8gMy4wO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYW4gYXZlcmFnZSBvZiBhbGwgdGhlIHZlcnRpY2VzIHBvc2l0aW9uc1xuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRBdmVyYWdlUG9pbnRMb2NhbFxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBDb252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5nZXRBdmVyYWdlUG9pbnRMb2NhbCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LnZhZGQodmVydHNbaV0sIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRhcmdldC5tdWx0KDEgLyBuLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRyYW5zZm9ybSBhbGwgbG9jYWwgcG9pbnRzLiBXaWxsIGNoYW5nZSB0aGUgLnZlcnRpY2VzXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHRyYW5zZm9ybUFsbFBvaW50c1xuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gb2Zmc2V0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnRyYW5zZm9ybUFsbFBvaW50cyA9IGZ1bmN0aW9uIChvZmZzZXQsIHF1YXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSByb3RhdGlvblxuICAgICAgICAgICAgICAgIGlmIChxdWF0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJvdGF0ZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YXQudm11bHQodiwgdik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUm90YXRlIGZhY2Ugbm9ybWFsc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdGhpcy5mYWNlTm9ybWFsc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YXQudm11bHQodiwgdik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgLy8gUm90YXRlIGVkZ2VzXG4gICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudW5pcXVlRWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnVuaXF1ZUVkZ2VzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xuICAgICAgICAgICAgICAgICAgICB9Ki9cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBvZmZzZXRcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdi52YWRkKG9mZnNldCwgdik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHAgaXMgaW5zaWRlIHRoZSBwb2x5aGVkcmEuIE11c3QgYmUgaW4gbG9jYWwgY29vcmRzLiBUaGUgcG9pbnQgbGllcyBvdXRzaWRlIG9mIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgb3RoZXIgcG9pbnRzIGlmIGFuZCBvbmx5IGlmIHRoZSBkaXJlY3Rpb24gb2YgYWxsIHRoZSB2ZWN0b3JzIGZyb20gaXQgdG8gdGhvc2Ugb3RoZXIgcG9pbnRzIGFyZSBvbiBsZXNzIHRoYW4gb25lIGhhbGYgb2YgYSBzcGhlcmUgYXJvdW5kIGl0LlxuICAgICAgICAgICAgICogQG1ldGhvZCBwb2ludElzSW5zaWRlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSBwICAgICAgQSBwb2ludCBnaXZlbiBpbiBsb2NhbCBjb29yZGluYXRlc1xuICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIENvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgQ29udmV4UG9seWhlZHJvbl92VG9QID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBDb252ZXhQb2x5aGVkcm9uX3ZUb1BvaW50SW5zaWRlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnBvaW50SXNJbnNpZGUgPSBmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgICAgICAgICAgICAgZmFjZXMgPSB0aGlzLmZhY2VzLFxuICAgICAgICAgICAgICAgICAgICBub3JtYWxzID0gdGhpcy5mYWNlTm9ybWFscztcbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpdmVSZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBOID0gdGhpcy5mYWNlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50SW5zaWRlID0gQ29udmV4UG9seWhlZHJvbl9wb2ludElzSW5zaWRlO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QXZlcmFnZVBvaW50TG9jYWwocG9pbnRJbnNpZGUpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1WZXJ0aWNlcyA9IHRoaXMuZmFjZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IG5vcm1hbHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdmVydHNbZmFjZXNbaV1bMF1dOyAvLyBXZSBvbmx5IG5lZWQgb25lIHBvaW50IGluIHRoZSBmYWNlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBkb3QgcHJvZHVjdCBkZXRlcm1pbmVzIHdoaWNoIHNpZGUgb2YgdGhlIGVkZ2UgdGhlIHBvaW50IGlzXG4gICAgICAgICAgICAgICAgICAgIHZhciB2VG9QID0gQ29udmV4UG9seWhlZHJvbl92VG9QO1xuICAgICAgICAgICAgICAgICAgICBwLnZzdWIodiwgdlRvUCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByMSA9IG4uZG90KHZUb1ApO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB2VG9Qb2ludEluc2lkZSA9IENvbnZleFBvbHloZWRyb25fdlRvUG9pbnRJbnNpZGU7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5zaWRlLnZzdWIodiwgdlRvUG9pbnRJbnNpZGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcjIgPSBuLmRvdCh2VG9Qb2ludEluc2lkZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChyMSA8IDAgJiYgcjIgPiAwKSB8fCAocjEgPiAwICYmIHIyIDwgMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gRW5jb3VudGVyZWQgc29tZSBvdGhlciBzaWduLiBFeGl0LlxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIGFsbCBkb3QgcHJvZHVjdHMgd2VyZSBvZiB0aGUgc2FtZSBzaWduLlxuICAgICAgICAgICAgICAgIHJldHVybiBwb3NpdGl2ZVJlc3VsdCA/IDEgOiAtMTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IG1heCBhbmQgbWluIGRvdCBwcm9kdWN0IG9mIGEgY29udmV4IGh1bGwgYXQgcG9zaXRpb24gKHBvcyxxdWF0KSBwcm9qZWN0ZWQgb250byBhbiBheGlzLiBSZXN1bHRzIGFyZSBzYXZlZCBpbiB0aGUgYXJyYXkgbWF4bWluLlxuICAgICAgICAgICAgICogQHN0YXRpY1xuICAgICAgICAgICAgICogQG1ldGhvZCBwcm9qZWN0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnZleFBvbHloZWRyb259IGh1bGxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gYXhpc1xuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBwb3NcbiAgICAgICAgICAgICAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdFxuICAgICAgICAgICAgICogQHBhcmFtIHthcnJheX0gcmVzdWx0IHJlc3VsdFswXSBhbmQgcmVzdWx0WzFdIHdpbGwgYmUgc2V0IHRvIG1heGltdW0gYW5kIG1pbmltdW0sIHJlc3BlY3RpdmVseS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHByb2plY3Rfd29ybGRWZXJ0ZXggPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHByb2plY3RfbG9jYWxBeGlzID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwcm9qZWN0X2xvY2FsT3JpZ2luID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdCA9IGZ1bmN0aW9uIChodWxsLCBheGlzLCBwb3MsIHF1YXQsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gaHVsbC52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydGV4ID0gcHJvamVjdF93b3JsZFZlcnRleCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxBeGlzID0gcHJvamVjdF9sb2NhbEF4aXMsXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IDAsXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IDAsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsT3JpZ2luID0gcHJvamVjdF9sb2NhbE9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgdnMgPSBodWxsLnZlcnRpY2VzO1xuXG4gICAgICAgICAgICAgICAgbG9jYWxPcmlnaW4uc2V0WmVybygpO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBheGlzIHRvIGxvY2FsXG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvTG9jYWxGcmFtZShwb3MsIHF1YXQsIGF4aXMsIGxvY2FsQXhpcyk7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvcywgcXVhdCwgbG9jYWxPcmlnaW4sIGxvY2FsT3JpZ2luKTtcbiAgICAgICAgICAgICAgICB2YXIgYWRkID0gbG9jYWxPcmlnaW4uZG90KGxvY2FsQXhpcyk7XG5cbiAgICAgICAgICAgICAgICBtaW4gPSBtYXggPSB2c1swXS5kb3QobG9jYWxBeGlzKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSB2c1tpXS5kb3QobG9jYWxBeGlzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtaW4gLT0gYWRkO1xuICAgICAgICAgICAgICAgIG1heCAtPSBhZGQ7XG5cbiAgICAgICAgICAgICAgICBpZiAobWluID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluY29uc2lzdGVudCAtIHN3YXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBtaW47XG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT3V0cHV0XG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gbWF4O1xuICAgICAgICAgICAgICAgIHJlc3VsdFsxXSA9IG1pbjtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4uL21hdGgvUXVhdGVybmlvblwiOiAyOCwgXCIuLi9tYXRoL1RyYW5zZm9ybVwiOiAyOSwgXCIuLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi9TaGFwZVwiOiA0MyB9XSwgMzk6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEN5bGluZGVyO1xuXG4gICAgICAgICAgICB2YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbiAgICAgICAgICAgIHZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi9Db252ZXhQb2x5aGVkcm9uJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNsYXNzIEN5bGluZGVyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBleHRlbmRzIENvbnZleFBvbHloZWRyb25cbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUb3BcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCb3R0b21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBudW1TZWdtZW50cyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGJ1aWxkIHRoZSBjeWxpbmRlciBvdXQgb2ZcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gQ3lsaW5kZXIocmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgbnVtU2VnbWVudHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgTiA9IG51bVNlZ21lbnRzLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0cyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBheGVzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzID0gW10sXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbWZhY2UgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9wZmFjZSA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBjb3MgPSBNYXRoLmNvcyxcbiAgICAgICAgICAgICAgICAgICAgc2luID0gTWF0aC5zaW47XG5cbiAgICAgICAgICAgICAgICAvLyBGaXJzdCBib3R0b20gcG9pbnRcbiAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c0JvdHRvbSAqIGNvcygwKSxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tICogc2luKDApLFxuICAgICAgICAgICAgICAgICAgICAtaGVpZ2h0ICogMC41KSk7XG4gICAgICAgICAgICAgICAgYm90dG9tZmFjZS5wdXNoKDApO1xuXG4gICAgICAgICAgICAgICAgLy8gRmlyc3QgdG9wIHBvaW50XG4gICAgICAgICAgICAgICAgdmVydHMucHVzaChuZXcgVmVjMyhyYWRpdXNUb3AgKiBjb3MoMCksXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1c1RvcCAqIHNpbigwKSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICogMC41KSk7XG4gICAgICAgICAgICAgICAgdG9wZmFjZS5wdXNoKDEpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBOICogKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRoZXRhTiA9IDIgKiBNYXRoLlBJIC8gTiAqIChpICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBOIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQm90dG9tXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c0JvdHRvbSAqIGNvcyh0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tICogc2luKHRoZXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAtaGVpZ2h0ICogMC41KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b21mYWNlLnB1c2goMiAqIGkgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRvcFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydHMucHVzaChuZXcgVmVjMyhyYWRpdXNUb3AgKiBjb3ModGhldGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1c1RvcCAqIHNpbih0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICogMC41KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BmYWNlLnB1c2goMiAqIGkgKyAzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgZmFjZXMucHVzaChbMiAqIGkgKyAyLCAyICogaSArIDMsIDIgKiBpICsgMSwgMiAqIGldKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goWzAsIDEsIDIgKiBpICsgMSwgMiAqIGldKTsgLy8gQ29ubmVjdFxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXhpczogd2UgY2FuIGN1dCBvZmYgaGFsZiBvZiB0aGVtIGlmIHdlIGhhdmUgZXZlbiBudW1iZXIgb2Ygc2VnbWVudHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKE4gJSAyID09PSAxIHx8IGkgPCBOIC8gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXhlcy5wdXNoKG5ldyBWZWMzKGNvcyh0aGV0YU4pLCBzaW4odGhldGFOKSwgMCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2godG9wZmFjZSk7XG4gICAgICAgICAgICAgICAgYXhlcy5wdXNoKG5ldyBWZWMzKDAsIDAsIDEpKTtcblxuICAgICAgICAgICAgICAgIC8vIFJlb3JkZXIgYm90dG9tIGZhY2VcbiAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm90dG9tZmFjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wLnB1c2goYm90dG9tZmFjZVtib3R0b21mYWNlLmxlbmd0aCAtIGkgLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZhY2VzLnB1c2godGVtcCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OO1xuICAgICAgICAgICAgICAgIENvbnZleFBvbHloZWRyb24uY2FsbCh0aGlzLCB2ZXJ0cywgZmFjZXMsIGF4ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBDeWxpbmRlci5wcm90b3R5cGUgPSBuZXcgQ29udmV4UG9seWhlZHJvbigpO1xuXG4gICAgICAgIH0sIHsgXCIuLi9tYXRoL1F1YXRlcm5pb25cIjogMjgsIFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4vQ29udmV4UG9seWhlZHJvblwiOiAzOCwgXCIuL1NoYXBlXCI6IDQzIH1dLCA0MDogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIHZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbiAgICAgICAgICAgIHZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi9Db252ZXhQb2x5aGVkcm9uJyk7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBIZWlnaHRmaWVsZDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIZWlnaHRmaWVsZCBzaGFwZSBjbGFzcy4gSGVpZ2h0IGRhdGEgaXMgZ2l2ZW4gYXMgYW4gYXJyYXkuIFRoZXNlIGRhdGEgcG9pbnRzIGFyZSBzcHJlYWQgb3V0IGV2ZW5seSB3aXRoIGEgZ2l2ZW4gZGlzdGFuY2UuXG4gICAgICAgICAgICAgKiBAY2xhc3MgSGVpZ2h0ZmllbGRcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFNoYXBlXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgQW4gYXJyYXkgb2YgWSB2YWx1ZXMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gY29uc3RydWN0IHRoZSB0ZXJyYWluLlxuICAgICAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5taW5WYWx1ZV0gTWluaW11bSB2YWx1ZSBvZiB0aGUgZGF0YSBwb2ludHMgaW4gdGhlIGRhdGEgYXJyYXkuIFdpbGwgYmUgY29tcHV0ZWQgYXV0b21hdGljYWxseSBpZiBub3QgZ2l2ZW4uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4VmFsdWVdIE1heGltdW0gdmFsdWUuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZWxlbWVudFNpemU9MC4xXSBXb3JsZCBzcGFjaW5nIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggZGlyZWN0aW9uLlxuICAgICAgICAgICAgICogQHRvZG8gU2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBhbG9uZyBhbGwgYXhlcywgbm90IGp1c3QgeVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAgLy8gR2VuZXJhdGUgc29tZSBoZWlnaHQgZGF0YSAoeS12YWx1ZXMpLlxuICAgICAgICAgICAgICogICAgIHZhciBkYXRhID0gW107XG4gICAgICAgICAgICAgKiAgICAgZm9yKHZhciBpID0gMDsgaSA8IDEwMDA7IGkrKyl7XG4gICAgICAgICAgICAgKiAgICAgICAgIHZhciB5ID0gMC41ICogTWF0aC5jb3MoMC4yICogaSk7XG4gICAgICAgICAgICAgKiAgICAgICAgIGRhdGEucHVzaCh5KTtcbiAgICAgICAgICAgICAqICAgICB9XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogICAgIC8vIENyZWF0ZSB0aGUgaGVpZ2h0ZmllbGQgc2hhcGVcbiAgICAgICAgICAgICAqICAgICB2YXIgaGVpZ2h0ZmllbGRTaGFwZSA9IG5ldyBIZWlnaHRmaWVsZChkYXRhLCB7XG4gICAgICAgICAgICAgKiAgICAgICAgIGVsZW1lbnRTaXplOiAxIC8vIERpc3RhbmNlIGJldHdlZW4gdGhlIGRhdGEgcG9pbnRzIGluIFggYW5kIFkgZGlyZWN0aW9uc1xuICAgICAgICAgICAgICogICAgIH0pO1xuICAgICAgICAgICAgICogICAgIHZhciBoZWlnaHRmaWVsZEJvZHkgPSBuZXcgQm9keSgpO1xuICAgICAgICAgICAgICogICAgIGhlaWdodGZpZWxkQm9keS5hZGRTaGFwZShoZWlnaHRmaWVsZFNoYXBlKTtcbiAgICAgICAgICAgICAqICAgICB3b3JsZC5hZGRCb2R5KGhlaWdodGZpZWxkQm9keSk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIEhlaWdodGZpZWxkKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gVXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgICAgICAgICAgICAgICBtYXhWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluVmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRTaXplOiAxXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBbiBhcnJheSBvZiBudW1iZXJzLCBvciBoZWlnaHQgdmFsdWVzLCB0aGF0IGFyZSBzcHJlYWQgb3V0IGFsb25nIHRoZSB4IGF4aXMuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHthcnJheX0gZGF0YVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4VmFsdWVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm1heFZhbHVlID0gb3B0aW9ucy5tYXhWYWx1ZTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE1heCB2YWx1ZSBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5WYWx1ZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMubWluVmFsdWUgPSBvcHRpb25zLm1pblZhbHVlO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIHdpZHRoIG9mIGVhY2ggZWxlbWVudFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlbGVtZW50U2l6ZVxuICAgICAgICAgICAgICAgICAqIEB0b2RvIGVsZW1lbnRTaXplWCBhbmQgWVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudFNpemUgPSBvcHRpb25zLmVsZW1lbnRTaXplO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubWluVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNaW5WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5tYXhWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU1heFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jYWNoZUVuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMucGlsbGFyQ29udmV4ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRDtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBcImlfal9pc1VwcGVyXCIgPT4geyBjb252ZXg6IC4uLiwgb2Zmc2V0OiAuLi4gfVxuICAgICAgICAgICAgICAgIC8vIGZvciBleGFtcGxlOlxuICAgICAgICAgICAgICAgIC8vIF9jYWNoZWRQaWxsYXJzW1wiMF8yXzFcIl1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxsIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGRhdGEgYXJyYXkuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBpbGxhcnMgPSB7fTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSAubWluVmFsdWUgcHJvcGVydHlcbiAgICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlTWluVmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1pblZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBtaW5WYWx1ZSA9IGRhdGFbMF1bMF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXVtqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2IDwgbWluVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5WYWx1ZSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5taW5WYWx1ZSA9IG1pblZhbHVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIC5tYXhWYWx1ZSBwcm9wZXJ0eVxuICAgICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVNYXhWYWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlTWF4VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIG1heFZhbHVlID0gZGF0YVswXVswXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFZhbHVlID0gdjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1heFZhbHVlID0gbWF4VmFsdWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgaGVpZ2h0IHZhbHVlIGF0IGFuIGluZGV4LiBEb24ndCBmb3JnZXQgdG8gdXBkYXRlIG1heFZhbHVlIGFuZCBtaW5WYWx1ZSBhZnRlciB5b3UncmUgZG9uZS5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc2V0SGVpZ2h0VmFsdWVBdEluZGV4XG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHhpXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2ludGVnZXJ9IHlpXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldEhlaWdodFZhbHVlQXRJbmRleCA9IGZ1bmN0aW9uICh4aSwgeWksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgZGF0YVt4aV1beWldID0gdmFsdWU7XG5cbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlXG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGlmICh4aSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeWkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWkgLSAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSAtIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHlpID4gMCAmJiB4aSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWkgLSAxLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBtYXgvbWluIGluIGEgcmVjdGFuZ2xlIGluIHRoZSBtYXRyaXggZGF0YVxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRSZWN0TWluTWF4XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWluWFxuICAgICAgICAgICAgICogQHBhcmFtICB7aW50ZWdlcn0gaU1pbllcbiAgICAgICAgICAgICAqIEBwYXJhbSAge2ludGVnZXJ9IGlNYXhYXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWF4WVxuICAgICAgICAgICAgICogQHBhcmFtICB7YXJyYXl9IFtyZXN1bHRdIEFuIGFycmF5IHRvIHN0b3JlIHRoZSByZXN1bHRzIGluLlxuICAgICAgICAgICAgICogQHJldHVybiB7YXJyYXl9IFRoZSByZXN1bHQgYXJyYXksIGlmIGl0IHdhcyBwYXNzZWQgaW4uIE1pbmltdW0gd2lsbCBiZSBhdCBwb3NpdGlvbiAwIGFuZCBtYXggYXQgMS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldFJlY3RNaW5NYXggPSBmdW5jdGlvbiAoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCB8fCBbXTtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBtYXggYW5kIG1pbiBvZiB0aGUgZGF0YVxuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBtYXggPSB0aGlzLm1pblZhbHVlOyAvLyBTZXQgZmlyc3QgdmFsdWVcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gaU1pblg7IGkgPD0gaU1heFg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gaU1pblk7IGogPD0gaU1heFk7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGRhdGFbaV1bal07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0ID4gbWF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4ID0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0WzBdID0gdGhpcy5taW5WYWx1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbMV0gPSBtYXg7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgaW5kZXggb2YgYSBsb2NhbCBwb3NpdGlvbiBvbiB0aGUgaGVpZ2h0ZmllbGQuIFRoZSBpbmRleGVzIGluZGljYXRlIHRoZSByZWN0YW5nbGVzLCBzbyBpZiB5b3VyIHRlcnJhaW4gaXMgbWFkZSBvZiBOIHggTiBoZWlnaHQgZGF0YSBwb2ludHMsIHlvdSB3aWxsIGhhdmUgcmVjdGFuZ2xlIGluZGV4ZXMgcmFuZ2luZyBmcm9tIDAgdG8gTi0xLlxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRJbmRleE9mUG9zaXRpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IFR3by1lbGVtZW50IGFycmF5XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBjbGFtcCBJZiB0aGUgcG9zaXRpb24gc2hvdWxkIGJlIGNsYW1wZWQgdG8gdGhlIGhlaWdodGZpZWxkIGVkZ2UuXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0SW5kZXhPZlBvc2l0aW9uID0gZnVuY3Rpb24gKHgsIHksIHJlc3VsdCwgY2xhbXApIHtcblxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgICAgICAgICAgICAgIHZhciB3ID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgeGkgPSBNYXRoLmZsb29yKHggLyB3KTtcbiAgICAgICAgICAgICAgICB2YXIgeWkgPSBNYXRoLmZsb29yKHkgLyB3KTtcblxuICAgICAgICAgICAgICAgIHJlc3VsdFswXSA9IHhpO1xuICAgICAgICAgICAgICAgIHJlc3VsdFsxXSA9IHlpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNsYW1wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXG4gICAgICAgICAgICAgICAgICAgIGlmICh4aSA8IDApIHsgeGkgPSAwOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh5aSA8IDApIHsgeWkgPSAwOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aSA+PSBkYXRhLmxlbmd0aCAtIDEpIHsgeGkgPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHlpID49IGRhdGFbMF0ubGVuZ3RoIC0gMSkgeyB5aSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cbiAgICAgICAgICAgICAgICBpZiAoeGkgPCAwIHx8IHlpIDwgMCB8fCB4aSA+PSBkYXRhLmxlbmd0aCAtIDEgfHwgeWkgPj0gZGF0YVswXS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRIZWlnaHRBdCA9IGZ1bmN0aW9uICh4LCB5LCBlZGdlQ2xhbXApIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbmRleE9mUG9zaXRpb24oeCwgeSwgaWR4LCBlZGdlQ2xhbXApO1xuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogZ2V0IHVwcGVyIG9yIGxvd2VyIHRyaWFuZ2xlLCB0aGVuIHVzZSBiYXJ5Y2VudHJpYyBpbnRlcnBvbGF0aW9uIHRvIGdldCB0aGUgaGVpZ2h0IGluIHRoZSB0cmlhbmdsZS5cbiAgICAgICAgICAgICAgICB2YXIgbWlubWF4ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRSZWN0TWluTWF4KGlkeFswXSwgaWR4WzFdICsgMSwgaWR4WzBdLCBpZHhbMV0gKyAxLCBtaW5tYXgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIChtaW5tYXhbMF0gKyBtaW5tYXhbMV0pIC8gMjsgLy8gYXZlcmFnZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkgPSBmdW5jdGlvbiAoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhpICsgJ18nICsgeWkgKyAnXycgKyAoZ2V0VXBwZXJUcmlhbmdsZSA/IDEgOiAwKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uICh4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGlsbGFyc1t0aGlzLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUuc2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbiAoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCBjb252ZXgsIG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldID0ge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXg6IGNvbnZleCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbiAoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYSB0cmlhbmdsZSBpbiB0aGUgdGVycmFpbiBpbiB0aGUgZm9ybSBvZiBhIHRyaWFuZ3VsYXIgY29udmV4IHNoYXBlLlxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRDb252ZXhUcmlhbmdsZVBpbGxhclxuICAgICAgICAgICAgICogQHBhcmFtICB7aW50ZWdlcn0gaVxuICAgICAgICAgICAgICogQHBhcmFtICB7aW50ZWdlcn0galxuICAgICAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZ2V0VXBwZXJUcmlhbmdsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBIZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbiAoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucGlsbGFyQ29udmV4O1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXRSZXN1bHQgPSB0aGlzLnBpbGxhck9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNhY2hlRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0Q2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGlsbGFyQ29udmV4ID0gZGF0YS5jb252ZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IGRhdGEub2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0UmVzdWx0ID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBvZmZzZXRSZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICAgICAgICAgICAgICB2YXIgZmFjZXMgPSByZXN1bHQuZmFjZXM7XG5cbiAgICAgICAgICAgICAgICAvLyBSZXVzZSB2ZXJ0cyBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LnZlcnRpY2VzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudmVydGljZXNbaV0gPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmV1c2UgZmFjZXMgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICBmYWNlcy5sZW5ndGggPSA1O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmFjZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VzW2ldID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgdmVydHMgPSByZXN1bHQudmVydGljZXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgaCA9IChNYXRoLm1pbihcbiAgICAgICAgICAgICAgICAgICAgZGF0YVt4aV1beWldLFxuICAgICAgICAgICAgICAgICAgICBkYXRhW3hpICsgMV1beWldLFxuICAgICAgICAgICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdLFxuICAgICAgICAgICAgICAgICAgICBkYXRhW3hpICsgMV1beWkgKyAxXVxuICAgICAgICAgICAgICAgICkgLSB0aGlzLm1pblZhbHVlKSAvIDIgKyB0aGlzLm1pblZhbHVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFnZXRVcHBlclRyaWFuZ2xlKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldFJlc3VsdC5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAoeGkgKyAwLjI1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAoeWkgKyAwLjI1KSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgaCAvLyB2ZXJ0aWNhbCBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgICAgICAgICAgICAgICAgdmVydHNbMF0uc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3hpXVt5aV0gLSBoXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRzWzFdLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3hpICsgMV1beWldIC0gaFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0c1syXS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXSAtIGhcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gdHJpYW5nbGUgdmVydHNcbiAgICAgICAgICAgICAgICAgICAgdmVydHNbM10uc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAgICAgICAgICAgICAtaCAtIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmVydHNbNF0uc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC1oIC0gMVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0c1s1XS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgLWggLSAxXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdG9wIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzBdWzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbMF1bMV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1swXVsyXSA9IDI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzFdWzBdID0gNTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbMV1bMV0gPSA0O1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1sxXVsyXSA9IDM7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gLXggZmFjaW5nIHF1YWRcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbMl1bMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1syXVsxXSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzJdWzJdID0gNTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbMl1bM10gPSAzO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC15IGZhY2luZyBxdWFkXG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzNdWzBdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbM11bMV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1szXVsyXSA9IDM7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzNdWzNdID0gNDtcblxuICAgICAgICAgICAgICAgICAgICAvLyAreHkgZmFjaW5nIHF1YWRcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbNF1bMF0gPSA0O1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1s0XVsxXSA9IDU7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzRdWzJdID0gMjtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbNF1bM10gPSAxO1xuXG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENlbnRlciBvZiB0aGUgdHJpYW5nbGUgcGlsbGFyIC0gYWxsIHBvbHlnb25zIGFyZSBnaXZlbiByZWxhdGl2ZSB0byB0aGlzIG9uZVxuICAgICAgICAgICAgICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgKHhpICsgMC43NSkgKiBlbGVtZW50U2l6ZSwgLy8gc29ydCBvZiBjZW50ZXIgb2YgYSB0cmlhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgKHlpICsgMC43NSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGggLy8gdmVydGljYWwgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgICAgICAgICAgICAgIHZlcnRzWzBdLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aSArIDFdIC0gaFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB2ZXJ0c1sxXS5zZXQoXG4gICAgICAgICAgICAgICAgICAgICAgICAtMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVt4aV1beWkgKyAxXSAtIGhcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmVydHNbMl0uc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbeGkgKyAxXVt5aV0gLSBoXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgICAgICAgICAgICAgIHZlcnRzWzNdLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gaCAtIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmVydHNbNF0uc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gaCAtIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgdmVydHNbNV0uc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC0gaCAtIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBUb3AgdHJpYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbMF1bMF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1swXVsxXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzBdWzJdID0gMjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBib3R0b20gdHJpYW5nbGVcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbMV1bMF0gPSA1O1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzFdWzJdID0gMztcblxuICAgICAgICAgICAgICAgICAgICAvLyAreCBmYWNpbmcgcXVhZFxuICAgICAgICAgICAgICAgICAgICBmYWNlc1syXVswXSA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzJdWzFdID0gNTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbMl1bMl0gPSAzO1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1syXVszXSA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gK3kgZmFjaW5nIHF1YWRcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbM11bMF0gPSAzO1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1szXVsxXSA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzNdWzJdID0gMTtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbM11bM10gPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC14eSBmYWNpbmcgcXVhZFxuICAgICAgICAgICAgICAgICAgICBmYWNlc1s0XVswXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGZhY2VzWzRdWzFdID0gNDtcbiAgICAgICAgICAgICAgICAgICAgZmFjZXNbNF1bMl0gPSA1O1xuICAgICAgICAgICAgICAgICAgICBmYWNlc1s0XVszXSA9IDI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXB1dGVOb3JtYWxzKCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmNvbXB1dGVFZGdlcygpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUsIHJlc3VsdCwgb2Zmc2V0UmVzdWx0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbiAobWFzcywgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTsgLy8gVGhlIHRlcnJhaW4gaXMgaW5maW5pdGVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEhlaWdodGZpZWxkLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbiAocG9zLCBxdWF0LCBtaW4sIG1heCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGRvIGl0IHByb3Blcmx5XG4gICAgICAgICAgICAgICAgbWluLnNldCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICAgICAgICAgICAgICBtYXguc2V0KE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBtaW4vbWF4IHZhbHVlc1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBzID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gbmV3IFZlYzMoZGF0YS5sZW5ndGggKiBzLCBkYXRhWzBdLmxlbmd0aCAqIHMsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLCBNYXRoLmFicyh0aGlzLm1pblZhbHVlKSkpLm5vcm0oKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi91dGlscy9VdGlsc1wiOiA1MywgXCIuL0NvbnZleFBvbHloZWRyb25cIjogMzgsIFwiLi9TaGFwZVwiOiA0MyB9XSwgNDE6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuXG4gICAgICAgICAgICB2YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBhcnRpY2xlIHNoYXBlLlxuICAgICAgICAgICAgICogQGNsYXNzIFBhcnRpY2xlXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGVcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFNoYXBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFBhcnRpY2xlKCkge1xuICAgICAgICAgICAgICAgIFNoYXBlLmNhbGwodGhpcyk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5QQVJUSUNMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuICAgICAgICAgICAgUGFydGljbGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFydGljbGU7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQYXJ0aWNsZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24gKG1hc3MsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFBhcnRpY2xlLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBQYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBQYXJ0aWNsZS5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24gKHBvcywgcXVhdCwgbWluLCBtYXgpIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgZWFjaCBheGlzIG1heFxuICAgICAgICAgICAgICAgIG1pbi5jb3B5KHBvcyk7XG4gICAgICAgICAgICAgICAgbWF4LmNvcHkocG9zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuL1NoYXBlXCI6IDQzIH1dLCA0MjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gUGxhbmU7XG5cbiAgICAgICAgICAgIHZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBwbGFuZSwgZmFjaW5nIGluIHRoZSBaIGRpcmVjdGlvbi4gVGhlIHBsYW5lIGhhcyBpdHMgc3VyZmFjZSBhdCB6PTAgYW5kIGV2ZXJ5dGhpbmcgYmVsb3cgej0wIGlzIGFzc3VtZWQgdG8gYmUgc29saWQgcGxhbmUuIFRvIG1ha2UgdGhlIHBsYW5lIGZhY2UgaW4gc29tZSBvdGhlciBkaXJlY3Rpb24gdGhhbiB6LCB5b3UgbXVzdCBwdXQgaXQgaW5zaWRlIGEgUmlnaWRCb2R5IGFuZCByb3RhdGUgdGhhdCBib2R5LiBTZWUgdGhlIGRlbW9zLlxuICAgICAgICAgICAgICogQGNsYXNzIFBsYW5lXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFNoYXBlXG4gICAgICAgICAgICAgKiBAYXV0aG9yIHNjaHRlcHBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFBsYW5lKCkge1xuICAgICAgICAgICAgICAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuUExBTkU7XG5cbiAgICAgICAgICAgICAgICAvLyBXb3JsZCBvcmllbnRlZCBub3JtYWxcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQbGFuZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbiAgICAgICAgICAgIFBsYW5lLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lO1xuXG4gICAgICAgICAgICBQbGFuZS5wcm90b3R5cGUuY29tcHV0ZVdvcmxkTm9ybWFsID0gZnVuY3Rpb24gKHF1YXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHRoaXMud29ybGROb3JtYWw7XG4gICAgICAgICAgICAgICAgbi5zZXQoMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgcXVhdC52bXVsdChuLCBuKTtcbiAgICAgICAgICAgICAgICB0aGlzLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFBsYW5lLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbiAobWFzcywgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFBsYW5lLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7IC8vIFRoZSBwbGFuZSBpcyBpbmZpbml0ZS4uLlxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRlbXBOb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgUGxhbmUucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uIChwb3MsIHF1YXQsIG1pbiwgbWF4KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHBsYW5lIEFBQkIgaXMgaW5maW5pdGUsIGV4Y2VwdCBpZiB0aGUgbm9ybWFsIGlzIHBvaW50aW5nIGFsb25nIGFueSBheGlzXG4gICAgICAgICAgICAgICAgdGVtcE5vcm1hbC5zZXQoMCwgMCwgMSk7IC8vIERlZmF1bHQgcGxhbmUgbm9ybWFsIGlzIHpcbiAgICAgICAgICAgICAgICBxdWF0LnZtdWx0KHRlbXBOb3JtYWwsIHRlbXBOb3JtYWwpO1xuICAgICAgICAgICAgICAgIHZhciBtYXhWYWwgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgICAgIG1pbi5zZXQoLW1heFZhbCwgLW1heFZhbCwgLW1heFZhbCk7XG4gICAgICAgICAgICAgICAgbWF4LnNldChtYXhWYWwsIG1heFZhbCwgbWF4VmFsKTtcblxuICAgICAgICAgICAgICAgIGlmICh0ZW1wTm9ybWFsLnggPT09IDEpIHsgbWF4LnggPSBwb3MueDsgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wTm9ybWFsLnkgPT09IDEpIHsgbWF4LnkgPSBwb3MueTsgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wTm9ybWFsLnogPT09IDEpIHsgbWF4LnogPSBwb3MuejsgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRlbXBOb3JtYWwueCA9PT0gLTEpIHsgbWluLnggPSBwb3MueDsgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wTm9ybWFsLnkgPT09IC0xKSB7IG1pbi55ID0gcG9zLnk7IH1cbiAgICAgICAgICAgICAgICBpZiAodGVtcE5vcm1hbC56ID09PSAtMSkgeyBtaW4ueiA9IHBvcy56OyB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBQbGFuZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7IFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4vU2hhcGVcIjogNDMgfV0sIDQzOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcblxuICAgICAgICAgICAgdmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbiAgICAgICAgICAgIHZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG4gICAgICAgICAgICB2YXIgTWF0ZXJpYWwgPSBfZGVyZXFfKCcuLi9tYXRlcmlhbC9NYXRlcmlhbCcpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJhc2UgY2xhc3MgZm9yIHNoYXBlc1xuICAgICAgICAgICAgICogQGNsYXNzIFNoYXBlXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGVcbiAgICAgICAgICAgICAqIEB0b2RvIFNob3VsZCBoYXZlIGEgbWVjaGFuaXNtIGZvciBjYWNoaW5nIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMgaW5zdGVhZCBvZiBjYWxjdWxhdGluZyBpdCBlYWNoIHRpbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gU2hhcGUoKSB7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZGVudGlmeWVyIG9mIHRoZSBTaGFwZS5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaWRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmlkID0gU2hhcGUuaWRDb3VudGVyKys7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBNdXN0IGJlIHNldCB0byBhbiBpbnQgPiAwIGJ5IHN1YmNsYXNzZXMuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICAgICAqIEBzZWUgU2hhcGUudHlwZXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhlIGxvY2FsIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMgb2YgdGhpcyBzaGFwZS5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdTcGhlcmVSYWRpdXNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gMDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBtYXRlcmlhbFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgU2hhcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGU7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMuIFRoZSByZXN1bHQgaXMgc3RvcmVkIGluIHRoZSBwcm9wZXJ0eSAuYm91bmRpbmdTcGhlcmVSYWRpdXNcbiAgICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXNcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU2hhcGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiY29tcHV0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiICsgdGhpcy50eXBlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHZvbHVtZSBvZiB0aGlzIHNoYXBlXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHZvbHVtZVxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTaGFwZS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRocm93IFwidm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiICsgdGhpcy50eXBlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBpbmVydGlhIGluIHRoZSBsb2NhbCBmcmFtZSBmb3IgdGhpcyBzaGFwZS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtWZWMzfVxuICAgICAgICAgICAgICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNoYXBlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbiAobWFzcywgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJjYWxjdWxhdGVMb2NhbEluZXJ0aWEoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHNoYXBlIHR5cGUgXCIgKyB0aGlzLnR5cGU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTaGFwZS5pZENvdW50ZXIgPSAwO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSBhdmFpbGFibGUgc2hhcGUgdHlwZXMuXG4gICAgICAgICAgICAgKiBAc3RhdGljXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkgdHlwZXNcbiAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNoYXBlLnR5cGVzID0ge1xuICAgICAgICAgICAgICAgIFNQSEVSRTogMSxcbiAgICAgICAgICAgICAgICBQTEFORTogMixcbiAgICAgICAgICAgICAgICBCT1g6IDQsXG4gICAgICAgICAgICAgICAgQ09NUE9VTkQ6IDgsXG4gICAgICAgICAgICAgICAgQ09OVkVYUE9MWUhFRFJPTjogMTYsXG4gICAgICAgICAgICAgICAgSEVJR0hURklFTEQ6IDMyLFxuICAgICAgICAgICAgICAgIFBBUlRJQ0xFOiA2NCxcbiAgICAgICAgICAgICAgICBDWUxJTkRFUjogMTI4LFxuICAgICAgICAgICAgICAgIFRSSU1FU0g6IDI1NlxuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgIH0sIHsgXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOiAyNSwgXCIuLi9tYXRoL1F1YXRlcm5pb25cIjogMjgsIFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4vU2hhcGVcIjogNDMgfV0sIDQ0OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBTcGhlcmU7XG5cbiAgICAgICAgICAgIHZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3BoZXJpY2FsIHNoYXBlXG4gICAgICAgICAgICAgKiBAY2xhc3MgU3BoZXJlXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFNoYXBlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gcmFkaXVzIFRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZSwgYSBub24tbmVnYXRpdmUgbnVtYmVyLlxuICAgICAgICAgICAgICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHA6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNwaGVyZShyYWRpdXMpIHtcbiAgICAgICAgICAgICAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHJhZGl1c1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzICE9PSB1bmRlZmluZWQgPyBOdW1iZXIocmFkaXVzKSA6IDEuMDtcbiAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5TUEhFUkU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yYWRpdXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwaGVyZSByYWRpdXMgY2Fubm90IGJlIG5lZ2F0aXZlLicpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNwaGVyZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcbiAgICAgICAgICAgIFNwaGVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmU7XG5cbiAgICAgICAgICAgIFNwaGVyZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24gKG1hc3MsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHZhciBJID0gMi4wICogbWFzcyAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgLyA1LjA7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnggPSBJO1xuICAgICAgICAgICAgICAgIHRhcmdldC55ID0gSTtcbiAgICAgICAgICAgICAgICB0YXJnZXQueiA9IEk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNwaGVyZS5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5yYWRpdXMgLyAzLjA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBTcGhlcmUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLnJhZGl1cztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIFNwaGVyZS5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24gKHBvcywgcXVhdCwgbWluLCBtYXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMucmFkaXVzO1xuICAgICAgICAgICAgICAgIHZhciBheGVzID0gWyd4JywgJ3knLCAneiddO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXggPSBheGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBtaW5bYXhdID0gcG9zW2F4XSAtIHI7XG4gICAgICAgICAgICAgICAgICAgIG1heFtheF0gPSBwb3NbYXhdICsgcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0sIHsgXCIuLi9tYXRoL1ZlYzNcIjogMzAsIFwiLi9TaGFwZVwiOiA0MyB9XSwgNDU6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFRyaW1lc2g7XG5cbiAgICAgICAgICAgIHZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xuICAgICAgICAgICAgdmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4uL21hdGgvVHJhbnNmb3JtJyk7XG4gICAgICAgICAgICB2YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG4gICAgICAgICAgICB2YXIgT2N0cmVlID0gX2RlcmVxXygnLi4vdXRpbHMvT2N0cmVlJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNsYXNzIFRyaW1lc2hcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHBhcmFtIHthcnJheX0gdmVydGljZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluZGljZXNcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFNoYXBlXG4gICAgICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgICAgICogICAgIC8vIEhvdyB0byBtYWtlIGEgbWVzaCB3aXRoIGEgc2luZ2xlIHRyaWFuZ2xlXG4gICAgICAgICAgICAgKiAgICAgdmFyIHZlcnRpY2VzID0gW1xuICAgICAgICAgICAgICogICAgICAgICAwLCAwLCAwLCAvLyB2ZXJ0ZXggMFxuICAgICAgICAgICAgICogICAgICAgICAxLCAwLCAwLCAvLyB2ZXJ0ZXggMVxuICAgICAgICAgICAgICogICAgICAgICAwLCAxLCAwICAvLyB2ZXJ0ZXggMlxuICAgICAgICAgICAgICogICAgIF07XG4gICAgICAgICAgICAgKiAgICAgdmFyIGluZGljZXMgPSBbXG4gICAgICAgICAgICAgKiAgICAgICAgIDAsIDEsIDIgIC8vIHRyaWFuZ2xlIDBcbiAgICAgICAgICAgICAqICAgICBdO1xuICAgICAgICAgICAgICogICAgIHZhciB0cmltZXNoU2hhcGUgPSBuZXcgVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcyk7XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFRyaW1lc2godmVydGljZXMsIGluZGljZXMpIHtcbiAgICAgICAgICAgICAgICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLlRSSU1FU0g7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQXJyYXkgb2YgaW50ZWdlcnMsIGluZGljYXRpbmcgd2hpY2ggdmVydGljZXMgZWFjaCB0cmlhbmdsZSBjb25zaXN0cyBvZi4gVGhlIGxlbmd0aCBvZiB0aGlzIGFycmF5IGlzIHRodXMgMyB0aW1lcyB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgaW5kaWNlc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmluZGljZXMgPSBuZXcgSW50MTZBcnJheShpbmRpY2VzKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBub3JtYWxzIGRhdGEuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IG5vcm1hbHNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgbG9jYWwgQUFCQiBvZiB0aGUgbWVzaC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUmVmZXJlbmNlcyB0byB2ZXJ0ZXggcGFpcnMsIG1ha2luZyB1cCBhbGwgdW5pcXVlIGVkZ2VzIGluIHRoZSB0cmltZXNoLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGVkZ2VzXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5lZGdlcyA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBMb2NhbCBzY2FsaW5nIG9mIHRoZSBtZXNoLiBVc2UgLnNldFNjYWxlKCkgdG8gc2V0IGl0LlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gc2NhbGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNjYWxlID0gbmV3IFZlYzMoMSwgMSwgMSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgaW5kZXhlZCB0cmlhbmdsZXMuIFVzZSAudXBkYXRlVHJlZSgpIHRvIHVwZGF0ZSBpdC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09jdHJlZX0gdHJlZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudHJlZSA9IG5ldyBPY3RyZWUoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWRnZXMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBUcmltZXNoLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmltZXNoO1xuXG4gICAgICAgICAgICB2YXIgY29tcHV0ZU5vcm1hbHNfbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVUcmVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZVRyZWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyZWUgPSB0aGlzLnRyZWU7XG5cbiAgICAgICAgICAgICAgICB0cmVlLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgdHJlZS5hYWJiLmNvcHkodGhpcy5hYWJiKTtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlOyAvLyBUaGUgbG9jYWwgbWVzaCBBQUJCIGlzIHNjYWxlZCwgYnV0IHRoZSBvY3RyZWUgQUFCQiBzaG91bGQgYmUgdW5zY2FsZWRcbiAgICAgICAgICAgICAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54O1xuICAgICAgICAgICAgICAgIHRyZWUuYWFiYi5sb3dlckJvdW5kLnkgKj0gMSAvIHNjYWxlLnk7XG4gICAgICAgICAgICAgICAgdHJlZS5hYWJiLmxvd2VyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcbiAgICAgICAgICAgICAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC54ICo9IDEgLyBzY2FsZS54O1xuICAgICAgICAgICAgICAgIHRyZWUuYWFiYi51cHBlckJvdW5kLnkgKj0gMSAvIHNjYWxlLnk7XG4gICAgICAgICAgICAgICAgdHJlZS5hYWJiLnVwcGVyQm91bmQueiAqPSAxIC8gc2NhbGUuejtcblxuICAgICAgICAgICAgICAgIC8vIEluc2VydCBhbGwgdHJpYW5nbGVzXG4gICAgICAgICAgICAgICAgdmFyIHRyaWFuZ2xlQUFCQiA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIHZhciBiID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICB2YXIgYyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFthLCBiLCBjXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5kaWNlcy5sZW5ndGggLyAzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgYSwgYiwgYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHVuc2NhbGVkIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0aGlzLmluZGljZXNbaTNdLCBhKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMV0sIGIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleCh0aGlzLmluZGljZXNbaTMgKyAyXSwgYyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJpYW5nbGVBQUJCLnNldEZyb21Qb2ludHMocG9pbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJlZS5pbnNlcnQodHJpYW5nbGVBQUJCLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJlZS5yZW1vdmVFbXB0eU5vZGVzKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgdW5zY2FsZWRBQUJCID0gbmV3IEFBQkIoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdHJpYW5nbGVzIGluIGEgbG9jYWwgQUFCQiBmcm9tIHRoZSB0cmltZXNoLlxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRUcmlhbmdsZXNJbkFBQkJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgb2YgaW50ZWdlcnMsIHJlZmVyZW5jaW5nIHRoZSBxdWVyaWVkIHRyaWFuZ2xlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUuZ2V0VHJpYW5nbGVzSW5BQUJCID0gZnVuY3Rpb24gKGFhYmIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHVuc2NhbGVkQUFCQi5jb3B5KGFhYmIpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2NhbGUgaXQgdG8gbG9jYWxcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgICAgICAgICAgICAgIHZhciBpc3ggPSBzY2FsZS54O1xuICAgICAgICAgICAgICAgIHZhciBpc3kgPSBzY2FsZS55O1xuICAgICAgICAgICAgICAgIHZhciBpc3ogPSBzY2FsZS56O1xuICAgICAgICAgICAgICAgIHZhciBsID0gdW5zY2FsZWRBQUJCLmxvd2VyQm91bmQ7XG4gICAgICAgICAgICAgICAgdmFyIHUgPSB1bnNjYWxlZEFBQkIudXBwZXJCb3VuZDtcbiAgICAgICAgICAgICAgICBsLnggLz0gaXN4O1xuICAgICAgICAgICAgICAgIGwueSAvPSBpc3k7XG4gICAgICAgICAgICAgICAgbC56IC89IGlzejtcbiAgICAgICAgICAgICAgICB1LnggLz0gaXN4O1xuICAgICAgICAgICAgICAgIHUueSAvPSBpc3k7XG4gICAgICAgICAgICAgICAgdS56IC89IGlzejtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWUuYWFiYlF1ZXJ5KHVuc2NhbGVkQUFCQiwgcmVzdWx0KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBzZXRTY2FsZVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSBzY2FsZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmltZXNoLnByb3RvdHlwZS5zZXRTY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgICAgICAgICAgIHZhciB3YXNVbmlmb3JtID0gdGhpcy5zY2FsZS54ID09PSB0aGlzLnNjYWxlLnkgPT09IHRoaXMuc2NhbGUuejtcbiAgICAgICAgICAgICAgICB2YXIgaXNVbmlmb3JtID0gc2NhbGUueCA9PT0gc2NhbGUueSA9PT0gc2NhbGUuejtcblxuICAgICAgICAgICAgICAgIGlmICghKHdhc1VuaWZvcm0gJiYgaXNVbmlmb3JtKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb24tdW5pZm9ybSBzY2FsaW5nLiBOZWVkIHRvIHVwZGF0ZSBub3JtYWxzLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FsZS5jb3B5KHNjYWxlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbXB1dGUgdGhlIG5vcm1hbHMgb2YgdGhlIGZhY2VzLiBXaWxsIHNhdmUgaW4gdGhlIC5ub3JtYWxzIGFycmF5LlxuICAgICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVOb3JtYWxzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZU5vcm1hbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSBjb21wdXRlTm9ybWFsc19uO1xuXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgbm9ybWFsc1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxzID0gdGhpcy5ub3JtYWxzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTMgPSBpICogMztcblxuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHRoaXMuaW5kaWNlc1tpM10sXG4gICAgICAgICAgICAgICAgICAgICAgICBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5pbmRpY2VzW2kzICsgMl07XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYSwgdmEpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFZlcnRleChiLCB2Yik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmVydGV4KGMsIHZjKTtcblxuICAgICAgICAgICAgICAgICAgICBUcmltZXNoLmNvbXB1dGVOb3JtYWwodmIsIHZhLCB2Yywgbik7XG5cbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1tpM10gPSBuLng7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbHNbaTMgKyAxXSA9IG4ueTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsc1tpMyArIDJdID0gbi56O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSAuZWRnZXMgcHJvcGVydHlcbiAgICAgICAgICAgICAqIEBtZXRob2QgdXBkYXRlRWRnZXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUudXBkYXRlRWRnZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkZ2VzID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uIChpbmRleEEsIGluZGV4Qikge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gYSA8IGIgPyBhICsgJ18nICsgYiA6IGIgKyAnXycgKyBhO1xuICAgICAgICAgICAgICAgICAgICBlZGdlc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTMgPSBpICogMztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSB0aGlzLmluZGljZXNbaTNdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYiA9IHRoaXMuaW5kaWNlc1tpMyArIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdO1xuICAgICAgICAgICAgICAgICAgICBhZGQoYSwgYik7XG4gICAgICAgICAgICAgICAgICAgIGFkZChiLCBjKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkKGMsIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGVkZ2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VzID0gbmV3IEludDE2QXJyYXkoa2V5cy5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluZGljZXMgPSBrZXlzW2ldLnNwbGl0KCdfJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZXNbMiAqIGldID0gcGFyc2VJbnQoaW5kaWNlc1swXSwgMTApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkZ2VzWzIgKiBpICsgMV0gPSBwYXJzZUludChpbmRpY2VzWzFdLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYW4gZWRnZSB2ZXJ0ZXhcbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0RWRnZVZlcnRleFxuICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBlZGdlSW5kZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gZmlyc3RPclNlY29uZCAwIG9yIDEsIGRlcGVuZGluZyBvbiB3aGljaCBvbmUgb2YgdGhlIHZlcnRpY2VzIHlvdSBuZWVkLlxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gdmVydGV4U3RvcmUgV2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmltZXNoLnByb3RvdHlwZS5nZXRFZGdlVmVydGV4ID0gZnVuY3Rpb24gKGVkZ2VJbmRleCwgZmlyc3RPclNlY29uZCwgdmVydGV4U3RvcmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmVydGV4SW5kZXggPSB0aGlzLmVkZ2VzW2VkZ2VJbmRleCAqIDIgKyAoZmlyc3RPclNlY29uZCA/IDEgOiAwKV07XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRWZXJ0ZXgodmVydGV4SW5kZXgsIHZlcnRleFN0b3JlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBnZXRFZGdlVmVjdG9yX3ZhID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBnZXRFZGdlVmVjdG9yX3ZiID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0RWRnZVZlY3RvclxuICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBlZGdlSW5kZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHZlY3RvclN0b3JlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZWN0b3IgPSBmdW5jdGlvbiAoZWRnZUluZGV4LCB2ZWN0b3JTdG9yZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YSA9IGdldEVkZ2VWZWN0b3JfdmE7XG4gICAgICAgICAgICAgICAgdmFyIHZiID0gZ2V0RWRnZVZlY3Rvcl92YjtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEVkZ2VWZXJ0ZXgoZWRnZUluZGV4LCAwLCB2YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMSwgdmIpO1xuICAgICAgICAgICAgICAgIHZiLnZzdWIodmEsIHZlY3RvclN0b3JlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGZhY2Ugbm9ybWFsIGdpdmVuIDMgdmVydGljZXNcbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbFxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB2YVxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB2YlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB2Y1xuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSB0YXJnZXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGNiID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBhYiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICBUcmltZXNoLmNvbXB1dGVOb3JtYWwgPSBmdW5jdGlvbiAodmEsIHZiLCB2YywgdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmIudnN1Yih2YSwgYWIpO1xuICAgICAgICAgICAgICAgIHZjLnZzdWIodmIsIGNiKTtcbiAgICAgICAgICAgICAgICBjYi5jcm9zcyhhYiwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHZhID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciB2YiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdmMgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB2ZXJ0ZXggaS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0VmVydGV4XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IG91dFxuICAgICAgICAgICAgICogQHJldHVybiB7VmVjM30gVGhlIFwib3V0XCIgdmVjdG9yIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmltZXNoLnByb3RvdHlwZS5nZXRWZXJ0ZXggPSBmdW5jdGlvbiAoaSwgb3V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleChpLCBvdXQpO1xuICAgICAgICAgICAgICAgIG91dC54ICo9IHNjYWxlLng7XG4gICAgICAgICAgICAgICAgb3V0LnkgKj0gc2NhbGUueTtcbiAgICAgICAgICAgICAgICBvdXQueiAqPSBzY2FsZS56O1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCByYXcgdmVydGV4IGlcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKiBAbWV0aG9kIF9nZXRVbnNjYWxlZFZlcnRleFxuICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSBvdXRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcIm91dFwiIHZlY3RvciBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUuX2dldFVuc2NhbGVkVmVydGV4ID0gZnVuY3Rpb24gKGksIG91dCkge1xuICAgICAgICAgICAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dC5zZXQoXG4gICAgICAgICAgICAgICAgICAgIHZlcnRpY2VzW2kzXSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbaTMgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgdmVydGljZXNbaTMgKyAyXVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIHZlcnRleCBmcm9tIHRoZSB0cmltZXNoLHRyYW5zZm9ybWVkIGJ5IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgcXVhdGVybmlvbi5cbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0V29ybGRWZXJ0ZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gaVxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gcG9zXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSBvdXRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcIm91dFwiIHZlY3RvciBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUuZ2V0V29ybGRWZXJ0ZXggPSBmdW5jdGlvbiAoaSwgcG9zLCBxdWF0LCBvdXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFZlcnRleChpLCBvdXQpO1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3MsIHF1YXQsIG91dCwgb3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHRocmVlIHZlcnRpY2VzIGZvciB0cmlhbmdsZSBpLlxuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRUcmlhbmdsZVZlcnRpY2VzXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGFcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUuZ2V0VHJpYW5nbGVWZXJ0aWNlcyA9IGZ1bmN0aW9uIChpLCBhLCBiLCBjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkzID0gaSAqIDM7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMV0sIGIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDJdLCBjKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGdldE5vcm1hbFxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInRhcmdldFwiIHZlY3RvciBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUuZ2V0Tm9ybWFsID0gZnVuY3Rpb24gKGksIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2V0KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHNbaTNdLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vcm1hbHNbaTMgKyAxXSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3JtYWxzW2kzICsgMl1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGNsaV9hYWJiID0gbmV3IEFBQkIoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAgICAgICAgICAgICAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInRhcmdldFwiIHZlY3RvciBvYmplY3RcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24gKG1hc3MsIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIEFwcHJveGltYXRlIHdpdGggYm94IGluZXJ0aWFcbiAgICAgICAgICAgICAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmIpO1xuICAgICAgICAgICAgICAgIHZhciB4ID0gY2xpX2FhYmIudXBwZXJCb3VuZC54IC0gY2xpX2FhYmIubG93ZXJCb3VuZC54LFxuICAgICAgICAgICAgICAgICAgICB5ID0gY2xpX2FhYmIudXBwZXJCb3VuZC55IC0gY2xpX2FhYmIubG93ZXJCb3VuZC55LFxuICAgICAgICAgICAgICAgICAgICB6ID0gY2xpX2FhYmIudXBwZXJCb3VuZC56IC0gY2xpX2FhYmIubG93ZXJCb3VuZC56O1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuc2V0KFxuICAgICAgICAgICAgICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICgyICogeSAqIDIgKiB5ICsgMiAqIHogKiAyICogeiksXG4gICAgICAgICAgICAgICAgICAgIDEuMCAvIDEyLjAgKiBtYXNzICogKDIgKiB4ICogMiAqIHggKyAyICogeiAqIDIgKiB6KSxcbiAgICAgICAgICAgICAgICAgICAgMS4wIC8gMTIuMCAqIG1hc3MgKiAoMiAqIHkgKiAyICogeSArIDIgKiB4ICogMiAqIHgpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcHV0ZSB0aGUgbG9jYWwgQUFCQiBmb3IgdGhlIHRyaW1lc2hcbiAgICAgICAgICAgICAqIEBtZXRob2QgY29tcHV0ZUxvY2FsQUFCQlxuICAgICAgICAgICAgICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmltZXNoLnByb3RvdHlwZS5jb21wdXRlTG9jYWxBQUJCID0gZnVuY3Rpb24gKGFhYmIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGFhYmIubG93ZXJCb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgdSA9IGFhYmIudXBwZXJCb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgICAgICAgICAgICAgIHYgPSBjb21wdXRlTG9jYWxBQUJCX3dvcmxkVmVydDtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmVydGV4KDAsIHYpO1xuICAgICAgICAgICAgICAgIGwuY29weSh2KTtcbiAgICAgICAgICAgICAgICB1LmNvcHkodik7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmVydGV4KGksIHYpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2LnggPCBsLngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwueCA9IHYueDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnggPiB1LngpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUueCA9IHYueDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2LnkgPCBsLnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwueSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnkgPiB1LnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUueSA9IHYueTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh2LnogPCBsLnopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGwueiA9IHYuejtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2LnogPiB1LnopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHUueiA9IHYuejtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIC5hYWJiIHByb3BlcnR5XG4gICAgICAgICAgICAgKiBAbWV0aG9kIHVwZGF0ZUFBQkJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVHJpbWVzaC5wcm90b3R5cGUudXBkYXRlQUFCQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIodGhpcy5hYWJiKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2lsbCB1cGRhdGUgdGhlIC5ib3VuZGluZ1NwaGVyZVJhZGl1cyBwcm9wZXJ0eVxuICAgICAgICAgICAgICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmltZXNoLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBBc3N1bWUgcG9pbnRzIGFyZSBkaXN0cmlidXRlZCB3aXRoIGxvY2FsICgwLDAsMCkgYXMgY2VudGVyXG4gICAgICAgICAgICAgICAgdmFyIG1heDIgPSAwO1xuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBOID0gdmVydGljZXMubGVuZ3RoIC8gMzsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmVydGV4KGksIHYpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybTIgPSB2Lm5vcm0yKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3JtMiA+IG1heDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heDIgPSBub3JtMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTWF0aC5zcXJ0KG1heDIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRlbXBXb3JsZFZlcnRleCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgY2FsY3VsYXRlV29ybGRBQUJCX2ZyYW1lID0gbmV3IFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgdmFyIGNhbGN1bGF0ZVdvcmxkQUFCQl9hYWJiID0gbmV3IEFBQkIoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNhbGN1bGF0ZVdvcmxkQUFCQlxuICAgICAgICAgICAgICogQHBhcmFtIHtWZWMzfSAgICAgICAgcG9zXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1F1YXRlcm5pb259ICBxdWF0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtaW5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1heFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmltZXNoLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbiAocG9zLCBxdWF0LCBtaW4sIG1heCkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDMsXG4gICAgICAgICAgICAgICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICAgICAgICAgICAgICB2YXIgbWlueCxtaW55LG1pbnosbWF4eCxtYXh5LG1heHo7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgdiA9IHRlbXBXb3JsZFZlcnRleDtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcbiAgICAgICAgICAgICAgICAgICAgcXVhdC52bXVsdCh2LCB2KTtcbiAgICAgICAgICAgICAgICAgICAgcG9zLnZhZGQodiwgdik7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWlueCA9IHYueDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHYueCA+IG1heHggfHwgbWF4eD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXh4ID0gdi54O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW55ID0gdi55O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodi55ID4gbWF4eSB8fCBtYXh5PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heHkgPSB2Lnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAodi56IDwgbWlueiB8fCBtaW56PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbnogPSB2Lno7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih2LnogPiBtYXh6IHx8IG1heHo9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4eiA9IHYuejtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTtcbiAgICAgICAgICAgICAgICBtYXguc2V0KG1heHgsbWF4eSxtYXh6KTtcbiAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQlxuICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlV29ybGRBQUJCX2FhYmI7XG4gICAgICAgICAgICAgICAgZnJhbWUucG9zaXRpb24gPSBwb3M7XG4gICAgICAgICAgICAgICAgZnJhbWUucXVhdGVybmlvbiA9IHF1YXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiLnRvV29ybGRGcmFtZShmcmFtZSwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICBtaW4uY29weShyZXN1bHQubG93ZXJCb3VuZCk7XG4gICAgICAgICAgICAgICAgbWF4LmNvcHkocmVzdWx0LnVwcGVyQm91bmQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYXBwcm94aW1hdGUgdm9sdW1lXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHZvbHVtZVxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUcmltZXNoLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzIC8gMy4wO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSBUcmltZXNoIGluc3RhbmNlLCBzaGFwZWQgYXMgYSB0b3J1cy5cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBtZXRob2QgY3JlYXRlVG9ydXNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW3JhZGl1cz0xXVxuICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBbdHViZT0wLjVdXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFtyYWRpYWxTZWdtZW50cz04XVxuICAgICAgICAgICAgICogQHBhcmFtICB7bnVtYmVyfSBbdHVidWxhclNlZ21lbnRzPTZdXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFthcmM9Ni4yODMxODUzMDcxNzk1ODZdXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtUcmltZXNofSBBIHRvcnVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFRyaW1lc2guY3JlYXRlVG9ydXMgPSBmdW5jdGlvbiAocmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMpIHtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSByYWRpdXMgfHwgMTtcbiAgICAgICAgICAgICAgICB0dWJlID0gdHViZSB8fCAwLjU7XG4gICAgICAgICAgICAgICAgcmFkaWFsU2VnbWVudHMgPSByYWRpYWxTZWdtZW50cyB8fCA4O1xuICAgICAgICAgICAgICAgIHR1YnVsYXJTZWdtZW50cyA9IHR1YnVsYXJTZWdtZW50cyB8fCA2O1xuICAgICAgICAgICAgICAgIGFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcblxuICAgICAgICAgICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSByYWRpYWxTZWdtZW50czsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBhcmM7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeCA9IChyYWRpdXMgKyB0dWJlICogTWF0aC5jb3ModikpICogTWF0aC5jb3ModSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IChyYWRpdXMgKyB0dWJlICogTWF0aC5jb3ModikpICogTWF0aC5zaW4odSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeiA9IHR1YmUgKiBNYXRoLnNpbih2KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmVydGljZXMucHVzaCh4LCB5LCB6KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gKHR1YnVsYXJTZWdtZW50cyArIDEpICogaiArIGkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiAoaiAtIDEpICsgaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9ICh0dWJ1bGFyU2VnbWVudHMgKyAxKSAqIChqIC0gMSkgKyBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSAodHVidWxhclNlZ21lbnRzICsgMSkgKiBqICsgaTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGEsIGIsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmltZXNoKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4uL2NvbGxpc2lvbi9BQUJCXCI6IDMsIFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6IDI4LCBcIi4uL21hdGgvVHJhbnNmb3JtXCI6IDI5LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi91dGlscy9PY3RyZWVcIjogNTAsIFwiLi9TaGFwZVwiOiA0MyB9XSwgNDY6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IEdTU29sdmVyO1xuXG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbiAgICAgICAgICAgIHZhciBTb2x2ZXIgPSBfZGVyZXFfKCcuL1NvbHZlcicpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cmFpbnQgZXF1YXRpb24gR2F1c3MtU2VpZGVsIHNvbHZlci5cbiAgICAgICAgICAgICAqIEBjbGFzcyBHU1NvbHZlclxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAdG9kbyBUaGUgc3Bvb2sgcGFyYW1ldGVycyBzaG91bGQgYmUgc3BlY2lmaWVkIGZvciBlYWNoIGNvbnN0cmFpbnQsIG5vdCBnbG9iYWxseS5cbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAgICAgICAgICAgICAqIEBzZWUgaHR0cHM6Ly93d3c4LmNzLnVtdS5zZS9rdXJzZXIvNURWMDU4L1ZUMDkvbGVjdHVyZXMvc3Bvb2tub3Rlcy5wZGZcbiAgICAgICAgICAgICAqIEBleHRlbmRzIFNvbHZlclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBHU1NvbHZlcigpIHtcbiAgICAgICAgICAgICAgICBTb2x2ZXIuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuIFRoZSBtb3JlIGl0ZXJhdGlvbnMsIHRoZSBtb3JlIGNvcnJlY3Qgc2ltdWxhdGlvbi4gTW9yZSBpdGVyYXRpb25zIG5lZWQgbW9yZSBjb21wdXRhdGlvbnMgdGhvdWdoLiBJZiB5b3UgaGF2ZSBhIGxhcmdlIGdyYXZpdHkgZm9yY2UgaW4geW91ciB3b3JsZCwgeW91IHdpbGwgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGl0ZXJhdGlvbnNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICAgICAqIEB0b2RvIHdyaXRlIG1vcmUgYWJvdXQgc29sdmVyIGFuZCBpdGVyYXRpb25zIGluIHRoZSB3aWtpXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5pdGVyYXRpb25zID0gMTA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBXaGVuIHRvbGVyYW5jZSBpcyByZWFjaGVkLCB0aGUgc3lzdGVtIGlzIGFzc3VtZWQgdG8gYmUgY29udmVyZ2VkLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB0b2xlcmFuY2VcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIEdTU29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcblxuICAgICAgICAgICAgdmFyIEdTU29sdmVyX3NvbHZlX2xhbWJkYSA9IFtdOyAvLyBKdXN0IHRlbXBvcmFyeSBudW1iZXIgaG9sZGVycyB0aGF0IHdlIHdhbnQgdG8gcmV1c2UgZWFjaCBzb2x2ZS5cbiAgICAgICAgICAgIHZhciBHU1NvbHZlcl9zb2x2ZV9pbnZDcyA9IFtdO1xuICAgICAgICAgICAgdmFyIEdTU29sdmVyX3NvbHZlX0JzID0gW107XG4gICAgICAgICAgICBHU1NvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAoZHQsIHdvcmxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXIgPSAwLFxuICAgICAgICAgICAgICAgICAgICBtYXhJdGVyID0gdGhpcy5pdGVyYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICB0b2xTcXVhcmVkID0gdGhpcy50b2xlcmFuY2UgKiB0aGlzLnRvbGVyYW5jZSxcbiAgICAgICAgICAgICAgICAgICAgZXF1YXRpb25zID0gdGhpcy5lcXVhdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIE5lcSA9IGVxdWF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcyxcbiAgICAgICAgICAgICAgICAgICAgTmJvZGllcyA9IGJvZGllcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIGggPSBkdCxcbiAgICAgICAgICAgICAgICAgICAgcSwgQiwgaW52QywgZGVsdGFsYW1iZGEsIGRlbHRhbGFtYmRhVG90LCBHV2xhbWJkYSwgbGFtYmRhajtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzb2x2ZSBtYXNzXG4gICAgICAgICAgICAgICAgaWYgKE5lcSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2RpZXNbaV0udXBkYXRlU29sdmVNYXNzUHJvcGVydGllcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVGhpbmdzIHRoYXQgZG9lcyBub3QgY2hhbmdlIGR1cmluZyBpdGVyYXRpb24gY2FuIGJlIGNvbXB1dGVkIG9uY2VcbiAgICAgICAgICAgICAgICB2YXIgaW52Q3MgPSBHU1NvbHZlcl9zb2x2ZV9pbnZDcyxcbiAgICAgICAgICAgICAgICAgICAgQnMgPSBHU1NvbHZlcl9zb2x2ZV9CcyxcbiAgICAgICAgICAgICAgICAgICAgbGFtYmRhID0gR1NTb2x2ZXJfc29sdmVfbGFtYmRhO1xuICAgICAgICAgICAgICAgIGludkNzLmxlbmd0aCA9IE5lcTtcbiAgICAgICAgICAgICAgICBCcy5sZW5ndGggPSBOZXE7XG4gICAgICAgICAgICAgICAgbGFtYmRhLmxlbmd0aCA9IE5lcTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmVxOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGMgPSBlcXVhdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgICAgIGxhbWJkYVtpXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgQnNbaV0gPSBjLmNvbXB1dGVCKGgpO1xuICAgICAgICAgICAgICAgICAgICBpbnZDc1tpXSA9IDEuMCAvIGMuY29tcHV0ZUMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoTmVxICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmJvZGllczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2bGFtYmRhID0gYi52bGFtYmRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdsYW1iZGEgPSBiLndsYW1iZGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2bGFtYmRhLnNldCgwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3bGFtYmRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2xhbWJkYS5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZXF1YXRpb25zXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaXRlciA9IDA7IGl0ZXIgIT09IG1heEl0ZXI7IGl0ZXIrKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IE5lcTsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQiA9IEJzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludkMgPSBpbnZDc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEdXbGFtYmRhID0gYy5jb21wdXRlR1dsYW1iZGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGludkMgKiAoQiAtIEdXbGFtYmRhIC0gYy5lcHMgKiBsYW1iZGFqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsYW1wIGlmIHdlIGFyZSBub3Qgd2l0aGluIHRoZSBtaW4vbWF4IGludGVydmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA8IGMubWluRm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGEgPSBjLm1pbkZvcmNlIC0gbGFtYmRhajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhbWJkYWogKyBkZWx0YWxhbWJkYSA+IGMubWF4Rm9yY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGEgPSBjLm1heEZvcmNlIC0gbGFtYmRhajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFtYmRhW2pdICs9IGRlbHRhbGFtYmRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGFUb3QgKz0gZGVsdGFsYW1iZGEgPiAwLjAgPyBkZWx0YWxhbWJkYSA6IC1kZWx0YWxhbWJkYTsgLy8gYWJzKGRlbHRhbGFtYmRhKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5hZGRUb1dsYW1iZGEoZGVsdGFsYW1iZGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdG90YWwgZXJyb3IgaXMgc21hbGwgZW5vdWdoIC0gc3RvcCBpdGVyYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsdGFsYW1iZGFUb3QgKiBkZWx0YWxhbWJkYVRvdCA8IHRvbFNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdiA9IGIudmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdyA9IGIuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdi52YWRkKGIudmxhbWJkYSwgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcudmFkZChiLndsYW1iZGEsIHcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZXI7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0sIHsgXCIuLi9tYXRoL1F1YXRlcm5pb25cIjogMjgsIFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4vU29sdmVyXCI6IDQ3IH1dLCA0NzogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gU29sdmVyO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyIGJhc2UgY2xhc3MuXG4gICAgICAgICAgICAgKiBAY2xhc3MgU29sdmVyXG4gICAgICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICAgICAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gU29sdmVyKCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEFsbCBlcXVhdGlvbnMgdG8gYmUgc29sdmVkXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gZXF1YXRpb25zXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTaG91bGQgYmUgaW1wbGVtZW50ZWQgaW4gc3ViY2xhc3NlcyFcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc29sdmVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTb2x2ZXIucHJvdG90eXBlLnNvbHZlID0gZnVuY3Rpb24gKGR0LCB3b3JsZCkge1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCByZXR1cm4gdGhlIG51bWJlciBvZiBpdGVyYXRpb25zIGRvbmUhXG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhbiBlcXVhdGlvblxuICAgICAgICAgICAgICogQG1ldGhvZCBhZGRFcXVhdGlvblxuICAgICAgICAgICAgICogQHBhcmFtIHtFcXVhdGlvbn0gZXFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgU29sdmVyLnByb3RvdHlwZS5hZGRFcXVhdGlvbiA9IGZ1bmN0aW9uIChlcSkge1xuICAgICAgICAgICAgICAgIGlmIChlcS5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIGFuIGVxdWF0aW9uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUVxdWF0aW9uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTb2x2ZXIucHJvdG90eXBlLnJlbW92ZUVxdWF0aW9uID0gZnVuY3Rpb24gKGVxKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgICAgICAgICAgICAgIHZhciBpID0gZXFzLmluZGV4T2YoZXEpO1xuICAgICAgICAgICAgICAgIGlmIChpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBlcXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGFsbCBlcXVhdGlvbnNcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlQWxsRXF1YXRpb25zXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFNvbHZlci5wcm90b3R5cGUucmVtb3ZlQWxsRXF1YXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXF1YXRpb25zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgfSwge31dLCA0ODogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gU3BsaXRTb2x2ZXI7XG5cbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xuICAgICAgICAgICAgdmFyIFNvbHZlciA9IF9kZXJlcV8oJy4vU29sdmVyJyk7XG4gICAgICAgICAgICB2YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNwbGl0cyB0aGUgZXF1YXRpb25zIGludG8gaXNsYW5kcyBhbmQgc29sdmVzIHRoZW0gaW5kZXBlbmRlbnRseS4gQ2FuIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgICAgICAgKiBAY2xhc3MgU3BsaXRTb2x2ZXJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQGV4dGVuZHMgU29sdmVyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge1NvbHZlcn0gc3Vic29sdmVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFNwbGl0U29sdmVyKHN1YnNvbHZlcikge1xuICAgICAgICAgICAgICAgIFNvbHZlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuaXRlcmF0aW9ucyA9IDEwO1xuICAgICAgICAgICAgICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNztcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNvbHZlciA9IHN1YnNvbHZlcjtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlUG9vbCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICB3aGlsZSAodGhpcy5ub2RlUG9vbC5sZW5ndGggPCAxMjgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBTcGxpdFNvbHZlci5wcm90b3R5cGUgPSBuZXcgU29sdmVyKCk7XG5cbiAgICAgICAgICAgIC8vIFJldHVybnMgdGhlIG51bWJlciBvZiBzdWJzeXN0ZW1zXG4gICAgICAgICAgICB2YXIgU3BsaXRTb2x2ZXJfc29sdmVfbm9kZXMgPSBbXTsgLy8gQWxsIGFsbG9jYXRlZCBub2RlIG9iamVjdHNcbiAgICAgICAgICAgIHZhciBTcGxpdFNvbHZlcl9zb2x2ZV9ub2RlUG9vbCA9IFtdOyAvLyBBbGwgYWxsb2NhdGVkIG5vZGUgb2JqZWN0c1xuICAgICAgICAgICAgdmFyIFNwbGl0U29sdmVyX3NvbHZlX2VxcyA9IFtdOyAgIC8vIFRlbXAgYXJyYXlcbiAgICAgICAgICAgIHZhciBTcGxpdFNvbHZlcl9zb2x2ZV9iZHMgPSBbXTsgICAvLyBUZW1wIGFycmF5XG4gICAgICAgICAgICB2YXIgU3BsaXRTb2x2ZXJfc29sdmVfZHVtbXlXb3JsZCA9IHsgYm9kaWVzOiBbXSB9OyAvLyBUZW1wIG9iamVjdFxuXG4gICAgICAgICAgICB2YXIgU1RBVElDID0gQm9keS5TVEFUSUM7XG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRVbnZpc2l0ZWROb2RlKG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIE5ub2RlcyA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTm5vZGVzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlLnZpc2l0ZWQgJiYgIShub2RlLmJvZHkudHlwZSAmIFNUQVRJQykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgICAgICBmdW5jdGlvbiBiZnMocm9vdCwgdmlzaXRGdW5jLCBiZHMsIGVxcykge1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocm9vdCk7XG4gICAgICAgICAgICAgICAgcm9vdC52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2aXNpdEZ1bmMocm9vdCwgYmRzLCBlcXMpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHVudmlzaXRlZCBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGUuY2hpbGRyZW4pKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQudmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpdEZ1bmMoY2hpbGQsIGJkcywgZXFzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB2aXNpdEZ1bmMobm9kZSwgYmRzLCBlcXMpIHtcbiAgICAgICAgICAgICAgICBiZHMucHVzaChub2RlLmJvZHkpO1xuICAgICAgICAgICAgICAgIHZhciBOZXFzID0gbm9kZS5lcXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSBOZXFzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVxID0gbm9kZS5lcXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcXMuaW5kZXhPZihlcSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcXMucHVzaChlcSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFNwbGl0U29sdmVyLnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGJvZHk6IG51bGwsIGNoaWxkcmVuOiBbXSwgZXFzOiBbXSwgdmlzaXRlZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU29sdmUgdGhlIHN1YnN5c3RlbXNcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc29sdmVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0gZHRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBTcGxpdFNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAoZHQsIHdvcmxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVzID0gU3BsaXRTb2x2ZXJfc29sdmVfbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVQb29sID0gdGhpcy5ub2RlUG9vbCxcbiAgICAgICAgICAgICAgICAgICAgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICAgICAgICAgICAgICBlcXVhdGlvbnMgPSB0aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgTmVxID0gZXF1YXRpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgTmJvZGllcyA9IGJvZGllcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHN1YnNvbHZlciA9IHRoaXMuc3Vic29sdmVyO1xuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcbiAgICAgICAgICAgICAgICB3aGlsZSAobm9kZVBvb2wubGVuZ3RoIDwgTmJvZGllcykge1xuICAgICAgICAgICAgICAgICAgICBub2RlUG9vbC5wdXNoKHRoaXMuY3JlYXRlTm9kZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZXMubGVuZ3RoID0gTmJvZGllcztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE5ib2RpZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1tpXSA9IG5vZGVQb29sW2ldO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IG5vZGUgdmFsdWVzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE5ib2RpZXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmJvZHkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5lcXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS52aXNpdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrICE9PSBOZXE7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXEgPSBlcXVhdGlvbnNba10sXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gYm9kaWVzLmluZGV4T2YoZXEuYmkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGJvZGllcy5pbmRleE9mKGVxLmJqKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5pID0gbm9kZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBuaiA9IG5vZGVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBuaS5jaGlsZHJlbi5wdXNoKG5qKTtcbiAgICAgICAgICAgICAgICAgICAgbmkuZXFzLnB1c2goZXEpO1xuICAgICAgICAgICAgICAgICAgICBuai5jaGlsZHJlbi5wdXNoKG5pKTtcbiAgICAgICAgICAgICAgICAgICAgbmouZXFzLnB1c2goZXEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCwgbiA9IDAsIGVxcyA9IFNwbGl0U29sdmVyX3NvbHZlX2VxcztcblxuICAgICAgICAgICAgICAgIHN1YnNvbHZlci50b2xlcmFuY2UgPSB0aGlzLnRvbGVyYW5jZTtcbiAgICAgICAgICAgICAgICBzdWJzb2x2ZXIuaXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9ucztcblxuICAgICAgICAgICAgICAgIHZhciBkdW1teVdvcmxkID0gU3BsaXRTb2x2ZXJfc29sdmVfZHVtbXlXb3JsZDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKGNoaWxkID0gZ2V0VW52aXNpdGVkTm9kZShub2RlcykpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVxcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBkdW1teVdvcmxkLmJvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBiZnMoY2hpbGQsIHZpc2l0RnVuYywgZHVtbXlXb3JsZC5ib2RpZXMsIGVxcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIE5lcXMgPSBlcXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGVxcyA9IGVxcy5zb3J0KHNvcnRCeUlkKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTmVxczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzb2x2ZXIuYWRkRXF1YXRpb24oZXFzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyID0gc3Vic29sdmVyLnNvbHZlKGR0LCBkdW1teVdvcmxkKTtcbiAgICAgICAgICAgICAgICAgICAgc3Vic29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICBuKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBzb3J0QnlJZChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGIuaWQgLSBhLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7IFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6IDI4LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi9vYmplY3RzL0JvZHlcIjogMzEsIFwiLi9Tb2x2ZXJcIjogNDcgfV0sIDQ5OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCYXNlIGNsYXNzIGZvciBvYmplY3RzIHRoYXQgZGlzcGF0Y2hlcyBldmVudHMuXG4gICAgICAgICAgICAgKiBAY2xhc3MgRXZlbnRUYXJnZXRcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgRXZlbnRUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG5cbiAgICAgICAgICAgIEV2ZW50VGFyZ2V0LnByb3RvdHlwZSA9IHtcbiAgICAgICAgICAgICAgICBjb25zdHJ1Y3RvcjogRXZlbnRUYXJnZXQsXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgKiBAbWV0aG9kIGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHR5cGVcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7IHRoaXMuX2xpc3RlbmVycyA9IHt9OyB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbdHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKSA9PT0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrIGlmIGFuIGV2ZW50IGxpc3RlbmVyIGlzIGFkZGVkXG4gICAgICAgICAgICAgICAgICogQG1ldGhvZCBoYXNFdmVudExpc3RlbmVyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBoYXNFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKSAhPT0gLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4ge0V2ZW50VGFyZ2V0fSBUaGUgc2VsZiBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyc1t0eXBlXSA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB0aGlzOyB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGxpc3RlbmVyc1t0eXBlXS5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1t0eXBlXS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgICAgICAgICAgICAgICAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcbiAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB0aGlzOyB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lckFycmF5ID0gbGlzdGVuZXJzW2V2ZW50LnR5cGVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyQXJyYXlbaV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7fV0sIDUwOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgdmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBPY3RyZWU7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNsYXNzIE9jdHJlZU5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2N0cmVlfSBbb3B0aW9ucy5yb290XVxuICAgICAgICAgICAgICogQHBhcmFtIHtBQUJCfSBbb3B0aW9ucy5hYWJiXVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBPY3RyZWVOb2RlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSByb290IG5vZGVcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge09jdHJlZU5vZGV9IHJvb3RcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QUFCQn0gYWFiYlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYWFiYiA9IG9wdGlvbnMuYWFiYiA/IG9wdGlvbnMuYWFiYi5jbG9uZSgpIDogbmV3IEFBQkIoKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvbnRhaW5lZCBkYXRhIGF0IHRoZSBjdXJyZW50IG5vZGUgbGV2ZWwuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gZGF0YVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hpbGRyZW4gdG8gdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNsYXNzIE9jdHJlZVxuICAgICAgICAgICAgICogQHBhcmFtIHtBQUJCfSBhYWJiIFRoZSB0b3RhbCBBQUJCIG9mIHRoZSB0cmVlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4RGVwdGg9OF1cbiAgICAgICAgICAgICAqIEBleHRlbmRzIE9jdHJlZU5vZGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gT2N0cmVlKGFhYmIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnJvb3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYWFiYiA9IGFhYmI7XG4gICAgICAgICAgICAgICAgT2N0cmVlTm9kZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTWF4aW11bSBzdWJkaXZpc2lvbiBkZXB0aFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhEZXB0aFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMubWF4RGVwdGggPSB0eXBlb2YgKG9wdGlvbnMubWF4RGVwdGgpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4RGVwdGggOiA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgT2N0cmVlLnByb3RvdHlwZSA9IG5ldyBPY3RyZWVOb2RlKCk7XG5cbiAgICAgICAgICAgIE9jdHJlZU5vZGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGFhYmIsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGggPSAwO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJbnNlcnQgZGF0YSBpbnRvIHRoaXMgbm9kZVxuICAgICAgICAgICAgICogQG1ldGhvZCBpbnNlcnRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAgICAgICAgICAgICAqIEBwYXJhbSAge29iamVjdH0gZWxlbWVudERhdGFcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE9jdHJlZU5vZGUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZURhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuXG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIG9iamVjdHMgdGhhdCBkbyBub3QgYmVsb25nIGluIHRoaXMgbm9kZVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5hYWJiLmNvbnRhaW5zKGFhYmIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb2JqZWN0IGNhbm5vdCBiZSBhZGRlZFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwgPCAodGhpcy5tYXhEZXB0aCB8fCB0aGlzLnJvb3QubWF4RGVwdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdWJkaXZpZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YmRpdmlkZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ViZGl2aWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdG8gd2hpY2hldmVyIG5vZGUgd2lsbCBhY2NlcHQgaXRcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmluc2VydChhYWJiLCBlbGVtZW50RGF0YSwgbGV2ZWwgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1YmRpdmlkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGNoaWxkcmVuIGFjY2VwdGVkISBNaWdodCBhcyB3ZWxsIGp1c3QgcmVtb3ZlIGVtIHNpbmNlIHRoZXkgY29udGFpbiBub25lXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVG9vIGRlZXAsIG9yIGNoaWxkcmVuIGRpZG50IHdhbnQgaXQuIGFkZCBpdCBpbiBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBub2RlRGF0YS5wdXNoKGVsZW1lbnREYXRhKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGhhbGZEaWFnb25hbCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIDggZXF1YWxseSBzaXplZCBjaGlsZHJlbiBub2RlcyBhbmQgcHV0IHRoZW0gaW4gdGhlIC5jaGlsZHJlbiBhcnJheS5cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc3ViZGl2aWRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE9jdHJlZU5vZGUucHJvdG90eXBlLnN1YmRpdmlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWFiYiA9IHRoaXMuYWFiYjtcbiAgICAgICAgICAgICAgICB2YXIgbCA9IGFhYmIubG93ZXJCb3VuZDtcbiAgICAgICAgICAgICAgICB2YXIgdSA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKFxuICAgICAgICAgICAgICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMCwgMCwgMCkgfSkgfSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygxLCAwLCAwKSB9KSB9KSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsIDEsIDApIH0pIH0pLFxuICAgICAgICAgICAgICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMSwgMSwgMSkgfSkgfSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLCAxLCAxKSB9KSB9KSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsIDAsIDEpIH0pIH0pLFxuICAgICAgICAgICAgICAgICAgICBuZXcgT2N0cmVlTm9kZSh7IGFhYmI6IG5ldyBBQUJCKHsgbG93ZXJCb3VuZDogbmV3IFZlYzMoMSwgMCwgMSkgfSkgfSksXG4gICAgICAgICAgICAgICAgICAgIG5ldyBPY3RyZWVOb2RlKHsgYWFiYjogbmV3IEFBQkIoeyBsb3dlckJvdW5kOiBuZXcgVmVjMygwLCAxLCAwKSB9KSB9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB1LnZzdWIobCwgaGFsZkRpYWdvbmFsKTtcbiAgICAgICAgICAgICAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QgfHwgdGhpcztcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnQgbm9kZSBhcyByb290XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLnJvb3QgPSByb290O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYm91bmRzXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb3dlckJvdW5kID0gY2hpbGQuYWFiYi5sb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgICAgICBsb3dlckJvdW5kLnggKj0gaGFsZkRpYWdvbmFsLng7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmQueSAqPSBoYWxmRGlhZ29uYWwueTtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJCb3VuZC56ICo9IGhhbGZEaWFnb25hbC56O1xuXG4gICAgICAgICAgICAgICAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcHBlciBib3VuZCBpcyBhbHdheXMgbG93ZXIgYm91bmQgKyBoYWxmRGlhZ29uYWxcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJCb3VuZC52YWRkKGhhbGZEaWFnb25hbCwgY2hpbGQuYWFiYi51cHBlckJvdW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgd2l0aGluIGFuIEFBQkJcbiAgICAgICAgICAgICAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHthcnJheX0gVGhlIFwicmVzdWx0XCIgb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE9jdHJlZU5vZGUucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uIChhYWJiLCByZXN1bHQpIHtcblxuICAgICAgICAgICAgICAgIHZhciBub2RlRGF0YSA9IHRoaXMuZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIGFib3J0IGlmIHRoZSByYW5nZSBkb2VzIG5vdCBpbnRlcnNlY3QgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgLy8gaWYgKCF0aGlzLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBvYmplY3RzIGF0IHRoaXMgbGV2ZWxcbiAgICAgICAgICAgICAgICAvLyBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGVEYXRhKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBjaGlsZCBkYXRhXG4gICAgICAgICAgICAgICAgLy8gQHRvZG8gdW53cmFwIHJlY3Vyc2lvbiBpbnRvIGEgcXVldWUgLyBsb29wLCB0aGF0J3MgZmFzdGVyIGluIEpTXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuXG4gICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAsIE4gPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNoaWxkcmVuW2ldLmFhYmJRdWVyeShhYWJiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgIHZhciBxdWV1ZSA9IFt0aGlzXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmFhYmIub3ZlcmxhcHMoYWFiYikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShxdWV1ZSwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgYWxsIGRhdGEsIHBvdGVudGlhbGx5IGludGVyc2VjdGVkIGJ5IGEgcmF5LlxuICAgICAgICAgICAgICogQG1ldGhvZCByYXlRdWVyeVxuICAgICAgICAgICAgICogQHBhcmFtICB7UmF5fSByYXlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1RyYW5zZm9ybX0gdHJlZVRyYW5zZm9ybVxuICAgICAgICAgICAgICogQHBhcmFtICB7YXJyYXl9IHJlc3VsdFxuICAgICAgICAgICAgICogQHJldHVybiB7YXJyYXl9IFRoZSBcInJlc3VsdFwiIG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPY3RyZWVOb2RlLnByb3RvdHlwZS5yYXlRdWVyeSA9IGZ1bmN0aW9uIChyYXksIHRyZWVUcmFuc2Zvcm0sIHJlc3VsdCkge1xuXG4gICAgICAgICAgICAgICAgLy8gVXNlIGFhYmIgcXVlcnkgZm9yIG5vdy5cbiAgICAgICAgICAgICAgICAvLyBAdG9kbyBpbXBsZW1lbnQgcmVhbCByYXkgcXVlcnkgd2hpY2ggbmVlZHMgbGVzcyBsb29rdXBzXG4gICAgICAgICAgICAgICAgcmF5LmdldEFBQkIodG1wQUFCQik7XG4gICAgICAgICAgICAgICAgdG1wQUFCQi50b0xvY2FsRnJhbWUodHJlZVRyYW5zZm9ybSwgdG1wQUFCQik7XG4gICAgICAgICAgICAgICAgdGhpcy5hYWJiUXVlcnkodG1wQUFCQiwgcmVzdWx0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVtb3ZlRW1wdHlOb2Rlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBPY3RyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmVFbXB0eU5vZGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBxdWV1ZSA9IFt0aGlzXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUuY2hpbGRyZW5baV0uZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShxdWV1ZSwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vY29sbGlzaW9uL0FBQkJcIjogMywgXCIuLi9tYXRoL1ZlYzNcIjogMzAgfV0sIDUxOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBQb29sO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBwb29saW5nIG9iamVjdHMgdGhhdCBjYW4gYmUgcmV1c2VkLlxuICAgICAgICAgICAgICogQGNsYXNzIFBvb2xcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBQb29sKCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBwb29sZWQgb2JqZWN0c1xuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9iamVjdHNcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm9iamVjdHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENvbnN0cnVjdG9yIG9mIHRoZSBvYmplY3RzXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHttaXhlZH0gdHlwZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IE9iamVjdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWxlYXNlIGFuIG9iamVjdCBhZnRlciB1c2VcbiAgICAgICAgICAgICAqIEBtZXRob2QgcmVsZWFzZVxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb29sLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBOYXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE5hcmdzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmplY3RzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbiBvYmplY3RcbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHttaXhlZH1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgUG9vbC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9iamVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdE9iamVjdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9iamVjdHMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb25zdHJ1Y3QgYW4gb2JqZWN0LiBTaG91bGQgYmUgaW1wbG1lbnRlZCBpbiBlYWNoIHN1YmNsYXNzLlxuICAgICAgICAgICAgICogQG1ldGhvZCBjb25zdHJ1Y3RPYmplY3RcbiAgICAgICAgICAgICAqIEByZXR1cm4ge21peGVkfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBQb29sLnByb3RvdHlwZS5jb25zdHJ1Y3RPYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29uc3RydWN0T2JqZWN0KCkgbm90IGltcGxlbWVudGVkIGluIHRoaXMgUG9vbCBzdWJjbGFzcyB5ZXQhXCIpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7fV0sIDUyOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBUdXBsZURpY3Rpb25hcnk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGNsYXNzIFR1cGxlRGljdGlvbmFyeVxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIFR1cGxlRGljdGlvbmFyeSgpIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBkYXRhIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgZGF0YVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0geyBrZXlzOiBbXSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge051bWJlcn0galxuICAgICAgICAgICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpLCBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiBqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN3YXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICAgICAgICAgICAgICBqID0gaTtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaSArICctJyArIGpdO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNldFxuICAgICAgICAgICAgICogQHBhcmFtICB7TnVtYmVyfSBpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpLCBqLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIGogPSBpO1xuICAgICAgICAgICAgICAgICAgICBpID0gdGVtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGkgKyAnLScgKyBqO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmdldChpLCBqKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGEua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCByZXNldFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBUdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBrZXlzID0gZGF0YS5rZXlzO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7fV0sIDUzOiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgZnVuY3Rpb24gVXRpbHMoKSB7IH1cblxuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBVdGlscztcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeHRlbmQgYW4gb3B0aW9ucyBvYmplY3Qgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICAgICAqIEBzdGF0aWNcbiAgICAgICAgICAgICAqIEBtZXRob2QgZGVmYXVsdHNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBvYmplY3QuIE1heSBiZSBmYWxzeTogaW4gdGhpcyBjYXNlLCBhIG5ldyBvYmplY3QgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtvYmplY3R9IGRlZmF1bHRzIEFuIG9iamVjdCBjb250YWluaW5nIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgbW9kaWZpZWQgb3B0aW9ucyBvYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFV0aWxzLmRlZmF1bHRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIGRlZmF1bHRzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zW2tleV0gPSBkZWZhdWx0c1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0sIHt9XSwgNTQ6IFtmdW5jdGlvbiAoX2RlcmVxXywgbW9kdWxlLCBleHBvcnRzKSB7XG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFZlYzNQb29sO1xuXG4gICAgICAgICAgICB2YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuICAgICAgICAgICAgdmFyIFBvb2wgPSBfZGVyZXFfKCcuL1Bvb2wnKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAY2xhc3MgVmVjM1Bvb2xcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQGV4dGVuZHMgUG9vbFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBWZWMzUG9vbCgpIHtcbiAgICAgICAgICAgICAgICBQb29sLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50eXBlID0gVmVjMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFZlYzNQb29sLnByb3RvdHlwZSA9IG5ldyBQb29sKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29uc3RydWN0IGEgdmVjdG9yXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvbnN0cnVjdE9iamVjdFxuICAgICAgICAgICAgICogQHJldHVybiB7VmVjM31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgVmVjM1Bvb2wucHJvdG90eXBlLmNvbnN0cnVjdE9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSwgeyBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuL1Bvb2xcIjogNTEgfV0sIDU1OiBbZnVuY3Rpb24gKF9kZXJlcV8sIG1vZHVsZSwgZXhwb3J0cykge1xuICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBOYXJyb3dwaGFzZTtcblxuICAgICAgICAgICAgdmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuICAgICAgICAgICAgdmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG4gICAgICAgICAgICB2YXIgUmF5ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheScpO1xuICAgICAgICAgICAgdmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbiAgICAgICAgICAgIHZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xuICAgICAgICAgICAgdmFyIENvbnZleFBvbHloZWRyb24gPSBfZGVyZXFfKCcuLi9zaGFwZXMvQ29udmV4UG9seWhlZHJvbicpO1xuICAgICAgICAgICAgdmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbiAgICAgICAgICAgIHZhciBTb2x2ZXIgPSBfZGVyZXFfKCcuLi9zb2x2ZXIvU29sdmVyJyk7XG4gICAgICAgICAgICB2YXIgVmVjM1Bvb2wgPSBfZGVyZXFfKCcuLi91dGlscy9WZWMzUG9vbCcpO1xuICAgICAgICAgICAgdmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbiAgICAgICAgICAgIHZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIZWxwZXIgY2xhc3MgZm9yIHRoZSBXb3JsZC4gR2VuZXJhdGVzIENvbnRhY3RFcXVhdGlvbnMuXG4gICAgICAgICAgICAgKiBAY2xhc3MgTmFycm93cGhhc2VcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICogQHRvZG8gU3BoZXJlLUNvbnZleFBvbHloZWRyb24gY29udGFjdHNcbiAgICAgICAgICAgICAqIEB0b2RvIENvbnRhY3QgcmVkdWN0aW9uXG4gICAgICAgICAgICAgKiBAdG9kbyAgc2hvdWxkIG1vdmUgbWV0aG9kcyB0byBwcm90b3R5cGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gTmFycm93cGhhc2Uod29ybGQpIHtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEludGVybmFsIHN0b3JhZ2Ugb2YgcG9vbGVkIGNvbnRhY3QgcG9pbnRzLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IGNvbnRhY3RQb2ludFBvb2xcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RQb2ludFBvb2wgPSBbXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBbXTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvblJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogUG9vbGVkIHZlY3RvcnMuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtWZWMzUG9vbH0gdjNwb29sXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy52M3Bvb2wgPSBuZXcgVmVjM1Bvb2woKTtcblxuICAgICAgICAgICAgICAgIHRoaXMud29ybGQgPSB3b3JsZDtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtCb29sZWFufSBlbmFibGVGcmljdGlvblJlZHVjdGlvblxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYWtlIGEgY29udGFjdCBvYmplY3QsIGJ5IHVzaW5nIHRoZSBpbnRlcm5hbCBwb29sIG9yIGNyZWF0aW5nIGEgbmV3IG9uZS5cbiAgICAgICAgICAgICAqIEBtZXRob2QgY3JlYXRlQ29udGFjdEVxdWF0aW9uXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtDb250YWN0RXF1YXRpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVDb250YWN0RXF1YXRpb24gPSBmdW5jdGlvbiAoYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29udGFjdFBvaW50UG9vbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IHRoaXMuY29udGFjdFBvaW50UG9vbC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgYy5iaSA9IGJpO1xuICAgICAgICAgICAgICAgICAgICBjLmJqID0gYmo7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYyA9IG5ldyBDb250YWN0RXF1YXRpb24oYmksIGJqKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcblxuICAgICAgICAgICAgICAgIHZhciBjbSA9IHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcblxuICAgICAgICAgICAgICAgIGMuc2V0U3Bvb2tQYXJhbXMoXG4gICAgICAgICAgICAgICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyxcbiAgICAgICAgICAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53b3JsZC5kdFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWF0QSA9IHNpLm1hdGVyaWFsIHx8IGJpLm1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIHZhciBtYXRCID0gc2oubWF0ZXJpYWwgfHwgYmoubWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgaWYgKG1hdEEgJiYgbWF0QiAmJiBtYXRBLnJlc3RpdHV0aW9uID49IDAgJiYgbWF0Qi5yZXN0aXR1dGlvbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGMucmVzdGl0dXRpb24gPSBtYXRBLnJlc3RpdHV0aW9uICogbWF0Qi5yZXN0aXR1dGlvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjLnNpID0gcnNpIHx8IHNpO1xuICAgICAgICAgICAgICAgIGMuc2ogPSByc2ogfHwgc2o7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0ID0gZnVuY3Rpb24gKGNvbnRhY3RFcXVhdGlvbiwgb3V0QXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYm9keUEgPSBjb250YWN0RXF1YXRpb24uYmk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlCID0gY29udGFjdEVxdWF0aW9uLmJqO1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZUEgPSBjb250YWN0RXF1YXRpb24uc2k7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlQiA9IGNvbnRhY3RFcXVhdGlvbi5zajtcblxuICAgICAgICAgICAgICAgIHZhciB3b3JsZCA9IHRoaXMud29ybGQ7XG4gICAgICAgICAgICAgICAgdmFyIGNtID0gdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgZnJpY3Rpb24gb3IgcmVzdGl0dXRpb24gd2VyZSBzcGVjaWZpZWQgaW4gdGhlIG1hdGVyaWFsLCB1c2UgdGhlbVxuICAgICAgICAgICAgICAgIHZhciBmcmljdGlvbiA9IGNtLmZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIHZhciBtYXRBID0gc2hhcGVBLm1hdGVyaWFsIHx8IGJvZHlBLm1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIHZhciBtYXRCID0gc2hhcGVCLm1hdGVyaWFsIHx8IGJvZHlCLm1hdGVyaWFsO1xuICAgICAgICAgICAgICAgIGlmIChtYXRBICYmIG1hdEIgJiYgbWF0QS5mcmljdGlvbiA+PSAwICYmIG1hdEIuZnJpY3Rpb24gPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmcmljdGlvbiA9IG1hdEEuZnJpY3Rpb24gKiBtYXRCLmZyaWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChmcmljdGlvbiA+IDApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXVnID0gZnJpY3Rpb24gKiB3b3JsZC5ncmF2aXR5Lmxlbmd0aCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVkdWNlZE1hc3MgPSAoYm9keUEuaW52TWFzcyArIGJvZHlCLmludk1hc3MpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVkdWNlZE1hc3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWR1Y2VkTWFzcyA9IDEgLyByZWR1Y2VkTWFzcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgcG9vbCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2w7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjMSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5QiwgbXVnICogcmVkdWNlZE1hc3MpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYzIgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihib2R5QSwgYm9keUIsIG11ZyAqIHJlZHVjZWRNYXNzKTtcblxuICAgICAgICAgICAgICAgICAgICBjMS5iaSA9IGMyLmJpID0gYm9keUE7XG4gICAgICAgICAgICAgICAgICAgIGMxLmJqID0gYzIuYmogPSBib2R5QjtcbiAgICAgICAgICAgICAgICAgICAgYzEubWluRm9yY2UgPSBjMi5taW5Gb3JjZSA9IC1tdWcgKiByZWR1Y2VkTWFzcztcbiAgICAgICAgICAgICAgICAgICAgYzEubWF4Rm9yY2UgPSBjMi5tYXhGb3JjZSA9IG11ZyAqIHJlZHVjZWRNYXNzO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgb3ZlciB0aGUgcmVsYXRpdmUgdmVjdG9yc1xuICAgICAgICAgICAgICAgICAgICBjMS5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7XG4gICAgICAgICAgICAgICAgICAgIGMxLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgYzIucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpO1xuICAgICAgICAgICAgICAgICAgICBjMi5yai5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRhbmdlbnRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RFcXVhdGlvbi5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgc3Bvb2sgcGFyYW1zXG4gICAgICAgICAgICAgICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG4gICAgICAgICAgICAgICAgICAgIGMyLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjb250YWN0RXF1YXRpb24uZW5hYmxlZDtcblxuICAgICAgICAgICAgICAgICAgICBvdXRBcnJheS5wdXNoKGMxLCBjMik7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGF2ZXJhZ2VOb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGF2ZXJhZ2VDb250YWN0UG9pbnRBID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBhdmVyYWdlQ29udGFjdFBvaW50QiA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8vIFRha2UgdGhlIGF2ZXJhZ2UgTiBsYXRlc3QgY29udGFjdCBwb2ludCBvbiB0aGUgcGxhbmUuXG4gICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSA9IGZ1bmN0aW9uIChudW1Db250YWN0cykge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IGNvbnRhY3RFcXVhdGlvblxuICAgICAgICAgICAgICAgIHZhciBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHJlc3VsdDogdHdvIFwiYXZlcmFnZVwiIGZyaWN0aW9uIGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KGMsIHRoaXMuZnJpY3Rpb25SZXN1bHQpIHx8IG51bUNvbnRhY3RzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZjEgPSB0aGlzLmZyaWN0aW9uUmVzdWx0W3RoaXMuZnJpY3Rpb25SZXN1bHQubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICAgICAgdmFyIGYyID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgYXZlcmFnZU5vcm1hbC5zZXRaZXJvKCk7XG4gICAgICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEuc2V0WmVybygpO1xuICAgICAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRCLnNldFplcm8oKTtcblxuICAgICAgICAgICAgICAgIHZhciBib2R5QSA9IGMuYmk7XG4gICAgICAgICAgICAgICAgdmFyIGJvZHlCID0gYy5iajtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gbnVtQ29udGFjdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjID0gdGhpcy5yZXN1bHRbdGhpcy5yZXN1bHQubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5ib2R5QSAhPT0gYm9keUEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2VOb3JtYWwudmFkZChjLm5pLCBhdmVyYWdlTm9ybWFsKTsgLy8gdmVjMi5hZGQoZXEudCwgZXEudCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnZhZGQoYy5yaSwgYXZlcmFnZUNvbnRhY3RQb2ludEEpOyAvLyB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIudmFkZChjLnJqLCBhdmVyYWdlQ29udGFjdFBvaW50Qik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmVyYWdlTm9ybWFsLnZzdWIoYy5uaSwgYXZlcmFnZU5vcm1hbCk7IC8vIHZlYzIuc3ViKGVxLnQsIGVxLnQsIGMubm9ybWFsQSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50QS52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRBKTsgLy8gdmVjMi5hZGQoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgYy5jb250YWN0UG9pbnRBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRCLnZhZGQoYy5yaSwgYXZlcmFnZUNvbnRhY3RQb2ludEIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGludk51bUNvbnRhY3RzID0gMSAvIG51bUNvbnRhY3RzO1xuICAgICAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNjYWxlKGludk51bUNvbnRhY3RzLCBmMS5yaSk7IC8vIHZlYzIuc2NhbGUoZXEuY29udGFjdFBvaW50QSwgZXEuY29udGFjdFBvaW50QSwgaW52TnVtQ29udGFjdHMpO1xuICAgICAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRCLnNjYWxlKGludk51bUNvbnRhY3RzLCBmMS5yaik7IC8vIHZlYzIuc2NhbGUoZXEuY29udGFjdFBvaW50QiwgZXEuY29udGFjdFBvaW50QiwgaW52TnVtQ29udGFjdHMpO1xuICAgICAgICAgICAgICAgIGYyLnJpLmNvcHkoZjEucmkpOyAvLyBTaG91bGQgYmUgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBmMi5yai5jb3B5KGYxLnJqKTtcbiAgICAgICAgICAgICAgICBhdmVyYWdlTm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIGF2ZXJhZ2VOb3JtYWwudGFuZ2VudHMoZjEudCwgZjIudCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIGVxO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICB2YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgdG1wUXVhdDEgPSBuZXcgUXVhdGVybmlvbigpO1xuICAgICAgICAgICAgdmFyIHRtcFF1YXQyID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZW5lcmF0ZSBhbGwgY29udGFjdHMgYmV0d2VlbiBhIGxpc3Qgb2YgYm9keSBwYWlyc1xuICAgICAgICAgICAgICogQG1ldGhvZCBnZXRDb250YWN0c1xuICAgICAgICAgICAgICogQHBhcmFtIHthcnJheX0gcDEgQXJyYXkgb2YgYm9keSBpbmRpY2VzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBwMiBBcnJheSBvZiBib2R5IGluZGljZXNcbiAgICAgICAgICAgICAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQXJyYXkgdG8gc3RvcmUgZ2VuZXJhdGVkIGNvbnRhY3RzXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBvbGRjb250YWN0cyBPcHRpb25hbC4gQXJyYXkgb2YgcmV1c2FibGUgY29udGFjdCBvYmplY3RzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5nZXRDb250YWN0cyA9IGZ1bmN0aW9uIChwMSwgcDIsIHdvcmxkLCByZXN1bHQsIG9sZGNvbnRhY3RzLCBmcmljdGlvblJlc3VsdCwgZnJpY3Rpb25Qb29sKSB7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBvbGQgY29udGFjdCBvYmplY3RzXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IGZyaWN0aW9uUG9vbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgcWkgPSB0bXBRdWF0MTtcbiAgICAgICAgICAgICAgICB2YXIgcWogPSB0bXBRdWF0MjtcbiAgICAgICAgICAgICAgICB2YXIgeGkgPSB0bXBWZWMxO1xuICAgICAgICAgICAgICAgIHZhciB4aiA9IHRtcFZlYzI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMCwgTiA9IHAxLmxlbmd0aDsgayAhPT0gTjsgaysrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgY29sbGlzaW9uIGJvZGllc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmkgPSBwMVtrXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJqID0gcDJba107XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNvbnRhY3QgbWF0ZXJpYWxcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlDb250YWN0TWF0ZXJpYWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlDb250YWN0TWF0ZXJpYWwgPSB3b3JsZC5nZXRDb250YWN0TWF0ZXJpYWwoYmkubWF0ZXJpYWwsIGJqLm1hdGVyaWFsKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiaS5zaGFwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpLnF1YXRlcm5pb24ubXVsdChiaS5zaGFwZU9yaWVudGF0aW9uc1tpXSwgcWkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmkucXVhdGVybmlvbi52bXVsdChiaS5zaGFwZU9mZnNldHNbaV0sIHhpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpLnZhZGQoYmkucG9zaXRpb24sIHhpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaSA9IGJpLnNoYXBlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiai5zaGFwZXMubGVuZ3RoOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgd29ybGQgdHJhbnNmb3JtIG9mIHNoYXBlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJqLnF1YXRlcm5pb24ubXVsdChiai5zaGFwZU9yaWVudGF0aW9uc1tqXSwgcWopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJqLnF1YXRlcm5pb24udm11bHQoYmouc2hhcGVPZmZzZXRzW2pdLCB4aik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGoudmFkZChiai5wb3NpdGlvbiwgeGopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaiA9IGJqLnNoYXBlc1tqXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNvbGxpc2lvbiBtYXRlcmlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZUNvbnRhY3RNYXRlcmlhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpLm1hdGVyaWFsICYmIHNqLm1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlQ29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLCBzai5tYXRlcmlhbCkgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWwgPSBzaGFwZUNvbnRhY3RNYXRlcmlhbCB8fCBib2R5Q29udGFjdE1hdGVyaWFsIHx8IHdvcmxkLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgY29udGFjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZXIgPSB0aGlzW3NpLnR5cGUgfCBzai50eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpLnR5cGUgPCBzai50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlci5jYWxsKHRoaXMsIHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyLmNhbGwodGhpcywgc2osIHNpLCB4aiwgeGksIHFqLCBxaSwgYmosIGJpLCBzaSwgc2opO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIG51bVdhcm5pbmdzID0gMDtcbiAgICAgICAgICAgIHZhciBtYXhXYXJuaW5ncyA9IDEwO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiB3YXJuKG1zZykge1xuICAgICAgICAgICAgICAgIGlmIChudW1XYXJuaW5ncyA+IG1heFdhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBudW1XYXJuaW5ncysrO1xuXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5CT1hdID1cbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94Qm94ID0gZnVuY3Rpb24gKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaikge1xuICAgICAgICAgICAgICAgICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICAgICAgICAgICAgICAgICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzai5jb2xsaXNpb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXhDb252ZXgoc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHNpLCBzaik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID1cbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94Q29udmV4ID0gZnVuY3Rpb24gKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaikge1xuICAgICAgICAgICAgICAgICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICAgICAgICAgICAgICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmV4Q29udmV4KHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHNpLCBzaik7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXSA9XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlLmJveFBhcnRpY2xlID0gZnVuY3Rpb24gKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaikge1xuICAgICAgICAgICAgICAgICAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICAgICAgICAgICAgICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udmV4UGFydGljbGUoc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc3BoZXJlU3BoZXJlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRV0gPVxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVTcGhlcmUgPSBmdW5jdGlvbiAoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgaGF2ZSBvbmx5IG9uZSBjb250YWN0IGluIHRoaXMgY2FzZVxuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb250YWN0IG5vcm1hbFxuICAgICAgICAgICAgICAgICAgICB4ai52c3ViKHhpLCByLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb250YWN0IHBvaW50IGxvY2F0aW9uc1xuICAgICAgICAgICAgICAgICAgICByLnJpLmNvcHkoci5uaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmouY29weShyLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgci5yaS5tdWx0KHNpLnJhZGl1cywgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmoubXVsdCgtc2oucmFkaXVzLCByLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBsYW5lVHJpbWVzaFxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBwbGFuZVRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwbGFuZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwbGFuZVRyaW1lc2hfcHJvamVjdGVkID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLlRSSU1FU0hdID1cbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVUcmltZXNoID0gZnVuY3Rpb24gKFxuICAgICAgICAgICAgICAgICAgICBwbGFuZVNoYXBlLFxuICAgICAgICAgICAgICAgICAgICB0cmltZXNoU2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIHBsYW5lUG9zLFxuICAgICAgICAgICAgICAgICAgICB0cmltZXNoUG9zLFxuICAgICAgICAgICAgICAgICAgICBwbGFuZVF1YXQsXG4gICAgICAgICAgICAgICAgICAgIHRyaW1lc2hRdWF0LFxuICAgICAgICAgICAgICAgICAgICBwbGFuZUJvZHksXG4gICAgICAgICAgICAgICAgICAgIHRyaW1lc2hCb2R5XG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgY29udGFjdHMhXG4gICAgICAgICAgICAgICAgICAgIHZhciB2ID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gcGxhbmVUcmltZXNoX25vcm1hbDtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsLnNldCgwLCAwLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGxhbmVRdWF0LnZtdWx0KG5vcm1hbCwgbm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmltZXNoU2hhcGUudmVydGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB3b3JsZCB2ZXJ0ZXggZnJvbSB0cmltZXNoXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KGksIHYpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTYWZlIHVwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdjIuY29weSh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdjIsIHYpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBwbGFuZSBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVscG9zID0gcGxhbmVUcmltZXNoX3JlbHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIHYudnN1YihwbGFuZVBvcywgcmVscG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3QgPD0gMC4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIHRyaW1lc2hCb2R5LCBwbGFuZVNoYXBlLCB0cmltZXNoU2hhcGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5uaS5jb3B5KG5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2plY3RlZCA9IHBsYW5lVHJpbWVzaF9wcm9qZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLnNjYWxlKHJlbHBvcy5kb3Qobm9ybWFsKSwgcHJvamVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LnZzdWIocHJvamVjdGVkLCBwcm9qZWN0ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmkgaXMgdGhlIHByb2plY3RlZCB3b3JsZCBwb3NpdGlvbiBtaW51cyBwbGFuZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkuY29weShwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yai5jb3B5KHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9yZSByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBzcGhlcmVUcmltZXNoXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzcGhlcmVTaGFwZVxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgdHJpbWVzaFNoYXBlXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICBzcGhlcmVQb3NcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHRyaW1lc2hQb3NcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHNwaGVyZVF1YXRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHRyaW1lc2hRdWF0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBzcGhlcmVCb2R5XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICB0cmltZXNoQm9keVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgc3BoZXJlVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgc3BoZXJlVHJpbWVzaF92ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX3YyID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhBID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3IgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3MgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZVRyaW1lc2hfdG1wID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX3ZhID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX3ZiID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX3ZjID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQiA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICB2YXIgc3BoZXJlVHJpbWVzaF90cmlhbmdsZXMgPSBbXTtcbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVRyaW1lc2ggPSBmdW5jdGlvbiAoXG4gICAgICAgICAgICAgICAgICAgIHNwaGVyZVNoYXBlLFxuICAgICAgICAgICAgICAgICAgICB0cmltZXNoU2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIHNwaGVyZVBvcyxcbiAgICAgICAgICAgICAgICAgICAgdHJpbWVzaFBvcyxcbiAgICAgICAgICAgICAgICAgICAgc3BoZXJlUXVhdCxcbiAgICAgICAgICAgICAgICAgICAgdHJpbWVzaFF1YXQsXG4gICAgICAgICAgICAgICAgICAgIHNwaGVyZUJvZHksXG4gICAgICAgICAgICAgICAgICAgIHRyaW1lc2hCb2R5XG4gICAgICAgICAgICAgICAgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VWZXJ0ZXhBID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VWZXJ0ZXhCID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VWZWN0b3IgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3I7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlVmVjdG9yVW5pdCA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0bXAgPSBzcGhlcmVUcmltZXNoX3RtcDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2FsU3BoZXJlQUFCQiA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVBQUJCO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSBzcGhlcmVUcmltZXNoX3YyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVscG9zID0gc3BoZXJlVHJpbWVzaF9yZWxwb3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmlhbmdsZXMgPSBzcGhlcmVUcmltZXNoX3RyaWFuZ2xlcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNwaGVyZSBwb3NpdGlvbiB0byBsb2NhbCBpbiB0aGUgdHJpbWVzaFxuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHNwaGVyZVBvcywgbG9jYWxTcGhlcmVQb3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgYWFiYiBvZiB0aGUgc3BoZXJlIGxvY2FsbHkgaW4gdGhlIHRyaW1lc2hcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwaGVyZVJhZGl1cyA9IHNwaGVyZVNoYXBlLnJhZGl1cztcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVBQUJCLmxvd2VyQm91bmQuc2V0KFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MueCAtIHNwaGVyZVJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnkgLSBzcGhlcmVSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNwaGVyZVBvcy56IC0gc3BoZXJlUmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU3BoZXJlQUFCQi51cHBlckJvdW5kLnNldChcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnggKyBzcGhlcmVSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNwaGVyZVBvcy55ICsgc3BoZXJlUmFkaXVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MueiArIHNwaGVyZVJhZGl1c1xuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZXNJbkFBQkIobG9jYWxTcGhlcmVBQUJCLCB0cmlhbmdsZXMpO1xuICAgICAgICAgICAgICAgICAgICAvL2ZvciAodmFyIGkgPSAwOyBpIDwgdHJpbWVzaFNoYXBlLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB0cmlhbmdsZXMucHVzaChpKTsgLy8gQWxsXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVmVydGljZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBzcGhlcmVUcmltZXNoX3Y7XG4gICAgICAgICAgICAgICAgICAgIHZhciByYWRpdXNTcXVhcmVkID0gc3BoZXJlU2hhcGUucmFkaXVzICogc3BoZXJlU2hhcGUucmFkaXVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRyaWFuZ2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCB2KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHZlcnRleCBvdmVybGFwIGluIHNwaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYudnN1Yihsb2NhbFNwaGVyZVBvcywgcmVscG9zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWxwb3Mubm9ybTIoKSA8PSByYWRpdXNTcXVhcmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2FmZSB1cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2Mi5jb3B5KHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHYyLCB2KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LnZzdWIoc3BoZXJlUG9zLCByZWxwb3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLm5pLmNvcHkocmVscG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByaSBpcyB0aGUgdmVjdG9yIGZyb20gc3BoZXJlIGNlbnRlciB0byB0aGUgc3BoZXJlIHN1cmZhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS5jb3B5KHIubmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudmFkZChzcGhlcmVQb3MsIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJpLnZzdWIoc3BoZXJlQm9keS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yai5jb3B5KHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWxsIGVkZ2VzXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpbWVzaFNoYXBlLmdldFZlcnRleCh0cmltZXNoU2hhcGUuaW5kaWNlc1t0cmlhbmdsZXNbaV0gKiAzICsgal0sIGVkZ2VWZXJ0ZXhBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyAoKGogKyAxKSAlIDMpXSwgZWRnZVZlcnRleEIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VWZXJ0ZXhCLnZzdWIoZWRnZVZlcnRleEEsIGVkZ2VWZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJvamVjdCBzcGhlcmUgcG9zaXRpb24gdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKGVkZ2VWZXJ0ZXhCLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbkFsb25nRWRnZUIgPSB0bXAuZG90KGVkZ2VWZWN0b3IpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25BbG9uZ0VkZ2VBID0gdG1wLmRvdChlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3cgY2hlY2sgdGhlIG9ydGhvZ29uYWwgZGlzdGFuY2UgZnJvbSBlZGdlIHRvIHNwaGVyZSBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlVmVjdG9yVW5pdC5jb3B5KGVkZ2VWZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlVmVjdG9yVW5pdC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BbG9uZ0VkZ2VBID0gdG1wLmRvdChlZGdlVmVjdG9yVW5pdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQuc2NhbGUocG9zaXRpb25BbG9uZ0VkZ2VBLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXAudmFkZChlZGdlVmVydGV4QSwgdG1wKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0bXAgaXMgbm93IHRoZSBzcGhlcmUgY2VudGVyIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZWRnZSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSB0cmltZXNoIGZyYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gdG1wLmRpc3RhbmNlVG8obG9jYWxTcGhlcmVQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCA8IHNwaGVyZVNoYXBlLnJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LCB0cmltZXNoQm9keSwgc3BoZXJlU2hhcGUsIHRyaW1lc2hTaGFwZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLm5pLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdG1wLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wLnZzdWIodHJpbWVzaEJvZHkucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLm5pLCByLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpYW5nbGUgZmFjZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhID0gc3BoZXJlVHJpbWVzaF92YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZiID0gc3BoZXJlVHJpbWVzaF92YjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZjID0gc3BoZXJlVHJpbWVzaF92YztcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHNwaGVyZVRyaW1lc2hfbm9ybWFsO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpbWVzaFNoYXBlLmdldFRyaWFuZ2xlVmVydGljZXModHJpYW5nbGVzW2ldLCB2YSwgdmIsIHZjKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXROb3JtYWwodHJpYW5nbGVzW2ldLCBub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1Yih2YSwgdG1wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gdG1wLmRvdChub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsLnNjYWxlKGRpc3QsIHRtcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHRtcCwgdG1wKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG1wIGlzIG5vdyB0aGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgdHJpYW5nbGUgcGxhbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoUmF5LnBvaW50SW5UcmlhbmdsZSh0bXAsIHZhLCB2YiwgdmMpICYmIGRpc3QgPCBzcGhlcmVTaGFwZS5yYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHNwaGVyZUJvZHksIHRyaW1lc2hCb2R5LCBzcGhlcmVTaGFwZSwgdHJpbWVzaFNoYXBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIubmkuc2NhbGUoc3BoZXJlU2hhcGUucmFkaXVzLCByLnJpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdG1wLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcC52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIubmksIHIubmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0cmlhbmdsZXMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwbGFuZV90b19zcGhlcmVfb3J0aG8gPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc3BoZXJlUGxhbmVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuUExBTkVdID1cbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlUGxhbmUgPSBmdW5jdGlvbiAoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgaGF2ZSBvbmUgY29udGFjdCBpbiB0aGlzIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udGFjdCBub3JtYWxcbiAgICAgICAgICAgICAgICAgICAgci5uaS5zZXQoMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHFqLnZtdWx0KHIubmksIHIubmkpO1xuICAgICAgICAgICAgICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsgLy8gYm9keSBpIGlzIHRoZSBzcGhlcmUsIGZsaXAgbm9ybWFsXG4gICAgICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7IC8vIE5lZWRlZD9cblxuICAgICAgICAgICAgICAgICAgICAvLyBWZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIGNvbnRhY3QgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgci5uaS5tdWx0KHNpLnJhZGl1cywgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvamVjdCBkb3duIHNwaGVyZSBvbiBwbGFuZVxuICAgICAgICAgICAgICAgICAgICB4aS52c3ViKHhqLCBwb2ludF9vbl9wbGFuZV90b19zcGhlcmUpO1xuICAgICAgICAgICAgICAgICAgICByLm5pLm11bHQoci5uaS5kb3QocG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlKSwgcGxhbmVfdG9fc3BoZXJlX29ydGhvKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLnZzdWIocGxhbmVfdG9fc3BoZXJlX29ydGhvLCByLnJqKTsgLy8gVGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gcGxhbmVcblxuICAgICAgICAgICAgICAgICAgICBpZiAoLXBvaW50X29uX3BsYW5lX3RvX3NwaGVyZS5kb3Qoci5uaSkgPD0gc2kucmFkaXVzKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIGJvZHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByaSA9IHIucmk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmogPSByLnJqO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gU2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLmNvbS9CdWxsZXQvQnVsbGV0RnVsbC9TcGhlcmVUcmlhbmdsZURldGVjdG9yXzhjcHBfc291cmNlLmh0bWxcbiAgICAgICAgICAgIHZhciBwb2ludEluUG9seWdvbl9lZGdlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwb2ludEluUG9seWdvbl92dHAgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9pbnRJblBvbHlnb24odmVydHMsIG5vcm1hbCwgcCkge1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGl2ZVJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIE4gPSB2ZXJ0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBlZGdlIHRvIHRoZSBuZXh0IHZlcnRleFxuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZSA9IHBvaW50SW5Qb2x5Z29uX2VkZ2U7XG4gICAgICAgICAgICAgICAgICAgIHZlcnRzWyhpICsgMSkgJSAoTildLnZzdWIodiwgZWRnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNyb3NzIHByb2R1Y3QgYmV0d2VlbiBwb2x5Z29uIG5vcm1hbCBhbmQgdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VfeF9ub3JtYWwgPSBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsO1xuICAgICAgICAgICAgICAgICAgICAvL3ZhciBlZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5jcm9zcyhub3JtYWwsIGVkZ2VfeF9ub3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB2ZWN0b3IgYmV0d2VlbiBwb2ludCBhbmQgY3VycmVudCB2ZXJ0ZXhcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZlcnRleF90b19wID0gcG9pbnRJblBvbHlnb25fdnRwO1xuICAgICAgICAgICAgICAgICAgICBwLnZzdWIodiwgdmVydGV4X3RvX3ApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpc1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IGVkZ2VfeF9ub3JtYWwuZG90KHZlcnRleF90b19wKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhbGwgc3VjaCBkb3QgcHJvZHVjdHMgaGF2ZSBzYW1lIHNpZ24sIHdlIGFyZSBpbnNpZGUgdGhlIHBvbHlnb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGl2ZVJlc3VsdCA9PT0gbnVsbCB8fCAociA+IDAgJiYgcG9zaXRpdmVSZXN1bHQgPT09IHRydWUpIHx8IChyIDw9IDAgJiYgcG9zaXRpdmVSZXN1bHQgPT09IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aXZlUmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVSZXN1bHQgPSByID4gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFbmNvdW50ZXJlZCBzb21lIG90aGVyIHNpZ24uIEV4aXQuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBib3hfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVCb3hfbnMgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUJveF9uczEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUJveF9uczIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUJveF9zaWRlcyA9IFtuZXcgVmVjMygpLCBuZXcgVmVjMygpLCBuZXcgVmVjMygpLCBuZXcgVmVjMygpLCBuZXcgVmVjMygpLCBuZXcgVmVjMygpXTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVCb3hfc3BoZXJlX3RvX2Nvcm5lciA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgc3BoZXJlQm94X3NpZGVfbnMgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUJveF9zaWRlX25zMSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgc3BoZXJlQm94X3NpZGVfbnMyID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHNwaGVyZUJveFxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5CT1hdID1cbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlQm94ID0gZnVuY3Rpb24gKHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjNwb29sID0gdGhpcy52M3Bvb2w7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgcmVmZXIgdG8gdGhlIGJveCBhcyBib2R5IGpcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGVzID0gc3BoZXJlQm94X3NpZGVzO1xuICAgICAgICAgICAgICAgICAgICB4aS52c3ViKHhqLCBib3hfdG9fc3BoZXJlKTtcbiAgICAgICAgICAgICAgICAgICAgc2ouZ2V0U2lkZU5vcm1hbHMoc2lkZXMsIHFqKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIFIgPSBzaS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZW5ldHJhdGluZ19zaWRlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBwZW5ldHJhdGlvbiBpbmZvXG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlX25zID0gc3BoZXJlQm94X3NpZGVfbnM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlX25zMSA9IHNwaGVyZUJveF9zaWRlX25zMTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGVfbnMyID0gc3BoZXJlQm94X3NpZGVfbnMyO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZV9oID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGVfcGVuZXRyYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNpZGVfZG90MSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaWRlX2RvdDIgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2lkZV9kaXN0YW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlkeCA9IDAsIG5zaWRlcyA9IHNpZGVzLmxlbmd0aDsgaWR4ICE9PSBuc2lkZXMgJiYgZm91bmQgPT09IGZhbHNlOyBpZHgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwbGFuZSBzaWRlIG5vcm1hbCAobnMpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnMgPSBzcGhlcmVCb3hfbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBucy5jb3B5KHNpZGVzW2lkeF0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IG5zLm5vcm0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5zLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9ybWFsL2Rpc3RhbmNlIGRvdCBwcm9kdWN0IHRlbGxzIHdoaWNoIHNpZGUgb2YgdGhlIHBsYW5lIHdlIGFyZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdCA9IGJveF90b19zcGhlcmUuZG90KG5zKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvdCA8IGggKyBSICYmIGRvdCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnRlcnNlY3RzIHBsYW5lLiBOb3cgY2hlY2sgdGhlIG90aGVyIHR3byBkaW1lbnNpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5zMSA9IHNwaGVyZUJveF9uczE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5zMiA9IHNwaGVyZUJveF9uczI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnMxLmNvcHkoc2lkZXNbKGlkeCArIDEpICUgM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5zMi5jb3B5KHNpZGVzWyhpZHggKyAyKSAlIDNdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaDEgPSBuczEubm9ybSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoMiA9IG5zMi5ub3JtKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbnMxLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5zMi5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90MSA9IGJveF90b19zcGhlcmUuZG90KG5zMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdDIgPSBib3hfdG9fc3BoZXJlLmRvdChuczIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3QxIDwgaDEgJiYgZG90MSA+IC1oMSAmJiBkb3QyIDwgaDIgJiYgZG90MiA+IC1oMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRvdCAtIGggLSBSKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGVfZGlzdGFuY2UgPT09IG51bGwgfHwgZGlzdCA8IHNpZGVfZGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9kb3QxID0gZG90MTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfZG90MiA9IGRvdDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlX2ggPSBoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9ucy5jb3B5KG5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfbnMxLmNvcHkobnMxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfbnMyLmNvcHkobnMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfcGVuZXRyYXRpb25zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZGVfcGVuZXRyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfbnMubXVsdCgtUiwgci5yaSk7IC8vIFNwaGVyZSByXG4gICAgICAgICAgICAgICAgICAgICAgICByLm5pLmNvcHkoc2lkZV9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHNob3VsZCBiZSBvdXQgb2Ygc3BoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlX25zLm11bHQoc2lkZV9oLCBzaWRlX25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfbnMxLm11bHQoc2lkZV9kb3QxLCBzaWRlX25zMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaWRlX25zLnZhZGQoc2lkZV9uczEsIHNpZGVfbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2lkZV9uczIubXVsdChzaWRlX2RvdDIsIHNpZGVfbnMyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVfbnMudmFkZChzaWRlX25zMiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgY29ybmVyc1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmogPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcGhlcmVfdG9fY29ybmVyID0gc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqICE9PSAyICYmICFmb3VuZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayAhPT0gMiAmJiAhZm91bmQ7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGwgPSAwOyBsICE9PSAyICYmICFmb3VuZDsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJqLnNldCgwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMF0sIHJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMF0sIHJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1sxXSwgcmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmoudnN1YihzaWRlc1sxXSwgcmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByai52YWRkKHNpZGVzWzJdLCByaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzJdLCByaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXb3JsZCBwb3NpdGlvbiBvZiBjb3JuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGoudmFkZChyaiwgc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwaGVyZV90b19jb3JuZXIudnN1Yih4aSwgc3BoZXJlX3RvX2Nvcm5lcik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwaGVyZV90b19jb3JuZXIubm9ybTIoKSA8IFIgKiBSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkuY29weShzcGhlcmVfdG9fY29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLm5pLmNvcHkoci5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJpLm11bHQoUiwgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJqLmNvcHkocmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShyaik7XG4gICAgICAgICAgICAgICAgICAgIHJqID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBlZGdlc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZWRnZVRhbmdlbnQgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlQ2VudGVyID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHYzcG9vbC5nZXQoKTsgLy8gciA9IGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXJcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9ydGhvZ29uYWwgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgTnNpZGVzID0gc2lkZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gTnNpZGVzICYmICFmb3VuZDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayAhPT0gTnNpZGVzICYmICFmb3VuZDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogJSAzICE9PSBrICUgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgZWRnZSB0YW5nZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZGVzW2tdLmNyb3NzKHNpZGVzW2pdLCBlZGdlVGFuZ2VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VUYW5nZW50Lm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWRlc1tqXS52YWRkKHNpZGVzW2tdLCBlZGdlQ2VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5jb3B5KHhpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci52c3ViKGVkZ2VDZW50ZXIsIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnZzdWIoeGosIHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3J0aG9ub3JtID0gci5kb3QoZWRnZVRhbmdlbnQpOyAvLyBkaXN0YW5jZSBmcm9tIGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBjZW50ZXIgaW4gdGhlIHRhbmdlbnQgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VUYW5nZW50Lm11bHQob3J0aG9ub3JtLCBvcnRob2dvbmFsKTsgLy8gVmVjdG9yIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb25cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSB0aGlyZCBzaWRlIG9ydGhvZ29uYWwgdG8gdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGwgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobCA9PT0gaiAlIDMgfHwgbCA9PT0gayAlIDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGwrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZlYyBmcm9tIGVkZ2UgY2VudGVyIHRvIHNwaGVyZSBwcm9qZWN0ZWQgdG8gdGhlIHBsYW5lIG9ydGhvZ29uYWwgdG8gdGhlIGVkZ2UgdGFuZ2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0LmNvcHkoeGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0LnZzdWIob3J0aG9nb25hbCwgZGlzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3QudnN1YihlZGdlQ2VudGVyLCBkaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdC52c3ViKHhqLCBkaXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXN0YW5jZXMgaW4gdGFuZ2VudCBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIGluIHRoZSBwbGFuZSBvcnRob2dvbmFsIHRvIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZGlzdCA9IE1hdGguYWJzKG9ydGhvbm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZGlzdCA9IGRpc3Qubm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZGlzdCA8IHNpZGVzW2xdLm5vcm0oKSAmJiBuZGlzdCA8IFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlQ2VudGVyLnZhZGQob3J0aG9nb25hbCwgcmVzLnJqKTsgLy8gYm94IHJqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmouY29weShyZXMucmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdC5uZWdhdGUocmVzLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5uaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnJpLmNvcHkocmVzLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5yaS52YWRkKHhqLCByZXMucmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoeGksIHJlcy5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmkubXVsdChSLCByZXMucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGksIHJlcy5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMucmkudnN1YihiaS5wb3NpdGlvbiwgcmVzLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5yai52YWRkKHhqLCByZXMucmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnJqLnZzdWIoYmoucG9zaXRpb24sIHJlcy5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyZXMsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGVkZ2VUYW5nZW50LCBlZGdlQ2VudGVyLCByLCBvcnRob2dvbmFsLCBkaXN0KTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY29udmV4X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgc3BoZXJlQ29udmV4X2VkZ2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBzcGhlcmVDb252ZXhcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVDb252ZXggPSBmdW5jdGlvbiAoc2ksIHNqLCB4aSwgeGosIHFpLCBxaiwgYmksIGJqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2M3Bvb2wgPSB0aGlzLnYzcG9vbDtcbiAgICAgICAgICAgICAgICAgICAgeGkudnN1Yih4aiwgY29udmV4X3RvX3NwaGVyZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWxzID0gc2ouZmFjZU5vcm1hbHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWNlcyA9IHNqLmZhY2VzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmVydHMgPSBzai52ZXJ0aWNlcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIFIgPSBzaS5yYWRpdXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZW5ldHJhdGluZ19zaWRlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKGNvbnZleF90b19zcGhlcmUubm9ybTIoKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgY29ybmVyc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gdmVydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmxkQ29ybmVyID0gc3BoZXJlQ29udmV4X3dvcmxkQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcWoudm11bHQodiwgd29ybGRDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh3b3JsZENvcm5lciwgd29ybGRDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZENvcm5lci52c3ViKHhpLCBzcGhlcmVfdG9fY29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGhlcmVfdG9fY29ybmVyLm5vcm0yKCkgPCBSICogUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJpLmNvcHkoc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLm5pLmNvcHkoci5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS5tdWx0KFIsIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGosIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBzaWRlIChwbGFuZSkgaW50ZXJzZWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG5mYWNlcyA9IGZhY2VzLmxlbmd0aDsgaSAhPT0gbmZhY2VzICYmIGZvdW5kID09PSBmYWxzZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybWFsID0gbm9ybWFsc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmYWNlID0gZmFjZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB3b3JsZC10cmFuc2Zvcm1lZCBub3JtYWwgb2YgdGhlIGZhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3b3JsZE5vcm1hbCA9IHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFqLnZtdWx0KG5vcm1hbCwgd29ybGROb3JtYWwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgYSB3b3JsZCB2ZXJ0ZXggZnJvbSB0aGUgZmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnQgPSBzcGhlcmVDb252ZXhfd29ybGRQb2ludDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbMF1dLCB3b3JsZFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkUG9pbnQudmFkZCh4aiwgd29ybGRQb2ludCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIHBvaW50IG9uIHRoZSBzcGhlcmUsIGNsb3Nlc3QgdG8gdGhlIGZhY2Ugbm9ybWFsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gc3BoZXJlQ29udmV4X3dvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkTm9ybWFsLm11bHQoLVIsIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aS52YWRkKHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVjdG9yIGZyb20gYSBmYWNlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzcGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZW5ldHJhdGlvblZlYyA9IHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZS52c3ViKHdvcmxkUG9pbnQsIHBlbmV0cmF0aW9uVmVjKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHBlbmV0cmF0aW9uLiBOZWdhdGl2ZSB2YWx1ZSBtZWFucyBvdmVybGFwLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb25WZWMuZG90KHdvcmxkTm9ybWFsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmxkUG9pbnRUb1NwaGVyZSA9IHNwaGVyZUNvbnZleF9zcGhlcmVUb1dvcmxkUG9pbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aS52c3ViKHdvcmxkUG9pbnQsIHdvcmxkUG9pbnRUb1NwaGVyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5ldHJhdGlvbiA8IDAgJiYgd29ybGRQb2ludFRvU3BoZXJlLmRvdCh3b3JsZE5vcm1hbCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJzZWN0cyBwbGFuZS4gTm93IGNoZWNrIGlmIHRoZSBzcGhlcmUgaXMgaW5zaWRlIHRoZSBmYWNlIHBvbHlnb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZmFjZVZlcnRzID0gW107IC8vIEZhY2UgdmVydGljZXMsIGluIHdvcmxkIGNvb3Jkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBOdmVydHMgPSBmYWNlLmxlbmd0aDsgaiAhPT0gTnZlcnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmxkVmVydGV4ID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlW2pdXSwgd29ybGRWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ai52YWRkKHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2VWZXJ0cy5wdXNoKHdvcmxkVmVydGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRJblBvbHlnb24oZmFjZVZlcnRzLCB3b3JsZE5vcm1hbCwgeGkpKSB7IC8vIElzIHRoZSBzcGhlcmUgY2VudGVyIGluIHRoZSBmYWNlIHBvbHlnb24/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSwgYmosIHNpLCBzaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ybGROb3JtYWwubXVsdCgtUiwgci5yaSk7IC8vIENvbnRhY3Qgb2Zmc2V0LCBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gY29udGFjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5uZWdhdGUoci5uaSk7IC8vIE5vcm1hbCBwb2ludGluZyBvdXQgb2Ygc3BoZXJlXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjMiA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ybGROb3JtYWwubXVsdCgtcGVuZXRyYXRpb24sIHBlbmV0cmF0aW9uVmVjMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwZW5ldHJhdGlvblNwaGVyZVBvaW50ID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCBwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3hpLnZzdWIoeGopLnZhZGQocGVuZXRyYXRpb25TcGhlcmVQb2ludCkudmFkZChwZW5ldHJhdGlvblZlYzIgLCByLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGkudnN1Yih4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmoudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50LCByLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uVmVjMiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblZlYzIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgTmZhY2V2ZXJ0cyA9IGZhY2VWZXJ0cy5sZW5ndGg7IGogIT09IE5mYWNldmVydHM7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gV2Ugb25seSBleHBlY3QgKm9uZSogZmFjZSBjb250YWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IGZhY2UubGVuZ3RoOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHR3byB3b3JsZCB0cmFuc2Zvcm1lZCB2ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYxID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYyID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVsoaiArIDEpICUgZmFjZS5sZW5ndGhdXSwgdjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVsoaiArIDIpICUgZmFjZS5sZW5ndGhdXSwgdjIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh2MiwgdjIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgZWRnZSB2ZWN0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gc3BoZXJlQ29udmV4X2VkZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2Mi52c3ViKHYxLCBlZGdlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBzYW1lIHZlY3RvciwgYnV0IG5vcm1hbGl6ZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlZGdlVW5pdCA9IHNwaGVyZUNvbnZleF9lZGdlVW5pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2UudW5pdChlZGdlVW5pdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHAgaXMgeGkgcHJvamVjdGVkIG9udG8gdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYxX3RvX3hpID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGkudnN1Yih2MSwgdjFfdG9feGkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdCA9IHYxX3RvX3hpLmRvdChlZGdlVW5pdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlVW5pdC5tdWx0KGRvdCwgcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnZhZGQodjEsIHApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGEgdmVjdG9yIGZyb20gcCB0byB0aGUgY2VudGVyIG9mIHRoZSBzcGhlcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4aV90b19wID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQU5EIGlmIHAgaXMgaW4gYmV0d2VlbiB2MSBhbmQgdjJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb3QgPiAwICYmIGRvdCAqIGRvdCA8IGVkZ2Uubm9ybTIoKSAmJiB4aV90b19wLm5vcm0yKCkgPCBSICogUikgeyAvLyBDb2xsaXNpb24gaWYgdGhlIGVkZ2Utc3BoZXJlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZSBjb250YWN0IVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2opO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAudnN1Yih4aiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwLnZzdWIoeGksIHIubmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLm5pLm11bHQoUiwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yai52YWRkKHhqLCByLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52c3ViKGJpLnBvc2l0aW9uLCByLnJpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmVsZWFzZSB3b3JsZCB2ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBOZmFjZXZlcnRzID0gZmFjZVZlcnRzLmxlbmd0aDsgaiAhPT0gTmZhY2V2ZXJ0czsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh4aV90b19wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MV90b194aSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MV90b194aSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIHdvcmxkIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIE5mYWNldmVydHMgPSBmYWNlVmVydHMubGVuZ3RoOyBqICE9PSBOZmFjZXZlcnRzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoZmFjZVZlcnRzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgcGxhbmVCb3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwbGFuZV90b19jb3JuZXIgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgcGxhbmVCb3hcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkJPWF0gPVxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUJveCA9IGZ1bmN0aW9uIChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmopIHtcbiAgICAgICAgICAgICAgICAgICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYW5lQ29udmV4KHNpLCBzai5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sIHhpLCB4aiwgcWksIHFqLCBiaSwgYmopO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBwbGFuZUNvbnZleF92ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwbGFuZUNvbnZleF9ub3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHBsYW5lQ29udmV4X3JlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgcGxhbmVDb252ZXhfcHJvamVjdGVkID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHBsYW5lQ29udmV4XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZUNvbnZleCA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgICAgICAgICAgcGxhbmVTaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgY29udmV4U2hhcGUsXG4gICAgICAgICAgICAgICAgICAgIHBsYW5lUG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNvbnZleFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwbGFuZVF1YXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnZleFF1YXQsXG4gICAgICAgICAgICAgICAgICAgIHBsYW5lQm9keSxcbiAgICAgICAgICAgICAgICAgICAgY29udmV4Qm9keVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW1wbHkgcmV0dXJuIHRoZSBwb2ludHMgYmVoaW5kIHRoZSBwbGFuZS5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHdvcmxkVmVydGV4ID0gcGxhbmVDb252ZXhfdixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkTm9ybWFsID0gcGxhbmVDb252ZXhfbm9ybWFsO1xuICAgICAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5zZXQoMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHBsYW5lUXVhdC52bXVsdCh3b3JsZE5vcm1hbCwgd29ybGROb3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmUgb3JpZW50YXRpb25cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVscG9zID0gcGxhbmVDb252ZXhfcmVscG9zO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gY29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGNvbnZleCB2ZXJ0ZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydGV4LmNvcHkoY29udmV4U2hhcGUudmVydGljZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmV4UXVhdC52bXVsdCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udmV4UG9zaXRpb24udmFkZCh3b3JsZFZlcnRleCwgd29ybGRWZXJ0ZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRWZXJ0ZXgudnN1YihwbGFuZVBvc2l0aW9uLCByZWxwb3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90ID0gd29ybGROb3JtYWwuZG90KHJlbHBvcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG90IDw9IDAuMCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihwbGFuZUJvZHksIGNvbnZleEJvZHksIHBsYW5lU2hhcGUsIGNvbnZleFNoYXBlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb2plY3RlZCA9IHBsYW5lQ29udmV4X3Byb2plY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KHdvcmxkTm9ybWFsLmRvdChyZWxwb3MpLCBwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIocHJvamVjdGVkLCBwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RlZC52c3ViKHBsYW5lUG9zaXRpb24sIHIucmkpOyAvLyBGcm9tIHBsYW5lIHRvIHZlcnRleCBwcm9qZWN0ZWQgb24gcGxhbmVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIubmkuY29weSh3b3JsZE5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWwgb3V0IGZyb20gcGxhbmVcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJqIGlzIG5vdyBqdXN0IHRoZSB2ZWN0b3IgZnJvbSB0aGUgY29udmV4IGNlbnRlciB0byB0aGUgdmVydGV4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ybGRWZXJ0ZXgudnN1Yihjb252ZXhQb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52YWRkKHBsYW5lUG9zaXRpb24sIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihwbGFuZUJvZHkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHIucmoudmFkZChjb252ZXhQb3NpdGlvbiwgci5yaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yai52c3ViKGNvbnZleEJvZHkucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1Db250YWN0cysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gJiYgbnVtQ29udGFjdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY29udmV4Q29udmV4X3NlcEF4aXMgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGNvbnZleENvbnZleF9xID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvbnZleENvbnZleFxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlLmNvbnZleENvbnZleCA9IGZ1bmN0aW9uIChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmosIHJzaSwgcnNqLCBmYWNlTGlzdEEsIGZhY2VMaXN0Qikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2VwQXhpcyA9IGNvbnZleENvbnZleF9zZXBBeGlzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaS5maW5kU2VwYXJhdGluZ0F4aXMoc2osIHhpLCBxaSwgeGosIHFqLCBzZXBBeGlzLCBmYWNlTGlzdEEsIGZhY2VMaXN0QikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxID0gY29udmV4Q29udmV4X3E7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaS5jbGlwQWdhaW5zdEh1bGwoeGksIHFpLCBzaiwgeGosIHFqLCBzZXBBeGlzLCAtMTAwLCAxMDAsIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogIT09IHJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmkgPSByLnJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaiA9IHIucmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VwQXhpcy5uZWdhdGUoci5uaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2pdLm5vcm1hbC5uZWdhdGUocSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzW2pdLnBvaW50LnZhZGQocSwgcmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJqLmNvcHkocmVzW2pdLnBvaW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaS52c3ViKHhpLCByaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmoudnN1Yih4aiwgcmopO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoeGosIHJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bUNvbnRhY3RzKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmFibGVGcmljdGlvblJlZHVjdGlvbiAmJiBudW1Db250YWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBjb252ZXhUcmltZXNoXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBOYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLlRSSU1FU0hdID1cbiAgICAgICAgICAgIC8vIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhUcmltZXNoID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixmYWNlTGlzdEEsZmFjZUxpc3RCKXtcbiAgICAgICAgICAgIC8vICAgICB2YXIgc2VwQXhpcyA9IGNvbnZleENvbnZleF9zZXBBeGlzO1xuXG4gICAgICAgICAgICAvLyAgICAgaWYoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKXtcbiAgICAgICAgICAgIC8vICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gICAgIH1cblxuICAgICAgICAgICAgLy8gICAgIC8vIENvbnN0cnVjdCBhIHRlbXAgaHVsbCBmb3IgZWFjaCB0cmlhbmdsZVxuICAgICAgICAgICAgLy8gICAgIHZhciBodWxsQiA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XG5cbiAgICAgICAgICAgIC8vICAgICBodWxsQi5mYWNlcyA9IFtbMCwxLDJdXTtcbiAgICAgICAgICAgIC8vICAgICB2YXIgdmEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgLy8gICAgIHZhciB2YiA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICAvLyAgICAgdmFyIHZjID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIC8vICAgICBodWxsQi52ZXJ0aWNlcyA9IFtcbiAgICAgICAgICAgIC8vICAgICAgICAgdmEsXG4gICAgICAgICAgICAvLyAgICAgICAgIHZiLFxuICAgICAgICAgICAgLy8gICAgICAgICB2Y1xuICAgICAgICAgICAgLy8gICAgIF07XG5cbiAgICAgICAgICAgIC8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNqLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG5cbiAgICAgICAgICAgIC8vICAgICAgICAgdmFyIHRyaWFuZ2xlTm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgc2ouZ2V0Tm9ybWFsKGksIHRyaWFuZ2xlTm9ybWFsKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgaHVsbEIuZmFjZU5vcm1hbHMgPSBbdHJpYW5nbGVOb3JtYWxdO1xuXG4gICAgICAgICAgICAvLyAgICAgICAgIHNqLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgdmEsIHZiLCB2Yyk7XG5cbiAgICAgICAgICAgIC8vICAgICAgICAgdmFyIGQgPSBzaS50ZXN0U2VwQXhpcyh0cmlhbmdsZU5vcm1hbCwgaHVsbEIsIHhpLCBxaSwgeGosIHFqKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgaWYoIWQpe1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgdHJpYW5nbGVOb3JtYWwuc2NhbGUoLTEsIHRyaWFuZ2xlTm9ybWFsKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIGQgPSBzaS50ZXN0U2VwQXhpcyh0cmlhbmdsZU5vcm1hbCwgaHVsbEIsIHhpLCBxaSwgeGosIHFqKTtcblxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgaWYoIWQpe1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgLy8gICAgICAgICB2YXIgcSA9IGNvbnZleENvbnZleF9xO1xuICAgICAgICAgICAgLy8gICAgICAgICBzaS5jbGlwQWdhaW5zdEh1bGwoeGkscWksaHVsbEIseGoscWosdHJpYW5nbGVOb3JtYWwsLTEwMCwxMDAscmVzKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgZm9yKHZhciBqID0gMDsgaiAhPT0gcmVzLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaiksXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgcmkgPSByLnJpLFxuICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgIHJqID0gci5yajtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHIubmkuY29weSh0cmlhbmdsZU5vcm1hbCk7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHJlc1tqXS5ub3JtYWwubmVnYXRlKHEpO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICByai5jb3B5KHJlc1tqXS5wb2ludCk7XG5cbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmVcbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHJpLnZzdWIoeGkscmkpO1xuICAgICAgICAgICAgLy8gICAgICAgICAgICAgcmoudnN1Yih4aixyaik7XG5cbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICByai52YWRkKHhqLCByaik7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG5cbiAgICAgICAgICAgIC8vICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgLy8gICAgICAgICB9XG4gICAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgICAgLy8gfTtcblxuICAgICAgICAgICAgdmFyIHBhcnRpY2xlUGxhbmVfbm9ybWFsID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBwYXJ0aWNsZVBsYW5lX3JlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgcGFydGljbGVQbGFuZVxuICAgICAgICAgICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuUEFSVElDTEVdID1cbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVQYXJ0aWNsZSA9IGZ1bmN0aW9uIChzaiwgc2ksIHhqLCB4aSwgcWosIHFpLCBiaiwgYmkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHBhcnRpY2xlUGxhbmVfbm9ybWFsO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwuc2V0KDAsIDAsIDEpO1xuICAgICAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLnZtdWx0KG5vcm1hbCwgbm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lIG9yaWVudGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWxwb3MgPSBwYXJ0aWNsZVBsYW5lX3JlbHBvcztcbiAgICAgICAgICAgICAgICAgICAgeGkudnN1Yihiai5wb3NpdGlvbiwgcmVscG9zKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvdCA9IG5vcm1hbC5kb3QocmVscG9zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvdCA8PSAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksIGJqLCBzaSwgc2opO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5uaS5jb3B5KG5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS5zZXQoMCwgMCwgMCk7IC8vIENlbnRlciBvZiBwYXJ0aWNsZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvamVjdGVkID0gcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwubXVsdChub3JtYWwuZG90KHhpKSwgcHJvamVjdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhpLnZzdWIocHJvamVjdGVkLCBwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9wcm9qZWN0ZWQudmFkZChiai5wb3NpdGlvbixwcm9qZWN0ZWQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByaiBpcyBub3cgdGhlIHByb2plY3RlZCB3b3JsZCBwb3NpdGlvbiBtaW51cyBwbGFuZSBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgci5yai5jb3B5KHByb2plY3RlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHBhcnRpY2xlU3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQG1ldGhvZCBwYXJ0aWNsZVNwaGVyZVxuICAgICAgICAgICAgICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICAgICAgICAgICAgICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFXSA9XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZVBhcnRpY2xlID0gZnVuY3Rpb24gKHNqLCBzaSwgeGosIHhpLCBxaiwgcWksIGJqLCBiaSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9ybWFsIGlzIHRoZSB1bml0IHZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gcGFydGljbGUgY2VudGVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBwYXJ0aWNsZVNwaGVyZV9ub3JtYWw7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbC5zZXQoMCwgMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHhpLnZzdWIoeGosIG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhTcXVhcmVkID0gbm9ybWFsLm5vcm0yKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aFNxdWFyZWQgPD0gc2oucmFkaXVzICogc2oucmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmouY29weShub3JtYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yai5tdWx0KHNqLnJhZGl1cywgci5yaik7XG4gICAgICAgICAgICAgICAgICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubmVnYXRlKHIubmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS5zZXQoMCwgMCwgMCk7IC8vIENlbnRlciBvZiBwYXJ0aWNsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFdJUFxuICAgICAgICAgICAgdmFyIGNxaiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgICAgICAgICB2YXIgY29udmV4UGFydGljbGVfbG9jYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGNvbnZleFBhcnRpY2xlX25vcm1hbCA9IG5ldyBWZWMzKCk7XG4gICAgICAgICAgICB2YXIgY29udmV4UGFydGljbGVfcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWMgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2QgY29udmV4UGFydGljbGVcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICAgICAgICAgICAgICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICAgICAgICAgICAgICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QQVJUSUNMRSB8IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID1cbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4UGFydGljbGUgPSBmdW5jdGlvbiAoc2osIHNpLCB4aiwgeGksIHFqLCBxaSwgYmosIGJpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZW5ldHJhdGVkRmFjZUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZW5ldHJhdGVkRmFjZU5vcm1hbCA9IGNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsO1xuICAgICAgICAgICAgICAgICAgICB2YXIgd29ybGRQZW5ldHJhdGlvblZlYyA9IGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW5QZW5ldHJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW1EZXRlY3RlZEZhY2VzID0gMDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHBhcnRpY2xlIHBvc2l0aW9uIHhpIHRvIGxvY2FsIGNvb3JkcyBpbiB0aGUgY29udmV4XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbCA9IGNvbnZleFBhcnRpY2xlX2xvY2FsO1xuICAgICAgICAgICAgICAgICAgICBsb2NhbC5jb3B5KHhpKTtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWwudnN1Yih4aiwgbG9jYWwpOyAvLyBDb252ZXJ0IHBvc2l0aW9uIHRvIHJlbGF0aXZlIHRoZSBjb252ZXggb3JpZ2luXG4gICAgICAgICAgICAgICAgICAgIHFqLmNvbmp1Z2F0ZShjcWopO1xuICAgICAgICAgICAgICAgICAgICBjcWoudm11bHQobG9jYWwsIGxvY2FsKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2oucG9pbnRJc0luc2lkZShsb2NhbCkpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNqLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZFZlcnRpY2VzKHhqLCBxaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2oud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2ouY29tcHV0ZVdvcmxkRmFjZU5vcm1hbHMocWopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZWFjaCB3b3JsZCBwb2x5Z29uIGluIHRoZSBwb2x5aGVkcmFcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBuZmFjZXMgPSBzai5mYWNlcy5sZW5ndGg7IGkgIT09IG5mYWNlczsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0cyA9IFtzai53b3JsZFZlcnRpY2VzW3NqLmZhY2VzW2ldWzBdXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vcm1hbCA9IHNqLndvcmxkRmFjZU5vcm1hbHNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBob3cgbXVjaCB0aGUgcGFydGljbGUgcGVuZXRyYXRlcyB0aGUgcG9seWdvbiBwbGFuZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aS52c3ViKHZlcnRzWzBdLCBjb252ZXhQYXJ0aWNsZV92ZXJ0ZXhUb1BhcnRpY2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGVuZXRyYXRpb24gPSAtbm9ybWFsLmRvdChjb252ZXhQYXJ0aWNsZV92ZXJ0ZXhUb1BhcnRpY2xlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluUGVuZXRyYXRpb24gPT09IG51bGwgfHwgTWF0aC5hYnMocGVuZXRyYXRpb24pIDwgTWF0aC5hYnMobWluUGVuZXRyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblBlbmV0cmF0aW9uID0gcGVuZXRyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG51bURldGVjdGVkRmFjZXMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZW5ldHJhdGVkRmFjZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhY3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5tdWx0KG1pblBlbmV0cmF0aW9uLCB3b3JsZFBlbmV0cmF0aW9uVmVjKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJqIGlzIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIGZhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFBlbmV0cmF0aW9uVmVjLnZhZGQoeGksIHdvcmxkUGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aiwgd29ybGRQZW5ldHJhdGlvblZlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yai5jb3B5KHdvcmxkUGVuZXRyYXRpb25WZWMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdmFyIHByb2plY3RlZFRvRmFjZSA9IHhpLnZzdWIoeGopLnZhZGQod29ybGRQZW5ldHJhdGlvblZlYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9wcm9qZWN0ZWRUb0ZhY2UuY29weShyLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcWoudm11bHQoci5yaixyLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5uZWdhdGUoci5uaSk7IC8vIENvbnRhY3Qgbm9ybWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5yaS5zZXQoMCwgMCwgMCk7IC8vIENlbnRlciBvZiBwYXJ0aWNsZVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpID0gci5yaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmogPSByLnJqO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoeGosIHJqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUG9pbnQgZm91bmQgaW5zaWRlIGNvbnZleCwgYnV0IGRpZCBub3QgZmluZCBwZW5ldHJhdGluZyBmYWNlIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRF0gPVxuICAgICAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uIChzaSwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmopIHtcbiAgICAgICAgICAgICAgICAgICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgICAgIHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNpLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZleEhlaWdodGZpZWxkKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgc2osIHhpLCB4aiwgcWksIHFqLCBiaSwgYmopO1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBjb252ZXhIZWlnaHRmaWVsZF90bXAxID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBjb252ZXhIZWlnaHRmaWVsZF90bXAyID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIHZhciBjb252ZXhIZWlnaHRmaWVsZF9mYWNlTGlzdCA9IFswXTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGNvbnZleEhlaWdodGZpZWxkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIE5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cbiAgICAgICAgICAgICAgICBOYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiAoXG4gICAgICAgICAgICAgICAgICAgIGNvbnZleFNoYXBlLFxuICAgICAgICAgICAgICAgICAgICBoZlNoYXBlLFxuICAgICAgICAgICAgICAgICAgICBjb252ZXhQb3MsXG4gICAgICAgICAgICAgICAgICAgIGhmUG9zLFxuICAgICAgICAgICAgICAgICAgICBjb252ZXhRdWF0LFxuICAgICAgICAgICAgICAgICAgICBoZlF1YXQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnZleEJvZHksXG4gICAgICAgICAgICAgICAgICAgIGhmQm9keVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzID0gY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JsZFBpbGxhck9mZnNldCA9IGNvbnZleEhlaWdodGZpZWxkX3RtcDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWNlTGlzdCA9IGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBzcGhlcmUgcG9zaXRpb24gdG8gaGVpZ2h0ZmllbGQgbG9jYWwhXG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbENvbnZleFBvcyA9IGNvbnZleEhlaWdodGZpZWxkX3RtcDE7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBjb252ZXhQb3MsIGxvY2FsQ29udmV4UG9zKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBkYXRhIHBvaW50cyB0byB0ZXN0IGFnYWluc3RcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlNaW5YID0gTWF0aC5mbG9vcigobG9jYWxDb252ZXhQb3MueCAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpTWF4WCA9IE1hdGguY2VpbCgobG9jYWxDb252ZXhQb3MueCArIHJhZGl1cykgLyB3KSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBpTWluWSA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnkgLSByYWRpdXMpIC8gdykgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaU1heFkgPSBNYXRoLmNlaWwoKGxvY2FsQ29udmV4UG9zLnkgKyByYWRpdXMpIC8gdykgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNYXhYIDwgMCB8fCBpTWF4WSA8IDAgfHwgaU1pblggPiBkYXRhLmxlbmd0aCB8fCBpTWluWSA+IGRhdGFbMF0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDbGFtcCBpbmRleCB0byBlZGdlc1xuICAgICAgICAgICAgICAgICAgICBpZiAoaU1pblggPCAwKSB7IGlNaW5YID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaU1heFggPCAwKSB7IGlNYXhYID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaU1pblkgPCAwKSB7IGlNaW5ZID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaU1heFkgPCAwKSB7IGlNYXhZID0gMDsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaU1pblggPj0gZGF0YS5sZW5ndGgpIHsgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNYXhYID49IGRhdGEubGVuZ3RoKSB7IGlNYXhYID0gZGF0YS5sZW5ndGggLSAxOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpTWF4WSA+PSBkYXRhWzBdLmxlbmd0aCkgeyBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaU1pblkgPj0gZGF0YVswXS5sZW5ndGgpIHsgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWluTWF4ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGhmU2hhcGUuZ2V0UmVjdE1pbk1heChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgbWluTWF4KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbiA9IG1pbk1heFswXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1heCA9IG1pbk1heFsxXTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBpZiB3ZSdyZSBjYW50IHRvdWNoIHRoZSBib3VuZGluZyBoZWlnaHQgYm94XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb2NhbENvbnZleFBvcy56IC0gcmFkaXVzID4gbWF4IHx8IGxvY2FsQ29udmV4UG9zLnogKyByYWRpdXMgPCBtaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvd2VyIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwgZmFjZUxpc3QsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwcGVyIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udmV4UG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbnZleENvbnZleChjb252ZXhTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIGNvbnZleFBvcywgd29ybGRQaWxsYXJPZmZzZXQsIGNvbnZleFF1YXQsIGhmUXVhdCwgY29udmV4Qm9keSwgaGZCb2R5LCBudWxsLCBudWxsLCBmYWNlTGlzdCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHNwaGVyZUhlaWdodGZpZWxkX3RtcDEgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgdmFyIHNwaGVyZUhlaWdodGZpZWxkX3RtcDIgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBtZXRob2Qgc3BoZXJlSGVpZ2h0ZmllbGRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEXSA9XG4gICAgICAgICAgICAgICAgTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZUhlaWdodGZpZWxkID0gZnVuY3Rpb24gKFxuICAgICAgICAgICAgICAgICAgICBzcGhlcmVTaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgaGZTaGFwZSxcbiAgICAgICAgICAgICAgICAgICAgc3BoZXJlUG9zLFxuICAgICAgICAgICAgICAgICAgICBoZlBvcyxcbiAgICAgICAgICAgICAgICAgICAgc3BoZXJlUXVhdCxcbiAgICAgICAgICAgICAgICAgICAgaGZRdWF0LFxuICAgICAgICAgICAgICAgICAgICBzcGhlcmVCb2R5LFxuICAgICAgICAgICAgICAgICAgICBoZkJvZHlcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBoZlNoYXBlLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMgPSBzcGhlcmVTaGFwZS5yYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50U2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkUGlsbGFyT2Zmc2V0ID0gc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMjtcblxuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgc3BoZXJlIHBvc2l0aW9uIHRvIGhlaWdodGZpZWxkIGxvY2FsIVxuICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxTcGhlcmVQb3MgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAxO1xuICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUoaGZQb3MsIGhmUXVhdCwgc3BoZXJlUG9zLCBsb2NhbFNwaGVyZVBvcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgICAgICAgICAgICAgICAgIHZhciBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsU3BoZXJlUG9zLnggLSByYWRpdXMpIC8gdykgLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaU1heFggPSBNYXRoLmNlaWwoKGxvY2FsU3BoZXJlUG9zLnggKyByYWRpdXMpIC8gdykgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaU1pblkgPSBNYXRoLmZsb29yKChsb2NhbFNwaGVyZVBvcy55IC0gcmFkaXVzKSAvIHcpIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBpZiB3ZSBhcmUgb3V0IG9mIHRoZSB0ZXJyYWluXG4gICAgICAgICAgICAgICAgICAgIGlmIChpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1heFkgPiBkYXRhWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2xhbXAgaW5kZXggdG8gZWRnZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNaW5YIDwgMCkgeyBpTWluWCA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNYXhYIDwgMCkgeyBpTWF4WCA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNaW5ZIDwgMCkgeyBpTWluWSA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNYXhZIDwgMCkgeyBpTWF4WSA9IDA7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNaW5YID49IGRhdGEubGVuZ3RoKSB7IGlNaW5YID0gZGF0YS5sZW5ndGggLSAxOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpTWF4WCA+PSBkYXRhLmxlbmd0aCkgeyBpTWF4WCA9IGRhdGEubGVuZ3RoIC0gMTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpIHsgaU1heFkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKSB7IGlNaW5ZID0gZGF0YVswXS5sZW5ndGggLSAxOyB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1pbk1heCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaW4gPSBtaW5NYXhbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXggPSBtaW5NYXhbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgY2FudCB0b3VjaCB0aGUgYm91bmRpbmcgaGVpZ2h0IGJveFxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxTcGhlcmVQb3MueiAtIHJhZGl1cyA+IG1heCB8fCBsb2NhbFNwaGVyZVBvcy56ICsgcmFkaXVzIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1Db250YWN0c0JlZm9yZSA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzcGhlcmVQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNwaGVyZVNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwcGVyIHRyaWFuZ2xlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BoZXJlUG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzcGhlcmVTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwaGVyZUNvbnZleChzcGhlcmVTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIHNwaGVyZVBvcywgd29ybGRQaWxsYXJPZmZzZXQsIHNwaGVyZVF1YXQsIGhmUXVhdCwgc3BoZXJlQm9keSwgaGZCb2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbnVtQ29udGFjdHMgPSByZXN1bHQubGVuZ3RoIC0gbnVtQ29udGFjdHNCZWZvcmU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobnVtQ29udGFjdHMgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGFsbCBidXQgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbnVtQ29udGFjdHMgLSAxOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICB9LCB7IFwiLi4vY29sbGlzaW9uL0FBQkJcIjogMywgXCIuLi9jb2xsaXNpb24vUmF5XCI6IDksIFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOiAxOSwgXCIuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvblwiOiAyMSwgXCIuLi9tYXRoL1F1YXRlcm5pb25cIjogMjgsIFwiLi4vbWF0aC9UcmFuc2Zvcm1cIjogMjksIFwiLi4vbWF0aC9WZWMzXCI6IDMwLCBcIi4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uXCI6IDM4LCBcIi4uL3NoYXBlcy9TaGFwZVwiOiA0MywgXCIuLi9zb2x2ZXIvU29sdmVyXCI6IDQ3LCBcIi4uL3V0aWxzL1ZlYzNQb29sXCI6IDU0IH1dLCA1NjogW2Z1bmN0aW9uIChfZGVyZXFfLCBtb2R1bGUsIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIC8qIGdsb2JhbCBwZXJmb3JtYW5jZSAqL1xuXG4gICAgICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG4gICAgICAgICAgICB2YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbiAgICAgICAgICAgIHZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG4gICAgICAgICAgICB2YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xuICAgICAgICAgICAgdmFyIEdTU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL0dTU29sdmVyJyk7XG4gICAgICAgICAgICB2YXIgVmVjM1Bvb2wgPSBfZGVyZXFfKCcuLi91dGlscy9WZWMzUG9vbCcpO1xuICAgICAgICAgICAgdmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbiAgICAgICAgICAgIHZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbiAgICAgICAgICAgIHZhciBOYXJyb3dwaGFzZSA9IF9kZXJlcV8oJy4vTmFycm93cGhhc2UnKTtcbiAgICAgICAgICAgIHZhciBFdmVudFRhcmdldCA9IF9kZXJlcV8oJy4uL3V0aWxzL0V2ZW50VGFyZ2V0Jyk7XG4gICAgICAgICAgICB2YXIgQXJyYXlDb2xsaXNpb25NYXRyaXggPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXgnKTtcbiAgICAgICAgICAgIHZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG4gICAgICAgICAgICB2YXIgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyk7XG4gICAgICAgICAgICB2YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xuICAgICAgICAgICAgdmFyIFR1cGxlRGljdGlvbmFyeSA9IF9kZXJlcV8oJy4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeScpO1xuICAgICAgICAgICAgdmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xuICAgICAgICAgICAgdmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xuICAgICAgICAgICAgdmFyIFJheSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXknKTtcbiAgICAgICAgICAgIHZhciBOYWl2ZUJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHBoeXNpY3Mgd29ybGRcbiAgICAgICAgICAgICAqIEBjbGFzcyBXb3JsZFxuICAgICAgICAgICAgICogQGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBXb3JsZCgpIHtcbiAgICAgICAgICAgICAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEN1cnJlbnRseSAvIGxhc3QgdXNlZCB0aW1lc3RlcC4gSXMgc2V0IHRvIC0xIGlmIG5vdCBhdmFpbGFibGUuIFRoaXMgdmFsdWUgaXMgdXBkYXRlZCBiZWZvcmUgZWFjaCBpbnRlcm5hbCBzdGVwLCB3aGljaCBtZWFucyB0aGF0IGl0IGlzIFwiZnJlc2hcIiBpbnNpZGUgZXZlbnQgY2FsbGJhY2tzLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBkdFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZHQgPSAtMTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE1ha2VzIGJvZGllcyBnbyB0byBzbGVlcCB3aGVuIHRoZXkndmUgYmVlbiBpbmFjdGl2ZVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBhbGxvd1NsZWVwXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5hbGxvd1NsZWVwID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBbGwgdGhlIGN1cnJlbnQgY29udGFjdHMgKGluc3RhbmNlcyBvZiBDb250YWN0RXF1YXRpb24pIGluIHRoZSB3b3JsZC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgY29udGFjdHNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0cyA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEhvdyBvZnRlbiB0byBub3JtYWxpemUgcXVhdGVybmlvbnMuIFNldCB0byAwIGZvciBldmVyeSBzdGVwLCAxIGZvciBldmVyeSBzZWNvbmQgZXRjLi4gQSBsYXJnZXIgdmFsdWUgaW5jcmVhc2VzIHBlcmZvcm1hbmNlLiBJZiBib2RpZXMgdGVuZCB0byBleHBsb2RlLCBzZXQgdG8gYSBzbWFsbGVyIHZhbHVlICh6ZXJvIHRvIGJlIHN1cmUgbm90aGluZyBjYW4gZ28gd3JvbmcpLlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBxdWF0Tm9ybWFsaXplU2tpcFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5xdWF0Tm9ybWFsaXplU2tpcCA9IDA7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBTZXQgdG8gdHJ1ZSB0byB1c2UgZmFzdCBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24uIEl0IGlzIG9mdGVuIGVub3VnaCBhY2N1cmF0ZSB0byB1c2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBmYWxzZS5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgcXVhdE5vcm1hbGl6ZUZhc3RcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAgICAgKiBAc2VlIFF1YXRlcm5pb24ubm9ybWFsaXplRmFzdFxuICAgICAgICAgICAgICAgICAqIEBzZWUgUXVhdGVybmlvbi5ub3JtYWxpemVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnF1YXROb3JtYWxpemVGYXN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBUaGUgd2FsbC1jbG9jayB0aW1lIHNpbmNlIHNpbXVsYXRpb24gc3RhcnRcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgdGltZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy50aW1lID0gMC4wO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogTnVtYmVyIG9mIHRpbWVzdGVwcyB0YWtlbiBzaW5jZSBzdGFydFxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBzdGVwbnVtYmVyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBudW1iZXIgPSAwO1xuXG4gICAgICAgICAgICAgICAgLy8vIERlZmF1bHQgYW5kIGxhc3QgdGltZXN0ZXAgc2l6ZXNcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRfZHQgPSAxIC8gNjA7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm5leHRJZCA9IDA7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGdyYXZpdHlcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmdyYXZpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkcGhhc2UgPSBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgYm9kaWVzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuYm9kaWVzID0gW107XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgc29sdmVyXG4gICAgICAgICAgICAgICAgICogQHR5cGUge1NvbHZlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnNvbHZlciA9IG5ldyBHU1NvbHZlcigpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSBuYXJyb3dwaGFzZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtOYXJyb3dwaGFzZX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm5hcnJvd3BoYXNlID0gbmV3IE5hcnJvd3BoYXNlKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHtBcnJheUNvbGxpc2lvbk1hdHJpeH0gY29sbGlzaW9uTWF0cml4XG4gICAgICAgICAgICAgICAgICogQHR5cGUge0FycmF5Q29sbGlzaW9uTWF0cml4fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWF0cml4ID0gbmV3IEFycmF5Q29sbGlzaW9uTWF0cml4KCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDb2xsaXNpb25NYXRyaXggZnJvbSB0aGUgcHJldmlvdXMgc3RlcC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge0FycmF5Q29sbGlzaW9uTWF0cml4fSBjb2xsaXNpb25NYXRyaXhQcmV2aW91c1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheUNvbGxpc2lvbk1hdHJpeH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gbmV3IEFycmF5Q29sbGlzaW9uTWF0cml4KCk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBbGwgYWRkZWQgbWF0ZXJpYWxzXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IG1hdGVyaWFsc1xuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFscyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGNvbnRhY3RtYXRlcmlhbHNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzID0gW107XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBVc2VkIHRvIGxvb2sgdXAgYSBDb250YWN0TWF0ZXJpYWwgZ2l2ZW4gdHdvIGluc3RhbmNlcyBvZiBNYXRlcmlhbC5cbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkge1R1cGxlRGljdGlvbmFyeX0gY29udGFjdE1hdGVyaWFsVGFibGVcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoXCJkZWZhdWx0XCIpO1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogVGhpcyBjb250YWN0IG1hdGVyaWFsIGlzIHVzZWQgaWYgbm8gc3VpdGFibGUgY29udGFjdG1hdGVyaWFsIGlzIGZvdW5kIGZvciBhIGNvbnRhY3QuXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IGRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Q29udGFjdE1hdGVyaWFsfVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCA9IG5ldyBDb250YWN0TWF0ZXJpYWwodGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHRoaXMuZGVmYXVsdE1hdGVyaWFsLCB7IGZyaWN0aW9uOiAwLjMsIHJlc3RpdHV0aW9uOiAwLjAgfSk7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgZG9Qcm9maWxpbmdcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmRvUHJvZmlsaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAcHJvcGVydHkgcHJvZmlsZVxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9maWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBzb2x2ZTogMCxcbiAgICAgICAgICAgICAgICAgICAgbWFrZUNvbnRhY3RDb25zdHJhaW50czogMCxcbiAgICAgICAgICAgICAgICAgICAgYnJvYWRwaGFzZTogMCxcbiAgICAgICAgICAgICAgICAgICAgaW50ZWdyYXRlOiAwLFxuICAgICAgICAgICAgICAgICAgICBuYXJyb3dwaGFzZTogMCxcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQHByb3BlcnR5IHN1YnN5c3RlbXNcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzeXN0ZW1zID0gW107XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFkZEJvZHlFdmVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhZGRCb2R5XCIsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQm9keUV2ZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJlbW92ZUJvZHlcIixcbiAgICAgICAgICAgICAgICAgICAgYm9keTogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgV29ybGQucHJvdG90eXBlID0gbmV3IEV2ZW50VGFyZ2V0KCk7XG5cbiAgICAgICAgICAgIC8vIFRlbXAgc3R1ZmZcbiAgICAgICAgICAgIHZhciB0bXBBQUJCMSA9IG5ldyBBQUJCKCk7XG4gICAgICAgICAgICB2YXIgdG1wQXJyYXkxID0gW107XG4gICAgICAgICAgICB2YXIgdG1wUmF5ID0gbmV3IFJheSgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgY29udGFjdCBtYXRlcmlhbCBiZXR3ZWVuIG1hdGVyaWFscyBtMSBhbmQgbTJcbiAgICAgICAgICAgICAqIEBtZXRob2QgZ2V0Q29udGFjdE1hdGVyaWFsXG4gICAgICAgICAgICAgKiBAcGFyYW0ge01hdGVyaWFsfSBtMVxuICAgICAgICAgICAgICogQHBhcmFtIHtNYXRlcmlhbH0gbTJcbiAgICAgICAgICAgICAqIEByZXR1cm4ge0NvbnRhY3RNYXRlcmlhbH0gVGhlIGNvbnRhY3QgbWF0ZXJpYWwgaWYgaXQgd2FzIGZvdW5kLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBXb3JsZC5wcm90b3R5cGUuZ2V0Q29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKG0xLCBtMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlLmdldChtMS5pZCwgbTIuaWQpOyAvL3RoaXMuY29udGFjdG1hdGVyaWFsc1t0aGlzLm1hdHMyY21hdFtpK2oqdGhpcy5tYXRlcmlhbHMubGVuZ3RoXV07XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgd29ybGQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIG51bU9iamVjdHNcbiAgICAgICAgICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFdvcmxkLnByb3RvdHlwZS5udW1PYmplY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvZGllcy5sZW5ndGg7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0b3JlIG9sZCBjb2xsaXNpb24gc3RhdGUgaW5mb1xuICAgICAgICAgICAgICogQG1ldGhvZCBjb2xsaXNpb25NYXRyaXhUaWNrXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFdvcmxkLnByb3RvdHlwZS5jb2xsaXNpb25NYXRyaXhUaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wID0gdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cztcbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gdGhpcy5jb2xsaXNpb25NYXRyaXg7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXggPSB0ZW1wO1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGlzaW9uTWF0cml4LnJlc2V0KCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhIHJpZ2lkIGJvZHkgdG8gdGhlIHNpbXVsYXRpb24uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFkZFxuICAgICAgICAgICAgICogQHBhcmFtIHtCb2R5fSBib2R5XG4gICAgICAgICAgICAgKiBAdG9kbyBJZiB0aGUgc2ltdWxhdGlvbiBoYXMgbm90IHlldCBzdGFydGVkLCB3aHkgcmVjcmV0ZSBhbmQgY29weSBhcnJheXMgZm9yIGVhY2ggYm9keT8gQWNjdW11bGF0ZSBpbiBkeW5hbWljIGFycmF5cyBpbiB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgKiBAdG9kbyBBZGRpbmcgYW4gYXJyYXkgb2YgYm9kaWVzIHNob3VsZCBiZSBwb3NzaWJsZS4gVGhpcyB3b3VsZCBzYXZlIHNvbWUgbG9vcHMgdG9vXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLmFkZEJvZHkgaW5zdGVhZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBXb3JsZC5wcm90b3R5cGUuYWRkID0gV29ybGQucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkuaW5kZXggPSB0aGlzLmJvZGllcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdGhpcy5ib2RpZXMucHVzaChib2R5KTtcbiAgICAgICAgICAgICAgICBib2R5LndvcmxkID0gdGhpcztcbiAgICAgICAgICAgICAgICBib2R5LmluaXRQb3NpdGlvbi5jb3B5KGJvZHkucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgIGJvZHkuaW5pdFZlbG9jaXR5LmNvcHkoYm9keS52ZWxvY2l0eSk7XG4gICAgICAgICAgICAgICAgYm9keS50aW1lTGFzdFNsZWVweSA9IHRoaXMudGltZTtcbiAgICAgICAgICAgICAgICBpZiAoYm9keSBpbnN0YW5jZW9mIEJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keS5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgICAgICAgICAgICAgICAgICBib2R5LmluaXRRdWF0ZXJuaW9uLmNvcHkoYm9keS5xdWF0ZXJuaW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyh0aGlzLmJvZGllcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkQm9keUV2ZW50LmJvZHkgPSBib2R5O1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLmFkZEJvZHlFdmVudCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHNpbXVsYXRpb24uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIGFkZENvbnN0cmFpbnRcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Q29uc3RyYWludH0gY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBXb3JsZC5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmVzIGEgY29uc3RyYWludFxuICAgICAgICAgICAgICogQG1ldGhvZCByZW1vdmVDb25zdHJhaW50XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgV29ybGQucHJvdG90eXBlLnJlbW92ZUNvbnN0cmFpbnQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSB0aGlzLmNvbnN0cmFpbnRzLmluZGV4T2YoYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJheWNhc3QgdGVzdFxuICAgICAgICAgICAgICogQG1ldGhvZCByYXlUZXN0XG4gICAgICAgICAgICAgKiBAcGFyYW0ge1ZlYzN9IGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSB7VmVjM30gdG9cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb258UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgLnJheWNhc3RBbGwsIC5yYXljYXN0Q2xvc2VzdCBvciAucmF5Y2FzdEFueSBpbnN0ZWFkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBXb3JsZC5wcm90b3R5cGUucmF5VGVzdCA9IGZ1bmN0aW9uIChmcm9tLCB0bywgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJheWNhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gcmF5Y2FzdGNsb3Nlc3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYXljYXN0Q2xvc2VzdChmcm9tLCB0bywge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEJhY2tmYWNlczogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9LCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIHJheWNhc3RBbGxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yYXljYXN0QWxsKGZyb20sIHRvLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0sIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJheWNhc3RBbGxcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICAgICAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICAgICAgICAgICAgICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFdvcmxkLnByb3RvdHlwZS5yYXljYXN0QWxsID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTEw7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRvID0gdG87XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJheSBjYXN0LCBhbmQgc3RvcCBhdCB0aGUgZmlyc3QgcmVzdWx0LiBOb3RlIHRoYXQgdGhlIG9yZGVyIGlzIHJhbmRvbSAtIGJ1dCB0aGUgbWV0aG9kIGlzIGZhc3QuXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJheWNhc3RBbnlcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICAgICAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICAgICAgICAgICAgICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFdvcmxkLnByb3RvdHlwZS5yYXljYXN0QW55ID0gZnVuY3Rpb24gKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1vZGUgPSBSYXkuQU5ZO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50byA9IHRvO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0bXBSYXkuaW50ZXJzZWN0V29ybGQodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJheSBjYXN0LCBhbmQgcmV0dXJuIGluZm9ybWF0aW9uIG9mIHRoZSBjbG9zZXN0IGhpdC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgcmF5Y2FzdENsb3Nlc3RcbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAgICAgICAgICAgICAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cbiAgICAgICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXG4gICAgICAgICAgICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICAgICAgICAgICAgICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICAgICAgICAgICAgICogQHBhcmFtICB7UmF5Y2FzdFJlc3VsdH0gcmVzdWx0XG4gICAgICAgICAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFdvcmxkLnByb3RvdHlwZS5yYXljYXN0Q2xvc2VzdCA9IGZ1bmN0aW9uIChmcm9tLCB0bywgb3B0aW9ucywgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tb2RlID0gUmF5LkNMT1NFU1Q7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnRvID0gdG87XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLlxuICAgICAgICAgICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIC5yZW1vdmVCb2R5IGluc3RlYWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgV29ybGQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICAgICAgYm9keS53b3JsZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmJvZGllcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICBib2RpZXMgPSB0aGlzLmJvZGllcyxcbiAgICAgICAgICAgICAgICAgICAgaWR4ID0gYm9kaWVzLmluZGV4T2YoYm9keSk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9kaWVzLnNwbGljZShpZHgsIDEpOyAvLyBUb2RvOiBzaG91bGQgdXNlIGEgZ2FyYmFnZSBmcmVlIG1ldGhvZFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29tcHV0ZSBpbmRleFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2RpZXNbaV0uaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhuKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVCb2R5RXZlbnQuYm9keSA9IGJvZHk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW1vdmUgYSByaWdpZCBib2R5IGZyb20gdGhlIHNpbXVsYXRpb24uXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHJlbW92ZUJvZHlcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBXb3JsZC5wcm90b3R5cGUucmVtb3ZlQm9keSA9IFdvcmxkLnByb3RvdHlwZS5yZW1vdmU7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkcyBhIG1hdGVyaWFsIHRvIHRoZSBXb3JsZC5cbiAgICAgICAgICAgICAqIEBtZXRob2QgYWRkTWF0ZXJpYWxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1cbiAgICAgICAgICAgICAqIEB0b2RvIE5lY2Vzc2FyeT9cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgV29ybGQucHJvdG90eXBlLmFkZE1hdGVyaWFsID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFscy5wdXNoKG0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGRzIGEgY29udGFjdCBtYXRlcmlhbCB0byB0aGUgV29ybGRcbiAgICAgICAgICAgICAqIEBtZXRob2QgYWRkQ29udGFjdE1hdGVyaWFsXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0NvbnRhY3RNYXRlcmlhbH0gY21hdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBXb3JsZC5wcm90b3R5cGUuYWRkQ29udGFjdE1hdGVyaWFsID0gZnVuY3Rpb24gKGNtYXQpIHtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBjb250YWN0IG1hdGVyaWFsXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzLnB1c2goY21hdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgY3VycmVudCBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBtYXRlcmlhbCB0YWJsZVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUuc2V0KGNtYXQubWF0ZXJpYWxzWzBdLmlkLCBjbWF0Lm1hdGVyaWFsc1sxXS5pZCwgY21hdCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwZXJmb3JtYW5jZS5ub3cpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm93T2Zmc2V0ID0gcGVyZm9ybWFuY2UudGltaW5nLm5hdmlnYXRpb25TdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGVyZm9ybWFuY2Uubm93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RlcF90bXAxID0gbmV3IFZlYzMoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGVwIHRoZSBwaHlzaWNzIHdvcmxkIGZvcndhcmQgaW4gdGltZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGVyZSBhcmUgdHdvIG1vZGVzLiBUaGUgc2ltcGxlIG1vZGUgaXMgZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvbi4gSW4gdGhpcyBjYXNlIHlvdSBvbmx5IHVzZSB0aGUgZmlyc3QgYXJndW1lbnQuIFRoZSBzZWNvbmQgY2FzZSB1c2VzIGludGVycG9sYXRpb24uIEluIHRoYXQgeW91IGFsc28gcHJvdmlkZSB0aGUgdGltZSBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgdXNlZCwgYXMgd2VsbCBhcyB0aGUgbWF4aW11bSBmaXhlZCB0aW1lc3RlcHMgdG8gdGFrZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIHN0ZXBcbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkdCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGZpeGVkIHRpbWUgc3RlcCBzaXplIHRvIHVzZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZVNpbmNlTGFzdENhbGxlZF0gICAgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgY2FsbGVkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTdWJTdGVwcz0xMF0gICAgICAgICBNYXhpbXVtIG51bWJlciBvZiBmaXhlZCBzdGVwcyB0byB0YWtlIHBlciBmdW5jdGlvbiBjYWxsLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAgICAgKiAgICAgLy8gZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICogICAgIHdvcmxkLnN0ZXAoMS82MCk7XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHNlZSBodHRwOi8vYnVsbGV0cGh5c2ljcy5vcmcvbWVkaWF3aWtpLTEuNS44L2luZGV4LnBocC9TdGVwcGluZ19UaGVfV29ybGRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgV29ybGQucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiAoZHQsIHRpbWVTaW5jZUxhc3RDYWxsZWQsIG1heFN1YlN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgbWF4U3ViU3RlcHMgPSBtYXhTdWJTdGVwcyB8fCAxMDtcbiAgICAgICAgICAgICAgICB0aW1lU2luY2VMYXN0Q2FsbGVkID0gdGltZVNpbmNlTGFzdENhbGxlZCB8fCAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRpbWVTaW5jZUxhc3RDYWxsZWQgPT09IDApIHsgLy8gRml4ZWQsIHNpbXBsZSBzdGVwcGluZ1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTdGVwKGR0KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJbmNyZW1lbnQgdGltZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgKz0gZHQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiBmaXhlZCBzdGVwcyB3ZSBzaG91bGQgaGF2ZSB0YWtlbiBzaW5jZSB0aGUgbGFzdCBzdGVwXG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnRlcm5hbFN0ZXBzID0gTWF0aC5mbG9vcigodGhpcy50aW1lICsgdGltZVNpbmNlTGFzdENhbGxlZCkgLyBkdCkgLSBNYXRoLmZsb29yKHRoaXMudGltZSAvIGR0KTtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxTdGVwcyA9IE1hdGgubWluKGludGVybmFsU3RlcHMsIG1heFN1YlN0ZXBzKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBEbyBzb21lIGZpeGVkIHN0ZXBzIHRvIGNhdGNoIHVwXG4gICAgICAgICAgICAgICAgICAgIHZhciB0MCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gaW50ZXJuYWxTdGVwczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsU3RlcChkdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSB0MCA+IGR0ICogMTAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBzbG93ZXIgdGhhbiByZWFsLXRpbWUuIEJldHRlciBiYWlsIG91dC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCBpbnRlcm5hbCBjbG9ja1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWUgKz0gdGltZVNpbmNlTGFzdENhbGxlZDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIFwiTGVmdCBvdmVyXCIgdGltZSBzdGVwXG4gICAgICAgICAgICAgICAgICAgIHZhciBoID0gdGhpcy50aW1lICUgZHQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoX2Rpdl9kdCA9IGggLyBkdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVycHZlbG8gPSBzdGVwX3RtcDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiAhPT0gYm9kaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IGJvZGllc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLnR5cGUgIT09IEJvZHkuU1RBVElDICYmIGIuc2xlZXBTdGF0ZSAhPT0gQm9keS5TTEVFUElORykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLnBvc2l0aW9uLnZzdWIoYi5wcmV2aW91c1Bvc2l0aW9uLCBpbnRlcnB2ZWxvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnB2ZWxvLnNjYWxlKGhfZGl2X2R0LCBpbnRlcnB2ZWxvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiLnBvc2l0aW9uLnZhZGQoaW50ZXJwdmVsbywgYi5pbnRlcnBvbGF0ZWRQb3NpdGlvbik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBpbnRlcnBvbGF0ZSBxdWF0ZXJuaW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYi5pbnRlcnBvbGF0ZWRBbmdsZSA9IGIuYW5nbGUgKyAoYi5hbmdsZSAtIGIucHJldmlvdXNBbmdsZSkgKiBoX2Rpdl9kdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBzdGF0aWMgYm9kaWVzLCBqdXN0IGNvcHkuIFdobyBlbHNlIHdpbGwgZG8gaXQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRQb3NpdGlvbi5jb3B5KGIucG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIuaW50ZXJwb2xhdGVkUXVhdGVybmlvbi5jb3B5KGIucXVhdGVybmlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0ZXAgdGhlIHNpbXVsYXRpb25cbiAgICAgICAgICAgICAqIEBtZXRob2Qgc3RlcFxuICAgICAgICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGR0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBXb3JsZF9zdGVwX3Bvc3RTdGVwRXZlbnQgPSB7IHR5cGU6IFwicG9zdFN0ZXBcIiB9LCAvLyBSZXVzYWJsZSBldmVudCBvYmplY3RzIHRvIHNhdmUgbWVtb3J5XG4gICAgICAgICAgICAgICAgV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQgPSB7IHR5cGU6IFwicHJlU3RlcFwiIH0sXG4gICAgICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQgPSB7IHR5cGU6IFwiY29sbGlkZVwiLCBib2R5OiBudWxsLCBjb250YWN0OiBudWxsIH0sXG4gICAgICAgICAgICAgICAgV29ybGRfc3RlcF9vbGRDb250YWN0cyA9IFtdLCAvLyBQb29scyBmb3IgdW51c2VkIG9iamVjdHNcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX2ZyaWN0aW9uRXF1YXRpb25Qb29sID0gW10sXG4gICAgICAgICAgICAgICAgV29ybGRfc3RlcF9wMSA9IFtdLCAvLyBSZXVzYWJsZSBhcnJheXMgZm9yIGNvbGxpc2lvbiBwYWlyc1xuICAgICAgICAgICAgICAgIFdvcmxkX3N0ZXBfcDIgPSBbXSxcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX2d2ZWMgPSBuZXcgVmVjMygpLCAvLyBUZW1wb3JhcnkgdmVjdG9ycyBhbmQgcXVhdHNcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX3ZpID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX3ZqID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX3dpID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX3dqID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX3QxID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX3QyID0gbmV3IFZlYzMoKSxcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX3JpeG4gPSBuZXcgVmVjMygpLFxuICAgICAgICAgICAgICAgIFdvcmxkX3N0ZXBfcmp4biA9IG5ldyBWZWMzKCksXG4gICAgICAgICAgICAgICAgV29ybGRfc3RlcF9zdGVwX3EgPSBuZXcgUXVhdGVybmlvbigpLFxuICAgICAgICAgICAgICAgIFdvcmxkX3N0ZXBfc3RlcF93ID0gbmV3IFF1YXRlcm5pb24oKSxcbiAgICAgICAgICAgICAgICBXb3JsZF9zdGVwX3N0ZXBfd3EgPSBuZXcgUXVhdGVybmlvbigpLFxuICAgICAgICAgICAgICAgIGludklfdGF1X2R0ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIFdvcmxkLnByb3RvdHlwZS5pbnRlcm5hbFN0ZXAgPSBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmR0ID0gZHQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgd29ybGQgPSB0aGlzLFxuICAgICAgICAgICAgICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdHMgPSB0aGlzLmNvbnRhY3RzLFxuICAgICAgICAgICAgICAgICAgICBwMSA9IFdvcmxkX3N0ZXBfcDEsXG4gICAgICAgICAgICAgICAgICAgIHAyID0gV29ybGRfc3RlcF9wMixcbiAgICAgICAgICAgICAgICAgICAgTiA9IHRoaXMubnVtT2JqZWN0cygpLFxuICAgICAgICAgICAgICAgICAgICBib2RpZXMgPSB0aGlzLmJvZGllcyxcbiAgICAgICAgICAgICAgICAgICAgc29sdmVyID0gdGhpcy5zb2x2ZXIsXG4gICAgICAgICAgICAgICAgICAgIGdyYXZpdHkgPSB0aGlzLmdyYXZpdHksXG4gICAgICAgICAgICAgICAgICAgIGRvUHJvZmlsaW5nID0gdGhpcy5kb1Byb2ZpbGluZyxcbiAgICAgICAgICAgICAgICAgICAgcHJvZmlsZSA9IHRoaXMucHJvZmlsZSxcbiAgICAgICAgICAgICAgICAgICAgRFlOQU1JQyA9IEJvZHkuRFlOQU1JQyxcbiAgICAgICAgICAgICAgICAgICAgcHJvZmlsaW5nU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyxcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2wgPSBXb3JsZF9zdGVwX2ZyaWN0aW9uRXF1YXRpb25Qb29sLFxuICAgICAgICAgICAgICAgICAgICBnbm9ybSA9IGdyYXZpdHkubm9ybSgpLFxuICAgICAgICAgICAgICAgICAgICBneCA9IGdyYXZpdHkueCxcbiAgICAgICAgICAgICAgICAgICAgZ3kgPSBncmF2aXR5LnksXG4gICAgICAgICAgICAgICAgICAgIGd6ID0gZ3Jhdml0eS56LFxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcblxuICAgICAgICAgICAgICAgIGlmIChkb1Byb2ZpbGluZykge1xuICAgICAgICAgICAgICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBncmF2aXR5IHRvIGFsbCBvYmplY3RzXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpLnR5cGUgJiBEWU5BTUlDKSB7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGJpLmZvcmNlLCBtID0gYmkubWFzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGYueCArPSBtICogZ3g7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnkgKz0gbSAqIGd5O1xuICAgICAgICAgICAgICAgICAgICAgICAgZi56ICs9IG0gKiBnejtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBzdWJzeXN0ZW1zXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIE5zdWJzeXN0ZW1zID0gdGhpcy5zdWJzeXN0ZW1zLmxlbmd0aDsgaSAhPT0gTnN1YnN5c3RlbXM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnN5c3RlbXNbaV0udXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ29sbGlzaW9uIGRldGVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChkb1Byb2ZpbGluZykgeyBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpOyB9XG4gICAgICAgICAgICAgICAgcDEubGVuZ3RoID0gMDsgLy8gQ2xlYW4gdXAgcGFpciBhcnJheXMgZnJvbSBsYXN0IHN0ZXBcbiAgICAgICAgICAgICAgICBwMi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRwaGFzZS5jb2xsaXNpb25QYWlycyh0aGlzLCBwMSwgcDIpO1xuICAgICAgICAgICAgICAgIGlmIChkb1Byb2ZpbGluZykgeyBwcm9maWxlLmJyb2FkcGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0OyB9XG5cbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXG4gICAgICAgICAgICAgICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWMuY29sbGlkZUNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IHAxLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChjLmJvZHlBID09PSBwMVtqXSAmJiBjLmJvZHlCID09PSBwMltqXSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGMuYm9keUIgPT09IHAxW2pdICYmIGMuYm9keUEgPT09IHAyW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwMS5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHAyLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNvbGxpc2lvbk1hdHJpeFRpY2soKTtcblxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGNvbnRhY3RzXG4gICAgICAgICAgICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7IHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7IH1cbiAgICAgICAgICAgICAgICB2YXIgb2xkY29udGFjdHMgPSBXb3JsZF9zdGVwX29sZENvbnRhY3RzO1xuICAgICAgICAgICAgICAgIHZhciBOb2xkQ29udGFjdHMgPSBjb250YWN0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOb2xkQ29udGFjdHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvbGRjb250YWN0cy5wdXNoKGNvbnRhY3RzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGFjdHMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIC8vIFRyYW5zZmVyIEZyaWN0aW9uRXF1YXRpb24gZnJvbSBjdXJyZW50IGxpc3QgdG8gdGhlIHBvb2wgZm9yIHJldXNlXG4gICAgICAgICAgICAgICAgdmFyIE5vbGRGcmljdGlvbkVxdWF0aW9ucyA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgIT09IE5vbGRGcmljdGlvbkVxdWF0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyaWN0aW9uRXF1YXRpb25Qb29sLnB1c2godGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvbnMubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgICAgIHRoaXMubmFycm93cGhhc2UuZ2V0Q29udGFjdHMoXG4gICAgICAgICAgICAgICAgICAgIHAxLFxuICAgICAgICAgICAgICAgICAgICBwMixcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdHMsXG4gICAgICAgICAgICAgICAgICAgIG9sZGNvbnRhY3RzLCAvLyBUbyBiZSByZXVzZWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2xcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGUubmFycm93cGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIExvb3Agb3ZlciBhbGwgY29sbGlzaW9uc1xuICAgICAgICAgICAgICAgIGlmIChkb1Byb2ZpbGluZykge1xuICAgICAgICAgICAgICAgICAgICBwcm9maWxpbmdTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCBhbGwgZnJpY3Rpb24gZXFzXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbih0aGlzLmZyaWN0aW9uRXF1YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgbmNvbnRhY3RzID0gY29udGFjdHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrICE9PSBuY29udGFjdHM7IGsrKykge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgY29udGFjdFxuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbnRhY3RzW2tdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBpbmRlY2VzXG4gICAgICAgICAgICAgICAgICAgIHZhciBiaSA9IGMuYmksXG4gICAgICAgICAgICAgICAgICAgICAgICBiaiA9IGMuYmosXG4gICAgICAgICAgICAgICAgICAgICAgICBzaSA9IGMuc2ksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaiA9IGMuc2o7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNvbGxpc2lvbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbSA9IHRoaXMuZ2V0Q29udGFjdE1hdGVyaWFsKGJpLm1hdGVyaWFsLCBiai5tYXRlcmlhbCkgfHwgdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY20gPSB0aGlzLmRlZmF1bHRDb250YWN0TWF0ZXJpYWw7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbXUgPSBjbS5mcmljdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgLy8gYy5yZXN0aXR1dGlvbiA9IGNtLnJlc3RpdHV0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGZyaWN0aW9uIG9yIHJlc3RpdHV0aW9uIHdlcmUgc3BlY2lmaWVkIGluIHRoZSBtYXRlcmlhbCwgdXNlIHRoZW1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmkubWF0ZXJpYWwuZnJpY3Rpb24gPj0gMCAmJiBiai5tYXRlcmlhbC5mcmljdGlvbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXUgPSBiaS5tYXRlcmlhbC5mcmljdGlvbiAqIGJqLm1hdGVyaWFsLmZyaWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmkubWF0ZXJpYWwucmVzdGl0dXRpb24gPj0gMCAmJiBiai5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5yZXN0aXR1dGlvbiA9IGJpLm1hdGVyaWFsLnJlc3RpdHV0aW9uICogYmoubWF0ZXJpYWwucmVzdGl0dXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBjLnNldFNwb29rUGFyYW1zKFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIGR0XG4gICAgICAgICAgICAgICAgICAgIC8vICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgc29sdmVyLmFkZEVxdWF0aW9uKGMpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIC8vIEFkZCBmcmljdGlvbiBjb25zdHJhaW50IGVxdWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKG11ID4gMCl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gXHQvLyBDcmVhdGUgMiB0YW5nZW50IGVxdWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyBcdHZhciBtdWcgPSBtdSAqIGdub3JtO1xuICAgICAgICAgICAgICAgICAgICAvLyBcdHZhciByZWR1Y2VkTWFzcyA9IChiaS5pbnZNYXNzICsgYmouaW52TWFzcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFx0aWYocmVkdWNlZE1hc3MgPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gXHRcdHJlZHVjZWRNYXNzID0gMS9yZWR1Y2VkTWFzcztcbiAgICAgICAgICAgICAgICAgICAgLy8gXHR9XG4gICAgICAgICAgICAgICAgICAgIC8vIFx0dmFyIHBvb2wgPSBmcmljdGlvbkVxdWF0aW9uUG9vbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gXHR2YXIgYzEgPSBwb29sLmxlbmd0aCA/IHBvb2wucG9wKCkgOiBuZXcgRnJpY3Rpb25FcXVhdGlvbihiaSxiaixtdWcqcmVkdWNlZE1hc3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBcdHZhciBjMiA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJpLGJqLG11ZypyZWR1Y2VkTWFzcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFx0dGhpcy5mcmljdGlvbkVxdWF0aW9ucy5wdXNoKGMxLCBjMik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gXHRjMS5iaSA9IGMyLmJpID0gYmk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFx0YzEuYmogPSBjMi5iaiA9IGJqO1xuICAgICAgICAgICAgICAgICAgICAvLyBcdGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzO1xuICAgICAgICAgICAgICAgICAgICAvLyBcdGMxLm1heEZvcmNlID0gYzIubWF4Rm9yY2UgPSBtdWcqcmVkdWNlZE1hc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gXHQvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gXHRjMS5yaS5jb3B5KGMucmkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBcdGMxLnJqLmNvcHkoYy5yaik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFx0YzIucmkuY29weShjLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gXHRjMi5yai5jb3B5KGMucmopO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFx0Ly8gQ29uc3RydWN0IHRhbmdlbnRzXG4gICAgICAgICAgICAgICAgICAgIC8vIFx0Yy5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcblxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgLy8gU2V0IHNwb29rIHBhcmFtc1xuICAgICAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIGMyLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCBkdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgIGMxLmVuYWJsZWQgPSBjMi5lbmFibGVkID0gYy5lbmFibGVkO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFx0Ly8gQWRkIGVxdWF0aW9ucyB0byBzb2x2ZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gXHRzb2x2ZXIuYWRkRXF1YXRpb24oYzEpO1xuICAgICAgICAgICAgICAgICAgICAvLyBcdHNvbHZlci5hZGRFcXVhdGlvbihjMik7XG4gICAgICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoYmkuYWxsb3dTbGVlcCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYmkudHlwZSA9PT0gQm9keS5EWU5BTUlDICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBiaS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBiai5zbGVlcFN0YXRlID09PSBCb2R5LkFXQUtFICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBiai50eXBlICE9PSBCb2R5LlNUQVRJQ1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gYmoudmVsb2NpdHkubm9ybTIoKSArIGJqLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQiA9IE1hdGgucG93KGJqLnNsZWVwU3BlZWRMaW1pdCwgMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BlZWRTcXVhcmVkQiA+PSBzcGVlZExpbWl0U3F1YXJlZEIgKiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGJqLmFsbG93U2xlZXAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGJqLnR5cGUgPT09IEJvZHkuRFlOQU1JQyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYmouc2xlZXBTdGF0ZSA9PT0gQm9keS5TTEVFUElORyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYmkuc2xlZXBTdGF0ZSA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYmkudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BlZWRTcXVhcmVkQSA9IGJpLnZlbG9jaXR5Lm5vcm0yKCkgKyBiaS5hbmd1bGFyVmVsb2NpdHkubm9ybTIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcGVlZExpbWl0U3F1YXJlZEEgPSBNYXRoLnBvdyhiaS5zbGVlcFNwZWVkTGltaXQsIDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBICogMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJqLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyB3ZSBrbm93IHRoYXQgaSBhbmQgaiBhcmUgaW4gY29udGFjdC4gU2V0IGNvbGxpc2lvbiBtYXRyaXggc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0KGJpLCBiaiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzLmdldChiaSwgYmopKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBjb250YWN0IVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmV1c2UgdGhlIGNvbGxpZGVFdmVudCBvYmplY3QsIG90aGVyd2lzZSB3ZSB3aWxsIGVuZCB1cCBjcmVhdGluZyBuZXcgb2JqZWN0cyBmb3IgZWFjaCBuZXcgY29udGFjdCwgZXZlbiBpZiB0aGVyZSdzIG5vIGV2ZW50IGxpc3RlbmVyIGF0dGFjaGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJqO1xuICAgICAgICAgICAgICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuY29udGFjdCA9IGM7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaS5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQuYm9keSA9IGJpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmouZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGUubWFrZUNvbnRhY3RDb25zdHJhaW50cyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2FrZSB1cCBib2RpZXNcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJpLndha2VVcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmkuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEFkZCB1c2VyLWFkZGVkIGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOY29uc3RyYWludHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgTmVxID0gYy5lcXVhdGlvbnMubGVuZ3RoOyBqICE9PSBOZXE7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVxID0gYy5lcXVhdGlvbnNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24oZXEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gU29sdmUgdGhlIGNvbnN0cmFpbmVkIHN5c3RlbVxuICAgICAgICAgICAgICAgIHNvbHZlci5zb2x2ZShkdCwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZG9Qcm9maWxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZmlsZS5zb2x2ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBjb250YWN0cyBmcm9tIHNvbHZlclxuICAgICAgICAgICAgICAgIHNvbHZlci5yZW1vdmVBbGxFcXVhdGlvbnMoKTtcblxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGRhbXBpbmcsIHNlZSBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYnVsbGV0L2lzc3Vlcy9kZXRhaWw/aWQ9NzQgZm9yIGRldGFpbHNcbiAgICAgICAgICAgICAgICB2YXIgcG93ID0gTWF0aC5wb3c7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpLnR5cGUgJiBEWU5BTUlDKSB7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGQgPSBwb3coMS4wIC0gYmkubGluZWFyRGFtcGluZywgZHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHYgPSBiaS52ZWxvY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYubXVsdChsZCwgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXYgPSBiaS5hbmd1bGFyVmVsb2NpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWQgPSBwb3coMS4wIC0gYmkuYW5ndWxhckRhbXBpbmcsIGR0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdi5tdWx0KGFkLCBhdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHByZS1zdGVwIGNhbGxiYWNrc1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgIT09IE47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaS5wcmVTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBiaS5wcmVTdGVwLmNhbGwoYmkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTGVhcCBmcm9nXG4gICAgICAgICAgICAgICAgLy8gdm5ldyA9IHYgKyBoKmYvbVxuICAgICAgICAgICAgICAgIC8vIHhuZXcgPSB4ICsgaCp2bmV3XG4gICAgICAgICAgICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBxID0gV29ybGRfc3RlcF9zdGVwX3E7XG4gICAgICAgICAgICAgICAgdmFyIHcgPSBXb3JsZF9zdGVwX3N0ZXBfdztcbiAgICAgICAgICAgICAgICB2YXIgd3EgPSBXb3JsZF9zdGVwX3N0ZXBfd3E7XG4gICAgICAgICAgICAgICAgdmFyIHN0ZXBudW1iZXIgPSB0aGlzLnN0ZXBudW1iZXI7XG4gICAgICAgICAgICAgICAgdmFyIERZTkFNSUNfT1JfS0lORU1BVElDID0gQm9keS5EWU5BTUlDIHwgQm9keS5LSU5FTUFUSUM7XG4gICAgICAgICAgICAgICAgdmFyIHF1YXROb3JtYWxpemUgPSBzdGVwbnVtYmVyICUgKHRoaXMucXVhdE5vcm1hbGl6ZVNraXAgKyAxKSA9PT0gMDtcbiAgICAgICAgICAgICAgICB2YXIgcXVhdE5vcm1hbGl6ZUZhc3QgPSB0aGlzLnF1YXROb3JtYWxpemVGYXN0O1xuICAgICAgICAgICAgICAgIHZhciBoYWxmX2R0ID0gZHQgKiAwLjU7XG4gICAgICAgICAgICAgICAgdmFyIFBMQU5FID0gU2hhcGUudHlwZXMuUExBTkUsXG4gICAgICAgICAgICAgICAgICAgIENPTlZFWCA9IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST047XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZSA9IGIuZm9yY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXUgPSBiLnRvcnF1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChiLnR5cGUgJiBEWU5BTUlDX09SX0tJTkVNQVRJQykgJiYgYi5zbGVlcFN0YXRlICE9PSBCb2R5LlNMRUVQSU5HKSB7IC8vIE9ubHkgZm9yIGR5bmFtaWNcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZWxvID0gYi52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyVmVsbyA9IGIuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IGIucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhdCA9IGIucXVhdGVybmlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZNYXNzID0gYi5pbnZNYXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludkluZXJ0aWEgPSBiLmludkluZXJ0aWFXb3JsZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmVsby54ICs9IGZvcmNlLnggKiBpbnZNYXNzICogZHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ZWxvLnkgKz0gZm9yY2UueSAqIGludk1hc3MgKiBkdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlbG8ueiArPSBmb3JjZS56ICogaW52TWFzcyAqIGR0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5hbmd1bGFyVmVsb2NpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZJbmVydGlhLnZtdWx0KHRhdSwgaW52SV90YXVfZHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludklfdGF1X2R0Lm11bHQoZHQsIGludklfdGF1X2R0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZJX3RhdV9kdC52YWRkKGFuZ3VsYXJWZWxvLCBhbmd1bGFyVmVsbyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSBuZXcgdmVsb2NpdHkgIC0gbGVhcCBmcm9nXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MueCArPSB2ZWxvLnggKiBkdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy55ICs9IHZlbG8ueSAqIGR0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zLnogKz0gdmVsby56ICogZHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiLmFuZ3VsYXJWZWxvY2l0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcuc2V0KGFuZ3VsYXJWZWxvLngsIGFuZ3VsYXJWZWxvLnksIGFuZ3VsYXJWZWxvLnosIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHcubXVsdChxdWF0LCB3cSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhdC54ICs9IGhhbGZfZHQgKiB3cS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1YXQueSArPSBoYWxmX2R0ICogd3EueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWF0LnogKz0gaGFsZl9kdCAqIHdxLno7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhdC53ICs9IGhhbGZfZHQgKiB3cS53O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWF0Tm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWF0Tm9ybWFsaXplRmFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVhdC5ub3JtYWxpemVGYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWF0Lm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYi5hYWJiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi5hYWJiTmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd29ybGQgaW5lcnRpYVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGIudXBkYXRlSW5lcnRpYVdvcmxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYi51cGRhdGVJbmVydGlhV29ybGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyRm9yY2VzKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkcGhhc2UuZGlydHkgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRvUHJvZmlsaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2ZpbGUuaW50ZWdyYXRlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgd29ybGQgdGltZVxuICAgICAgICAgICAgICAgIHRoaXMudGltZSArPSBkdDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXBudW1iZXIgKz0gMTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChXb3JsZF9zdGVwX3Bvc3RTdGVwRXZlbnQpO1xuXG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHBvc3Qtc3RlcCBjYWxsYmFja3NcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcG9zdFN0ZXAgPSBiaS5wb3N0U3RlcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc3RTdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0U3RlcC5jYWxsKGJpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNsZWVwaW5nIHVwZGF0ZVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93U2xlZXApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib2RpZXNbaV0uc2xlZXBUaWNrKHRoaXMudGltZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldHMgYWxsIGJvZHkgZm9yY2VzIGluIHRoZSB3b3JsZCB0byB6ZXJvLlxuICAgICAgICAgICAgICogQG1ldGhvZCBjbGVhckZvcmNlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBXb3JsZC5wcm90b3R5cGUuY2xlYXJGb3JjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuICAgICAgICAgICAgICAgIHZhciBOID0gYm9kaWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gTjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2UgPSBiLmZvcmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGF1ID0gYi50b3JxdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgYi5mb3JjZS5zZXQoMCwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGIudG9ycXVlLnNldCgwLCAwLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0sIHsgXCIuLi9jb2xsaXNpb24vQUFCQlwiOiAzLCBcIi4uL2NvbGxpc2lvbi9BcnJheUNvbGxpc2lvbk1hdHJpeFwiOiA0LCBcIi4uL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjogNywgXCIuLi9jb2xsaXNpb24vUmF5XCI6IDksIFwiLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHRcIjogMTAsIFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOiAxOSwgXCIuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvblwiOiAyMSwgXCIuLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWxcIjogMjQsIFwiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjogMjUsIFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6IDI4LCBcIi4uL21hdGgvVmVjM1wiOiAzMCwgXCIuLi9vYmplY3RzL0JvZHlcIjogMzEsIFwiLi4vc2hhcGVzL1NoYXBlXCI6IDQzLCBcIi4uL3NvbHZlci9HU1NvbHZlclwiOiA0NiwgXCIuLi91dGlscy9FdmVudFRhcmdldFwiOiA0OSwgXCIuLi91dGlscy9UdXBsZURpY3Rpb25hcnlcIjogNTIsIFwiLi4vdXRpbHMvVmVjM1Bvb2xcIjogNTQsIFwiLi9OYXJyb3dwaGFzZVwiOiA1NSB9XVxuICAgIH0sIHt9LCBbMl0pXG4gICAgICAgICgyKVxufSk7IiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgcGFyc2UoY21kKSB7XHJcbiAgICBsZXQgd29yZHMgPSBjbWQuc3BsaXQoXCIgXCIpXHJcbiAgICBsZXQgYXJncyA9IFtdXHJcbiAgICBmb3IgKGxldCB3b3JkIG9mIHdvcmRzKSB7XHJcbiAgICAgIGlmICh3b3JkKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGFyZ3MucHVzaChKU09OLnBhcnNlKHdvcmQpKVxyXG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICBpZiAod29yZCAhPT0gXCI9XCIpXHJcbiAgICAgICAgICAgIGFyZ3MucHVzaCh3b3JkKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyZ3NcclxuICB9LFxyXG4gIHN0cmluZ2lmeVBhcmFtKHZhbCkge1xyXG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCkucmVwbGFjZUFsbChcIiBcIiwgXCJcXFxcdTAwMjBcIikucmVwbGFjZUFsbChcIlxcXCJfXCIsIFwiXFxcIlwiKVxyXG4gIH1cclxufSJdfQ==
