(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
/* global AFRAME, THREE, CANNON */
if (typeof window !== "undefined")
  return

const cmd = require("./libs/cmdCodec")

global.CANNON = require("./libs/cannon")
global.world = new CANNON.World()
global.bodies = []
global.movingBodies = []
global.joints = []

let vec = new CANNON.Vec3()
let quat = new CANNON.Quaternion()
let cyloff = new CANNON.Quaternion()
let lastStep = 0

function init() {
  cyloff.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2)
  addEventListener("message", onMessage)
}

function onMessage(e) {
  if (typeof e.data === "string") {
    let command = cmd.parse(e.data)
    switch (command.shift()) {
      case "world":
        worldCommand(command)
        break
    }
  }
  else if (e.data instanceof Float64Array) {
    let buffer = e.data
    let now = Date.now()
    for (let mid = 0; mid < movingBodies.length; mid++) {
      let body = movingBodies[mid]
      let p = mid * 8
      if (!body) continue
      if (body.type === CANNON.Body.KINEMATIC) {
        vec.set(buffer[p++], buffer[p++], buffer[p++])
        body.position.copy(vec)
        buffer[p++] = body.sleepState === CANNON.Body.SLEEPING
        quat.set(buffer[p++], buffer[p++], buffer[p++], buffer[p++])
        body.quaternion.copy(quat)
      }
    }
    if (now - lastStep < 128) {
      world.step((now - lastStep) / 1000)
    }
    for (let mid = 0; mid < movingBodies.length; mid++) {
      let body = movingBodies[mid]
      let p = mid * 8
      if (!body) continue
      if (body.type !== CANNON.Body.KINEMATIC) {
        buffer[p++] = body.position.x
        buffer[p++] = body.position.y
        buffer[p++] = body.position.z
        buffer[p++] = body.sleepState === CANNON.Body.SLEEPING
        buffer[p++] = body.quaternion.x
        buffer[p++] = body.quaternion.y
        buffer[p++] = body.quaternion.z
        buffer[p++] = body.quaternion.w
      }
    }
    postMessage(buffer, [buffer.buffer])
    lastStep = now
  }
}

function worldCommand(params) {
  if (typeof params[0] === "number") {
    params.shift()
  }
  switch (params.shift()) {
    case "body":
      bodyCommand(params)
      break
    case "joint":
      jointCommand(params)
      break
    case "gravity":
      world.gravity.copy(params[0])
      break
  }
}

function bodyCommand(params) {
  let id = params.shift()
  let body = bodies[id]
  if (!body && params[0] !== "create") return
  switch (params.shift()) {
    case "shape":
      shapeCommand(body, params)
      break
    case "create":
      if (body) {
        world.removeBody(body)
        if (body._mid_ !== null)
          movingBodies[body._mid_] = null
      }
      body = new CANNON.Body({
        type: params[0].type === "dynamic" ? CANNON.Body.DYNAMIC : params[0].type === "kinematic" ? CANNON.Body.KINEMATIC : CANNON.Body.STATIC,
        sleepSpeedLimit: 1,
        position: new CANNON.Vec3().copy(params[0].position),
        quaternion: new CANNON.Quaternion().copy(params[0].quaternion),
      })
      body._id_ = id
      body._mid_ = params[0].mid
      if (body._mid_ !== null)
        movingBodies[body._mid_] = body
      body._shapes_ = []
      world.addBody(bodies[id] = body)
      break
    case "remove":
      world.removeBody(body)
      bodies[id] = null
      if (body._mid_ !== null)
        movingBodies[body._mid_] = null
      break
    case "position":
      body.position.copy(params[0])
      break
    case "quaternion":
      body.quaternion.copy(params[0])
      break
    case "type":
      body.type = params[0] === "dynamic" ? CANNON.Body.DYNAMIC : params[0] === "kinematic" ? CANNON.Body.KINEMATIC : CANNON.Body.STATIC
      break
    case "mass":
      body.mass = body.type === CANNON.Body.STATIC ? 0 : params[0]
      body.updateMassProperties()
      break
    case "belongsTo":
      body.collisionFilterGroup = params[0]
      break
    case "collidesWith":
      body.collisionFilterMask = params[0]
      break
    case "emitsWith":
      if (params[0] && !body._emitsWith_) {
        body.addEventListener("collide", onCollide)
      }
      if (body._emitsWith_ && !params[0]) {
        body.removeEventListener("collide", onCollide)
      }
      body._emitsWith_ = params[0]
      break
    case "sleeping":
      if (params[0]) body.sleep()
      else body.wakeUp()
      break
  }
}

function jointCommand(params) {
  let id = params.shift()
  let joint = joints[id]
  if (!joint && params[0] !== "create") return
  switch (params.shift()) {
    case "create":
      if (joint) {
        world.removeConstraint(joint)
      }
      switch (params[0].type) {
        case "hinge":
          joint = new CANNON.HingeConstraint(
            bodies[params[0].body1],
            bodies[params[0].body2],
            {
              pivotA: new CANNON.Vec3().copy(params[0].pivot1),
              pivotB: new CANNON.Vec3().copy(params[0].pivot2),
              axisA: new CANNON.Vec3().copy(params[0].axis1),
              axisB: new CANNON.Vec3().copy(params[0].axis2)
            }
          )
          break
        case "distance":
          joint = new CANNON.DistanceConstraint(
            bodies[params[0].body1],
            bodies[params[0].body2]
          )
          break

        default:
          joint = new CANNON.PointToPointConstraint(
            bodies[params[0].body1],
            new CANNON.Vec3().copy(params[0].pivot1),
            bodies[params[0].body2],
            new CANNON.Vec3().copy(params[0].pivot2)
          )
          break
      }
      joint.collideConnected = params[0].collision
      joint._id_ = id
      world.addConstraint(joints[id] = joint)
      break
    case "remove":
      world.removeConstraint(joint)
      joints[id] = null
      break
  }
}

function shapeCommand(body, params) {
  if (!body) return
  let id = params.shift()
  let shape = body._shapes_[id]
  if (!shape && params[0] !== "create") return
  switch (params.shift()) {
    case "create":
      if (shape)
        body.removeShape(shape)
      let quat = (new CANNON.Quaternion()).copy(params[0].quaternion)
      switch (params[0].type) {
        case "sphere": shape = new CANNON.Sphere(params[0].size.x / 2); break
        case "cylinder": shape = new CANNON.Cylinder(params[0].size.x / 2, params[0].size.x / 2, params[0].size.y, 16); quat.mult(cyloff, quat); break
        default: shape = new CANNON.Box(new CANNON.Vec3().copy(params[0].size).scale(0.5))
      }
      shape._id_ = id
      body.addShape(body._shapes_[id] = shape, (new CANNON.Vec3()).copy(params[0].position), quat)
      body.updateMassProperties()
      break
    case "remove":
      body.removeShape(shape)
      body._shapes_[id] = null
      body.updateMassProperties()
      break
  }
}




function onCollide(e) {
  let b1 = e.contact.bi
  let b2 = e.contact.bj
  if (this === b1 && (b1._emitsWith_ & b2.collisionFilterGroup)) {
    postMessage("world body " + b1._id_ + " emits " + cmd.stringifyParam({
      event: "collision",
      body1: b1._id_,
      body2: b2._id_,
      shape1: e.contact.si._id_,
      shape2: e.contact.sj._id_
    }))
  }
  if (this === b2 && (b2._emitsWith_ & b1.collisionFilterGroup)) {
    postMessage("world body " + b2._id_ + " emits " + cmd.stringifyParam({
      event: "collision",
      body1: b2._id_,
      body2: b1._id_,
      shape1: e.contact.sj._id_,
      shape2: e.contact.si._id_
    }))
  }
}
init()
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./libs/cannon":2,"./libs/cmdCodec":3}],2:[function(require,module,exports){
(function (global){(function (){
/*
 * Copyright (c) 2015 cannon.js Authors
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&false)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.CANNON=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
module.exports={
  "name": "cannon",
  "version": "0.6.2",
  "description": "A lightweight 3D physics engine written in JavaScript.",
  "homepage": "https://github.com/schteppe/cannon.js",
  "author": "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
  "keywords": [
    "cannon.js",
    "cannon",
    "physics",
    "engine",
    "3d"
  ],
  "main": "./build/cannon.js",
  "engines": {
    "node": "*"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/schteppe/cannon.js.git"
  },
  "bugs": {
    "url": "https://github.com/schteppe/cannon.js/issues"
  },
  "licenses": [
    {
      "type": "MIT"
    }
  ],
  "devDependencies": {
    "jshint": "latest",
    "uglify-js": "latest",
    "nodeunit": "^0.9.0",
    "grunt": "~0.4.0",
    "grunt-contrib-jshint": "~0.1.1",
    "grunt-contrib-nodeunit": "^0.4.1",
    "grunt-contrib-concat": "~0.1.3",
    "grunt-contrib-uglify": "^0.5.1",
    "grunt-browserify": "^2.1.4",
    "grunt-contrib-yuidoc": "^0.5.2",
    "browserify": "*"
  },
  "dependencies": {}
}

},{}],2:[function(_dereq_,module,exports){
// Export classes
module.exports = {
    version :                       _dereq_('../package.json').version,

    AABB :                          _dereq_('./collision/AABB'),
    ArrayCollisionMatrix :          _dereq_('./collision/ArrayCollisionMatrix'),
    Body :                          _dereq_('./objects/Body'),
    Box :                           _dereq_('./shapes/Box'),
    Broadphase :                    _dereq_('./collision/Broadphase'),
    Constraint :                    _dereq_('./constraints/Constraint'),
    ContactEquation :               _dereq_('./equations/ContactEquation'),
    Narrowphase :                   _dereq_('./world/Narrowphase'),
    ConeTwistConstraint :           _dereq_('./constraints/ConeTwistConstraint'),
    ContactMaterial :               _dereq_('./material/ContactMaterial'),
    ConvexPolyhedron :              _dereq_('./shapes/ConvexPolyhedron'),
    Cylinder :                      _dereq_('./shapes/Cylinder'),
    DistanceConstraint :            _dereq_('./constraints/DistanceConstraint'),
    Equation :                      _dereq_('./equations/Equation'),
    EventTarget :                   _dereq_('./utils/EventTarget'),
    FrictionEquation :              _dereq_('./equations/FrictionEquation'),
    GSSolver :                      _dereq_('./solver/GSSolver'),
    GridBroadphase :                _dereq_('./collision/GridBroadphase'),
    Heightfield :                   _dereq_('./shapes/Heightfield'),
    HingeConstraint :               _dereq_('./constraints/HingeConstraint'),
    LockConstraint :                _dereq_('./constraints/LockConstraint'),
    Mat3 :                          _dereq_('./math/Mat3'),
    Material :                      _dereq_('./material/Material'),
    NaiveBroadphase :               _dereq_('./collision/NaiveBroadphase'),
    ObjectCollisionMatrix :         _dereq_('./collision/ObjectCollisionMatrix'),
    Pool :                          _dereq_('./utils/Pool'),
    Particle :                      _dereq_('./shapes/Particle'),
    Plane :                         _dereq_('./shapes/Plane'),
    PointToPointConstraint :        _dereq_('./constraints/PointToPointConstraint'),
    Quaternion :                    _dereq_('./math/Quaternion'),
    Ray :                           _dereq_('./collision/Ray'),
    RaycastVehicle :                _dereq_('./objects/RaycastVehicle'),
    RaycastResult :                 _dereq_('./collision/RaycastResult'),
    RigidVehicle :                  _dereq_('./objects/RigidVehicle'),
    RotationalEquation :            _dereq_('./equations/RotationalEquation'),
    RotationalMotorEquation :       _dereq_('./equations/RotationalMotorEquation'),
    SAPBroadphase :                 _dereq_('./collision/SAPBroadphase'),
    SPHSystem :                     _dereq_('./objects/SPHSystem'),
    Shape :                         _dereq_('./shapes/Shape'),
    Solver :                        _dereq_('./solver/Solver'),
    Sphere :                        _dereq_('./shapes/Sphere'),
    SplitSolver :                   _dereq_('./solver/SplitSolver'),
    Spring :                        _dereq_('./objects/Spring'),
    Trimesh :                       _dereq_('./shapes/Trimesh'),
    Vec3 :                          _dereq_('./math/Vec3'),
    Vec3Pool :                      _dereq_('./utils/Vec3Pool'),
    World :                         _dereq_('./world/World'),
};

},{"../package.json":1,"./collision/AABB":3,"./collision/ArrayCollisionMatrix":4,"./collision/Broadphase":5,"./collision/GridBroadphase":6,"./collision/NaiveBroadphase":7,"./collision/ObjectCollisionMatrix":8,"./collision/Ray":9,"./collision/RaycastResult":10,"./collision/SAPBroadphase":11,"./constraints/ConeTwistConstraint":12,"./constraints/Constraint":13,"./constraints/DistanceConstraint":14,"./constraints/HingeConstraint":15,"./constraints/LockConstraint":16,"./constraints/PointToPointConstraint":17,"./equations/ContactEquation":19,"./equations/Equation":20,"./equations/FrictionEquation":21,"./equations/RotationalEquation":22,"./equations/RotationalMotorEquation":23,"./material/ContactMaterial":24,"./material/Material":25,"./math/Mat3":27,"./math/Quaternion":28,"./math/Vec3":30,"./objects/Body":31,"./objects/RaycastVehicle":32,"./objects/RigidVehicle":33,"./objects/SPHSystem":34,"./objects/Spring":35,"./shapes/Box":37,"./shapes/ConvexPolyhedron":38,"./shapes/Cylinder":39,"./shapes/Heightfield":40,"./shapes/Particle":41,"./shapes/Plane":42,"./shapes/Shape":43,"./shapes/Sphere":44,"./shapes/Trimesh":45,"./solver/GSSolver":46,"./solver/Solver":47,"./solver/SplitSolver":48,"./utils/EventTarget":49,"./utils/Pool":51,"./utils/Vec3Pool":54,"./world/Narrowphase":55,"./world/World":56}],3:[function(_dereq_,module,exports){
var Vec3 = _dereq_('../math/Vec3');
var Utils = _dereq_('../utils/Utils');

module.exports = AABB;

/**
 * Axis aligned bounding box class.
 * @class AABB
 * @constructor
 * @param {Object} [options]
 * @param {Vec3}   [options.upperBound]
 * @param {Vec3}   [options.lowerBound]
 */
function AABB(options){
    options = options || {};

    /**
     * The lower bound of the bounding box.
     * @property lowerBound
     * @type {Vec3}
     */
    this.lowerBound = new Vec3();
    if(options.lowerBound){
        this.lowerBound.copy(options.lowerBound);
    }

    /**
     * The upper bound of the bounding box.
     * @property upperBound
     * @type {Vec3}
     */
    this.upperBound = new Vec3();
    if(options.upperBound){
        this.upperBound.copy(options.upperBound);
    }
}

var tmp = new Vec3();

/**
 * Set the AABB bounds from a set of points.
 * @method setFromPoints
 * @param {Array} points An array of Vec3's.
 * @param {Vec3} position
 * @param {Quaternion} quaternion
 * @param {number} skinSize
 * @return {AABB} The self object
 */
AABB.prototype.setFromPoints = function(points, position, quaternion, skinSize){
    var l = this.lowerBound,
        u = this.upperBound,
        q = quaternion;

    // Set to the first point
    l.copy(points[0]);
    if(q){
        q.vmult(l, l);
    }
    u.copy(l);

    for(var i = 1; i<points.length; i++){
        var p = points[i];

        if(q){
            q.vmult(p, tmp);
            p = tmp;
        }

        if(p.x > u.x){ u.x = p.x; }
        if(p.x < l.x){ l.x = p.x; }
        if(p.y > u.y){ u.y = p.y; }
        if(p.y < l.y){ l.y = p.y; }
        if(p.z > u.z){ u.z = p.z; }
        if(p.z < l.z){ l.z = p.z; }
    }

    // Add offset
    if (position) {
        position.vadd(l, l);
        position.vadd(u, u);
    }

    if(skinSize){
        l.x -= skinSize;
        l.y -= skinSize;
        l.z -= skinSize;
        u.x += skinSize;
        u.y += skinSize;
        u.z += skinSize;
    }

    return this;
};

/**
 * Copy bounds from an AABB to this AABB
 * @method copy
 * @param  {AABB} aabb Source to copy from
 * @return {AABB} The this object, for chainability
 */
AABB.prototype.copy = function(aabb){
    this.lowerBound.copy(aabb.lowerBound);
    this.upperBound.copy(aabb.upperBound);
    return this;
};

/**
 * Clone an AABB
 * @method clone
 */
AABB.prototype.clone = function(){
    return new AABB().copy(this);
};

/**
 * Extend this AABB so that it covers the given AABB too.
 * @method extend
 * @param  {AABB} aabb
 */
AABB.prototype.extend = function(aabb){
    // Extend lower bound
    var l = aabb.lowerBound.x;
    if(this.lowerBound.x > l){
        this.lowerBound.x = l;
    }

    // Upper
    var u = aabb.upperBound.x;
    if(this.upperBound.x < u){
        this.upperBound.x = u;
    }

    // Extend lower bound
    var l = aabb.lowerBound.y;
    if(this.lowerBound.y > l){
        this.lowerBound.y = l;
    }

    // Upper
    var u = aabb.upperBound.y;
    if(this.upperBound.y < u){
        this.upperBound.y = u;
    }

    // Extend lower bound
    var l = aabb.lowerBound.z;
    if(this.lowerBound.z > l){
        this.lowerBound.z = l;
    }

    // Upper
    var u = aabb.upperBound.z;
    if(this.upperBound.z < u){
        this.upperBound.z = u;
    }
};

/**
 * Returns true if the given AABB overlaps this AABB.
 * @method overlaps
 * @param  {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.overlaps = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |--------|
    // l1       u1

    return ((l2.x <= u1.x && u1.x <= u2.x) || (l1.x <= u2.x && u2.x <= u1.x)) &&
           ((l2.y <= u1.y && u1.y <= u2.y) || (l1.y <= u2.y && u2.y <= u1.y)) &&
           ((l2.z <= u1.z && u1.z <= u2.z) || (l1.z <= u2.z && u2.z <= u1.z));
};

/**
 * Returns true if the given AABB is fully contained in this AABB.
 * @method contains
 * @param {AABB} aabb
 * @return {Boolean}
 */
AABB.prototype.contains = function(aabb){
    var l1 = this.lowerBound,
        u1 = this.upperBound,
        l2 = aabb.lowerBound,
        u2 = aabb.upperBound;

    //      l2        u2
    //      |---------|
    // |---------------|
    // l1              u1

    return (
        (l1.x <= l2.x && u1.x >= u2.x) &&
        (l1.y <= l2.y && u1.y >= u2.y) &&
        (l1.z <= l2.z && u1.z >= u2.z)
    );
};

/**
 * @method getCorners
 * @param {Vec3} a
 * @param {Vec3} b
 * @param {Vec3} c
 * @param {Vec3} d
 * @param {Vec3} e
 * @param {Vec3} f
 * @param {Vec3} g
 * @param {Vec3} h
 */
AABB.prototype.getCorners = function(a, b, c, d, e, f, g, h){
    var l = this.lowerBound,
        u = this.upperBound;

    a.copy(l);
    b.set( u.x, l.y, l.z );
    c.set( u.x, u.y, l.z );
    d.set( l.x, u.y, u.z );
    e.set( u.x, l.y, l.z );
    f.set( l.x, u.y, l.z );
    g.set( l.x, l.y, u.z );
    h.copy(u);
};

var transformIntoFrame_corners = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3()
];

/**
 * Get the representation of an AABB in another frame.
 * @method toLocalFrame
 * @param  {Transform} frame
 * @param  {AABB} target
 * @return {AABB} The "target" AABB object.
 */
AABB.prototype.toLocalFrame = function(frame, target){

    var corners = transformIntoFrame_corners;
    var a = corners[0];
    var b = corners[1];
    var c = corners[2];
    var d = corners[3];
    var e = corners[4];
    var f = corners[5];
    var g = corners[6];
    var h = corners[7];

    // Get corners in current frame
    this.getCorners(a, b, c, d, e, f, g, h);

    // Transform them to new local frame
    for(var i=0; i !== 8; i++){
        var corner = corners[i];
        frame.pointToLocal(corner, corner);
    }

    return target.setFromPoints(corners);
};

/**
 * Get the representation of an AABB in the global frame.
 * @method toWorldFrame
 * @param  {Transform} frame
 * @param  {AABB} target
 * @return {AABB} The "target" AABB object.
 */
AABB.prototype.toWorldFrame = function(frame, target){

    var corners = transformIntoFrame_corners;
    var a = corners[0];
    var b = corners[1];
    var c = corners[2];
    var d = corners[3];
    var e = corners[4];
    var f = corners[5];
    var g = corners[6];
    var h = corners[7];

    // Get corners in current frame
    this.getCorners(a, b, c, d, e, f, g, h);

    // Transform them to new local frame
    for(var i=0; i !== 8; i++){
        var corner = corners[i];
        frame.pointToWorld(corner, corner);
    }

    return target.setFromPoints(corners);
};

},{"../math/Vec3":30,"../utils/Utils":53}],4:[function(_dereq_,module,exports){
module.exports = ArrayCollisionMatrix;

/**
 * Collision "matrix". It's actually a triangular-shaped array of whether two bodies are touching this step, for reference next step
 * @class ArrayCollisionMatrix
 * @constructor
 */
function ArrayCollisionMatrix() {

    /**
     * The matrix storage
     * @property matrix
     * @type {Array}
     */
	this.matrix = [];
}

/**
 * Get an element
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
ArrayCollisionMatrix.prototype.get = function(i, j) {
	i = i.index;
	j = j.index;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	return this.matrix[(i*(i + 1)>>1) + j-1];
};

/**
 * Set an element
 * @method set
 * @param {Number} i
 * @param {Number} j
 * @param {Number} value
 */
ArrayCollisionMatrix.prototype.set = function(i, j, value) {
	i = i.index;
	j = j.index;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	this.matrix[(i*(i + 1)>>1) + j-1] = value ? 1 : 0;
};

/**
 * Sets all elements to zero
 * @method reset
 */
ArrayCollisionMatrix.prototype.reset = function() {
	for (var i=0, l=this.matrix.length; i!==l; i++) {
		this.matrix[i]=0;
	}
};

/**
 * Sets the max number of objects
 * @method setNumObjects
 * @param {Number} n
 */
ArrayCollisionMatrix.prototype.setNumObjects = function(n) {
	this.matrix.length = n*(n-1)>>1;
};

},{}],5:[function(_dereq_,module,exports){
var Body = _dereq_('../objects/Body');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Shape = _dereq_('../shapes/Shape');
var Plane = _dereq_('../shapes/Plane');

module.exports = Broadphase;

/**
 * Base class for broadphase implementations
 * @class Broadphase
 * @constructor
 * @author schteppe
 */
function Broadphase(){
    /**
    * The world to search for collisions in.
    * @property world
    * @type {World}
    */
    this.world = null;

    /**
     * If set to true, the broadphase uses bounding boxes for intersection test, else it uses bounding spheres.
     * @property useBoundingBoxes
     * @type {Boolean}
     */
    this.useBoundingBoxes = false;

    /**
     * Set to true if the objects in the world moved.
     * @property {Boolean} dirty
     */
    this.dirty = true;
}

/**
 * Get the collision pairs from the world
 * @method collisionPairs
 * @param {World} world The world to search in
 * @param {Array} p1 Empty array to be filled with body objects
 * @param {Array} p2 Empty array to be filled with body objects
 */
Broadphase.prototype.collisionPairs = function(world,p1,p2){
    throw new Error("collisionPairs not implemented for this BroadPhase class!");
};

/**
 * Check if a body pair needs to be intersection tested at all.
 * @method needBroadphaseCollision
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @return {bool}
 */
var Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC = Body.STATIC | Body.KINEMATIC;
Broadphase.prototype.needBroadphaseCollision = function(bodyA,bodyB){

    // Check collision filter masks
    if( (bodyA.collisionFilterGroup & bodyB.collisionFilterMask)===0 || (bodyB.collisionFilterGroup & bodyA.collisionFilterMask)===0){
        return false;
    }

    // Check types
    if(((bodyA.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyA.sleepState === Body.SLEEPING) &&
       ((bodyB.type & Broadphase_needBroadphaseCollision_STATIC_OR_KINEMATIC)!==0 || bodyB.sleepState === Body.SLEEPING)) {
        // Both bodies are static, kinematic or sleeping. Skip.
        return false;
    }

    return true;
};

/**
 * Check if the bounding volumes of two bodies intersect.
 * @method intersectionTest
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {array} pairs1
 * @param {array} pairs2
  */
Broadphase.prototype.intersectionTest = function(bodyA, bodyB, pairs1, pairs2){
    if(this.useBoundingBoxes){
        this.doBoundingBoxBroadphase(bodyA,bodyB,pairs1,pairs2);
    } else {
        this.doBoundingSphereBroadphase(bodyA,bodyB,pairs1,pairs2);
    }
};

/**
 * Check if the bounding spheres of two bodies are intersecting.
 * @method doBoundingSphereBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1 bodyA is appended to this array if intersection
 * @param {Array} pairs2 bodyB is appended to this array if intersection
 */
var Broadphase_collisionPairs_r = new Vec3(), // Temp objects
    Broadphase_collisionPairs_normal =  new Vec3(),
    Broadphase_collisionPairs_quat =  new Quaternion(),
    Broadphase_collisionPairs_relpos  =  new Vec3();
Broadphase.prototype.doBoundingSphereBroadphase = function(bodyA,bodyB,pairs1,pairs2){
    var r = Broadphase_collisionPairs_r;
    bodyB.position.vsub(bodyA.position,r);
    var boundingRadiusSum2 = Math.pow(bodyA.boundingRadius + bodyB.boundingRadius, 2);
    var norm2 = r.norm2();
    if(norm2 < boundingRadiusSum2){
        pairs1.push(bodyA);
        pairs2.push(bodyB);
    }
};

/**
 * Check if the bounding boxes of two bodies are intersecting.
 * @method doBoundingBoxBroadphase
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
Broadphase.prototype.doBoundingBoxBroadphase = function(bodyA,bodyB,pairs1,pairs2){
    if(bodyA.aabbNeedsUpdate){
        bodyA.computeAABB();
    }
    if(bodyB.aabbNeedsUpdate){
        bodyB.computeAABB();
    }

    // Check AABB / AABB
    if(bodyA.aabb.overlaps(bodyB.aabb)){
        pairs1.push(bodyA);
        pairs2.push(bodyB);
    }
};

/**
 * Removes duplicate pairs from the pair arrays.
 * @method makePairsUnique
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
var Broadphase_makePairsUnique_temp = { keys:[] },
    Broadphase_makePairsUnique_p1 = [],
    Broadphase_makePairsUnique_p2 = [];
Broadphase.prototype.makePairsUnique = function(pairs1,pairs2){
    var t = Broadphase_makePairsUnique_temp,
        p1 = Broadphase_makePairsUnique_p1,
        p2 = Broadphase_makePairsUnique_p2,
        N = pairs1.length;

    for(var i=0; i!==N; i++){
        p1[i] = pairs1[i];
        p2[i] = pairs2[i];
    }

    pairs1.length = 0;
    pairs2.length = 0;

    for(var i=0; i!==N; i++){
        var id1 = p1[i].id,
            id2 = p2[i].id;
        var key = id1 < id2 ? id1+","+id2 :  id2+","+id1;
        t[key] = i;
        t.keys.push(key);
    }

    for(var i=0; i!==t.keys.length; i++){
        var key = t.keys.pop(),
            pairIndex = t[key];
        pairs1.push(p1[pairIndex]);
        pairs2.push(p2[pairIndex]);
        delete t[key];
    }
};

/**
 * To be implemented by subcasses
 * @method setWorld
 * @param {World} world
 */
Broadphase.prototype.setWorld = function(world){
};

/**
 * Check if the bounding spheres of two bodies overlap.
 * @method boundingSphereCheck
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @return {boolean}
 */
var bsc_dist = new Vec3();
Broadphase.boundingSphereCheck = function(bodyA,bodyB){
    var dist = bsc_dist;
    bodyA.position.vsub(bodyB.position,dist);
    return Math.pow(bodyA.shape.boundingSphereRadius + bodyB.shape.boundingSphereRadius,2) > dist.norm2();
};

/**
 * Returns all the bodies within the AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param  {array} result An array to store resulting bodies in.
 * @return {array}
 */
Broadphase.prototype.aabbQuery = function(world, aabb, result){
    console.warn('.aabbQuery is not implemented in this Broadphase subclass.');
    return [];
};
},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Plane":42,"../shapes/Shape":43}],6:[function(_dereq_,module,exports){
module.exports = GridBroadphase;

var Broadphase = _dereq_('./Broadphase');
var Vec3 = _dereq_('../math/Vec3');
var Shape = _dereq_('../shapes/Shape');

/**
 * Axis aligned uniform grid broadphase.
 * @class GridBroadphase
 * @constructor
 * @extends Broadphase
 * @todo Needs support for more than just planes and spheres.
 * @param {Vec3} aabbMin
 * @param {Vec3} aabbMax
 * @param {Number} nx Number of boxes along x
 * @param {Number} ny Number of boxes along y
 * @param {Number} nz Number of boxes along z
 */
function GridBroadphase(aabbMin,aabbMax,nx,ny,nz){
    Broadphase.apply(this);
    this.nx = nx || 10;
    this.ny = ny || 10;
    this.nz = nz || 10;
    this.aabbMin = aabbMin || new Vec3(100,100,100);
    this.aabbMax = aabbMax || new Vec3(-100,-100,-100);
	var nbins = this.nx * this.ny * this.nz;
	if (nbins <= 0) {
		throw "GridBroadphase: Each dimension's n must be >0";
	}
    this.bins = [];
	this.binLengths = []; //Rather than continually resizing arrays (thrashing the memory), just record length and allow them to grow
	this.bins.length = nbins;
	this.binLengths.length = nbins;
	for (var i=0;i<nbins;i++) {
		this.bins[i]=[];
		this.binLengths[i]=0;
	}
}
GridBroadphase.prototype = new Broadphase();
GridBroadphase.prototype.constructor = GridBroadphase;

/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
var GridBroadphase_collisionPairs_d = new Vec3();
var GridBroadphase_collisionPairs_binPos = new Vec3();
GridBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
    var N = world.numObjects(),
        bodies = world.bodies;

    var max = this.aabbMax,
        min = this.aabbMin,
        nx = this.nx,
        ny = this.ny,
        nz = this.nz;

	var xstep = ny*nz;
	var ystep = nz;
	var zstep = 1;

    var xmax = max.x,
        ymax = max.y,
        zmax = max.z,
        xmin = min.x,
        ymin = min.y,
        zmin = min.z;

    var xmult = nx / (xmax-xmin),
        ymult = ny / (ymax-ymin),
        zmult = nz / (zmax-zmin);

    var binsizeX = (xmax - xmin) / nx,
        binsizeY = (ymax - ymin) / ny,
        binsizeZ = (zmax - zmin) / nz;

	var binRadius = Math.sqrt(binsizeX*binsizeX + binsizeY*binsizeY + binsizeZ*binsizeZ) * 0.5;

    var types = Shape.types;
    var SPHERE =            types.SPHERE,
        PLANE =             types.PLANE,
        BOX =               types.BOX,
        COMPOUND =          types.COMPOUND,
        CONVEXPOLYHEDRON =  types.CONVEXPOLYHEDRON;

    var bins=this.bins,
		binLengths=this.binLengths,
        Nbins=this.bins.length;

    // Reset bins
    for(var i=0; i!==Nbins; i++){
        binLengths[i] = 0;
    }

    var ceil = Math.ceil;
	var min = Math.min;
	var max = Math.max;

	function addBoxToBins(x0,y0,z0,x1,y1,z1,bi) {
		var xoff0 = ((x0 - xmin) * xmult)|0,
			yoff0 = ((y0 - ymin) * ymult)|0,
			zoff0 = ((z0 - zmin) * zmult)|0,
			xoff1 = ceil((x1 - xmin) * xmult),
			yoff1 = ceil((y1 - ymin) * ymult),
			zoff1 = ceil((z1 - zmin) * zmult);

		if (xoff0 < 0) { xoff0 = 0; } else if (xoff0 >= nx) { xoff0 = nx - 1; }
		if (yoff0 < 0) { yoff0 = 0; } else if (yoff0 >= ny) { yoff0 = ny - 1; }
		if (zoff0 < 0) { zoff0 = 0; } else if (zoff0 >= nz) { zoff0 = nz - 1; }
		if (xoff1 < 0) { xoff1 = 0; } else if (xoff1 >= nx) { xoff1 = nx - 1; }
		if (yoff1 < 0) { yoff1 = 0; } else if (yoff1 >= ny) { yoff1 = ny - 1; }
		if (zoff1 < 0) { zoff1 = 0; } else if (zoff1 >= nz) { zoff1 = nz - 1; }

		xoff0 *= xstep;
		yoff0 *= ystep;
		zoff0 *= zstep;
		xoff1 *= xstep;
		yoff1 *= ystep;
		zoff1 *= zstep;

		for (var xoff = xoff0; xoff <= xoff1; xoff += xstep) {
			for (var yoff = yoff0; yoff <= yoff1; yoff += ystep) {
				for (var zoff = zoff0; zoff <= zoff1; zoff += zstep) {
					var idx = xoff+yoff+zoff;
					bins[idx][binLengths[idx]++] = bi;
				}
			}
		}
	}

    // Put all bodies into the bins
    for(var i=0; i!==N; i++){
        var bi = bodies[i];
        var si = bi.shape;

        switch(si.type){
        case SPHERE:
            // Put in bin
            // check if overlap with other bins
            var x = bi.position.x,
                y = bi.position.y,
                z = bi.position.z;
            var r = si.radius;

			addBoxToBins(x-r, y-r, z-r, x+r, y+r, z+r, bi);
            break;

        case PLANE:
            if(si.worldNormalNeedsUpdate){
                si.computeWorldNormal(bi.quaternion);
            }
            var planeNormal = si.worldNormal;

			//Relative position from origin of plane object to the first bin
			//Incremented as we iterate through the bins
			var xreset = xmin + binsizeX*0.5 - bi.position.x,
				yreset = ymin + binsizeY*0.5 - bi.position.y,
				zreset = zmin + binsizeZ*0.5 - bi.position.z;

            var d = GridBroadphase_collisionPairs_d;
			d.set(xreset, yreset, zreset);

			for (var xi = 0, xoff = 0; xi !== nx; xi++, xoff += xstep, d.y = yreset, d.x += binsizeX) {
				for (var yi = 0, yoff = 0; yi !== ny; yi++, yoff += ystep, d.z = zreset, d.y += binsizeY) {
					for (var zi = 0, zoff = 0; zi !== nz; zi++, zoff += zstep, d.z += binsizeZ) {
						if (d.dot(planeNormal) < binRadius) {
							var idx = xoff + yoff + zoff;
							bins[idx][binLengths[idx]++] = bi;
						}
					}
				}
			}
            break;

        default:
			if (bi.aabbNeedsUpdate) {
				bi.computeAABB();
			}

			addBoxToBins(
				bi.aabb.lowerBound.x,
				bi.aabb.lowerBound.y,
				bi.aabb.lowerBound.z,
				bi.aabb.upperBound.x,
				bi.aabb.upperBound.y,
				bi.aabb.upperBound.z,
				bi);
            break;
        }
    }

    // Check each bin
    for(var i=0; i!==Nbins; i++){
		var binLength = binLengths[i];
		//Skip bins with no potential collisions
		if (binLength > 1) {
			var bin = bins[i];

			// Do N^2 broadphase inside
			for(var xi=0; xi!==binLength; xi++){
				var bi = bin[xi];
				for(var yi=0; yi!==xi; yi++){
					var bj = bin[yi];
					if(this.needBroadphaseCollision(bi,bj)){
						this.intersectionTest(bi,bj,pairs1,pairs2);
					}
				}
			}
		}
    }

//	for (var zi = 0, zoff=0; zi < nz; zi++, zoff+= zstep) {
//		console.log("layer "+zi);
//		for (var yi = 0, yoff=0; yi < ny; yi++, yoff += ystep) {
//			var row = '';
//			for (var xi = 0, xoff=0; xi < nx; xi++, xoff += xstep) {
//				var idx = xoff + yoff + zoff;
//				row += ' ' + binLengths[idx];
//			}
//			console.log(row);
//		}
//	}

    this.makePairsUnique(pairs1,pairs2);
};

},{"../math/Vec3":30,"../shapes/Shape":43,"./Broadphase":5}],7:[function(_dereq_,module,exports){
module.exports = NaiveBroadphase;

var Broadphase = _dereq_('./Broadphase');
var AABB = _dereq_('./AABB');

/**
 * Naive broadphase implementation, used in lack of better ones.
 * @class NaiveBroadphase
 * @constructor
 * @description The naive broadphase looks at all possible pairs without restriction, therefore it has complexity N^2 (which is bad)
 * @extends Broadphase
 */
function NaiveBroadphase(){
    Broadphase.apply(this);
}
NaiveBroadphase.prototype = new Broadphase();
NaiveBroadphase.prototype.constructor = NaiveBroadphase;

/**
 * Get all the collision pairs in the physics world
 * @method collisionPairs
 * @param {World} world
 * @param {Array} pairs1
 * @param {Array} pairs2
 */
NaiveBroadphase.prototype.collisionPairs = function(world,pairs1,pairs2){
    var bodies = world.bodies,
        n = bodies.length,
        i,j,bi,bj;

    // Naive N^2 ftw!
    for(i=0; i!==n; i++){
        for(j=0; j!==i; j++){

            bi = bodies[i];
            bj = bodies[j];

            if(!this.needBroadphaseCollision(bi,bj)){
                continue;
            }

            this.intersectionTest(bi,bj,pairs1,pairs2);
        }
    }
};

var tmpAABB = new AABB();

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
NaiveBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    for(var i = 0; i < world.bodies.length; i++){
        var b = world.bodies[i];

        if(b.aabbNeedsUpdate){
            b.computeAABB();
        }

        // Ugly hack until Body gets aabb
        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"./AABB":3,"./Broadphase":5}],8:[function(_dereq_,module,exports){
module.exports = ObjectCollisionMatrix;

/**
 * Records what objects are colliding with each other
 * @class ObjectCollisionMatrix
 * @constructor
 */
function ObjectCollisionMatrix() {

    /**
     * The matrix storage
     * @property matrix
     * @type {Object}
     */
	this.matrix = {};
}

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
ObjectCollisionMatrix.prototype.get = function(i, j) {
	i = i.id;
	j = j.id;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
    }
	return i+'-'+j in this.matrix;
};

/**
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
ObjectCollisionMatrix.prototype.set = function(i, j, value) {
	i = i.id;
	j = j.id;
    if (j > i) {
        var temp = j;
        j = i;
        i = temp;
	}
	if (value) {
		this.matrix[i+'-'+j] = true;
	}
	else {
		delete this.matrix[i+'-'+j];
	}
};

/**
 * Empty the matrix
 * @method reset
 */
ObjectCollisionMatrix.prototype.reset = function() {
	this.matrix = {};
};

/**
 * Set max number of objects
 * @method setNumObjects
 * @param {Number} n
 */
ObjectCollisionMatrix.prototype.setNumObjects = function(n) {
};

},{}],9:[function(_dereq_,module,exports){
module.exports = Ray;

var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Transform = _dereq_('../math/Transform');
var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
var Box = _dereq_('../shapes/Box');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Shape = _dereq_('../shapes/Shape');
var AABB = _dereq_('../collision/AABB');

/**
 * A line in 3D space that intersects bodies and return points.
 * @class Ray
 * @constructor
 * @param {Vec3} from
 * @param {Vec3} to
 */
function Ray(from, to){
    /**
     * @property {Vec3} from
     */
    this.from = from ? from.clone() : new Vec3();

    /**
     * @property {Vec3} to
     */
    this.to = to ? to.clone() : new Vec3();

    /**
     * @private
     * @property {Vec3} _direction
     */
    this._direction = new Vec3();

    /**
     * The precision of the ray. Used when checking parallelity etc.
     * @property {Number} precision
     */
    this.precision = 0.0001;

    /**
     * Set to true if you want the Ray to take .collisionResponse flags into account on bodies and shapes.
     * @property {Boolean} checkCollisionResponse
     */
    this.checkCollisionResponse = true;

    /**
     * If set to true, the ray skips any hits with normal.dot(rayDirection) < 0.
     * @property {Boolean} skipBackfaces
     */
    this.skipBackfaces = false;

    /**
     * @property {number} collisionFilterMask
     * @default -1
     */
    this.collisionFilterMask = -1;

    /**
     * @property {number} collisionFilterGroup
     * @default -1
     */
    this.collisionFilterGroup = -1;

    /**
     * The intersection mode. Should be Ray.ANY, Ray.ALL or Ray.CLOSEST.
     * @property {number} mode
     */
    this.mode = Ray.ANY;

    /**
     * Current result object.
     * @property {RaycastResult} result
     */
    this.result = new RaycastResult();

    /**
     * Will be set to true during intersectWorld() if the ray hit anything.
     * @property {Boolean} hasHit
     */
    this.hasHit = false;

    /**
     * Current, user-provided result callback. Will be used if mode is Ray.ALL.
     * @property {Function} callback
     */
    this.callback = function(result){};
}
Ray.prototype.constructor = Ray;

Ray.CLOSEST = 1;
Ray.ANY = 2;
Ray.ALL = 4;

var tmpAABB = new AABB();
var tmpArray = [];

/**
 * Do itersection against all bodies in the given World.
 * @method intersectWorld
 * @param  {World} world
 * @param  {object} options
 * @return {Boolean} True if the ray hit anything, otherwise false.
 */
Ray.prototype.intersectWorld = function (world, options) {
    this.mode = options.mode || Ray.ANY;
    this.result = options.result || new RaycastResult();
    this.skipBackfaces = !!options.skipBackfaces;
    this.collisionFilterMask = typeof(options.collisionFilterMask) !== 'undefined' ? options.collisionFilterMask : -1;
    this.collisionFilterGroup = typeof(options.collisionFilterGroup) !== 'undefined' ? options.collisionFilterGroup : -1;
    if(options.from){
        this.from.copy(options.from);
    }
    if(options.to){
        this.to.copy(options.to);
    }
    this.callback = options.callback || function(){};
    this.hasHit = false;

    this.result.reset();
    this._updateDirection();

    this.getAABB(tmpAABB);
    tmpArray.length = 0;
    world.broadphase.aabbQuery(world, tmpAABB, tmpArray);
    this.intersectBodies(tmpArray);

    return this.hasHit;
};

var v1 = new Vec3(),
    v2 = new Vec3();

/*
 * As per "Barycentric Technique" as named here http://www.blackpawn.com/texts/pointinpoly/default.html But without the division
 */
Ray.pointInTriangle = pointInTriangle;
function pointInTriangle(p, a, b, c) {
    c.vsub(a,v0);
    b.vsub(a,v1);
    p.vsub(a,v2);

    var dot00 = v0.dot( v0 );
    var dot01 = v0.dot( v1 );
    var dot02 = v0.dot( v2 );
    var dot11 = v1.dot( v1 );
    var dot12 = v1.dot( v2 );

    var u,v;

    return  ( (u = dot11 * dot02 - dot01 * dot12) >= 0 ) &&
            ( (v = dot00 * dot12 - dot01 * dot02) >= 0 ) &&
            ( u + v < ( dot00 * dot11 - dot01 * dot01 ) );
}

/**
 * Shoot a ray at a body, get back information about the hit.
 * @method intersectBody
 * @private
 * @param {Body} body
 * @param {RaycastResult} [result] Deprecated - set the result property of the Ray instead.
 */
var intersectBody_xi = new Vec3();
var intersectBody_qi = new Quaternion();
Ray.prototype.intersectBody = function (body, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }
    var checkCollisionResponse = this.checkCollisionResponse;

    if(checkCollisionResponse && !body.collisionResponse){
        return;
    }

    if((this.collisionFilterGroup & body.collisionFilterMask)===0 || (body.collisionFilterGroup & this.collisionFilterMask)===0){
        return;
    }

    var xi = intersectBody_xi;
    var qi = intersectBody_qi;

    for (var i = 0, N = body.shapes.length; i < N; i++) {
        var shape = body.shapes[i];

        if(checkCollisionResponse && !shape.collisionResponse){
            continue; // Skip
        }

        body.quaternion.mult(body.shapeOrientations[i], qi);
        body.quaternion.vmult(body.shapeOffsets[i], xi);
        xi.vadd(body.position, xi);

        this.intersectShape(
            shape,
            qi,
            xi,
            body
        );

        if(this.result._shouldStop){
            break;
        }
    }
};

/**
 * @method intersectBodies
 * @param {Array} bodies An array of Body objects.
 * @param {RaycastResult} [result] Deprecated
 */
Ray.prototype.intersectBodies = function (bodies, result) {
    if(result){
        this.result = result;
        this._updateDirection();
    }

    for ( var i = 0, l = bodies.length; !this.result._shouldStop && i < l; i ++ ) {
        this.intersectBody(bodies[i]);
    }
};

/**
 * Updates the _direction vector.
 * @private
 * @method _updateDirection
 */
Ray.prototype._updateDirection = function(){
    this.to.vsub(this.from, this._direction);
    this._direction.normalize();
};

/**
 * @method intersectShape
 * @private
 * @param {Shape} shape
 * @param {Quaternion} quat
 * @param {Vec3} position
 * @param {Body} body
 */
Ray.prototype.intersectShape = function(shape, quat, position, body){
    var from = this.from;


    // Checking boundingSphere
    var distance = distanceFromIntersection(from, this._direction, position);
    if ( distance > shape.boundingSphereRadius ) {
        return;
    }

    var intersectMethod = this[shape.type];
    if(intersectMethod){
        intersectMethod.call(this, shape, quat, position, body);
    }
};

var vector = new Vec3();
var normal = new Vec3();
var intersectPoint = new Vec3();

var a = new Vec3();
var b = new Vec3();
var c = new Vec3();
var d = new Vec3();

var tmpRaycastResult = new RaycastResult();

/**
 * @method intersectBox
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectBox = function(shape, quat, position, body){
    return this.intersectConvex(shape.convexPolyhedronRepresentation, quat, position, body);
};
Ray.prototype[Shape.types.BOX] = Ray.prototype.intersectBox;

/**
 * @method intersectPlane
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectPlane = function(shape, quat, position, body){
    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    // Get plane normal
    var worldNormal = new Vec3(0, 0, 1);
    quat.vmult(worldNormal, worldNormal);

    var len = new Vec3();
    from.vsub(position, len);
    var planeToFrom = len.dot(worldNormal);
    to.vsub(position, len);
    var planeToTo = len.dot(worldNormal);

    if(planeToFrom * planeToTo > 0){
        // "from" and "to" are on the same side of the plane... bail out
        return;
    }

    if(from.distanceTo(to) < planeToFrom){
        return;
    }

    var n_dot_dir = worldNormal.dot(direction);

    if (Math.abs(n_dot_dir) < this.precision) {
        // No intersection
        return;
    }

    var planePointToFrom = new Vec3();
    var dir_scaled_with_t = new Vec3();
    var hitPointWorld = new Vec3();

    from.vsub(position, planePointToFrom);
    var t = -worldNormal.dot(planePointToFrom) / n_dot_dir;
    direction.scale(t, dir_scaled_with_t);
    from.vadd(dir_scaled_with_t, hitPointWorld);

    this.reportIntersection(worldNormal, hitPointWorld, shape, body, -1);
};
Ray.prototype[Shape.types.PLANE] = Ray.prototype.intersectPlane;

/**
 * Get the world AABB of the ray.
 * @method getAABB
 * @param  {AABB} aabb
 */
Ray.prototype.getAABB = function(result){
    var to = this.to;
    var from = this.from;
    result.lowerBound.x = Math.min(to.x, from.x);
    result.lowerBound.y = Math.min(to.y, from.y);
    result.lowerBound.z = Math.min(to.z, from.z);
    result.upperBound.x = Math.max(to.x, from.x);
    result.upperBound.y = Math.max(to.y, from.y);
    result.upperBound.z = Math.max(to.z, from.z);
};

var intersectConvexOptions = {
    faceList: [0]
};

/**
 * @method intersectHeightfield
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectHeightfield = function(shape, quat, position, body){
    var data = shape.data,
        w = shape.elementSize,
        worldPillarOffset = new Vec3();

    // Convert the ray to local heightfield coordinates
    var localRay = new Ray(this.from, this.to);
    Transform.pointToLocalFrame(position, quat, localRay.from, localRay.from);
    Transform.pointToLocalFrame(position, quat, localRay.to, localRay.to);

    // Get the index of the data points to test against
    var index = [];
    var iMinX = null;
    var iMinY = null;
    var iMaxX = null;
    var iMaxY = null;

    var inside = shape.getIndexOfPosition(localRay.from.x, localRay.from.y, index, false);
    if(inside){
        iMinX = index[0];
        iMinY = index[1];
        iMaxX = index[0];
        iMaxY = index[1];
    }
    inside = shape.getIndexOfPosition(localRay.to.x, localRay.to.y, index, false);
    if(inside){
        if (iMinX === null || index[0] < iMinX) { iMinX = index[0]; }
        if (iMaxX === null || index[0] > iMaxX) { iMaxX = index[0]; }
        if (iMinY === null || index[1] < iMinY) { iMinY = index[1]; }
        if (iMaxY === null || index[1] > iMaxY) { iMaxY = index[1]; }
    }

    if(iMinX === null){
        return;
    }

    var minMax = [];
    shape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // // Bail out if the ray can't touch the bounding box
    // // TODO
    // var aabb = new AABB();
    // this.getAABB(aabb);
    // if(aabb.intersects()){
    //     return;
    // }

    for(var i = iMinX; i <= iMaxX; i++){
        for(var j = iMinY; j <= iMaxY; j++){

            if(this.result._shouldStop){
                return;
            }

            // Lower triangle
            shape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);

            if(this.result._shouldStop){
                return;
            }

            // Upper triangle
            shape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(position, quat, shape.pillarOffset, worldPillarOffset);
            this.intersectConvex(shape.pillarConvex, quat, worldPillarOffset, body, intersectConvexOptions);
        }
    }
};
Ray.prototype[Shape.types.HEIGHTFIELD] = Ray.prototype.intersectHeightfield;

var Ray_intersectSphere_intersectionPoint = new Vec3();
var Ray_intersectSphere_normal = new Vec3();

/**
 * @method intersectSphere
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 */
Ray.prototype.intersectSphere = function(shape, quat, position, body){
    var from = this.from,
        to = this.to,
        r = shape.radius;

    var a = Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2) + Math.pow(to.z - from.z, 2);
    var b = 2 * ((to.x - from.x) * (from.x - position.x) + (to.y - from.y) * (from.y - position.y) + (to.z - from.z) * (from.z - position.z));
    var c = Math.pow(from.x - position.x, 2) + Math.pow(from.y - position.y, 2) + Math.pow(from.z - position.z, 2) - Math.pow(r, 2);

    var delta = Math.pow(b, 2) - 4 * a * c;

    var intersectionPoint = Ray_intersectSphere_intersectionPoint;
    var normal = Ray_intersectSphere_normal;

    if(delta < 0){
        // No intersection
        return;

    } else if(delta === 0){
        // single intersection point
        from.lerp(to, delta, intersectionPoint);

        intersectionPoint.vsub(position, normal);
        normal.normalize();

        this.reportIntersection(normal, intersectionPoint, shape, body, -1);

    } else {
        var d1 = (- b - Math.sqrt(delta)) / (2 * a);
        var d2 = (- b + Math.sqrt(delta)) / (2 * a);

        if(d1 >= 0 && d1 <= 1){
            from.lerp(to, d1, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, shape, body, -1);
        }

        if(this.result._shouldStop){
            return;
        }

        if(d2 >= 0 && d2 <= 1){
            from.lerp(to, d2, intersectionPoint);
            intersectionPoint.vsub(position, normal);
            normal.normalize();
            this.reportIntersection(normal, intersectionPoint, shape, body, -1);
        }
    }
};
Ray.prototype[Shape.types.SPHERE] = Ray.prototype.intersectSphere;


var intersectConvex_normal = new Vec3();
var intersectConvex_minDistNormal = new Vec3();
var intersectConvex_minDistIntersect = new Vec3();
var intersectConvex_vector = new Vec3();

/**
 * @method intersectConvex
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 * @param {object} [options]
 * @param {array} [options.faceList]
 */
Ray.prototype.intersectConvex = function intersectConvex(
    shape,
    quat,
    position,
    body,
    options
){
    var minDistNormal = intersectConvex_minDistNormal;
    var normal = intersectConvex_normal;
    var vector = intersectConvex_vector;
    var minDistIntersect = intersectConvex_minDistIntersect;
    var faceList = (options && options.faceList) || null;

    // Checking faces
    var faces = shape.faces,
        vertices = shape.vertices,
        normals = shape.faceNormals;
    var direction = this._direction;

    var from = this.from;
    var to = this.to;
    var fromToDistance = from.distanceTo(to);

    var minDist = -1;
    var Nfaces = faceList ? faceList.length : faces.length;
    var result = this.result;

    for (var j = 0; !result._shouldStop && j < Nfaces; j++) {
        var fi = faceList ? faceList[j] : j;

        var face = faces[fi];
        var faceNormal = normals[fi];
        var q = quat;
        var x = position;

        // determine if ray intersects the plane of the face
        // note: this works regardless of the direction of the face normal

        // Get plane point in world coordinates...
        vector.copy(vertices[face[0]]);
        q.vmult(vector,vector);
        vector.vadd(x,vector);

        // ...but make it relative to the ray from. We'll fix this later.
        vector.vsub(from,vector);

        // Get plane normal
        q.vmult(faceNormal,normal);

        // If this dot product is negative, we have something interesting
        var dot = direction.dot(normal);

        // Bail out if ray and plane are parallel
        if ( Math.abs( dot ) < this.precision ){
            continue;
        }

        // calc distance to plane
        var scalar = normal.dot(vector) / dot;

        // if negative distance, then plane is behind ray
        if (scalar < 0){
            continue;
        }

        // if (dot < 0) {

        // Intersection point is from + direction * scalar
        direction.mult(scalar,intersectPoint);
        intersectPoint.vadd(from,intersectPoint);

        // a is the point we compare points b and c with.
        a.copy(vertices[face[0]]);
        q.vmult(a,a);
        x.vadd(a,a);

        for(var i = 1; !result._shouldStop && i < face.length - 1; i++){
            // Transform 3 vertices to world coords
            b.copy(vertices[face[i]]);
            c.copy(vertices[face[i+1]]);
            q.vmult(b,b);
            q.vmult(c,c);
            x.vadd(b,b);
            x.vadd(c,c);

            var distance = intersectPoint.distanceTo(from);

            if(!(pointInTriangle(intersectPoint, a, b, c) || pointInTriangle(intersectPoint, b, a, c)) || distance > fromToDistance){
                continue;
            }

            this.reportIntersection(normal, intersectPoint, shape, body, fi);
        }
        // }
    }
};
Ray.prototype[Shape.types.CONVEXPOLYHEDRON] = Ray.prototype.intersectConvex;

var intersectTrimesh_normal = new Vec3();
var intersectTrimesh_localDirection = new Vec3();
var intersectTrimesh_localFrom = new Vec3();
var intersectTrimesh_localTo = new Vec3();
var intersectTrimesh_worldNormal = new Vec3();
var intersectTrimesh_worldIntersectPoint = new Vec3();
var intersectTrimesh_localAABB = new AABB();
var intersectTrimesh_triangles = [];
var intersectTrimesh_treeTransform = new Transform();

/**
 * @method intersectTrimesh
 * @private
 * @param  {Shape} shape
 * @param  {Quaternion} quat
 * @param  {Vec3} position
 * @param  {Body} body
 * @param {object} [options]
 * @todo Optimize by transforming the world to local space first.
 * @todo Use Octree lookup
 */
Ray.prototype.intersectTrimesh = function intersectTrimesh(
    mesh,
    quat,
    position,
    body,
    options
){
    var normal = intersectTrimesh_normal;
    var triangles = intersectTrimesh_triangles;
    var treeTransform = intersectTrimesh_treeTransform;
    var minDistNormal = intersectConvex_minDistNormal;
    var vector = intersectConvex_vector;
    var minDistIntersect = intersectConvex_minDistIntersect;
    var localAABB = intersectTrimesh_localAABB;
    var localDirection = intersectTrimesh_localDirection;
    var localFrom = intersectTrimesh_localFrom;
    var localTo = intersectTrimesh_localTo;
    var worldIntersectPoint = intersectTrimesh_worldIntersectPoint;
    var worldNormal = intersectTrimesh_worldNormal;
    var faceList = (options && options.faceList) || null;

    // Checking faces
    var indices = mesh.indices,
        vertices = mesh.vertices,
        normals = mesh.faceNormals;

    var from = this.from;
    var to = this.to;
    var direction = this._direction;

    var minDist = -1;
    treeTransform.position.copy(position);
    treeTransform.quaternion.copy(quat);

    // Transform ray to local space!
    Transform.vectorToLocalFrame(position, quat, direction, localDirection);
    //body.vectorToLocalFrame(direction, localDirection);
    Transform.pointToLocalFrame(position, quat, from, localFrom);
    //body.pointToLocalFrame(from, localFrom);
    Transform.pointToLocalFrame(position, quat, to, localTo);
    //body.pointToLocalFrame(to, localTo);
    var fromToDistanceSquared = localFrom.distanceSquared(localTo);

    mesh.tree.rayQuery(this, treeTransform, triangles);

    for (var i = 0, N = triangles.length; !this.result._shouldStop && i !== N; i++) {
        var trianglesIndex = triangles[i];

        mesh.getNormal(trianglesIndex, normal);

        // determine if ray intersects the plane of the face
        // note: this works regardless of the direction of the face normal

        // Get plane point in world coordinates...
        mesh.getVertex(indices[trianglesIndex * 3], a);

        // ...but make it relative to the ray from. We'll fix this later.
        a.vsub(localFrom,vector);

        // Get plane normal
        // quat.vmult(normal, normal);

        // If this dot product is negative, we have something interesting
        var dot = localDirection.dot(normal);

        // Bail out if ray and plane are parallel
        // if (Math.abs( dot ) < this.precision){
        //     continue;
        // }

        // calc distance to plane
        var scalar = normal.dot(vector) / dot;

        // if negative distance, then plane is behind ray
        if (scalar < 0){
            continue;
        }

        // Intersection point is from + direction * scalar
        localDirection.scale(scalar,intersectPoint);
        intersectPoint.vadd(localFrom,intersectPoint);

        // Get triangle vertices
        mesh.getVertex(indices[trianglesIndex * 3 + 1], b);
        mesh.getVertex(indices[trianglesIndex * 3 + 2], c);

        var squaredDistance = intersectPoint.distanceSquared(localFrom);

        if(!(pointInTriangle(intersectPoint, b, a, c) || pointInTriangle(intersectPoint, a, b, c)) || squaredDistance > fromToDistanceSquared){
            continue;
        }

        // transform intersectpoint and normal to world
        Transform.vectorToWorldFrame(quat, normal, worldNormal);
        //body.vectorToWorldFrame(normal, worldNormal);
        Transform.pointToWorldFrame(position, quat, intersectPoint, worldIntersectPoint);
        //body.pointToWorldFrame(intersectPoint, worldIntersectPoint);
        this.reportIntersection(worldNormal, worldIntersectPoint, mesh, body, trianglesIndex);
    }
    triangles.length = 0;
};
Ray.prototype[Shape.types.TRIMESH] = Ray.prototype.intersectTrimesh;


/**
 * @method reportIntersection
 * @private
 * @param  {Vec3} normal
 * @param  {Vec3} hitPointWorld
 * @param  {Shape} shape
 * @param  {Body} body
 * @return {boolean} True if the intersections should continue
 */
Ray.prototype.reportIntersection = function(normal, hitPointWorld, shape, body, hitFaceIndex){
    var from = this.from;
    var to = this.to;
    var distance = from.distanceTo(hitPointWorld);
    var result = this.result;

    // Skip back faces?
    if(this.skipBackfaces && normal.dot(this._direction) > 0){
        return;
    }

    result.hitFaceIndex = typeof(hitFaceIndex) !== 'undefined' ? hitFaceIndex : -1;

    switch(this.mode){
    case Ray.ALL:
        this.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result.hasHit = true;
        this.callback(result);
        break;

    case Ray.CLOSEST:

        // Store if closer than current closest
        if(distance < result.distance || !result.hasHit){
            this.hasHit = true;
            result.hasHit = true;
            result.set(
                from,
                to,
                normal,
                hitPointWorld,
                shape,
                body,
                distance
            );
        }
        break;

    case Ray.ANY:

        // Report and stop.
        this.hasHit = true;
        result.hasHit = true;
        result.set(
            from,
            to,
            normal,
            hitPointWorld,
            shape,
            body,
            distance
        );
        result._shouldStop = true;
        break;
    }
};

var v0 = new Vec3(),
    intersect = new Vec3();
function distanceFromIntersection(from, direction, position) {

    // v0 is vector from from to position
    position.vsub(from,v0);
    var dot = v0.dot(direction);

    // intersect = direction*dot + from
    direction.mult(dot,intersect);
    intersect.vadd(from,intersect);

    var distance = position.distanceTo(intersect);

    return distance;
}


},{"../collision/AABB":3,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/Box":37,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43}],10:[function(_dereq_,module,exports){
var Vec3 = _dereq_('../math/Vec3');

module.exports = RaycastResult;

/**
 * Storage for Ray casting data.
 * @class RaycastResult
 * @constructor
 */
function RaycastResult(){

	/**
	 * @property {Vec3} rayFromWorld
	 */
	this.rayFromWorld = new Vec3();

	/**
	 * @property {Vec3} rayToWorld
	 */
	this.rayToWorld = new Vec3();

	/**
	 * @property {Vec3} hitNormalWorld
	 */
	this.hitNormalWorld = new Vec3();

	/**
	 * @property {Vec3} hitPointWorld
	 */
	this.hitPointWorld = new Vec3();

	/**
	 * @property {boolean} hasHit
	 */
	this.hasHit = false;

	/**
	 * The hit shape, or null.
	 * @property {Shape} shape
	 */
	this.shape = null;

	/**
	 * The hit body, or null.
	 * @property {Body} body
	 */
	this.body = null;

	/**
	 * The index of the hit triangle, if the hit shape was a trimesh.
	 * @property {number} hitFaceIndex
	 * @default -1
	 */
	this.hitFaceIndex = -1;

	/**
	 * Distance to the hit. Will be set to -1 if there was no hit.
	 * @property {number} distance
	 * @default -1
	 */
	this.distance = -1;

	/**
	 * If the ray should stop traversing the bodies.
	 * @private
	 * @property {Boolean} _shouldStop
	 * @default false
	 */
	this._shouldStop = false;
}

/**
 * Reset all result data.
 * @method reset
 */
RaycastResult.prototype.reset = function () {
	this.rayFromWorld.setZero();
	this.rayToWorld.setZero();
	this.hitNormalWorld.setZero();
	this.hitPointWorld.setZero();
	this.hasHit = false;
	this.shape = null;
	this.body = null;
	this.hitFaceIndex = -1;
	this.distance = -1;
	this._shouldStop = false;
};

/**
 * @method abort
 */
RaycastResult.prototype.abort = function(){
	this._shouldStop = true;
};

/**
 * @method set
 * @param {Vec3} rayFromWorld
 * @param {Vec3} rayToWorld
 * @param {Vec3} hitNormalWorld
 * @param {Vec3} hitPointWorld
 * @param {Shape} shape
 * @param {Body} body
 * @param {number} distance
 */
RaycastResult.prototype.set = function(
	rayFromWorld,
	rayToWorld,
	hitNormalWorld,
	hitPointWorld,
	shape,
	body,
	distance
){
	this.rayFromWorld.copy(rayFromWorld);
	this.rayToWorld.copy(rayToWorld);
	this.hitNormalWorld.copy(hitNormalWorld);
	this.hitPointWorld.copy(hitPointWorld);
	this.shape = shape;
	this.body = body;
	this.distance = distance;
};
},{"../math/Vec3":30}],11:[function(_dereq_,module,exports){
var Shape = _dereq_('../shapes/Shape');
var Broadphase = _dereq_('../collision/Broadphase');

module.exports = SAPBroadphase;

/**
 * Sweep and prune broadphase along one axis.
 *
 * @class SAPBroadphase
 * @constructor
 * @param {World} [world]
 * @extends Broadphase
 */
function SAPBroadphase(world){
    Broadphase.apply(this);

    /**
     * List of bodies currently in the broadphase.
     * @property axisList
     * @type {Array}
     */
    this.axisList = [];

    /**
     * The world to search in.
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * Axis to sort the bodies along. Set to 0 for x axis, and 1 for y axis. For best performance, choose an axis that the bodies are spread out more on.
     * @property axisIndex
     * @type {Number}
     */
    this.axisIndex = 0;

    var axisList = this.axisList;

    this._addBodyHandler = function(e){
        axisList.push(e.body);
    };

    this._removeBodyHandler = function(e){
        var idx = axisList.indexOf(e.body);
        if(idx !== -1){
            axisList.splice(idx,1);
        }
    };

    if(world){
        this.setWorld(world);
    }
}
SAPBroadphase.prototype = new Broadphase();

/**
 * Change the world
 * @method setWorld
 * @param  {World} world
 */
SAPBroadphase.prototype.setWorld = function(world){
    // Clear the old axis array
    this.axisList.length = 0;

    // Add all bodies from the new world
    for(var i=0; i<world.bodies.length; i++){
        this.axisList.push(world.bodies[i]);
    }

    // Remove old handlers, if any
    world.removeEventListener("addBody", this._addBodyHandler);
    world.removeEventListener("removeBody", this._removeBodyHandler);

    // Add handlers to update the list of bodies.
    world.addEventListener("addBody", this._addBodyHandler);
    world.addEventListener("removeBody", this._removeBodyHandler);

    this.world = world;
    this.dirty = true;
};

/**
 * @static
 * @method insertionSortX
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortX = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.x <= v.aabb.lowerBound.x){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * @static
 * @method insertionSortY
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortY = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.y <= v.aabb.lowerBound.y){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * @static
 * @method insertionSortZ
 * @param  {Array} a
 * @return {Array}
 */
SAPBroadphase.insertionSortZ = function(a) {
    for(var i=1,l=a.length;i<l;i++) {
        var v = a[i];
        for(var j=i - 1;j>=0;j--) {
            if(a[j].aabb.lowerBound.z <= v.aabb.lowerBound.z){
                break;
            }
            a[j+1] = a[j];
        }
        a[j+1] = v;
    }
    return a;
};

/**
 * Collect all collision pairs
 * @method collisionPairs
 * @param  {World} world
 * @param  {Array} p1
 * @param  {Array} p2
 */
SAPBroadphase.prototype.collisionPairs = function(world,p1,p2){
    var bodies = this.axisList,
        N = bodies.length,
        axisIndex = this.axisIndex,
        i, j;

    if(this.dirty){
        this.sortList();
        this.dirty = false;
    }

    // Look through the list
    for(i=0; i !== N; i++){
        var bi = bodies[i];

        for(j=i+1; j < N; j++){
            var bj = bodies[j];

            if(!this.needBroadphaseCollision(bi,bj)){
                continue;
            }

            if(!SAPBroadphase.checkBounds(bi,bj,axisIndex)){
                break;
            }

            this.intersectionTest(bi,bj,p1,p2);
        }
    }
};

SAPBroadphase.prototype.sortList = function(){
    var axisList = this.axisList;
    var axisIndex = this.axisIndex;
    var N = axisList.length;

    // Update AABBs
    for(var i = 0; i!==N; i++){
        var bi = axisList[i];
        if(bi.aabbNeedsUpdate){
            bi.computeAABB();
        }
    }

    // Sort the list
    if(axisIndex === 0){
        SAPBroadphase.insertionSortX(axisList);
    } else if(axisIndex === 1){
        SAPBroadphase.insertionSortY(axisList);
    } else if(axisIndex === 2){
        SAPBroadphase.insertionSortZ(axisList);
    }
};

/**
 * Check if the bounds of two bodies overlap, along the given SAP axis.
 * @static
 * @method checkBounds
 * @param  {Body} bi
 * @param  {Body} bj
 * @param  {Number} axisIndex
 * @return {Boolean}
 */
SAPBroadphase.checkBounds = function(bi, bj, axisIndex){
    var biPos;
    var bjPos;

    if(axisIndex === 0){
        biPos = bi.position.x;
        bjPos = bj.position.x;
    } else if(axisIndex === 1){
        biPos = bi.position.y;
        bjPos = bj.position.y;
    } else if(axisIndex === 2){
        biPos = bi.position.z;
        bjPos = bj.position.z;
    }

    var ri = bi.boundingRadius,
        rj = bj.boundingRadius,
        boundA1 = biPos - ri,
        boundA2 = biPos + ri,
        boundB1 = bjPos - rj,
        boundB2 = bjPos + rj;

    return boundB1 < boundA2;
};

/**
 * Computes the variance of the body positions and estimates the best
 * axis to use. Will automatically set property .axisIndex.
 * @method autoDetectAxis
 */
SAPBroadphase.prototype.autoDetectAxis = function(){
    var sumX=0,
        sumX2=0,
        sumY=0,
        sumY2=0,
        sumZ=0,
        sumZ2=0,
        bodies = this.axisList,
        N = bodies.length,
        invN=1/N;

    for(var i=0; i!==N; i++){
        var b = bodies[i];

        var centerX = b.position.x;
        sumX += centerX;
        sumX2 += centerX*centerX;

        var centerY = b.position.y;
        sumY += centerY;
        sumY2 += centerY*centerY;

        var centerZ = b.position.z;
        sumZ += centerZ;
        sumZ2 += centerZ*centerZ;
    }

    var varianceX = sumX2 - sumX*sumX*invN,
        varianceY = sumY2 - sumY*sumY*invN,
        varianceZ = sumZ2 - sumZ*sumZ*invN;

    if(varianceX > varianceY){
        if(varianceX > varianceZ){
            this.axisIndex = 0;
        } else{
            this.axisIndex = 2;
        }
    } else if(varianceY > varianceZ){
        this.axisIndex = 1;
    } else{
        this.axisIndex = 2;
    }
};

/**
 * Returns all the bodies within an AABB.
 * @method aabbQuery
 * @param  {World} world
 * @param  {AABB} aabb
 * @param {array} result An array to store resulting bodies in.
 * @return {array}
 */
SAPBroadphase.prototype.aabbQuery = function(world, aabb, result){
    result = result || [];

    if(this.dirty){
        this.sortList();
        this.dirty = false;
    }

    var axisIndex = this.axisIndex, axis = 'x';
    if(axisIndex === 1){ axis = 'y'; }
    if(axisIndex === 2){ axis = 'z'; }

    var axisList = this.axisList;
    var lower = aabb.lowerBound[axis];
    var upper = aabb.upperBound[axis];
    for(var i = 0; i < axisList.length; i++){
        var b = axisList[i];

        if(b.aabbNeedsUpdate){
            b.computeAABB();
        }

        if(b.aabb.overlaps(aabb)){
            result.push(b);
        }
    }

    return result;
};
},{"../collision/Broadphase":5,"../shapes/Shape":43}],12:[function(_dereq_,module,exports){
module.exports = ConeTwistConstraint;

var Constraint = _dereq_('./Constraint');
var PointToPointConstraint = _dereq_('./PointToPointConstraint');
var ConeEquation = _dereq_('../equations/ConeEquation');
var RotationalEquation = _dereq_('../equations/RotationalEquation');
var ContactEquation = _dereq_('../equations/ContactEquation');
var Vec3 = _dereq_('../math/Vec3');

/**
 * @class ConeTwistConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA]
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function ConeTwistConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    // Set pivot point in between
    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();
    this.axisA = options.axisA ? options.axisA.clone() : new Vec3();
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3();

    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    this.collideConnected = !!options.collideConnected;

    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;

    /**
     * @property {ConeEquation} coneEquation
     */
    var c = this.coneEquation = new ConeEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} twistEquation
     */
    var t = this.twistEquation = new RotationalEquation(bodyA,bodyB,options);
    this.twistAngle = typeof(options.twistAngle) !== 'undefined' ? options.twistAngle : 0;

    // Make the cone equation push the bodies toward the cone axis, not outward
    c.maxForce = 0;
    c.minForce = -maxForce;

    // Make the twist equation add torque toward the initial position
    t.maxForce = 0;
    t.minForce = -maxForce;

    this.equations.push(c, t);
}
ConeTwistConstraint.prototype = new PointToPointConstraint();
ConeTwistConstraint.constructor = ConeTwistConstraint;

var ConeTwistConstraint_update_tmpVec1 = new Vec3();
var ConeTwistConstraint_update_tmpVec2 = new Vec3();

ConeTwistConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        cone = this.coneEquation,
        twist = this.twistEquation;

    PointToPointConstraint.prototype.update.call(this);

    // Update the axes to the cone constraint
    bodyA.vectorToWorldFrame(this.axisA, cone.axisA);
    bodyB.vectorToWorldFrame(this.axisB, cone.axisB);

    // Update the world axes in the twist constraint
    this.axisA.tangents(twist.axisA, twist.axisA);
    bodyA.vectorToWorldFrame(twist.axisA, twist.axisA);

    this.axisB.tangents(twist.axisB, twist.axisB);
    bodyB.vectorToWorldFrame(twist.axisB, twist.axisB);

    cone.angle = this.angle;
    twist.maxAngle = this.twistAngle;
};


},{"../equations/ConeEquation":18,"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],13:[function(_dereq_,module,exports){
module.exports = Constraint;

var Utils = _dereq_('../utils/Utils');

/**
 * Constraint base class
 * @class Constraint
 * @author schteppe
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {boolean} [options.collideConnected=true]
 * @param {boolean} [options.wakeUpBodies=true]
 */
function Constraint(bodyA, bodyB, options){
    options = Utils.defaults(options,{
        collideConnected : true,
        wakeUpBodies : true,
    });

    /**
     * Equations to be solved in this constraint
     * @property equations
     * @type {Array}
     */
    this.equations = [];

    /**
     * @property {Body} bodyA
     */
    this.bodyA = bodyA;

    /**
     * @property {Body} bodyB
     */
    this.bodyB = bodyB;

    /**
     * @property {Number} id
     */
    this.id = Constraint.idCounter++;

    /**
     * Set to true if you want the bodies to collide when they are connected.
     * @property collideConnected
     * @type {boolean}
     */
    this.collideConnected = options.collideConnected;

    if(options.wakeUpBodies){
        if(bodyA){
            bodyA.wakeUp();
        }
        if(bodyB){
            bodyB.wakeUp();
        }
    }
}

/**
 * Update all the equations with data.
 * @method update
 */
Constraint.prototype.update = function(){
    throw new Error("method update() not implmemented in this Constraint subclass!");
};

/**
 * Enables all equations in the constraint.
 * @method enable
 */
Constraint.prototype.enable = function(){
    var eqs = this.equations;
    for(var i=0; i<eqs.length; i++){
        eqs[i].enabled = true;
    }
};

/**
 * Disables all equations in the constraint.
 * @method disable
 */
Constraint.prototype.disable = function(){
    var eqs = this.equations;
    for(var i=0; i<eqs.length; i++){
        eqs[i].enabled = false;
    }
};

Constraint.idCounter = 0;

},{"../utils/Utils":53}],14:[function(_dereq_,module,exports){
module.exports = DistanceConstraint;

var Constraint = _dereq_('./Constraint');
var ContactEquation = _dereq_('../equations/ContactEquation');

/**
 * Constrains two bodies to be at a constant distance from each others center of mass.
 * @class DistanceConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} [distance] The distance to keep. If undefined, it will be set to the current distance between bodyA and bodyB
 * @param {Number} [maxForce=1e6]
 * @extends Constraint
 */
function DistanceConstraint(bodyA,bodyB,distance,maxForce){
    Constraint.call(this,bodyA,bodyB);

    if(typeof(distance)==="undefined") {
        distance = bodyA.position.distanceTo(bodyB.position);
    }

    if(typeof(maxForce)==="undefined") {
        maxForce = 1e6;
    }

    /**
     * @property {number} distance
     */
    this.distance = distance;

    /**
     * @property {ContactEquation} distanceEquation
     */
    var eq = this.distanceEquation = new ContactEquation(bodyA, bodyB);
    this.equations.push(eq);

    // Make it bidirectional
    eq.minForce = -maxForce;
    eq.maxForce =  maxForce;
}
DistanceConstraint.prototype = new Constraint();

DistanceConstraint.prototype.update = function(){
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;
    var eq = this.distanceEquation;
    var halfDist = this.distance * 0.5;
    var normal = eq.ni;

    bodyB.position.vsub(bodyA.position, normal);
    normal.normalize();
    normal.mult(halfDist, eq.ri);
    normal.mult(-halfDist, eq.rj);
};
},{"../equations/ContactEquation":19,"./Constraint":13}],15:[function(_dereq_,module,exports){
module.exports = HingeConstraint;

var Constraint = _dereq_('./Constraint');
var PointToPointConstraint = _dereq_('./PointToPointConstraint');
var RotationalEquation = _dereq_('../equations/RotationalEquation');
var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
var ContactEquation = _dereq_('../equations/ContactEquation');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Hinge constraint. Think of it as a door hinge. It tries to keep the door in the correct place and with the correct orientation.
 * @class HingeConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Vec3} [options.pivotA] A point defined locally in bodyA. This defines the offset of axisA.
 * @param {Vec3} [options.axisA] An axis that bodyA can rotate around, defined locally in bodyA.
 * @param {Vec3} [options.pivotB]
 * @param {Vec3} [options.axisB]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function HingeConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;
    var pivotA = options.pivotA ? options.pivotA.clone() : new Vec3();
    var pivotB = options.pivotB ? options.pivotB.clone() : new Vec3();

    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    /**
     * Rotation axis, defined locally in bodyA.
     * @property {Vec3} axisA
     */
    var axisA = this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1,0,0);
    axisA.normalize();

    /**
     * Rotation axis, defined locally in bodyB.
     * @property {Vec3} axisB
     */
    var axisB = this.axisB = options.axisB ? options.axisB.clone() : new Vec3(1,0,0);
    axisB.normalize();

    /**
     * @property {RotationalEquation} rotationalEquation1
     */
    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation2
     */
    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalMotorEquation} motorEquation
     */
    var motor = this.motorEquation = new RotationalMotorEquation(bodyA,bodyB,maxForce);
    motor.enabled = false; // Not enabled by default

    // Equations to be fed to the solver
    this.equations.push(
        r1, // rotational1
        r2, // rotational2
        motor
    );
}
HingeConstraint.prototype = new PointToPointConstraint();
HingeConstraint.constructor = HingeConstraint;

/**
 * @method enableMotor
 */
HingeConstraint.prototype.enableMotor = function(){
    this.motorEquation.enabled = true;
};

/**
 * @method disableMotor
 */
HingeConstraint.prototype.disableMotor = function(){
    this.motorEquation.enabled = false;
};

/**
 * @method setMotorSpeed
 * @param {number} speed
 */
HingeConstraint.prototype.setMotorSpeed = function(speed){
    this.motorEquation.targetVelocity = speed;
};

/**
 * @method setMotorMaxForce
 * @param {number} maxForce
 */
HingeConstraint.prototype.setMotorMaxForce = function(maxForce){
    this.motorEquation.maxForce = maxForce;
    this.motorEquation.minForce = -maxForce;
};

var HingeConstraint_update_tmpVec1 = new Vec3();
var HingeConstraint_update_tmpVec2 = new Vec3();

HingeConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        motor = this.motorEquation,
        r1 = this.rotationalEquation1,
        r2 = this.rotationalEquation2,
        worldAxisA = HingeConstraint_update_tmpVec1,
        worldAxisB = HingeConstraint_update_tmpVec2;

    var axisA = this.axisA;
    var axisB = this.axisB;

    PointToPointConstraint.prototype.update.call(this);

    // Get world axes
    bodyA.quaternion.vmult(axisA, worldAxisA);
    bodyB.quaternion.vmult(axisB, worldAxisB);

    worldAxisA.tangents(r1.axisA, r2.axisA);
    r1.axisB.copy(worldAxisB);
    r2.axisB.copy(worldAxisB);

    if(this.motorEquation.enabled){
        bodyA.quaternion.vmult(this.axisA, motor.axisA);
        bodyB.quaternion.vmult(this.axisB, motor.axisB);
    }
};


},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],16:[function(_dereq_,module,exports){
module.exports = LockConstraint;

var Constraint = _dereq_('./Constraint');
var PointToPointConstraint = _dereq_('./PointToPointConstraint');
var RotationalEquation = _dereq_('../equations/RotationalEquation');
var RotationalMotorEquation = _dereq_('../equations/RotationalMotorEquation');
var ContactEquation = _dereq_('../equations/ContactEquation');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Lock constraint. Will remove all degrees of freedom between the bodies.
 * @class LockConstraint
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {object} [options]
 * @param {Number} [options.maxForce=1e6]
 * @extends PointToPointConstraint
 */
function LockConstraint(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    // Set pivot point in between
    var pivotA = new Vec3();
    var pivotB = new Vec3();
    var halfWay = new Vec3();
    bodyA.position.vadd(bodyB.position, halfWay);
    halfWay.scale(0.5, halfWay);
    bodyB.pointToLocalFrame(halfWay, pivotB);
    bodyA.pointToLocalFrame(halfWay, pivotA);
    PointToPointConstraint.call(this, bodyA, pivotA, bodyB, pivotB, maxForce);

    /**
     * @property {RotationalEquation} rotationalEquation1
     */
    var r1 = this.rotationalEquation1 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation2
     */
    var r2 = this.rotationalEquation2 = new RotationalEquation(bodyA,bodyB,options);

    /**
     * @property {RotationalEquation} rotationalEquation3
     */
    var r3 = this.rotationalEquation3 = new RotationalEquation(bodyA,bodyB,options);

    this.equations.push(r1, r2, r3);
}
LockConstraint.prototype = new PointToPointConstraint();
LockConstraint.constructor = LockConstraint;

var LockConstraint_update_tmpVec1 = new Vec3();
var LockConstraint_update_tmpVec2 = new Vec3();

LockConstraint.prototype.update = function(){
    var bodyA = this.bodyA,
        bodyB = this.bodyB,
        motor = this.motorEquation,
        r1 = this.rotationalEquation1,
        r2 = this.rotationalEquation2,
        r3 = this.rotationalEquation3,
        worldAxisA = LockConstraint_update_tmpVec1,
        worldAxisB = LockConstraint_update_tmpVec2;

    PointToPointConstraint.prototype.update.call(this);

    bodyA.vectorToWorldFrame(Vec3.UNIT_X, r1.axisA);
    bodyB.vectorToWorldFrame(Vec3.UNIT_Y, r1.axisB);

    bodyA.vectorToWorldFrame(Vec3.UNIT_Y, r2.axisA);
    bodyB.vectorToWorldFrame(Vec3.UNIT_Z, r2.axisB);

    bodyA.vectorToWorldFrame(Vec3.UNIT_Z, r3.axisA);
    bodyB.vectorToWorldFrame(Vec3.UNIT_X, r3.axisB);
};


},{"../equations/ContactEquation":19,"../equations/RotationalEquation":22,"../equations/RotationalMotorEquation":23,"../math/Vec3":30,"./Constraint":13,"./PointToPointConstraint":17}],17:[function(_dereq_,module,exports){
module.exports = PointToPointConstraint;

var Constraint = _dereq_('./Constraint');
var ContactEquation = _dereq_('../equations/ContactEquation');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Connects two bodies at given offset points.
 * @class PointToPointConstraint
 * @extends Constraint
 * @constructor
 * @param {Body} bodyA
 * @param {Vec3} pivotA The point relative to the center of mass of bodyA which bodyA is constrained to.
 * @param {Body} bodyB Body that will be constrained in a similar way to the same point as bodyA. We will therefore get a link between bodyA and bodyB. If not specified, bodyA will be constrained to a static point.
 * @param {Vec3} pivotB See pivotA.
 * @param {Number} maxForce The maximum force that should be applied to constrain the bodies.
 *
 * @example
 *     var bodyA = new Body({ mass: 1 });
 *     var bodyB = new Body({ mass: 1 });
 *     bodyA.position.set(-1, 0, 0);
 *     bodyB.position.set(1, 0, 0);
 *     bodyA.addShape(shapeA);
 *     bodyB.addShape(shapeB);
 *     world.addBody(bodyA);
 *     world.addBody(bodyB);
 *     var localPivotA = new Vec3(1, 0, 0);
 *     var localPivotB = new Vec3(-1, 0, 0);
 *     var constraint = new PointToPointConstraint(bodyA, localPivotA, bodyB, localPivotB);
 *     world.addConstraint(constraint);
 */
function PointToPointConstraint(bodyA,pivotA,bodyB,pivotB,maxForce){
    Constraint.call(this,bodyA,bodyB);

    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;

    /**
     * Pivot, defined locally in bodyA.
     * @property {Vec3} pivotA
     */
    this.pivotA = pivotA ? pivotA.clone() : new Vec3();

    /**
     * Pivot, defined locally in bodyB.
     * @property {Vec3} pivotB
     */
    this.pivotB = pivotB ? pivotB.clone() : new Vec3();

    /**
     * @property {ContactEquation} equationX
     */
    var x = this.equationX = new ContactEquation(bodyA,bodyB);

    /**
     * @property {ContactEquation} equationY
     */
    var y = this.equationY = new ContactEquation(bodyA,bodyB);

    /**
     * @property {ContactEquation} equationZ
     */
    var z = this.equationZ = new ContactEquation(bodyA,bodyB);

    // Equations to be fed to the solver
    this.equations.push(x, y, z);

    // Make the equations bidirectional
    x.minForce = y.minForce = z.minForce = -maxForce;
    x.maxForce = y.maxForce = z.maxForce =  maxForce;

    x.ni.set(1, 0, 0);
    y.ni.set(0, 1, 0);
    z.ni.set(0, 0, 1);
}
PointToPointConstraint.prototype = new Constraint();

PointToPointConstraint.prototype.update = function(){
    var bodyA = this.bodyA;
    var bodyB = this.bodyB;
    var x = this.equationX;
    var y = this.equationY;
    var z = this.equationZ;

    // Rotate the pivots to world space
    bodyA.quaternion.vmult(this.pivotA,x.ri);
    bodyB.quaternion.vmult(this.pivotB,x.rj);

    y.ri.copy(x.ri);
    y.rj.copy(x.rj);
    z.ri.copy(x.ri);
    z.rj.copy(x.rj);
};
},{"../equations/ContactEquation":19,"../math/Vec3":30,"./Constraint":13}],18:[function(_dereq_,module,exports){
module.exports = ConeEquation;

var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');
var Equation = _dereq_('./Equation');

/**
 * Cone equation. Works to keep the given body world vectors aligned, or tilted within a given angle from each other.
 * @class ConeEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA] Local axis in A
 * @param {Vec3} [options.axisB] Local axis in B
 * @param {Vec3} [options.angle] The "cone angle" to keep
 * @param {number} [options.maxForce=1e6]
 * @extends Equation
 */
function ConeEquation(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

    /**
     * The cone angle to keep
     * @property {number} angle
     */
    this.angle = typeof(options.angle) !== 'undefined' ? options.angle : 0;
}

ConeEquation.prototype = new Equation();
ConeEquation.prototype.constructor = ConeEquation;

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();

ConeEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,

        ni = this.axisA,
        nj = this.axisB,

        nixnj = tmpVec1,
        njxni = tmpVec2,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // Caluclate cross products
    ni.cross(nj, nixnj);
    nj.cross(ni, njxni);

    // The angle between two vector is:
    // cos(theta) = a * b / (length(a) * length(b) = { len(a) = len(b) = 1 } = a * b

    // g = a * b
    // gdot = (b x a) * wi + (a x b) * wj
    // G = [0 bxa 0 axb]
    // W = [vi wi vj wj]
    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);

    var g = Math.cos(this.angle) - ni.dot(nj),
        GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h * GiMf;

    return B;
};


},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],19:[function(_dereq_,module,exports){
module.exports = ContactEquation;

var Equation = _dereq_('./Equation');
var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');

/**
 * Contact/non-penetration constraint equation
 * @class ContactEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @extends Equation
 */
function ContactEquation(bodyA, bodyB, maxForce){
    maxForce = typeof(maxForce) !== 'undefined' ? maxForce : 1e6;
    Equation.call(this, bodyA, bodyB, 0, maxForce);

    /**
     * @property restitution
     * @type {Number}
     */
    this.restitution = 0.0; // "bounciness": u1 = -e*u0

    /**
     * World-oriented vector that goes from the center of bi to the contact point.
     * @property {Vec3} ri
     */
    this.ri = new Vec3();

    /**
     * World-oriented vector that starts in body j position and goes to the contact point.
     * @property {Vec3} rj
     */
    this.rj = new Vec3();

    /**
     * Contact normal, pointing out of body i.
     * @property {Vec3} ni
     */
    this.ni = new Vec3();
}

ContactEquation.prototype = new Equation();
ContactEquation.prototype.constructor = ContactEquation;

var ContactEquation_computeB_temp1 = new Vec3(); // Temp vectors
var ContactEquation_computeB_temp2 = new Vec3();
var ContactEquation_computeB_temp3 = new Vec3();
ContactEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,
        ri = this.ri,
        rj = this.rj,
        rixn = ContactEquation_computeB_temp1,
        rjxn = ContactEquation_computeB_temp2,

        vi = bi.velocity,
        wi = bi.angularVelocity,
        fi = bi.force,
        taui = bi.torque,

        vj = bj.velocity,
        wj = bj.angularVelocity,
        fj = bj.force,
        tauj = bj.torque,

        penetrationVec = ContactEquation_computeB_temp3,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB,

        n = this.ni;

    // Caluclate cross products
    ri.cross(n,rixn);
    rj.cross(n,rjxn);

    // g = xj+rj -(xi+ri)
    // G = [ -ni  -rixn  ni  rjxn ]
    n.negate(GA.spatial);
    rixn.negate(GA.rotational);
    GB.spatial.copy(n);
    GB.rotational.copy(rjxn);

    // Calculate the penetration vector
    penetrationVec.copy(bj.position);
    penetrationVec.vadd(rj,penetrationVec);
    penetrationVec.vsub(bi.position,penetrationVec);
    penetrationVec.vsub(ri,penetrationVec);

    var g = n.dot(penetrationVec);

    // Compute iteration
    var ePlusOne = this.restitution + 1;
    var GW = ePlusOne * vj.dot(n) - ePlusOne * vi.dot(n) + wj.dot(rjxn) - wi.dot(rixn);
    var GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h*GiMf;

    return B;
};

var ContactEquation_getImpactVelocityAlongNormal_vi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_vj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xi = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_xj = new Vec3();
var ContactEquation_getImpactVelocityAlongNormal_relVel = new Vec3();

/**
 * Get the current relative velocity in the contact point.
 * @method getImpactVelocityAlongNormal
 * @return {number}
 */
ContactEquation.prototype.getImpactVelocityAlongNormal = function(){
    var vi = ContactEquation_getImpactVelocityAlongNormal_vi;
    var vj = ContactEquation_getImpactVelocityAlongNormal_vj;
    var xi = ContactEquation_getImpactVelocityAlongNormal_xi;
    var xj = ContactEquation_getImpactVelocityAlongNormal_xj;
    var relVel = ContactEquation_getImpactVelocityAlongNormal_relVel;

    this.bi.position.vadd(this.ri, xi);
    this.bj.position.vadd(this.rj, xj);

    this.bi.getVelocityAtWorldPoint(xi, vi);
    this.bj.getVelocityAtWorldPoint(xj, vj);

    vi.vsub(vj, relVel);

    return this.ni.dot(relVel);
};


},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],20:[function(_dereq_,module,exports){
module.exports = Equation;

var JacobianElement = _dereq_('../math/JacobianElement'),
    Vec3 = _dereq_('../math/Vec3');

/**
 * Equation base class
 * @class Equation
 * @constructor
 * @author schteppe
 * @param {Body} bi
 * @param {Body} bj
 * @param {Number} minForce Minimum (read: negative max) force to be applied by the constraint.
 * @param {Number} maxForce Maximum (read: positive max) force to be applied by the constraint.
 */
function Equation(bi,bj,minForce,maxForce){
    this.id = Equation.id++;

    /**
     * @property {number} minForce
     */
    this.minForce = typeof(minForce)==="undefined" ? -1e6 : minForce;

    /**
     * @property {number} maxForce
     */
    this.maxForce = typeof(maxForce)==="undefined" ? 1e6 : maxForce;

    /**
     * @property bi
     * @type {Body}
     */
    this.bi = bi;

    /**
     * @property bj
     * @type {Body}
     */
    this.bj = bj;

    /**
     * SPOOK parameter
     * @property {number} a
     */
    this.a = 0.0;

    /**
     * SPOOK parameter
     * @property {number} b
     */
    this.b = 0.0;

    /**
     * SPOOK parameter
     * @property {number} eps
     */
    this.eps = 0.0;

    /**
     * @property {JacobianElement} jacobianElementA
     */
    this.jacobianElementA = new JacobianElement();

    /**
     * @property {JacobianElement} jacobianElementB
     */
    this.jacobianElementB = new JacobianElement();

    /**
     * @property {boolean} enabled
     * @default true
     */
    this.enabled = true;

    // Set typical spook params
    this.setSpookParams(1e7,4,1/60);
}
Equation.prototype.constructor = Equation;

Equation.id = 0;

/**
 * Recalculates a,b,eps.
 * @method setSpookParams
 */
Equation.prototype.setSpookParams = function(stiffness,relaxation,timeStep){
    var d = relaxation,
        k = stiffness,
        h = timeStep;
    this.a = 4.0 / (h * (1 + 4 * d));
    this.b = (4.0 * d) / (1 + 4 * d);
    this.eps = 4.0 / (h * h * k * (1 + 4 * d));
};

/**
 * Computes the RHS of the SPOOK equation
 * @method computeB
 * @return {Number}
 */
Equation.prototype.computeB = function(a,b,h){
    var GW = this.computeGW(),
        Gq = this.computeGq(),
        GiMf = this.computeGiMf();
    return - Gq * a - GW * b - GiMf*h;
};

/**
 * Computes G*q, where q are the generalized body coordinates
 * @method computeGq
 * @return {Number}
 */
Equation.prototype.computeGq = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        xi = bi.position,
        xj = bj.position;
    return GA.spatial.dot(xi) + GB.spatial.dot(xj);
};

var zero = new Vec3();

/**
 * Computes G*W, where W are the body velocities
 * @method computeGW
 * @return {Number}
 */
Equation.prototype.computeGW = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        vi = bi.velocity,
        vj = bj.velocity,
        wi = bi.angularVelocity || zero,
        wj = bj.angularVelocity || zero;
    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
};


/**
 * Computes G*Wlambda, where W are the body velocities
 * @method computeGWlambda
 * @return {Number}
 */
Equation.prototype.computeGWlambda = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        vi = bi.vlambda,
        vj = bj.vlambda,
        wi = bi.wlambda || zero,
        wj = bj.wlambda || zero;
    return GA.multiplyVectors(vi,wi) + GB.multiplyVectors(vj,wj);
};

/**
 * Computes G*inv(M)*f, where M is the mass matrix with diagonal blocks for each body, and f are the forces on the bodies.
 * @method computeGiMf
 * @return {Number}
 */
var iMfi = new Vec3(),
    iMfj = new Vec3(),
    invIi_vmult_taui = new Vec3(),
    invIj_vmult_tauj = new Vec3();
Equation.prototype.computeGiMf = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        fi = bi.force,
        ti = bi.torque,
        fj = bj.force,
        tj = bj.torque,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve;

    if(bi.invInertiaWorldSolve){ bi.invInertiaWorldSolve.vmult(ti,invIi_vmult_taui); }
    else { invIi_vmult_taui.set(0,0,0); }
    if(bj.invInertiaWorldSolve){ bj.invInertiaWorldSolve.vmult(tj,invIj_vmult_tauj); }
    else { invIj_vmult_tauj.set(0,0,0); }

    fi.mult(invMassi,iMfi);
    fj.mult(invMassj,iMfj);

    return GA.multiplyVectors(iMfi,invIi_vmult_taui) + GB.multiplyVectors(iMfj,invIj_vmult_tauj);
};

/**
 * Computes G*inv(M)*G'
 * @method computeGiMGt
 * @return {Number}
 */
var tmp = new Vec3();
Equation.prototype.computeGiMGt = function(){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        invMassi = bi.invMassSolve,
        invMassj = bj.invMassSolve,
        invIi = bi.invInertiaWorldSolve,
        invIj = bj.invInertiaWorldSolve,
        result = invMassi + invMassj;

    if(invIi){
        invIi.vmult(GA.rotational,tmp);
        result += tmp.dot(GA.rotational);
    }

    if(invIj){
        invIj.vmult(GB.rotational,tmp);
        result += tmp.dot(GB.rotational);
    }

    return  result;
};

var addToWlambda_temp = new Vec3(),
    addToWlambda_Gi = new Vec3(),
    addToWlambda_Gj = new Vec3(),
    addToWlambda_ri = new Vec3(),
    addToWlambda_rj = new Vec3(),
    addToWlambda_Mdiag = new Vec3();

/**
 * Add constraint velocity to the bodies.
 * @method addToWlambda
 * @param {Number} deltalambda
 */
Equation.prototype.addToWlambda = function(deltalambda){
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB,
        bi = this.bi,
        bj = this.bj,
        temp = addToWlambda_temp;

    // Add to linear velocity
    // v_lambda += inv(M) * delta_lamba * G
    GA.spatial.mult(bi.invMassSolve * deltalambda,temp);
    bi.vlambda.vadd(temp, bi.vlambda);

    GB.spatial.mult(bj.invMassSolve * deltalambda,temp);
    bj.vlambda.vadd(temp, bj.vlambda);

    // Add to angular velocity
    if(bi.invInertiaWorldSolve){
        bi.invInertiaWorldSolve.vmult(GA.rotational,temp);
        temp.mult(deltalambda,temp);
        bi.wlambda.vadd(temp,bi.wlambda);
    }

    if(bj.invInertiaWorldSolve){
        bj.invInertiaWorldSolve.vmult(GB.rotational,temp);
        temp.mult(deltalambda,temp);
        bj.wlambda.vadd(temp,bj.wlambda);
    }
};

/**
 * Compute the denominator part of the SPOOK equation: C = G*inv(M)*G' + eps
 * @method computeInvC
 * @param  {Number} eps
 * @return {Number}
 */
Equation.prototype.computeC = function(){
    return this.computeGiMGt() + this.eps;
};

},{"../math/JacobianElement":26,"../math/Vec3":30}],21:[function(_dereq_,module,exports){
module.exports = FrictionEquation;

var Equation = _dereq_('./Equation');
var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');

/**
 * Constrains the slipping in a contact along a tangent
 * @class FrictionEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} slipForce should be +-F_friction = +-mu * F_normal = +-mu * m * g
 * @extends Equation
 */
function FrictionEquation(bodyA, bodyB, slipForce){
    Equation.call(this,bodyA, bodyB, -slipForce, slipForce);
    this.ri = new Vec3();
    this.rj = new Vec3();
    this.t = new Vec3(); // tangent
}

FrictionEquation.prototype = new Equation();
FrictionEquation.prototype.constructor = FrictionEquation;

var FrictionEquation_computeB_temp1 = new Vec3();
var FrictionEquation_computeB_temp2 = new Vec3();
FrictionEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,
        ri = this.ri,
        rj = this.rj,
        rixt = FrictionEquation_computeB_temp1,
        rjxt = FrictionEquation_computeB_temp2,
        t = this.t;

    // Caluclate cross products
    ri.cross(t,rixt);
    rj.cross(t,rjxt);

    // G = [-t -rixt t rjxt]
    // And remember, this is a pure velocity constraint, g is always zero!
    var GA = this.jacobianElementA,
        GB = this.jacobianElementB;
    t.negate(GA.spatial);
    rixt.negate(GA.rotational);
    GB.spatial.copy(t);
    GB.rotational.copy(rjxt);

    var GW = this.computeGW();
    var GiMf = this.computeGiMf();

    var B = - GW * b - h * GiMf;

    return B;
};

},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],22:[function(_dereq_,module,exports){
module.exports = RotationalEquation;

var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');
var Equation = _dereq_('./Equation');

/**
 * Rotational constraint. Works to keep the local vectors orthogonal to each other in world space.
 * @class RotationalEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec3} [options.axisA]
 * @param {Vec3} [options.axisB]
 * @param {number} [options.maxForce]
 * @extends Equation
 */
function RotationalEquation(bodyA, bodyB, options){
    options = options || {};
    var maxForce = typeof(options.maxForce) !== 'undefined' ? options.maxForce : 1e6;

    Equation.call(this,bodyA,bodyB,-maxForce, maxForce);

    this.axisA = options.axisA ? options.axisA.clone() : new Vec3(1, 0, 0);
    this.axisB = options.axisB ? options.axisB.clone() : new Vec3(0, 1, 0);

    this.maxAngle = Math.PI / 2;
}

RotationalEquation.prototype = new Equation();
RotationalEquation.prototype.constructor = RotationalEquation;

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();

RotationalEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,

        ni = this.axisA,
        nj = this.axisB,

        nixnj = tmpVec1,
        njxni = tmpVec2,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // Caluclate cross products
    ni.cross(nj, nixnj);
    nj.cross(ni, njxni);

    // g = ni * nj
    // gdot = (nj x ni) * wi + (ni x nj) * wj
    // G = [0 njxni 0 nixnj]
    // W = [vi wi vj wj]
    GA.rotational.copy(njxni);
    GB.rotational.copy(nixnj);

    var g = Math.cos(this.maxAngle) - ni.dot(nj),
        GW = this.computeGW(),
        GiMf = this.computeGiMf();

    var B = - g * a - GW * b - h * GiMf;

    return B;
};


},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],23:[function(_dereq_,module,exports){
module.exports = RotationalMotorEquation;

var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');
var Equation = _dereq_('./Equation');

/**
 * Rotational motor constraint. Tries to keep the relative angular velocity of the bodies to a given value.
 * @class RotationalMotorEquation
 * @constructor
 * @author schteppe
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Number} maxForce
 * @extends Equation
 */
function RotationalMotorEquation(bodyA, bodyB, maxForce){
    maxForce = typeof(maxForce)!=='undefined' ? maxForce : 1e6;
    Equation.call(this,bodyA,bodyB,-maxForce,maxForce);

    /**
     * World oriented rotational axis
     * @property {Vec3} axisA
     */
    this.axisA = new Vec3();

    /**
     * World oriented rotational axis
     * @property {Vec3} axisB
     */
    this.axisB = new Vec3(); // World oriented rotational axis

    /**
     * Motor velocity
     * @property {Number} targetVelocity
     */
    this.targetVelocity = 0;
}

RotationalMotorEquation.prototype = new Equation();
RotationalMotorEquation.prototype.constructor = RotationalMotorEquation;

RotationalMotorEquation.prototype.computeB = function(h){
    var a = this.a,
        b = this.b,
        bi = this.bi,
        bj = this.bj,

        axisA = this.axisA,
        axisB = this.axisB,

        GA = this.jacobianElementA,
        GB = this.jacobianElementB;

    // g = 0
    // gdot = axisA * wi - axisB * wj
    // gdot = G * W = G * [vi wi vj wj]
    // =>
    // G = [0 axisA 0 -axisB]

    GA.rotational.copy(axisA);
    axisB.negate(GB.rotational);

    var GW = this.computeGW() - this.targetVelocity,
        GiMf = this.computeGiMf();

    var B = - GW * b - h * GiMf;

    return B;
};

},{"../math/Mat3":27,"../math/Vec3":30,"./Equation":20}],24:[function(_dereq_,module,exports){
var Utils = _dereq_('../utils/Utils');

module.exports = ContactMaterial;

/**
 * Defines what happens when two materials meet.
 * @class ContactMaterial
 * @constructor
 * @param {Material} m1
 * @param {Material} m2
 * @param {object} [options]
 * @param {Number} [options.friction=0.3]
 * @param {Number} [options.restitution=0.3]
 * @param {number} [options.contactEquationStiffness=1e7]
 * @param {number} [options.contactEquationRelaxation=3]
 * @param {number} [options.frictionEquationStiffness=1e7]
 * @param {Number} [options.frictionEquationRelaxation=3]
 */
function ContactMaterial(m1, m2, options){
    options = Utils.defaults(options, {
        friction: 0.3,
        restitution: 0.3,
        contactEquationStiffness: 1e7,
        contactEquationRelaxation: 3,
        frictionEquationStiffness: 1e7,
        frictionEquationRelaxation: 3
    });

    /**
     * Identifier of this material
     * @property {Number} id
     */
    this.id = ContactMaterial.idCounter++;

    /**
     * Participating materials
     * @property {Array} materials
     * @todo  Should be .materialA and .materialB instead
     */
    this.materials = [m1, m2];

    /**
     * Friction coefficient
     * @property {Number} friction
     */
    this.friction = options.friction;

    /**
     * Restitution coefficient
     * @property {Number} restitution
     */
    this.restitution = options.restitution;

    /**
     * Stiffness of the produced contact equations
     * @property {Number} contactEquationStiffness
     */
    this.contactEquationStiffness = options.contactEquationStiffness;

    /**
     * Relaxation time of the produced contact equations
     * @property {Number} contactEquationRelaxation
     */
    this.contactEquationRelaxation = options.contactEquationRelaxation;

    /**
     * Stiffness of the produced friction equations
     * @property {Number} frictionEquationStiffness
     */
    this.frictionEquationStiffness = options.frictionEquationStiffness;

    /**
     * Relaxation time of the produced friction equations
     * @property {Number} frictionEquationRelaxation
     */
    this.frictionEquationRelaxation = options.frictionEquationRelaxation;
}

ContactMaterial.idCounter = 0;

},{"../utils/Utils":53}],25:[function(_dereq_,module,exports){
module.exports = Material;

/**
 * Defines a physics material.
 * @class Material
 * @constructor
 * @param {object} [options]
 * @author schteppe
 */
function Material(options){
    var name = '';
    options = options || {};

    // Backwards compatibility fix
    if(typeof(options) === 'string'){
        name = options;
        options = {};
    } else if(typeof(options) === 'object') {
        name = '';
    }

    /**
     * @property name
     * @type {String}
     */
    this.name = name;

    /**
     * material id.
     * @property id
     * @type {number}
     */
    this.id = Material.idCounter++;

    /**
     * Friction for this material. If non-negative, it will be used instead of the friction given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
     * @property {number} friction
     */
    this.friction = typeof(options.friction) !== 'undefined' ? options.friction : -1;

    /**
     * Restitution for this material. If non-negative, it will be used instead of the restitution given by ContactMaterials. If there's no matching ContactMaterial, the value from .defaultContactMaterial in the World will be used.
     * @property {number} restitution
     */
    this.restitution = typeof(options.restitution) !== 'undefined' ? options.restitution : -1;
}

Material.idCounter = 0;

},{}],26:[function(_dereq_,module,exports){
module.exports = JacobianElement;

var Vec3 = _dereq_('./Vec3');

/**
 * An element containing 6 entries, 3 spatial and 3 rotational degrees of freedom.
 * @class JacobianElement
 * @constructor
 */
function JacobianElement(){

    /**
     * @property {Vec3} spatial
     */
    this.spatial = new Vec3();

    /**
     * @property {Vec3} rotational
     */
    this.rotational = new Vec3();
}

/**
 * Multiply with other JacobianElement
 * @method multiplyElement
 * @param  {JacobianElement} element
 * @return {Number}
 */
JacobianElement.prototype.multiplyElement = function(element){
    return element.spatial.dot(this.spatial) + element.rotational.dot(this.rotational);
};

/**
 * Multiply with two vectors
 * @method multiplyVectors
 * @param  {Vec3} spatial
 * @param  {Vec3} rotational
 * @return {Number}
 */
JacobianElement.prototype.multiplyVectors = function(spatial,rotational){
    return spatial.dot(this.spatial) + rotational.dot(this.rotational);
};

},{"./Vec3":30}],27:[function(_dereq_,module,exports){
module.exports = Mat3;

var Vec3 = _dereq_('./Vec3');

/**
 * A 3x3 matrix.
 * @class Mat3
 * @constructor
 * @param array elements Array of nine elements. Optional.
 * @author schteppe / http://github.com/schteppe
 */
function Mat3(elements){
    /**
     * A vector of length 9, containing all matrix elements
     * @property {Array} elements
     */
    if(elements){
        this.elements = elements;
    } else {
        this.elements = [0,0,0,0,0,0,0,0,0];
    }
}

/**
 * Sets the matrix to identity
 * @method identity
 * @todo Should perhaps be renamed to setIdentity() to be more clear.
 * @todo Create another function that immediately creates an identity matrix eg. eye()
 */
Mat3.prototype.identity = function(){
    var e = this.elements;
    e[0] = 1;
    e[1] = 0;
    e[2] = 0;

    e[3] = 0;
    e[4] = 1;
    e[5] = 0;

    e[6] = 0;
    e[7] = 0;
    e[8] = 1;
};

/**
 * Set all elements to zero
 * @method setZero
 */
Mat3.prototype.setZero = function(){
    var e = this.elements;
    e[0] = 0;
    e[1] = 0;
    e[2] = 0;
    e[3] = 0;
    e[4] = 0;
    e[5] = 0;
    e[6] = 0;
    e[7] = 0;
    e[8] = 0;
};

/**
 * Sets the matrix diagonal elements from a Vec3
 * @method setTrace
 * @param {Vec3} vec3
 */
Mat3.prototype.setTrace = function(vec3){
    var e = this.elements;
    e[0] = vec3.x;
    e[4] = vec3.y;
    e[8] = vec3.z;
};

/**
 * Gets the matrix diagonal elements
 * @method getTrace
 * @return {Vec3}
 */
Mat3.prototype.getTrace = function(target){
    var target = target || new Vec3();
    var e = this.elements;
    target.x = e[0];
    target.y = e[4];
    target.z = e[8];
};

/**
 * Matrix-Vector multiplication
 * @method vmult
 * @param {Vec3} v The vector to multiply with
 * @param {Vec3} target Optional, target to save the result in.
 */
Mat3.prototype.vmult = function(v,target){
    target = target || new Vec3();

    var e = this.elements,
        x = v.x,
        y = v.y,
        z = v.z;
    target.x = e[0]*x + e[1]*y + e[2]*z;
    target.y = e[3]*x + e[4]*y + e[5]*z;
    target.z = e[6]*x + e[7]*y + e[8]*z;

    return target;
};

/**
 * Matrix-scalar multiplication
 * @method smult
 * @param {Number} s
 */
Mat3.prototype.smult = function(s){
    for(var i=0; i<this.elements.length; i++){
        this.elements[i] *= s;
    }
};

/**
 * Matrix multiplication
 * @method mmult
 * @param {Mat3} m Matrix to multiply with from left side.
 * @return {Mat3} The result.
 */
Mat3.prototype.mmult = function(m,target){
    var r = target || new Mat3();
    for(var i=0; i<3; i++){
        for(var j=0; j<3; j++){
            var sum = 0.0;
            for(var k=0; k<3; k++){
                sum += m.elements[i+k*3] * this.elements[k+j*3];
            }
            r.elements[i+j*3] = sum;
        }
    }
    return r;
};

/**
 * Scale each column of the matrix
 * @method scale
 * @param {Vec3} v
 * @return {Mat3} The result.
 */
Mat3.prototype.scale = function(v,target){
    target = target || new Mat3();
    var e = this.elements,
        t = target.elements;
    for(var i=0; i!==3; i++){
        t[3*i + 0] = v.x * e[3*i + 0];
        t[3*i + 1] = v.y * e[3*i + 1];
        t[3*i + 2] = v.z * e[3*i + 2];
    }
    return target;
};

/**
 * Solve Ax=b
 * @method solve
 * @param {Vec3} b The right hand side
 * @param {Vec3} target Optional. Target vector to save in.
 * @return {Vec3} The solution x
 * @todo should reuse arrays
 */
Mat3.prototype.solve = function(b,target){
    target = target || new Vec3();

    // Construct equations
    var nr = 3; // num rows
    var nc = 4; // num cols
    var eqns = [];
    for(var i=0; i<nr*nc; i++){
        eqns.push(0);
    }
    var i,j;
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            eqns[i+nc*j] = this.elements[i+3*j];
        }
    }
    eqns[3+4*0] = b.x;
    eqns[3+4*1] = b.y;
    eqns[3+4*2] = b.z;

    // Compute right upper triangular version of the matrix - Gauss elimination
    var n = 3, k = n, np;
    var kp = 4; // num rows
    var p, els;
    do {
        i = k - n;
        if (eqns[i+nc*i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
                if (eqns[i+nc*j] !== 0) {
                    np = kp;
                    do {  // do ligne( i ) = ligne( i ) + ligne( k )
                        p = kp - np;
                        eqns[p+nc*i] += eqns[p+nc*j];
                    } while (--np);
                    break;
                }
            }
        }
        if (eqns[i+nc*i] !== 0) {
            for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
                np = kp;
                do {  // do ligne( k ) = ligne( k ) - multiplier * ligne( i )
                    p = kp - np;
                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
                } while (--np);
            }
        }
    } while (--n);

    // Get the solution
    target.z = eqns[2*nc+3] / eqns[2*nc+2];
    target.y = (eqns[1*nc+3] - eqns[1*nc+2]*target.z) / eqns[1*nc+1];
    target.x = (eqns[0*nc+3] - eqns[0*nc+2]*target.z - eqns[0*nc+1]*target.y) / eqns[0*nc+0];

    if(isNaN(target.x) || isNaN(target.y) || isNaN(target.z) || target.x===Infinity || target.y===Infinity || target.z===Infinity){
        throw "Could not solve equation! Got x=["+target.toString()+"], b=["+b.toString()+"], A=["+this.toString()+"]";
    }

    return target;
};

/**
 * Get an element in the matrix by index. Index starts at 0, not 1!!!
 * @method e
 * @param {Number} row
 * @param {Number} column
 * @param {Number} value Optional. If provided, the matrix element will be set to this value.
 * @return {Number}
 */
Mat3.prototype.e = function( row , column ,value){
    if(value===undefined){
        return this.elements[column+3*row];
    } else {
        // Set value
        this.elements[column+3*row] = value;
    }
};

/**
 * Copy another matrix into this matrix object.
 * @method copy
 * @param {Mat3} source
 * @return {Mat3} this
 */
Mat3.prototype.copy = function(source){
    for(var i=0; i < source.elements.length; i++){
        this.elements[i] = source.elements[i];
    }
    return this;
};

/**
 * Returns a string representation of the matrix.
 * @method toString
 * @return string
 */
Mat3.prototype.toString = function(){
    var r = "";
    var sep = ",";
    for(var i=0; i<9; i++){
        r += this.elements[i] + sep;
    }
    return r;
};

/**
 * reverse the matrix
 * @method reverse
 * @param {Mat3} target Optional. Target matrix to save in.
 * @return {Mat3} The solution x
 */
Mat3.prototype.reverse = function(target){

    target = target || new Mat3();

    // Construct equations
    var nr = 3; // num rows
    var nc = 6; // num cols
    var eqns = [];
    for(var i=0; i<nr*nc; i++){
        eqns.push(0);
    }
    var i,j;
    for(i=0; i<3; i++){
        for(j=0; j<3; j++){
            eqns[i+nc*j] = this.elements[i+3*j];
        }
    }
    eqns[3+6*0] = 1;
    eqns[3+6*1] = 0;
    eqns[3+6*2] = 0;
    eqns[4+6*0] = 0;
    eqns[4+6*1] = 1;
    eqns[4+6*2] = 0;
    eqns[5+6*0] = 0;
    eqns[5+6*1] = 0;
    eqns[5+6*2] = 1;

    // Compute right upper triangular version of the matrix - Gauss elimination
    var n = 3, k = n, np;
    var kp = nc; // num rows
    var p;
    do {
        i = k - n;
        if (eqns[i+nc*i] === 0) {
            // the pivot is null, swap lines
            for (j = i + 1; j < k; j++) {
                if (eqns[i+nc*j] !== 0) {
                    np = kp;
                    do { // do line( i ) = line( i ) + line( k )
                        p = kp - np;
                        eqns[p+nc*i] += eqns[p+nc*j];
                    } while (--np);
                    break;
                }
            }
        }
        if (eqns[i+nc*i] !== 0) {
            for (j = i + 1; j < k; j++) {
                var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
                np = kp;
                do { // do line( k ) = line( k ) - multiplier * line( i )
                    p = kp - np;
                    eqns[p+nc*j] = p <= i ? 0 : eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
                } while (--np);
            }
        }
    } while (--n);

    // eliminate the upper left triangle of the matrix
    i = 2;
    do {
        j = i-1;
        do {
            var multiplier = eqns[i+nc*j] / eqns[i+nc*i];
            np = nc;
            do {
                p = nc - np;
                eqns[p+nc*j] =  eqns[p+nc*j] - eqns[p+nc*i] * multiplier ;
            } while (--np);
        } while (j--);
    } while (--i);

    // operations on the diagonal
    i = 2;
    do {
        var multiplier = 1 / eqns[i+nc*i];
        np = nc;
        do {
            p = nc - np;
            eqns[p+nc*i] = eqns[p+nc*i] * multiplier ;
        } while (--np);
    } while (i--);

    i = 2;
    do {
        j = 2;
        do {
            p = eqns[nr+j+nc*i];
            if( isNaN( p ) || p ===Infinity ){
                throw "Could not reverse! A=["+this.toString()+"]";
            }
            target.e( i , j , p );
        } while (j--);
    } while (i--);

    return target;
};

/**
 * Set the matrix from a quaterion
 * @method setRotationFromQuaternion
 * @param {Quaternion} q
 */
Mat3.prototype.setRotationFromQuaternion = function( q ) {
    var x = q.x, y = q.y, z = q.z, w = q.w,
        x2 = x + x, y2 = y + y, z2 = z + z,
        xx = x * x2, xy = x * y2, xz = x * z2,
        yy = y * y2, yz = y * z2, zz = z * z2,
        wx = w * x2, wy = w * y2, wz = w * z2,
        e = this.elements;

    e[3*0 + 0] = 1 - ( yy + zz );
    e[3*0 + 1] = xy - wz;
    e[3*0 + 2] = xz + wy;

    e[3*1 + 0] = xy + wz;
    e[3*1 + 1] = 1 - ( xx + zz );
    e[3*1 + 2] = yz - wx;

    e[3*2 + 0] = xz - wy;
    e[3*2 + 1] = yz + wx;
    e[3*2 + 2] = 1 - ( xx + yy );

    return this;
};

/**
 * Transpose the matrix
 * @method transpose
 * @param  {Mat3} target Where to store the result.
 * @return {Mat3} The target Mat3, or a new Mat3 if target was omitted.
 */
Mat3.prototype.transpose = function( target ) {
    target = target || new Mat3();

    var Mt = target.elements,
        M = this.elements;

    for(var i=0; i!==3; i++){
        for(var j=0; j!==3; j++){
            Mt[3*i + j] = M[3*j + i];
        }
    }

    return target;
};

},{"./Vec3":30}],28:[function(_dereq_,module,exports){
module.exports = Quaternion;

var Vec3 = _dereq_('./Vec3');

/**
 * A Quaternion describes a rotation in 3D space. The Quaternion is mathematically defined as Q = x*i + y*j + z*k + w, where (i,j,k) are imaginary basis vectors. (x,y,z) can be seen as a vector related to the axis of rotation, while the real multiplier, w, is related to the amount of rotation.
 * @class Quaternion
 * @constructor
 * @param {Number} x Multiplier of the imaginary basis vector i.
 * @param {Number} y Multiplier of the imaginary basis vector j.
 * @param {Number} z Multiplier of the imaginary basis vector k.
 * @param {Number} w Multiplier of the real part.
 * @see http://en.wikipedia.org/wiki/Quaternion
 */
function Quaternion(x,y,z,w){
    /**
     * @property {Number} x
     */
    this.x = x!==undefined ? x : 0;

    /**
     * @property {Number} y
     */
    this.y = y!==undefined ? y : 0;

    /**
     * @property {Number} z
     */
    this.z = z!==undefined ? z : 0;

    /**
     * The multiplier of the real quaternion basis vector.
     * @property {Number} w
     */
    this.w = w!==undefined ? w : 1;
}

/**
 * Set the value of the quaternion.
 * @method set
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {Number} w
 */
Quaternion.prototype.set = function(x,y,z,w){
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
};

/**
 * Convert to a readable format
 * @method toString
 * @return string
 */
Quaternion.prototype.toString = function(){
    return this.x+","+this.y+","+this.z+","+this.w;
};

/**
 * Convert to an Array
 * @method toArray
 * @return Array
 */
Quaternion.prototype.toArray = function(){
    return [this.x, this.y, this.z, this.w];
};

/**
 * Set the quaternion components given an axis and an angle.
 * @method setFromAxisAngle
 * @param {Vec3} axis
 * @param {Number} angle in radians
 */
Quaternion.prototype.setFromAxisAngle = function(axis,angle){
    var s = Math.sin(angle*0.5);
    this.x = axis.x * s;
    this.y = axis.y * s;
    this.z = axis.z * s;
    this.w = Math.cos(angle*0.5);
};

/**
 * Converts the quaternion to axis/angle representation.
 * @method toAxisAngle
 * @param {Vec3} targetAxis Optional. A vector object to reuse for storing the axis.
 * @return Array An array, first elemnt is the axis and the second is the angle in radians.
 */
Quaternion.prototype.toAxisAngle = function(targetAxis){
    targetAxis = targetAxis || new Vec3();
    this.normalize(); // if w>1 acos and sqrt will produce errors, this cant happen if quaternion is normalised
    var angle = 2 * Math.acos(this.w);
    var s = Math.sqrt(1-this.w*this.w); // assuming quaternion normalised then w is less than 1, so term always positive.
    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
        // if s close to zero then direction of axis not important
        targetAxis.x = this.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
        targetAxis.y = this.y;
        targetAxis.z = this.z;
    } else {
        targetAxis.x = this.x / s; // normalise axis
        targetAxis.y = this.y / s;
        targetAxis.z = this.z / s;
    }
    return [targetAxis,angle];
};

var sfv_t1 = new Vec3(),
    sfv_t2 = new Vec3();

/**
 * Set the quaternion value given two vectors. The resulting rotation will be the needed rotation to rotate u to v.
 * @method setFromVectors
 * @param {Vec3} u
 * @param {Vec3} v
 */
Quaternion.prototype.setFromVectors = function(u,v){
    if(u.isAntiparallelTo(v)){
        var t1 = sfv_t1;
        var t2 = sfv_t2;

        u.tangents(t1,t2);
        this.setFromAxisAngle(t1,Math.PI);
    } else {
        var a = u.cross(v);
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = Math.sqrt(Math.pow(u.norm(),2) * Math.pow(v.norm(),2)) + u.dot(v);
        this.normalize();
    }
};

/**
 * Quaternion multiplication
 * @method mult
 * @param {Quaternion} q
 * @param {Quaternion} target Optional.
 * @return {Quaternion}
 */
var Quaternion_mult_va = new Vec3();
var Quaternion_mult_vb = new Vec3();
var Quaternion_mult_vaxvb = new Vec3();
Quaternion.prototype.mult = function(q,target){
    target = target || new Quaternion();
    var w = this.w,
        va = Quaternion_mult_va,
        vb = Quaternion_mult_vb,
        vaxvb = Quaternion_mult_vaxvb;

    va.set(this.x,this.y,this.z);
    vb.set(q.x,q.y,q.z);
    target.w = w*q.w - va.dot(vb);
    va.cross(vb,vaxvb);

    target.x = w * vb.x + q.w*va.x + vaxvb.x;
    target.y = w * vb.y + q.w*va.y + vaxvb.y;
    target.z = w * vb.z + q.w*va.z + vaxvb.z;

    return target;
};

/**
 * Get the inverse quaternion rotation.
 * @method inverse
 * @param {Quaternion} target
 * @return {Quaternion}
 */
Quaternion.prototype.inverse = function(target){
    var x = this.x, y = this.y, z = this.z, w = this.w;
    target = target || new Quaternion();

    this.conjugate(target);
    var inorm2 = 1/(x*x + y*y + z*z + w*w);
    target.x *= inorm2;
    target.y *= inorm2;
    target.z *= inorm2;
    target.w *= inorm2;

    return target;
};

/**
 * Get the quaternion conjugate
 * @method conjugate
 * @param {Quaternion} target
 * @return {Quaternion}
 */
Quaternion.prototype.conjugate = function(target){
    target = target || new Quaternion();

    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    target.w = this.w;

    return target;
};

/**
 * Normalize the quaternion. Note that this changes the values of the quaternion.
 * @method normalize
 */
Quaternion.prototype.normalize = function(){
    var l = Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);
    if ( l === 0 ) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    } else {
        l = 1 / l;
        this.x *= l;
        this.y *= l;
        this.z *= l;
        this.w *= l;
    }
};

/**
 * Approximation of quaternion normalization. Works best when quat is already almost-normalized.
 * @method normalizeFast
 * @see http://jsperf.com/fast-quaternion-normalization
 * @author unphased, https://github.com/unphased
 */
Quaternion.prototype.normalizeFast = function () {
    var f = (3.0-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2.0;
    if ( f === 0 ) {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.w = 0;
    } else {
        this.x *= f;
        this.y *= f;
        this.z *= f;
        this.w *= f;
    }
};

/**
 * Multiply the quaternion by a vector
 * @method vmult
 * @param {Vec3} v
 * @param {Vec3} target Optional
 * @return {Vec3}
 */
Quaternion.prototype.vmult = function(v,target){
    target = target || new Vec3();

    var x = v.x,
        y = v.y,
        z = v.z;

    var qx = this.x,
        qy = this.y,
        qz = this.z,
        qw = this.w;

    // q*v
    var ix =  qw * x + qy * z - qz * y,
    iy =  qw * y + qz * x - qx * z,
    iz =  qw * z + qx * y - qy * x,
    iw = -qx * x - qy * y - qz * z;

    target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

    return target;
};

/**
 * Copies value of source to this quaternion.
 * @method copy
 * @param {Quaternion} source
 * @return {Quaternion} this
 */
Quaternion.prototype.copy = function(source){
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    this.w = source.w;
    return this;
};

/**
 * Convert the quaternion to euler angle representation. Order: YZX, as this page describes: http://www.euclideanspace.com/maths/standards/index.htm
 * @method toEuler
 * @param {Vec3} target
 * @param string order Three-character string e.g. "YZX", which also is default.
 */
Quaternion.prototype.toEuler = function(target,order){
    order = order || "YZX";

    var heading, attitude, bank;
    var x = this.x, y = this.y, z = this.z, w = this.w;

    switch(order){
    case "YZX":
        var test = x*y + z*w;
        if (test > 0.499) { // singularity at north pole
            heading = 2 * Math.atan2(x,w);
            attitude = Math.PI/2;
            bank = 0;
        }
        if (test < -0.499) { // singularity at south pole
            heading = -2 * Math.atan2(x,w);
            attitude = - Math.PI/2;
            bank = 0;
        }
        if(isNaN(heading)){
            var sqx = x*x;
            var sqy = y*y;
            var sqz = z*z;
            heading = Math.atan2(2*y*w - 2*x*z , 1 - 2*sqy - 2*sqz); // Heading
            attitude = Math.asin(2*test); // attitude
            bank = Math.atan2(2*x*w - 2*y*z , 1 - 2*sqx - 2*sqz); // bank
        }
        break;
    default:
        throw new Error("Euler order "+order+" not supported yet.");
    }

    target.y = heading;
    target.z = attitude;
    target.x = bank;
};

/**
 * See http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m
 * @method setFromEuler
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @param {String} order The order to apply angles: 'XYZ' or 'YXZ' or any other combination
 */
Quaternion.prototype.setFromEuler = function ( x, y, z, order ) {
    order = order || "XYZ";

    var c1 = Math.cos( x / 2 );
    var c2 = Math.cos( y / 2 );
    var c3 = Math.cos( z / 2 );
    var s1 = Math.sin( x / 2 );
    var s2 = Math.sin( y / 2 );
    var s3 = Math.sin( z / 2 );

    if ( order === 'XYZ' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'YXZ' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'ZXY' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'ZYX' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    } else if ( order === 'YZX' ) {

        this.x = s1 * c2 * c3 + c1 * s2 * s3;
        this.y = c1 * s2 * c3 + s1 * c2 * s3;
        this.z = c1 * c2 * s3 - s1 * s2 * c3;
        this.w = c1 * c2 * c3 - s1 * s2 * s3;

    } else if ( order === 'XZY' ) {

        this.x = s1 * c2 * c3 - c1 * s2 * s3;
        this.y = c1 * s2 * c3 - s1 * c2 * s3;
        this.z = c1 * c2 * s3 + s1 * s2 * c3;
        this.w = c1 * c2 * c3 + s1 * s2 * s3;

    }

    return this;

};

Quaternion.prototype.clone = function(){
    return new Quaternion(this.x, this.y, this.z, this.w);
};
},{"./Vec3":30}],29:[function(_dereq_,module,exports){
var Vec3 = _dereq_('./Vec3');
var Quaternion = _dereq_('./Quaternion');

module.exports = Transform;

/**
 * @class Transform
 * @constructor
 */
function Transform(options) {
    options = options || {};

	/**
	 * @property {Vec3} position
	 */
	this.position = new Vec3();
    if(options.position){
        this.position.copy(options.position);
    }

	/**
	 * @property {Quaternion} quaternion
	 */
	this.quaternion = new Quaternion();
    if(options.quaternion){
        this.quaternion.copy(options.quaternion);
    }
}

var tmpQuat = new Quaternion();

/**
 * @static
 * @method pointToLocaFrame
 * @param {Vec3} position
 * @param {Quaternion} quaternion
 * @param {Vec3} worldPoint
 * @param {Vec3} result
 */
Transform.pointToLocalFrame = function(position, quaternion, worldPoint, result){
    var result = result || new Vec3();
    worldPoint.vsub(position, result);
    quaternion.conjugate(tmpQuat);
    tmpQuat.vmult(result, result);
    return result;
};

/**
 * Get a global point in local transform coordinates.
 * @method pointToLocal
 * @param  {Vec3} point
 * @param  {Vec3} result
 * @return {Vec3} The "result" vector object
 */
Transform.prototype.pointToLocal = function(worldPoint, result){
    return Transform.pointToLocalFrame(this.position, this.quaternion, worldPoint, result);
};

/**
 * @static
 * @method pointToWorldFrame
 * @param {Vec3} position
 * @param {Vec3} quaternion
 * @param {Vec3} localPoint
 * @param {Vec3} result
 */
Transform.pointToWorldFrame = function(position, quaternion, localPoint, result){
    var result = result || new Vec3();
    quaternion.vmult(localPoint, result);
    result.vadd(position, result);
    return result;
};

/**
 * Get a local point in global transform coordinates.
 * @method pointToWorld
 * @param  {Vec3} point
 * @param  {Vec3} result
 * @return {Vec3} The "result" vector object
 */
Transform.prototype.pointToWorld = function(localPoint, result){
    return Transform.pointToWorldFrame(this.position, this.quaternion, localPoint, result);
};


Transform.prototype.vectorToWorldFrame = function(localVector, result){
    var result = result || new Vec3();
    this.quaternion.vmult(localVector, result);
    return result;
};

Transform.vectorToWorldFrame = function(quaternion, localVector, result){
    quaternion.vmult(localVector, result);
    return result;
};

Transform.vectorToLocalFrame = function(position, quaternion, worldVector, result){
    var result = result || new Vec3();
    quaternion.w *= -1;
    quaternion.vmult(worldVector, result);
    quaternion.w *= -1;
    return result;
};

},{"./Quaternion":28,"./Vec3":30}],30:[function(_dereq_,module,exports){
module.exports = Vec3;

var Mat3 = _dereq_('./Mat3');

/**
 * 3-dimensional vector
 * @class Vec3
 * @constructor
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @author schteppe
 * @example
 *     var v = new Vec3(1, 2, 3);
 *     console.log('x=' + v.x); // x=1
 */
function Vec3(x,y,z){
    /**
     * @property x
     * @type {Number}
     */
    this.x = x||0.0;

    /**
     * @property y
     * @type {Number}
     */
    this.y = y||0.0;

    /**
     * @property z
     * @type {Number}
     */
    this.z = z||0.0;
}

/**
 * @static
 * @property {Vec3} ZERO
 */
Vec3.ZERO = new Vec3(0, 0, 0);

/**
 * @static
 * @property {Vec3} UNIT_X
 */
Vec3.UNIT_X = new Vec3(1, 0, 0);

/**
 * @static
 * @property {Vec3} UNIT_Y
 */
Vec3.UNIT_Y = new Vec3(0, 1, 0);

/**
 * @static
 * @property {Vec3} UNIT_Z
 */
Vec3.UNIT_Z = new Vec3(0, 0, 1);

/**
 * Vector cross product
 * @method cross
 * @param {Vec3} v
 * @param {Vec3} target Optional. Target to save in.
 * @return {Vec3}
 */
Vec3.prototype.cross = function(v,target){
    var vx=v.x, vy=v.y, vz=v.z, x=this.x, y=this.y, z=this.z;
    target = target || new Vec3();

    target.x = (y * vz) - (z * vy);
    target.y = (z * vx) - (x * vz);
    target.z = (x * vy) - (y * vx);

    return target;
};

/**
 * Set the vectors' 3 elements
 * @method set
 * @param {Number} x
 * @param {Number} y
 * @param {Number} z
 * @return Vec3
 */
Vec3.prototype.set = function(x,y,z){
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
};

/**
 * Set all components of the vector to zero.
 * @method setZero
 */
Vec3.prototype.setZero = function(){
    this.x = this.y = this.z = 0;
};

/**
 * Vector addition
 * @method vadd
 * @param {Vec3} v
 * @param {Vec3} target Optional.
 * @return {Vec3}
 */
Vec3.prototype.vadd = function(v,target){
    if(target){
        target.x = v.x + this.x;
        target.y = v.y + this.y;
        target.z = v.z + this.z;
    } else {
        return new Vec3(this.x + v.x,
                               this.y + v.y,
                               this.z + v.z);
    }
};

/**
 * Vector subtraction
 * @method vsub
 * @param {Vec3} v
 * @param {Vec3} target Optional. Target to save in.
 * @return {Vec3}
 */
Vec3.prototype.vsub = function(v,target){
    if(target){
        target.x = this.x - v.x;
        target.y = this.y - v.y;
        target.z = this.z - v.z;
    } else {
        return new Vec3(this.x-v.x,
                               this.y-v.y,
                               this.z-v.z);
    }
};

/**
 * Get the cross product matrix a_cross from a vector, such that a x b = a_cross * b = c
 * @method crossmat
 * @see http://www8.cs.umu.se/kurser/TDBD24/VT06/lectures/Lecture6.pdf
 * @return {Mat3}
 */
Vec3.prototype.crossmat = function(){
    return new Mat3([     0,  -this.z,   this.y,
                            this.z,        0,  -this.x,
                           -this.y,   this.x,        0]);
};

/**
 * Normalize the vector. Note that this changes the values in the vector.
 * @method normalize
 * @return {Number} Returns the norm of the vector
 */
Vec3.prototype.normalize = function(){
    var x=this.x, y=this.y, z=this.z;
    var n = Math.sqrt(x*x + y*y + z*z);
    if(n>0.0){
        var invN = 1/n;
        this.x *= invN;
        this.y *= invN;
        this.z *= invN;
    } else {
        // Make something up
        this.x = 0;
        this.y = 0;
        this.z = 0;
    }
    return n;
};

/**
 * Get the version of this vector that is of length 1.
 * @method unit
 * @param {Vec3} target Optional target to save in
 * @return {Vec3} Returns the unit vector
 */
Vec3.prototype.unit = function(target){
    target = target || new Vec3();
    var x=this.x, y=this.y, z=this.z;
    var ninv = Math.sqrt(x*x + y*y + z*z);
    if(ninv>0.0){
        ninv = 1.0/ninv;
        target.x = x * ninv;
        target.y = y * ninv;
        target.z = z * ninv;
    } else {
        target.x = 1;
        target.y = 0;
        target.z = 0;
    }
    return target;
};

/**
 * Get the length of the vector
 * @method norm
 * @return {Number}
 * @deprecated Use .length() instead
 */
Vec3.prototype.norm = function(){
    var x=this.x, y=this.y, z=this.z;
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Get the length of the vector
 * @method length
 * @return {Number}
 */
Vec3.prototype.length = Vec3.prototype.norm;

/**
 * Get the squared length of the vector
 * @method norm2
 * @return {Number}
 * @deprecated Use .lengthSquared() instead.
 */
Vec3.prototype.norm2 = function(){
    return this.dot(this);
};

/**
 * Get the squared length of the vector.
 * @method lengthSquared
 * @return {Number}
 */
Vec3.prototype.lengthSquared = Vec3.prototype.norm2;

/**
 * Get distance from this point to another point
 * @method distanceTo
 * @param  {Vec3} p
 * @return {Number}
 */
Vec3.prototype.distanceTo = function(p){
    var x=this.x, y=this.y, z=this.z;
    var px=p.x, py=p.y, pz=p.z;
    return Math.sqrt((px-x)*(px-x)+
                     (py-y)*(py-y)+
                     (pz-z)*(pz-z));
};

/**
 * Get squared distance from this point to another point
 * @method distanceSquared
 * @param  {Vec3} p
 * @return {Number}
 */
Vec3.prototype.distanceSquared = function(p){
    var x=this.x, y=this.y, z=this.z;
    var px=p.x, py=p.y, pz=p.z;
    return (px-x)*(px-x) + (py-y)*(py-y) + (pz-z)*(pz-z);
};

/**
 * Multiply all the components of the vector with a scalar.
 * @deprecated Use .scale instead
 * @method mult
 * @param {Number} scalar
 * @param {Vec3} target The vector to save the result in.
 * @return {Vec3}
 * @deprecated Use .scale() instead
 */
Vec3.prototype.mult = function(scalar,target){
    target = target || new Vec3();
    var x = this.x,
        y = this.y,
        z = this.z;
    target.x = scalar * x;
    target.y = scalar * y;
    target.z = scalar * z;
    return target;
};

/**
 * Multiply the vector with a scalar.
 * @method scale
 * @param {Number} scalar
 * @param {Vec3} target
 * @return {Vec3}
 */
Vec3.prototype.scale = Vec3.prototype.mult;

/**
 * Calculate dot product
 * @method dot
 * @param {Vec3} v
 * @return {Number}
 */
Vec3.prototype.dot = function(v){
    return this.x * v.x + this.y * v.y + this.z * v.z;
};

/**
 * @method isZero
 * @return bool
 */
Vec3.prototype.isZero = function(){
    return this.x===0 && this.y===0 && this.z===0;
};

/**
 * Make the vector point in the opposite direction.
 * @method negate
 * @param {Vec3} target Optional target to save in
 * @return {Vec3}
 */
Vec3.prototype.negate = function(target){
    target = target || new Vec3();
    target.x = -this.x;
    target.y = -this.y;
    target.z = -this.z;
    return target;
};

/**
 * Compute two artificial tangents to the vector
 * @method tangents
 * @param {Vec3} t1 Vector object to save the first tangent in
 * @param {Vec3} t2 Vector object to save the second tangent in
 */
var Vec3_tangents_n = new Vec3();
var Vec3_tangents_randVec = new Vec3();
Vec3.prototype.tangents = function(t1,t2){
    var norm = this.norm();
    if(norm>0.0){
        var n = Vec3_tangents_n;
        var inorm = 1/norm;
        n.set(this.x*inorm,this.y*inorm,this.z*inorm);
        var randVec = Vec3_tangents_randVec;
        if(Math.abs(n.x) < 0.9){
            randVec.set(1,0,0);
            n.cross(randVec,t1);
        } else {
            randVec.set(0,1,0);
            n.cross(randVec,t1);
        }
        n.cross(t1,t2);
    } else {
        // The normal length is zero, make something up
        t1.set(1, 0, 0);
        t2.set(0, 1, 0);
    }
};

/**
 * Converts to a more readable format
 * @method toString
 * @return string
 */
Vec3.prototype.toString = function(){
    return this.x+","+this.y+","+this.z;
};

/**
 * Converts to an array
 * @method toArray
 * @return Array
 */
Vec3.prototype.toArray = function(){
    return [this.x, this.y, this.z];
};

/**
 * Copies value of source to this vector.
 * @method copy
 * @param {Vec3} source
 * @return {Vec3} this
 */
Vec3.prototype.copy = function(source){
    this.x = source.x;
    this.y = source.y;
    this.z = source.z;
    return this;
};


/**
 * Do a linear interpolation between two vectors
 * @method lerp
 * @param {Vec3} v
 * @param {Number} t A number between 0 and 1. 0 will make this function return u, and 1 will make it return v. Numbers in between will generate a vector in between them.
 * @param {Vec3} target
 */
Vec3.prototype.lerp = function(v,t,target){
    var x=this.x, y=this.y, z=this.z;
    target.x = x + (v.x-x)*t;
    target.y = y + (v.y-y)*t;
    target.z = z + (v.z-z)*t;
};

/**
 * Check if a vector equals is almost equal to another one.
 * @method almostEquals
 * @param {Vec3} v
 * @param {Number} precision
 * @return bool
 */
Vec3.prototype.almostEquals = function(v,precision){
    if(precision===undefined){
        precision = 1e-6;
    }
    if( Math.abs(this.x-v.x)>precision ||
        Math.abs(this.y-v.y)>precision ||
        Math.abs(this.z-v.z)>precision){
        return false;
    }
    return true;
};

/**
 * Check if a vector is almost zero
 * @method almostZero
 * @param {Number} precision
 */
Vec3.prototype.almostZero = function(precision){
    if(precision===undefined){
        precision = 1e-6;
    }
    if( Math.abs(this.x)>precision ||
        Math.abs(this.y)>precision ||
        Math.abs(this.z)>precision){
        return false;
    }
    return true;
};

var antip_neg = new Vec3();

/**
 * Check if the vector is anti-parallel to another vector.
 * @method isAntiparallelTo
 * @param  {Vec3}  v
 * @param  {Number}  precision Set to zero for exact comparisons
 * @return {Boolean}
 */
Vec3.prototype.isAntiparallelTo = function(v,precision){
    this.negate(antip_neg);
    return antip_neg.almostEquals(v,precision);
};

/**
 * Clone the vector
 * @method clone
 * @return {Vec3}
 */
Vec3.prototype.clone = function(){
    return new Vec3(this.x, this.y, this.z);
};
},{"./Mat3":27}],31:[function(_dereq_,module,exports){
module.exports = Body;

var EventTarget = _dereq_('../utils/EventTarget');
var Shape = _dereq_('../shapes/Shape');
var Vec3 = _dereq_('../math/Vec3');
var Mat3 = _dereq_('../math/Mat3');
var Quaternion = _dereq_('../math/Quaternion');
var Material = _dereq_('../material/Material');
var AABB = _dereq_('../collision/AABB');
var Box = _dereq_('../shapes/Box');

/**
 * Base class for all body types.
 * @class Body
 * @constructor
 * @extends EventTarget
 * @param {object} [options]
 * @param {Vec3} [options.position]
 * @param {Vec3} [options.velocity]
 * @param {Vec3} [options.angularVelocity]
 * @param {Quaternion} [options.quaternion]
 * @param {number} [options.mass]
 * @param {Material} [options.material]
 * @param {number} [options.type]
 * @param {number} [options.linearDamping=0.01]
 * @param {number} [options.angularDamping=0.01]
 * @param {boolean} [options.allowSleep=true]
 * @param {number} [options.sleepSpeedLimit=0.1]
 * @param {number} [options.sleepTimeLimit=1]
 * @param {number} [options.collisionFilterGroup=1]
 * @param {number} [options.collisionFilterMask=1]
 * @param {boolean} [options.fixedRotation=false]
 * @param {Body} [options.shape]
 * @example
 *     var body = new Body({
 *         mass: 1
 *     });
 *     var shape = new Sphere(1);
 *     body.addShape(shape);
 *     world.add(body);
 */
function Body(options){
    options = options || {};

    EventTarget.apply(this);

    this.id = Body.idCounter++;

    /**
     * Reference to the world the body is living in
     * @property world
     * @type {World}
     */
    this.world = null;

    /**
     * Callback function that is used BEFORE stepping the system. Use it to apply forces, for example. Inside the function, "this" will refer to this Body object.
     * @property preStep
     * @type {Function}
     * @deprecated Use World events instead
     */
    this.preStep = null;

    /**
     * Callback function that is used AFTER stepping the system. Inside the function, "this" will refer to this Body object.
     * @property postStep
     * @type {Function}
     * @deprecated Use World events instead
     */
    this.postStep = null;

    this.vlambda = new Vec3();

    /**
     * @property {Number} collisionFilterGroup
     */
    this.collisionFilterGroup = typeof(options.collisionFilterGroup) === 'number' ? options.collisionFilterGroup : 1;

    /**
     * @property {Number} collisionFilterMask
     */
    this.collisionFilterMask = typeof(options.collisionFilterMask) === 'number' ? options.collisionFilterMask : 1;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
     * @property {Number} collisionResponse
     */
	this.collisionResponse = true;

    /**
     * @property position
     * @type {Vec3}
     */
    this.position = new Vec3();

    if(options.position){
        this.position.copy(options.position);
    }

    /**
     * @property {Vec3} previousPosition
     */
    this.previousPosition = new Vec3();

    /**
     * Initial position of the body
     * @property initPosition
     * @type {Vec3}
     */
    this.initPosition = new Vec3();

    /**
     * @property velocity
     * @type {Vec3}
     */
    this.velocity = new Vec3();

    if(options.velocity){
        this.velocity.copy(options.velocity);
    }

    /**
     * @property initVelocity
     * @type {Vec3}
     */
    this.initVelocity = new Vec3();

    /**
     * Linear force on the body
     * @property force
     * @type {Vec3}
     */
    this.force = new Vec3();

    var mass = typeof(options.mass) === 'number' ? options.mass : 0;

    /**
     * @property mass
     * @type {Number}
     * @default 0
     */
    this.mass = mass;

    /**
     * @property invMass
     * @type {Number}
     */
    this.invMass = mass > 0 ? 1.0 / mass : 0;

    /**
     * @property material
     * @type {Material}
     */
    this.material = options.material || null;

    /**
     * @property linearDamping
     * @type {Number}
     */
    this.linearDamping = typeof(options.linearDamping) === 'number' ? options.linearDamping : 0.01;

    /**
     * One of: Body.DYNAMIC, Body.STATIC and Body.KINEMATIC.
     * @property type
     * @type {Number}
     */
    this.type = (mass <= 0.0 ? Body.STATIC : Body.DYNAMIC);
    if(typeof(options.type) === typeof(Body.STATIC)){
        this.type = options.type;
    }

    /**
     * If true, the body will automatically fall to sleep.
     * @property allowSleep
     * @type {Boolean}
     * @default true
     */
    this.allowSleep = typeof(options.allowSleep) !== 'undefined' ? options.allowSleep : true;

    /**
     * Current sleep state.
     * @property sleepState
     * @type {Number}
     */
    this.sleepState = 0;

    /**
     * If the speed (the norm of the velocity) is smaller than this value, the body is considered sleepy.
     * @property sleepSpeedLimit
     * @type {Number}
     * @default 0.1
     */
    this.sleepSpeedLimit = typeof(options.sleepSpeedLimit) !== 'undefined' ? options.sleepSpeedLimit : 0.1;

    /**
     * If the body has been sleepy for this sleepTimeLimit seconds, it is considered sleeping.
     * @property sleepTimeLimit
     * @type {Number}
     * @default 1
     */
    this.sleepTimeLimit = typeof(options.sleepTimeLimit) !== 'undefined' ? options.sleepTimeLimit : 1;

    this.timeLastSleepy = 0;

    this._wakeUpAfterNarrowphase = false;


    /**
     * Rotational force on the body, around center of mass
     * @property {Vec3} torque
     */
    this.torque = new Vec3();

    /**
     * Orientation of the body
     * @property quaternion
     * @type {Quaternion}
     */
    this.quaternion = new Quaternion();

    if(options.quaternion){
        this.quaternion.copy(options.quaternion);
    }

    /**
     * @property initQuaternion
     * @type {Quaternion}
     */
    this.initQuaternion = new Quaternion();

    /**
     * @property angularVelocity
     * @type {Vec3}
     */
    this.angularVelocity = new Vec3();

    if(options.angularVelocity){
        this.angularVelocity.copy(options.angularVelocity);
    }

    /**
     * @property initAngularVelocity
     * @type {Vec3}
     */
    this.initAngularVelocity = new Vec3();

    this.interpolatedPosition = new Vec3();
    this.interpolatedQuaternion = new Quaternion();

    /**
     * @property shapes
     * @type {array}
     */
    this.shapes = [];

    /**
     * @property shapeOffsets
     * @type {array}
     */
    this.shapeOffsets = [];

    /**
     * @property shapeOrientations
     * @type {array}
     */
    this.shapeOrientations = [];

    /**
     * @property inertia
     * @type {Vec3}
     */
    this.inertia = new Vec3();

    /**
     * @property {Vec3} invInertia
     */
    this.invInertia = new Vec3();

    /**
     * @property {Mat3} invInertiaWorld
     */
    this.invInertiaWorld = new Mat3();

    this.invMassSolve = 0;

    /**
     * @property {Vec3} invInertiaSolve
     */
    this.invInertiaSolve = new Vec3();

    /**
     * @property {Mat3} invInertiaWorldSolve
     */
    this.invInertiaWorldSolve = new Mat3();

    /**
     * Set to true if you don't want the body to rotate. Make sure to run .updateMassProperties() after changing this.
     * @property {Boolean} fixedRotation
     * @default false
     */
    this.fixedRotation = typeof(options.fixedRotation) !== "undefined" ? options.fixedRotation : false;

    /**
     * @property {Number} angularDamping
     */
    this.angularDamping = typeof(options.angularDamping) !== 'undefined' ? options.angularDamping : 0.01;

    /**
     * @property aabb
     * @type {AABB}
     */
    this.aabb = new AABB();

    /**
     * Indicates if the AABB needs to be updated before use.
     * @property aabbNeedsUpdate
     * @type {Boolean}
     */
    this.aabbNeedsUpdate = true;

    this.wlambda = new Vec3();

    if(options.shape){
        this.addShape(options.shape);
    }

    this.updateMassProperties();
}
Body.prototype = new EventTarget();
Body.prototype.constructor = Body;

/**
 * A dynamic body is fully simulated. Can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. A dynamic body always has finite, non-zero mass.
 * @static
 * @property DYNAMIC
 * @type {Number}
 */
Body.DYNAMIC = 1;

/**
 * A static body does not move during simulation and behaves as if it has infinite mass. Static bodies can be moved manually by setting the position of the body. The velocity of a static body is always zero. Static bodies do not collide with other static or kinematic bodies.
 * @static
 * @property STATIC
 * @type {Number}
 */
Body.STATIC = 2;

/**
 * A kinematic body moves under simulation according to its velocity. They do not respond to forces. They can be moved manually, but normally a kinematic body is moved by setting its velocity. A kinematic body behaves as if it has infinite mass. Kinematic bodies do not collide with other static or kinematic bodies.
 * @static
 * @property KINEMATIC
 * @type {Number}
 */
Body.KINEMATIC = 4;



/**
 * @static
 * @property AWAKE
 * @type {number}
 */
Body.AWAKE = 0;

/**
 * @static
 * @property SLEEPY
 * @type {number}
 */
Body.SLEEPY = 1;

/**
 * @static
 * @property SLEEPING
 * @type {number}
 */
Body.SLEEPING = 2;

Body.idCounter = 0;

/**
 * Wake the body up.
 * @method wakeUp
 */
Body.prototype.wakeUp = function(){
    var s = this.sleepState;
    this.sleepState = 0;
    if(s === Body.SLEEPING){
        this.dispatchEvent({type:"wakeup"});
    }
};

/**
 * Force body sleep
 * @method sleep
 */
Body.prototype.sleep = function(){
    this.sleepState = Body.SLEEPING;
    this.velocity.set(0,0,0);
    this.angularVelocity.set(0,0,0);
};

Body.sleepyEvent = {
    type: "sleepy"
};

Body.sleepEvent = {
    type: "sleep"
};

/**
 * Called every timestep to update internal sleep timer and change sleep state if needed.
 * @method sleepTick
 * @param {Number} time The world time in seconds
 */
Body.prototype.sleepTick = function(time){
    if(this.allowSleep){
        var sleepState = this.sleepState;
        var speedSquared = this.velocity.norm2() + this.angularVelocity.norm2();
        var speedLimitSquared = Math.pow(this.sleepSpeedLimit,2);
        if(sleepState===Body.AWAKE && speedSquared < speedLimitSquared){
            this.sleepState = Body.SLEEPY; // Sleepy
            this.timeLastSleepy = time;
            this.dispatchEvent(Body.sleepyEvent);
        } else if(sleepState===Body.SLEEPY && speedSquared > speedLimitSquared){
            this.wakeUp(); // Wake up
        } else if(sleepState===Body.SLEEPY && (time - this.timeLastSleepy ) > this.sleepTimeLimit){
            this.sleep(); // Sleeping
            this.dispatchEvent(Body.sleepEvent);
        }
    }
};

/**
 * If the body is sleeping, it should be immovable / have infinite mass during solve. We solve it by having a separate "solve mass".
 * @method updateSolveMassProperties
 */
Body.prototype.updateSolveMassProperties = function(){
    if(this.sleepState === Body.SLEEPING || this.type === Body.KINEMATIC){
        this.invMassSolve = 0;
        this.invInertiaSolve.setZero();
        this.invInertiaWorldSolve.setZero();
    } else {
        this.invMassSolve = this.invMass;
        this.invInertiaSolve.copy(this.invInertia);
        this.invInertiaWorldSolve.copy(this.invInertiaWorld);
    }
};

/**
 * Convert a world point to local body frame.
 * @method pointToLocalFrame
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.pointToLocalFrame = function(worldPoint,result){
    var result = result || new Vec3();
    worldPoint.vsub(this.position,result);
    this.quaternion.conjugate().vmult(result,result);
    return result;
};

/**
 * Convert a world vector to local body frame.
 * @method vectorToLocalFrame
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.vectorToLocalFrame = function(worldVector, result){
    var result = result || new Vec3();
    this.quaternion.conjugate().vmult(worldVector,result);
    return result;
};

/**
 * Convert a local body point to world frame.
 * @method pointToWorldFrame
 * @param  {Vec3} localPoint
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.pointToWorldFrame = function(localPoint,result){
    var result = result || new Vec3();
    this.quaternion.vmult(localPoint,result);
    result.vadd(this.position,result);
    return result;
};

/**
 * Convert a local body point to world frame.
 * @method vectorToWorldFrame
 * @param  {Vec3} localVector
 * @param  {Vec3} result
 * @return {Vec3}
 */
Body.prototype.vectorToWorldFrame = function(localVector, result){
    var result = result || new Vec3();
    this.quaternion.vmult(localVector, result);
    return result;
};

var tmpVec = new Vec3();
var tmpQuat = new Quaternion();

/**
 * Add a shape to the body with a local offset and orientation.
 * @method addShape
 * @param {Shape} shape
 * @param {Vec3} offset
 * @param {Quaternion} quaternion
 * @return {Body} The body object, for chainability.
 */
Body.prototype.addShape = function(shape, _offset, _orientation){
    var offset = new Vec3();
    var orientation = new Quaternion();

    if(_offset){
        offset.copy(_offset);
    }
    if(_orientation){
        orientation.copy(_orientation);
    }

    this.shapes.push(shape);
    this.shapeOffsets.push(offset);
    this.shapeOrientations.push(orientation);
    this.updateMassProperties();
    this.updateBoundingRadius();

    this.aabbNeedsUpdate = true;

    return this;
};

/**
 * Update the bounding radius of the body. Should be done if any of the shapes are changed.
 * @method updateBoundingRadius
 */
Body.prototype.updateBoundingRadius = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        N = shapes.length,
        radius = 0;

    for(var i=0; i!==N; i++){
        var shape = shapes[i];
        shape.updateBoundingSphereRadius();
        var offset = shapeOffsets[i].norm(),
            r = shape.boundingSphereRadius;
        if(offset + r > radius){
            radius = offset + r;
        }
    }

    this.boundingRadius = radius;
};

var computeAABB_shapeAABB = new AABB();

/**
 * Updates the .aabb
 * @method computeAABB
 * @todo rename to updateAABB()
 */
Body.prototype.computeAABB = function(){
    var shapes = this.shapes,
        shapeOffsets = this.shapeOffsets,
        shapeOrientations = this.shapeOrientations,
        N = shapes.length,
        offset = tmpVec,
        orientation = tmpQuat,
        bodyQuat = this.quaternion,
        aabb = this.aabb,
        shapeAABB = computeAABB_shapeAABB;

    for(var i=0; i!==N; i++){
        var shape = shapes[i];

        // Get shape world quaternion
        shapeOrientations[i].mult(bodyQuat, orientation);

        // Get shape world position
        orientation.vmult(shapeOffsets[i], offset);
        offset.vadd(this.position, offset);

        // vec2.rotate(offset, shapeOffsets[i], bodyAngle);
        // vec2.add(offset, offset, this.position);

        // Get shape AABB
        shape.calculateWorldAABB(offset, orientation, shapeAABB.lowerBound, shapeAABB.upperBound);

        if(i === 0){
            aabb.copy(shapeAABB);
        } else {
            aabb.extend(shapeAABB);
        }
    }

    this.aabbNeedsUpdate = false;
};

var uiw_m1 = new Mat3(),
    uiw_m2 = new Mat3(),
    uiw_m3 = new Mat3();

/**
 * Update .inertiaWorld and .invInertiaWorld
 * @method updateInertiaWorld
 */
Body.prototype.updateInertiaWorld = function(force){
    var I = this.invInertia;
    if (I.x === I.y && I.y === I.z && !force) {
        // If inertia M = s*I, where I is identity and s a scalar, then
        //    R*M*R' = R*(s*I)*R' = s*R*I*R' = s*R*R' = s*I = M
        // where R is the rotation matrix.
        // In other words, we don't have to transform the inertia if all
        // inertia diagonal entries are equal.
    } else {
        var m1 = uiw_m1,
            m2 = uiw_m2,
            m3 = uiw_m3;
        m1.setRotationFromQuaternion(this.quaternion);
        m1.transpose(m2);
        m1.scale(I,m1);
        m1.mmult(m2,this.invInertiaWorld);
        //m3.getTrace(this.invInertiaWorld);
    }

    /*
    this.quaternion.vmult(this.inertia,this.inertiaWorld);
    this.quaternion.vmult(this.invInertia,this.invInertiaWorld);
    */
};

/**
 * Apply force to a world point. This could for example be a point on the Body surface. Applying force this way will add to Body.force and Body.torque.
 * @method applyForce
 * @param  {Vec3} force The amount of force to add.
 * @param  {Vec3} worldPoint A world point to apply the force on.
 */
var Body_applyForce_r = new Vec3();
var Body_applyForce_rotForce = new Vec3();
Body.prototype.applyForce = function(force,worldPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    // Compute point position relative to the body center
    var r = Body_applyForce_r;
    worldPoint.vsub(this.position,r);

    // Compute produced rotational force
    var rotForce = Body_applyForce_rotForce;
    r.cross(force,rotForce);

    // Add linear force
    this.force.vadd(force,this.force);

    // Add rotational force
    this.torque.vadd(rotForce,this.torque);
};

/**
 * Apply force to a local point in the body.
 * @method applyLocalForce
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */
var Body_applyLocalForce_worldForce = new Vec3();
var Body_applyLocalForce_worldPoint = new Vec3();
Body.prototype.applyLocalForce = function(localForce, localPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    var worldForce = Body_applyLocalForce_worldForce;
    var worldPoint = Body_applyLocalForce_worldPoint;

    // Transform the force vector to world space
    this.vectorToWorldFrame(localForce, worldForce);
    this.pointToWorldFrame(localPoint, worldPoint);

    this.applyForce(worldForce, worldPoint);
};

/**
 * Apply impulse to a world point. This could for example be a point on the Body surface. An impulse is a force added to a body during a short period of time (impulse = force * time). Impulses will be added to Body.velocity and Body.angularVelocity.
 * @method applyImpulse
 * @param  {Vec3} impulse The amount of impulse to add.
 * @param  {Vec3} worldPoint A world point to apply the force on.
 */
var Body_applyImpulse_r = new Vec3();
var Body_applyImpulse_velo = new Vec3();
var Body_applyImpulse_rotVelo = new Vec3();
Body.prototype.applyImpulse = function(impulse, worldPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    // Compute point position relative to the body center
    var r = Body_applyImpulse_r;
    worldPoint.vsub(this.position,r);

    // Compute produced central impulse velocity
    var velo = Body_applyImpulse_velo;
    velo.copy(impulse);
    velo.mult(this.invMass,velo);

    // Add linear impulse
    this.velocity.vadd(velo, this.velocity);

    // Compute produced rotational impulse velocity
    var rotVelo = Body_applyImpulse_rotVelo;
    r.cross(impulse,rotVelo);

    /*
    rotVelo.x *= this.invInertia.x;
    rotVelo.y *= this.invInertia.y;
    rotVelo.z *= this.invInertia.z;
    */
    this.invInertiaWorld.vmult(rotVelo,rotVelo);

    // Add rotational Impulse
    this.angularVelocity.vadd(rotVelo, this.angularVelocity);
};

/**
 * Apply locally-defined impulse to a local point in the body.
 * @method applyLocalImpulse
 * @param  {Vec3} force The force vector to apply, defined locally in the body frame.
 * @param  {Vec3} localPoint A local point in the body to apply the force on.
 */
var Body_applyLocalImpulse_worldImpulse = new Vec3();
var Body_applyLocalImpulse_worldPoint = new Vec3();
Body.prototype.applyLocalImpulse = function(localImpulse, localPoint){
    if(this.type !== Body.DYNAMIC){
        return;
    }

    var worldImpulse = Body_applyLocalImpulse_worldImpulse;
    var worldPoint = Body_applyLocalImpulse_worldPoint;

    // Transform the force vector to world space
    this.vectorToWorldFrame(localImpulse, worldImpulse);
    this.pointToWorldFrame(localPoint, worldPoint);

    this.applyImpulse(worldImpulse, worldPoint);
};

var Body_updateMassProperties_halfExtents = new Vec3();

/**
 * Should be called whenever you change the body shape or mass.
 * @method updateMassProperties
 */
Body.prototype.updateMassProperties = function(){
    var halfExtents = Body_updateMassProperties_halfExtents;

    this.invMass = this.mass > 0 ? 1.0 / this.mass : 0;
    var I = this.inertia;
    var fixed = this.fixedRotation;

    // Approximate with AABB box
    this.computeAABB();
    halfExtents.set(
        (this.aabb.upperBound.x-this.aabb.lowerBound.x) / 2,
        (this.aabb.upperBound.y-this.aabb.lowerBound.y) / 2,
        (this.aabb.upperBound.z-this.aabb.lowerBound.z) / 2
    );
    Box.calculateInertia(halfExtents, this.mass, I);

    this.invInertia.set(
        I.x > 0 && !fixed ? 1.0 / I.x : 0,
        I.y > 0 && !fixed ? 1.0 / I.y : 0,
        I.z > 0 && !fixed ? 1.0 / I.z : 0
    );
    this.updateInertiaWorld(true);
};

/**
 * Get world velocity of a point in the body.
 * @method getVelocityAtWorldPoint
 * @param  {Vec3} worldPoint
 * @param  {Vec3} result
 * @return {Vec3} The result vector.
 */
Body.prototype.getVelocityAtWorldPoint = function(worldPoint, result){
    var r = new Vec3();
    worldPoint.vsub(this.position, r);
    this.angularVelocity.cross(r, result);
    this.velocity.vadd(result, result);
    return result;
};

},{"../collision/AABB":3,"../material/Material":25,"../math/Mat3":27,"../math/Quaternion":28,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Shape":43,"../utils/EventTarget":49}],32:[function(_dereq_,module,exports){
var Body = _dereq_('./Body');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Ray = _dereq_('../collision/Ray');
var WheelInfo = _dereq_('../objects/WheelInfo');

module.exports = RaycastVehicle;

/**
 * Vehicle helper class that casts rays from the wheel positions towards the ground and applies forces.
 * @class RaycastVehicle
 * @constructor
 * @param {object} [options]
 * @param {Body} [options.chassisBody] The car chassis body.
 * @param {integer} [options.indexRightAxis] Axis to use for right. x=0, y=1, z=2
 * @param {integer} [options.indexLeftAxis]
 * @param {integer} [options.indexUpAxis]
 */
function RaycastVehicle(options){

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = options.chassisBody;

    /**
     * An array of WheelInfo objects.
     * @property {array} wheelInfos
     */
    this.wheelInfos = [];

    /**
     * Will be set to true if the car is sliding.
     * @property {boolean} sliding
     */
    this.sliding = false;

    /**
     * @property {World} world
     */
    this.world = null;

    /**
     * Index of the right axis, 0=x, 1=y, 2=z
     * @property {integer} indexRightAxis
     * @default 1
     */
    this.indexRightAxis = typeof(options.indexRightAxis) !== 'undefined' ? options.indexRightAxis : 1;

    /**
     * Index of the forward axis, 0=x, 1=y, 2=z
     * @property {integer} indexForwardAxis
     * @default 0
     */
    this.indexForwardAxis = typeof(options.indexForwardAxis) !== 'undefined' ? options.indexForwardAxis : 0;

    /**
     * Index of the up axis, 0=x, 1=y, 2=z
     * @property {integer} indexUpAxis
     * @default 2
     */
    this.indexUpAxis = typeof(options.indexUpAxis) !== 'undefined' ? options.indexUpAxis : 2;
}

var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpVec3 = new Vec3();
var tmpVec4 = new Vec3();
var tmpVec5 = new Vec3();
var tmpVec6 = new Vec3();
var tmpRay = new Ray();

/**
 * Add a wheel. For information about the options, see WheelInfo.
 * @method addWheel
 * @param {object} [options]
 */
RaycastVehicle.prototype.addWheel = function(options){
    options = options || {};

    var info = new WheelInfo(options);
    var index = this.wheelInfos.length;
    this.wheelInfos.push(info);

    return index;
};

/**
 * Set the steering value of a wheel.
 * @method setSteeringValue
 * @param {number} value
 * @param {integer} wheelIndex
 */
RaycastVehicle.prototype.setSteeringValue = function(value, wheelIndex){
    var wheel = this.wheelInfos[wheelIndex];
    wheel.steering = value;
};

var torque = new Vec3();

/**
 * Set the wheel force to apply on one of the wheels each time step
 * @method applyEngineForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RaycastVehicle.prototype.applyEngineForce = function(value, wheelIndex){
    this.wheelInfos[wheelIndex].engineForce = value;
};

/**
 * Set the braking force of a wheel
 * @method setBrake
 * @param {number} brake
 * @param {integer} wheelIndex
 */
RaycastVehicle.prototype.setBrake = function(brake, wheelIndex){
    this.wheelInfos[wheelIndex].brake = brake;
};

/**
 * Add the vehicle including its constraints to the world.
 * @method addToWorld
 * @param {World} world
 */
RaycastVehicle.prototype.addToWorld = function(world){
    var constraints = this.constraints;
    world.add(this.chassisBody);
    var that = this;
    this.preStepCallback = function(){
        that.updateVehicle(world.dt);
    };
    world.addEventListener('preStep', this.preStepCallback);
    this.world = world;
};

/**
 * Get one of the wheel axles, world-oriented.
 * @private
 * @method getVehicleAxisWorld
 * @param  {integer} axisIndex
 * @param  {Vec3} result
 */
RaycastVehicle.prototype.getVehicleAxisWorld = function(axisIndex, result){
    result.set(
        axisIndex === 0 ? 1 : 0,
        axisIndex === 1 ? 1 : 0,
        axisIndex === 2 ? 1 : 0
    );
    this.chassisBody.vectorToWorldFrame(result, result);
};

RaycastVehicle.prototype.updateVehicle = function(timeStep){
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;
    var chassisBody = this.chassisBody;

    for (var i = 0; i < numWheels; i++) {
        this.updateWheelTransform(i);
    }

    this.currentVehicleSpeedKmHour = 3.6 * chassisBody.velocity.norm();

    var forwardWorld = new Vec3();
    this.getVehicleAxisWorld(this.indexForwardAxis, forwardWorld);

    if (forwardWorld.dot(chassisBody.velocity) < 0){
        this.currentVehicleSpeedKmHour *= -1;
    }

    // simulate suspension
    for (var i = 0; i < numWheels; i++) {
        this.castRay(wheelInfos[i]);
    }

    this.updateSuspension(timeStep);

    var impulse = new Vec3();
    var relpos = new Vec3();
    for (var i = 0; i < numWheels; i++) {
        //apply suspension force
        var wheel = wheelInfos[i];
        var suspensionForce = wheel.suspensionForce;
        if (suspensionForce > wheel.maxSuspensionForce) {
            suspensionForce = wheel.maxSuspensionForce;
        }
        wheel.raycastResult.hitNormalWorld.scale(suspensionForce * timeStep, impulse);

        wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, relpos);
        chassisBody.applyImpulse(impulse, wheel.raycastResult.hitPointWorld/*relpos*/);
    }

    this.updateFriction(timeStep);

    var hitNormalWorldScaledWithProj = new Vec3();
    var fwd  = new Vec3();
    var vel = new Vec3();
    for (i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];
        //var relpos = new Vec3();
        //wheel.chassisConnectionPointWorld.vsub(chassisBody.position, relpos);
        chassisBody.getVelocityAtWorldPoint(wheel.chassisConnectionPointWorld, vel);

        // Hack to get the rotation in the correct direction
        var m = 1;
        switch(this.indexUpAxis){
        case 1:
            m = -1;
            break;
        }

        if (wheel.isInContact) {

            this.getVehicleAxisWorld(this.indexForwardAxis, fwd);
            var proj = fwd.dot(wheel.raycastResult.hitNormalWorld);
            wheel.raycastResult.hitNormalWorld.scale(proj, hitNormalWorldScaledWithProj);

            fwd.vsub(hitNormalWorldScaledWithProj, fwd);

            var proj2 = fwd.dot(vel);
            wheel.deltaRotation = m * proj2 * timeStep / wheel.radius;
        }

        if((wheel.sliding || !wheel.isInContact) && wheel.engineForce !== 0 && wheel.useCustomSlidingRotationalSpeed){
            // Apply custom rotation when accelerating and sliding
            wheel.deltaRotation = (wheel.engineForce > 0 ? 1 : -1) * wheel.customSlidingRotationalSpeed * timeStep;
        }

        // Lock wheels
        if(Math.abs(wheel.brake) > Math.abs(wheel.engineForce)){
            wheel.deltaRotation = 0;
        }

        wheel.rotation += wheel.deltaRotation; // Use the old value
        wheel.deltaRotation *= 0.99; // damping of rotation when not in contact
    }
};

RaycastVehicle.prototype.updateSuspension = function(deltaTime) {
    var chassisBody = this.chassisBody;
    var chassisMass = chassisBody.mass;
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;

    for (var w_it = 0; w_it < numWheels; w_it++){
        var wheel = wheelInfos[w_it];

        if (wheel.isInContact){
            var force;

            // Spring
            var susp_length = wheel.suspensionRestLength;
            var current_length = wheel.suspensionLength;
            var length_diff = (susp_length - current_length);

            force = wheel.suspensionStiffness * length_diff * wheel.clippedInvContactDotSuspension;

            // Damper
            var projected_rel_vel = wheel.suspensionRelativeVelocity;
            var susp_damping;
            if (projected_rel_vel < 0) {
                susp_damping = wheel.dampingCompression;
            } else {
                susp_damping = wheel.dampingRelaxation;
            }
            force -= susp_damping * projected_rel_vel;

            wheel.suspensionForce = force * chassisMass;
            if (wheel.suspensionForce < 0) {
                wheel.suspensionForce = 0;
            }
        } else {
            wheel.suspensionForce = 0;
        }
    }
};

/**
 * Remove the vehicle including its constraints from the world.
 * @method removeFromWorld
 * @param {World} world
 */
RaycastVehicle.prototype.removeFromWorld = function(world){
    var constraints = this.constraints;
    world.remove(this.chassisBody);
    world.removeEventListener('preStep', this.preStepCallback);
    this.world = null;
};

var castRay_rayvector = new Vec3();
var castRay_target = new Vec3();
RaycastVehicle.prototype.castRay = function(wheel) {
    var rayvector = castRay_rayvector;
    var target = castRay_target;

    this.updateWheelTransformWorld(wheel);
    var chassisBody = this.chassisBody;

    var depth = -1;

    var raylen = wheel.suspensionRestLength + wheel.radius;

    wheel.directionWorld.scale(raylen, rayvector);
    var source = wheel.chassisConnectionPointWorld;
    source.vadd(rayvector, target);
    var raycastResult = wheel.raycastResult;

    var param = 0;

    raycastResult.reset();
    // Turn off ray collision with the chassis temporarily
    var oldState = chassisBody.collisionResponse;
    chassisBody.collisionResponse = false;

    // Cast ray against world
    this.world.rayTest(source, target, raycastResult);
    chassisBody.collisionResponse = oldState;

    var object = raycastResult.body;

    wheel.raycastResult.groundObject = 0;

    if (object) {
        depth = raycastResult.distance;
        wheel.raycastResult.hitNormalWorld  = raycastResult.hitNormalWorld;
        wheel.isInContact = true;

        var hitDistance = raycastResult.distance;
        wheel.suspensionLength = hitDistance - wheel.radius;

        // clamp on max suspension travel
        var minSuspensionLength = wheel.suspensionRestLength - wheel.maxSuspensionTravel;
        var maxSuspensionLength = wheel.suspensionRestLength + wheel.maxSuspensionTravel;
        if (wheel.suspensionLength < minSuspensionLength) {
            wheel.suspensionLength = minSuspensionLength;
        }
        if (wheel.suspensionLength > maxSuspensionLength) {
            wheel.suspensionLength = maxSuspensionLength;
            wheel.raycastResult.reset();
        }

        var denominator = wheel.raycastResult.hitNormalWorld.dot(wheel.directionWorld);

        var chassis_velocity_at_contactPoint = new Vec3();
        chassisBody.getVelocityAtWorldPoint(wheel.raycastResult.hitPointWorld, chassis_velocity_at_contactPoint);

        var projVel = wheel.raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );

        if (denominator >= -0.1) {
            wheel.suspensionRelativeVelocity = 0;
            wheel.clippedInvContactDotSuspension = 1 / 0.1;
        } else {
            var inv = -1 / denominator;
            wheel.suspensionRelativeVelocity = projVel * inv;
            wheel.clippedInvContactDotSuspension = inv;
        }

    } else {

        //put wheel info as in rest position
        wheel.suspensionLength = wheel.suspensionRestLength + 0 * wheel.maxSuspensionTravel;
        wheel.suspensionRelativeVelocity = 0.0;
        wheel.directionWorld.scale(-1, wheel.raycastResult.hitNormalWorld);
        wheel.clippedInvContactDotSuspension = 1.0;
    }

    return depth;
};

RaycastVehicle.prototype.updateWheelTransformWorld = function(wheel){
    wheel.isInContact = false;
    var chassisBody = this.chassisBody;
    chassisBody.pointToWorldFrame(wheel.chassisConnectionPointLocal, wheel.chassisConnectionPointWorld);
    chassisBody.vectorToWorldFrame(wheel.directionLocal, wheel.directionWorld);
    chassisBody.vectorToWorldFrame(wheel.axleLocal, wheel.axleWorld);
};


/**
 * Update one of the wheel transform.
 * Note when rendering wheels: during each step, wheel transforms are updated BEFORE the chassis; ie. their position becomes invalid after the step. Thus when you render wheels, you must update wheel transforms before rendering them. See raycastVehicle demo for an example.
 * @method updateWheelTransform
 * @param {integer} wheelIndex The wheel index to update.
 */
RaycastVehicle.prototype.updateWheelTransform = function(wheelIndex){
    var up = tmpVec4;
    var right = tmpVec5;
    var fwd = tmpVec6;

    var wheel = this.wheelInfos[wheelIndex];
    this.updateWheelTransformWorld(wheel);

    wheel.directionLocal.scale(-1, up);
    right.copy(wheel.axleLocal);
    up.cross(right, fwd);
    fwd.normalize();
    right.normalize();

    // Rotate around steering over the wheelAxle
    var steering = wheel.steering;
    var steeringOrn = new Quaternion();
    steeringOrn.setFromAxisAngle(up, steering);

    var rotatingOrn = new Quaternion();
    rotatingOrn.setFromAxisAngle(right, wheel.rotation);

    // World rotation of the wheel
    var q = wheel.worldTransform.quaternion;
    this.chassisBody.quaternion.mult(steeringOrn, q);
    q.mult(rotatingOrn, q);

    q.normalize();

    // world position of the wheel
    var p = wheel.worldTransform.position;
    p.copy(wheel.directionWorld);
    p.scale(wheel.suspensionLength, p);
    p.vadd(wheel.chassisConnectionPointWorld, p);
};

var directions = [
    new Vec3(1, 0, 0),
    new Vec3(0, 1, 0),
    new Vec3(0, 0, 1)
];

/**
 * Get the world transform of one of the wheels
 * @method getWheelTransformWorld
 * @param  {integer} wheelIndex
 * @return {Transform}
 */
RaycastVehicle.prototype.getWheelTransformWorld = function(wheelIndex) {
    return this.wheelInfos[wheelIndex].worldTransform;
};


var updateFriction_surfNormalWS_scaled_proj = new Vec3();
var updateFriction_axle = [];
var updateFriction_forwardWS = [];
var sideFrictionStiffness2 = 1;
RaycastVehicle.prototype.updateFriction = function(timeStep) {
    var surfNormalWS_scaled_proj = updateFriction_surfNormalWS_scaled_proj;

    //calculate the impulse, so that the wheels don't move sidewards
    var wheelInfos = this.wheelInfos;
    var numWheels = wheelInfos.length;
    var chassisBody = this.chassisBody;
    var forwardWS = updateFriction_forwardWS;
    var axle = updateFriction_axle;

    var numWheelsOnGround = 0;

    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];

        var groundObject = wheel.raycastResult.body;
        if (groundObject){
            numWheelsOnGround++;
        }

        wheel.sideImpulse = 0;
        wheel.forwardImpulse = 0;
        if(!forwardWS[i]){
            forwardWS[i] = new Vec3();
        }
        if(!axle[i]){
            axle[i] = new Vec3();
        }
    }

    for (var i = 0; i < numWheels; i++){
        var wheel = wheelInfos[i];

        var groundObject = wheel.raycastResult.body;

        if (groundObject) {
            var axlei = axle[i];
            var wheelTrans = this.getWheelTransformWorld(i);

            // Get world axle
            wheelTrans.vectorToWorldFrame(directions[this.indexRightAxis], axlei);

            var surfNormalWS = wheel.raycastResult.hitNormalWorld;
            var proj = axlei.dot(surfNormalWS);
            surfNormalWS.scale(proj, surfNormalWS_scaled_proj);
            axlei.vsub(surfNormalWS_scaled_proj, axlei);
            axlei.normalize();

            surfNormalWS.cross(axlei, forwardWS[i]);
            forwardWS[i].normalize();

            wheel.sideImpulse = resolveSingleBilateral(
                chassisBody,
                wheel.raycastResult.hitPointWorld,
                groundObject,
                wheel.raycastResult.hitPointWorld,
                axlei
            );

            wheel.sideImpulse *= sideFrictionStiffness2;
        }
    }

    var sideFactor = 1;
    var fwdFactor = 0.5;

    this.sliding = false;
    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];
        var groundObject = wheel.raycastResult.body;

        var rollingFriction = 0;

        wheel.slipInfo = 1;
        if (groundObject) {
            var defaultRollingFrictionImpulse = 0;
            var maxImpulse = wheel.brake ? wheel.brake : defaultRollingFrictionImpulse;

            // btWheelContactPoint contactPt(chassisBody,groundObject,wheelInfraycastInfo.hitPointWorld,forwardWS[wheel],maxImpulse);
            // rollingFriction = calcRollingFriction(contactPt);
            rollingFriction = calcRollingFriction(chassisBody, groundObject, wheel.raycastResult.hitPointWorld, forwardWS[i], maxImpulse);

            rollingFriction += wheel.engineForce * timeStep;

            // rollingFriction = 0;
            var factor = maxImpulse / rollingFriction;
            wheel.slipInfo *= factor;
        }

        //switch between active rolling (throttle), braking and non-active rolling friction (nthrottle/break)

        wheel.forwardImpulse = 0;
        wheel.skidInfo = 1;

        if (groundObject) {
            wheel.skidInfo = 1;

            var maximp = wheel.suspensionForce * timeStep * wheel.frictionSlip;
            var maximpSide = maximp;

            var maximpSquared = maximp * maximpSide;

            wheel.forwardImpulse = rollingFriction;//wheelInfo.engineForce* timeStep;

            var x = wheel.forwardImpulse * fwdFactor;
            var y = wheel.sideImpulse * sideFactor;

            var impulseSquared = x * x + y * y;

            wheel.sliding = false;
            if (impulseSquared > maximpSquared) {
                this.sliding = true;
                wheel.sliding = true;

                var factor = maximp / Math.sqrt(impulseSquared);

                wheel.skidInfo *= factor;
            }
        }
    }

    if (this.sliding) {
        for (var i = 0; i < numWheels; i++) {
            var wheel = wheelInfos[i];
            if (wheel.sideImpulse !== 0) {
                if (wheel.skidInfo < 1){
                    wheel.forwardImpulse *= wheel.skidInfo;
                    wheel.sideImpulse *= wheel.skidInfo;
                }
            }
        }
    }

    // apply the impulses
    for (var i = 0; i < numWheels; i++) {
        var wheel = wheelInfos[i];

        var rel_pos = new Vec3();
        //wheel.raycastResult.hitPointWorld.vsub(chassisBody.position, rel_pos);
        // cannons applyimpulse is using world coord for the position
        rel_pos.copy(wheel.raycastResult.hitPointWorld);

        if (wheel.forwardImpulse !== 0) {
            var impulse = new Vec3();
            forwardWS[i].scale(wheel.forwardImpulse, impulse);
            chassisBody.applyImpulse(impulse, rel_pos);
        }

        if (wheel.sideImpulse !== 0){
            var groundObject = wheel.raycastResult.body;

            var rel_pos2 = new Vec3();
            //wheel.raycastResult.hitPointWorld.vsub(groundObject.position, rel_pos2);
            rel_pos2.copy(wheel.raycastResult.hitPointWorld);
            var sideImp = new Vec3();
            axle[i].scale(wheel.sideImpulse, sideImp);

            // Scale the relative position in the up direction with rollInfluence.
            // If rollInfluence is 1, the impulse will be applied on the hitPoint (easy to roll over), if it is zero it will be applied in the same plane as the center of mass (not easy to roll over).
            chassisBody.pointToLocalFrame(rel_pos, rel_pos);
            rel_pos['xyz'[this.indexUpAxis]] *= wheel.rollInfluence;
            chassisBody.pointToWorldFrame(rel_pos, rel_pos);
            chassisBody.applyImpulse(sideImp, rel_pos);

            //apply friction impulse on the ground
            sideImp.scale(-1, sideImp);
            groundObject.applyImpulse(sideImp, rel_pos2);
        }
    }
};

var calcRollingFriction_vel1 = new Vec3();
var calcRollingFriction_vel2 = new Vec3();
var calcRollingFriction_vel = new Vec3();

function calcRollingFriction(body0, body1, frictionPosWorld, frictionDirectionWorld, maxImpulse) {
    var j1 = 0;
    var contactPosWorld = frictionPosWorld;

    // var rel_pos1 = new Vec3();
    // var rel_pos2 = new Vec3();
    var vel1 = calcRollingFriction_vel1;
    var vel2 = calcRollingFriction_vel2;
    var vel = calcRollingFriction_vel;
    // contactPosWorld.vsub(body0.position, rel_pos1);
    // contactPosWorld.vsub(body1.position, rel_pos2);

    body0.getVelocityAtWorldPoint(contactPosWorld, vel1);
    body1.getVelocityAtWorldPoint(contactPosWorld, vel2);
    vel1.vsub(vel2, vel);

    var vrel = frictionDirectionWorld.dot(vel);

    var denom0 = computeImpulseDenominator(body0, frictionPosWorld, frictionDirectionWorld);
    var denom1 = computeImpulseDenominator(body1, frictionPosWorld, frictionDirectionWorld);
    var relaxation = 1;
    var jacDiagABInv = relaxation / (denom0 + denom1);

    // calculate j that moves us to zero relative velocity
    j1 = -vrel * jacDiagABInv;

    if (maxImpulse < j1) {
        j1 = maxImpulse;
    }
    if (j1 < -maxImpulse) {
        j1 = -maxImpulse;
    }

    return j1;
}

var computeImpulseDenominator_r0 = new Vec3();
var computeImpulseDenominator_c0 = new Vec3();
var computeImpulseDenominator_vec = new Vec3();
var computeImpulseDenominator_m = new Vec3();
function computeImpulseDenominator(body, pos, normal) {
    var r0 = computeImpulseDenominator_r0;
    var c0 = computeImpulseDenominator_c0;
    var vec = computeImpulseDenominator_vec;
    var m = computeImpulseDenominator_m;

    pos.vsub(body.position, r0);
    r0.cross(normal, c0);
    body.invInertiaWorld.vmult(c0, m);
    m.cross(r0, vec);

    return body.invMass + normal.dot(vec);
}


var resolveSingleBilateral_vel1 = new Vec3();
var resolveSingleBilateral_vel2 = new Vec3();
var resolveSingleBilateral_vel = new Vec3();

//bilateral constraint between two dynamic objects
function resolveSingleBilateral(body1, pos1, body2, pos2, normal, impulse){
    var normalLenSqr = normal.norm2();
    if (normalLenSqr > 1.1){
        return 0; // no impulse
    }
    // var rel_pos1 = new Vec3();
    // var rel_pos2 = new Vec3();
    // pos1.vsub(body1.position, rel_pos1);
    // pos2.vsub(body2.position, rel_pos2);

    var vel1 = resolveSingleBilateral_vel1;
    var vel2 = resolveSingleBilateral_vel2;
    var vel = resolveSingleBilateral_vel;
    body1.getVelocityAtWorldPoint(pos1, vel1);
    body2.getVelocityAtWorldPoint(pos2, vel2);

    vel1.vsub(vel2, vel);

    var rel_vel = normal.dot(vel);

    var contactDamping = 0.2;
    var massTerm = 1 / (body1.invMass + body2.invMass);
    var impulse = - contactDamping * rel_vel * massTerm;

    return impulse;
}
},{"../collision/Ray":9,"../collision/RaycastResult":10,"../math/Quaternion":28,"../math/Vec3":30,"../objects/WheelInfo":36,"./Body":31}],33:[function(_dereq_,module,exports){
var Body = _dereq_('./Body');
var Sphere = _dereq_('../shapes/Sphere');
var Box = _dereq_('../shapes/Box');
var Vec3 = _dereq_('../math/Vec3');
var HingeConstraint = _dereq_('../constraints/HingeConstraint');

module.exports = RigidVehicle;

/**
 * Simple vehicle helper class with spherical rigid body wheels.
 * @class RigidVehicle
 * @constructor
 * @param {Body} [options.chassisBody]
 */
function RigidVehicle(options){
    this.wheelBodies = [];

    /**
     * @property coordinateSystem
     * @type {Vec3}
     */
    this.coordinateSystem = typeof(options.coordinateSystem)==='undefined' ? new Vec3(1, 2, 3) : options.coordinateSystem.clone();

    /**
     * @property {Body} chassisBody
     */
    this.chassisBody = options.chassisBody;

    if(!this.chassisBody){
        // No chassis body given. Create it!
        var chassisShape = new Box(new Vec3(5, 2, 0.5));
        this.chassisBody = new Body(1, chassisShape);
    }

    /**
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    this.wheelAxes = [];
    this.wheelForces = [];
}

/**
 * Add a wheel
 * @method addWheel
 * @param {object} options
 * @param {boolean} [options.isFrontWheel]
 * @param {Vec3} [options.position] Position of the wheel, locally in the chassis body.
 * @param {Vec3} [options.direction] Slide direction of the wheel along the suspension.
 * @param {Vec3} [options.axis] Axis of rotation of the wheel, locally defined in the chassis.
 * @param {Body} [options.body] The wheel body.
 */
RigidVehicle.prototype.addWheel = function(options){
    options = options || {};
    var wheelBody = options.body;
    if(!wheelBody){
        wheelBody =  new Body(1, new Sphere(1.2));
    }
    this.wheelBodies.push(wheelBody);
    this.wheelForces.push(0);

    // Position constrain wheels
    var zero = new Vec3();
    var position = typeof(options.position) !== 'undefined' ? options.position.clone() : new Vec3();

    // Set position locally to the chassis
    var worldPosition = new Vec3();
    this.chassisBody.pointToWorldFrame(position, worldPosition);
    wheelBody.position.set(worldPosition.x, worldPosition.y, worldPosition.z);

    // Constrain wheel
    var axis = typeof(options.axis) !== 'undefined' ? options.axis.clone() : new Vec3(0, 1, 0);
    this.wheelAxes.push(axis);

    var hingeConstraint = new HingeConstraint(this.chassisBody, wheelBody, {
        pivotA: position,
        axisA: axis,
        pivotB: Vec3.ZERO,
        axisB: axis,
        collideConnected: false
    });
    this.constraints.push(hingeConstraint);

    return this.wheelBodies.length - 1;
};

/**
 * Set the steering value of a wheel.
 * @method setSteeringValue
 * @param {number} value
 * @param {integer} wheelIndex
 * @todo check coordinateSystem
 */
RigidVehicle.prototype.setSteeringValue = function(value, wheelIndex){
    // Set angle of the hinge axis
    var axis = this.wheelAxes[wheelIndex];

    var c = Math.cos(value),
        s = Math.sin(value),
        x = axis.x,
        y = axis.y;
    this.constraints[wheelIndex].axisA.set(
        c*x -s*y,
        s*x +c*y,
        0
    );
};

/**
 * Set the target rotational speed of the hinge constraint.
 * @method setMotorSpeed
 * @param {number} value
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.setMotorSpeed = function(value, wheelIndex){
    var hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.enableMotor();
    hingeConstraint.motorTargetVelocity = value;
};

/**
 * Set the target rotational speed of the hinge constraint.
 * @method disableMotor
 * @param {number} value
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.disableMotor = function(wheelIndex){
    var hingeConstraint = this.constraints[wheelIndex];
    hingeConstraint.disableMotor();
};

var torque = new Vec3();

/**
 * Set the wheel force to apply on one of the wheels each time step
 * @method setWheelForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RigidVehicle.prototype.setWheelForce = function(value, wheelIndex){
    this.wheelForces[wheelIndex] = value;
};

/**
 * Apply a torque on one of the wheels.
 * @method applyWheelForce
 * @param  {number} value
 * @param  {integer} wheelIndex
 */
RigidVehicle.prototype.applyWheelForce = function(value, wheelIndex){
    var axis = this.wheelAxes[wheelIndex];
    var wheelBody = this.wheelBodies[wheelIndex];
    var bodyTorque = wheelBody.torque;

    axis.scale(value, torque);
    wheelBody.vectorToWorldFrame(torque, torque);
    bodyTorque.vadd(torque, bodyTorque);
};

/**
 * Add the vehicle including its constraints to the world.
 * @method addToWorld
 * @param {World} world
 */
RigidVehicle.prototype.addToWorld = function(world){
    var constraints = this.constraints;
    var bodies = this.wheelBodies.concat([this.chassisBody]);

    for (var i = 0; i < bodies.length; i++) {
        world.add(bodies[i]);
    }

    for (var i = 0; i < constraints.length; i++) {
        world.addConstraint(constraints[i]);
    }

    world.addEventListener('preStep', this._update.bind(this));
};

RigidVehicle.prototype._update = function(){
    var wheelForces = this.wheelForces;
    for (var i = 0; i < wheelForces.length; i++) {
        this.applyWheelForce(wheelForces[i], i);
    }
};

/**
 * Remove the vehicle including its constraints from the world.
 * @method removeFromWorld
 * @param {World} world
 */
RigidVehicle.prototype.removeFromWorld = function(world){
    var constraints = this.constraints;
    var bodies = this.wheelBodies.concat([this.chassisBody]);

    for (var i = 0; i < bodies.length; i++) {
        world.remove(bodies[i]);
    }

    for (var i = 0; i < constraints.length; i++) {
        world.removeConstraint(constraints[i]);
    }
};

var worldAxis = new Vec3();

/**
 * Get current rotational velocity of a wheel
 * @method getWheelSpeed
 * @param {integer} wheelIndex
 */
RigidVehicle.prototype.getWheelSpeed = function(wheelIndex){
    var axis = this.wheelAxes[wheelIndex];
    var wheelBody = this.wheelBodies[wheelIndex];
    var w = wheelBody.angularVelocity;
    this.chassisBody.vectorToWorldFrame(axis, worldAxis);
    return w.dot(worldAxis);
};

},{"../constraints/HingeConstraint":15,"../math/Vec3":30,"../shapes/Box":37,"../shapes/Sphere":44,"./Body":31}],34:[function(_dereq_,module,exports){
module.exports = SPHSystem;

var Shape = _dereq_('../shapes/Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Particle = _dereq_('../shapes/Particle');
var Body = _dereq_('../objects/Body');
var Material = _dereq_('../material/Material');

/**
 * Smoothed-particle hydrodynamics system
 * @class SPHSystem
 * @constructor
 */
function SPHSystem(){
    this.particles = [];
	
    /**
     * Density of the system (kg/m3).
     * @property {number} density
     */
    this.density = 1;
	
    /**
     * Distance below which two particles are considered to be neighbors.
     * It should be adjusted so there are about 15-20 neighbor particles within this radius.
     * @property {number} smoothingRadius
     */
    this.smoothingRadius = 1;
    this.speedOfSound = 1;
	
    /**
     * Viscosity of the system.
     * @property {number} viscosity
     */
    this.viscosity = 0.01;
    this.eps = 0.000001;

    // Stuff Computed per particle
    this.pressures = [];
    this.densities = [];
    this.neighbors = [];
}

/**
 * Add a particle to the system.
 * @method add
 * @param {Body} particle
 */
SPHSystem.prototype.add = function(particle){
    this.particles.push(particle);
    if(this.neighbors.length < this.particles.length){
        this.neighbors.push([]);
    }
};

/**
 * Remove a particle from the system.
 * @method remove
 * @param {Body} particle
 */
SPHSystem.prototype.remove = function(particle){
    var idx = this.particles.indexOf(particle);
    if(idx !== -1){
        this.particles.splice(idx,1);
        if(this.neighbors.length > this.particles.length){
            this.neighbors.pop();
        }
    }
};

/**
 * Get neighbors within smoothing volume, save in the array neighbors
 * @method getNeighbors
 * @param {Body} particle
 * @param {Array} neighbors
 */
var SPHSystem_getNeighbors_dist = new Vec3();
SPHSystem.prototype.getNeighbors = function(particle,neighbors){
    var N = this.particles.length,
        id = particle.id,
        R2 = this.smoothingRadius * this.smoothingRadius,
        dist = SPHSystem_getNeighbors_dist;
    for(var i=0; i!==N; i++){
        var p = this.particles[i];
        p.position.vsub(particle.position,dist);
        if(id!==p.id && dist.norm2() < R2){
            neighbors.push(p);
        }
    }
};

// Temp vectors for calculation
var SPHSystem_update_dist = new Vec3(),
    SPHSystem_update_a_pressure = new Vec3(),
    SPHSystem_update_a_visc = new Vec3(),
    SPHSystem_update_gradW = new Vec3(),
    SPHSystem_update_r_vec = new Vec3(),
    SPHSystem_update_u = new Vec3(); // Relative velocity
SPHSystem.prototype.update = function(){
    var N = this.particles.length,
        dist = SPHSystem_update_dist,
        cs = this.speedOfSound,
        eps = this.eps;

    for(var i=0; i!==N; i++){
        var p = this.particles[i]; // Current particle
        var neighbors = this.neighbors[i];

        // Get neighbors
        neighbors.length = 0;
        this.getNeighbors(p,neighbors);
        neighbors.push(this.particles[i]); // Add current too
        var numNeighbors = neighbors.length;

        // Accumulate density for the particle
        var sum = 0.0;
        for(var j=0; j!==numNeighbors; j++){

            //printf("Current particle has position %f %f %f\n",objects[id].pos.x(),objects[id].pos.y(),objects[id].pos.z());
            p.position.vsub(neighbors[j].position, dist);
            var len = dist.norm();

            var weight = this.w(len);
            sum += neighbors[j].mass * weight;
        }

        // Save
        this.densities[i] = sum;
        this.pressures[i] = cs * cs * (this.densities[i] - this.density);
    }

    // Add forces

    // Sum to these accelerations
    var a_pressure= SPHSystem_update_a_pressure;
    var a_visc =    SPHSystem_update_a_visc;
    var gradW =     SPHSystem_update_gradW;
    var r_vec =     SPHSystem_update_r_vec;
    var u =         SPHSystem_update_u;

    for(var i=0; i!==N; i++){

        var particle = this.particles[i];

        a_pressure.set(0,0,0);
        a_visc.set(0,0,0);

        // Init vars
        var Pij;
        var nabla;
        var Vij;

        // Sum up for all other neighbors
        var neighbors = this.neighbors[i];
        var numNeighbors = neighbors.length;

        //printf("Neighbors: ");
        for(var j=0; j!==numNeighbors; j++){

            var neighbor = neighbors[j];
            //printf("%d ",nj);

            // Get r once for all..
            particle.position.vsub(neighbor.position,r_vec);
            var r = r_vec.norm();

            // Pressure contribution
            Pij = -neighbor.mass * (this.pressures[i] / (this.densities[i]*this.densities[i] + eps) + this.pressures[j] / (this.densities[j]*this.densities[j] + eps));
            this.gradw(r_vec, gradW);
            // Add to pressure acceleration
            gradW.mult(Pij , gradW);
            a_pressure.vadd(gradW, a_pressure);

            // Viscosity contribution
            neighbor.velocity.vsub(particle.velocity, u);
            u.mult( 1.0 / (0.0001+this.densities[i] * this.densities[j]) * this.viscosity * neighbor.mass , u );
            nabla = this.nablaw(r);
            u.mult(nabla,u);
            // Add to viscosity acceleration
            a_visc.vadd( u, a_visc );
        }

        // Calculate force
        a_visc.mult(particle.mass, a_visc);
        a_pressure.mult(particle.mass, a_pressure);

        // Add force to particles
        particle.force.vadd(a_visc, particle.force);
        particle.force.vadd(a_pressure, particle.force);
    }
};

// Calculate the weight using the W(r) weightfunction
SPHSystem.prototype.w = function(r){
    // 315
    var h = this.smoothingRadius;
    return 315.0/(64.0*Math.PI*Math.pow(h,9)) * Math.pow(h*h-r*r,3);
};

// calculate gradient of the weight function
SPHSystem.prototype.gradw = function(rVec,resultVec){
    var r = rVec.norm(),
        h = this.smoothingRadius;
    rVec.mult(945.0/(32.0*Math.PI*Math.pow(h,9)) * Math.pow((h*h-r*r),2) , resultVec);
};

// Calculate nabla(W)
SPHSystem.prototype.nablaw = function(r){
    var h = this.smoothingRadius;
    var nabla = 945.0/(32.0*Math.PI*Math.pow(h,9)) * (h*h-r*r)*(7*r*r - 3*h*h);
    return nabla;
};

},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Particle":41,"../shapes/Shape":43}],35:[function(_dereq_,module,exports){
var Vec3 = _dereq_('../math/Vec3');

module.exports = Spring;

/**
 * A spring, connecting two bodies.
 *
 * @class Spring
 * @constructor
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Object} [options]
 * @param {number} [options.restLength]   A number > 0. Default: 1
 * @param {number} [options.stiffness]    A number >= 0. Default: 100
 * @param {number} [options.damping]      A number >= 0. Default: 1
 * @param {Vec3}  [options.worldAnchorA] Where to hook the spring to body A, in world coordinates.
 * @param {Vec3}  [options.worldAnchorB]
 * @param {Vec3}  [options.localAnchorA] Where to hook the spring to body A, in local body coordinates.
 * @param {Vec3}  [options.localAnchorB]
 */
function Spring(bodyA,bodyB,options){
    options = options || {};

    /**
     * Rest length of the spring.
     * @property restLength
     * @type {number}
     */
    this.restLength = typeof(options.restLength) === "number" ? options.restLength : 1;

    /**
     * Stiffness of the spring.
     * @property stiffness
     * @type {number}
     */
    this.stiffness = options.stiffness || 100;

    /**
     * Damping of the spring.
     * @property damping
     * @type {number}
     */
    this.damping = options.damping || 1;

    /**
     * First connected body.
     * @property bodyA
     * @type {Body}
     */
    this.bodyA = bodyA;

    /**
     * Second connected body.
     * @property bodyB
     * @type {Body}
     */
    this.bodyB = bodyB;

    /**
     * Anchor for bodyA in local bodyA coordinates.
     * @property localAnchorA
     * @type {Vec3}
     */
    this.localAnchorA = new Vec3();

    /**
     * Anchor for bodyB in local bodyB coordinates.
     * @property localAnchorB
     * @type {Vec3}
     */
    this.localAnchorB = new Vec3();

    if(options.localAnchorA){
        this.localAnchorA.copy(options.localAnchorA);
    }
    if(options.localAnchorB){
        this.localAnchorB.copy(options.localAnchorB);
    }
    if(options.worldAnchorA){
        this.setWorldAnchorA(options.worldAnchorA);
    }
    if(options.worldAnchorB){
        this.setWorldAnchorB(options.worldAnchorB);
    }
}

/**
 * Set the anchor point on body A, using world coordinates.
 * @method setWorldAnchorA
 * @param {Vec3} worldAnchorA
 */
Spring.prototype.setWorldAnchorA = function(worldAnchorA){
    this.bodyA.pointToLocalFrame(worldAnchorA,this.localAnchorA);
};

/**
 * Set the anchor point on body B, using world coordinates.
 * @method setWorldAnchorB
 * @param {Vec3} worldAnchorB
 */
Spring.prototype.setWorldAnchorB = function(worldAnchorB){
    this.bodyB.pointToLocalFrame(worldAnchorB,this.localAnchorB);
};

/**
 * Get the anchor point on body A, in world coordinates.
 * @method getWorldAnchorA
 * @param {Vec3} result The vector to store the result in.
 */
Spring.prototype.getWorldAnchorA = function(result){
    this.bodyA.pointToWorldFrame(this.localAnchorA,result);
};

/**
 * Get the anchor point on body B, in world coordinates.
 * @method getWorldAnchorB
 * @param {Vec3} result The vector to store the result in.
 */
Spring.prototype.getWorldAnchorB = function(result){
    this.bodyB.pointToWorldFrame(this.localAnchorB,result);
};

var applyForce_r =              new Vec3(),
    applyForce_r_unit =         new Vec3(),
    applyForce_u =              new Vec3(),
    applyForce_f =              new Vec3(),
    applyForce_worldAnchorA =   new Vec3(),
    applyForce_worldAnchorB =   new Vec3(),
    applyForce_ri =             new Vec3(),
    applyForce_rj =             new Vec3(),
    applyForce_ri_x_f =         new Vec3(),
    applyForce_rj_x_f =         new Vec3(),
    applyForce_tmp =            new Vec3();

/**
 * Apply the spring force to the connected bodies.
 * @method applyForce
 */
Spring.prototype.applyForce = function(){
    var k = this.stiffness,
        d = this.damping,
        l = this.restLength,
        bodyA = this.bodyA,
        bodyB = this.bodyB,
        r = applyForce_r,
        r_unit = applyForce_r_unit,
        u = applyForce_u,
        f = applyForce_f,
        tmp = applyForce_tmp;

    var worldAnchorA = applyForce_worldAnchorA,
        worldAnchorB = applyForce_worldAnchorB,
        ri = applyForce_ri,
        rj = applyForce_rj,
        ri_x_f = applyForce_ri_x_f,
        rj_x_f = applyForce_rj_x_f;

    // Get world anchors
    this.getWorldAnchorA(worldAnchorA);
    this.getWorldAnchorB(worldAnchorB);

    // Get offset points
    worldAnchorA.vsub(bodyA.position,ri);
    worldAnchorB.vsub(bodyB.position,rj);

    // Compute distance vector between world anchor points
    worldAnchorB.vsub(worldAnchorA,r);
    var rlen = r.norm();
    r_unit.copy(r);
    r_unit.normalize();

    // Compute relative velocity of the anchor points, u
    bodyB.velocity.vsub(bodyA.velocity,u);
    // Add rotational velocity

    bodyB.angularVelocity.cross(rj,tmp);
    u.vadd(tmp,u);
    bodyA.angularVelocity.cross(ri,tmp);
    u.vsub(tmp,u);

    // F = - k * ( x - L ) - D * ( u )
    r_unit.mult(-k*(rlen-l) - d*u.dot(r_unit), f);

    // Add forces to bodies
    bodyA.force.vsub(f,bodyA.force);
    bodyB.force.vadd(f,bodyB.force);

    // Angular force
    ri.cross(f,ri_x_f);
    rj.cross(f,rj_x_f);
    bodyA.torque.vsub(ri_x_f,bodyA.torque);
    bodyB.torque.vadd(rj_x_f,bodyB.torque);
};

},{"../math/Vec3":30}],36:[function(_dereq_,module,exports){
var Vec3 = _dereq_('../math/Vec3');
var Transform = _dereq_('../math/Transform');
var RaycastResult = _dereq_('../collision/RaycastResult');
var Utils = _dereq_('../utils/Utils');

module.exports = WheelInfo;

/**
 * @class WheelInfo
 * @constructor
 * @param {Object} [options]
 *
 * @param {Vec3} [options.chassisConnectionPointLocal]
 * @param {Vec3} [options.chassisConnectionPointWorld]
 * @param {Vec3} [options.directionLocal]
 * @param {Vec3} [options.directionWorld]
 * @param {Vec3} [options.axleLocal]
 * @param {Vec3} [options.axleWorld]
 * @param {number} [options.suspensionRestLength=1]
 * @param {number} [options.suspensionMaxLength=2]
 * @param {number} [options.radius=1]
 * @param {number} [options.suspensionStiffness=100]
 * @param {number} [options.dampingCompression=10]
 * @param {number} [options.dampingRelaxation=10]
 * @param {number} [options.frictionSlip=10000]
 * @param {number} [options.steering=0]
 * @param {number} [options.rotation=0]
 * @param {number} [options.deltaRotation=0]
 * @param {number} [options.rollInfluence=0.01]
 * @param {number} [options.maxSuspensionForce]
 * @param {boolean} [options.isFrontWheel=true]
 * @param {number} [options.clippedInvContactDotSuspension=1]
 * @param {number} [options.suspensionRelativeVelocity=0]
 * @param {number} [options.suspensionForce=0]
 * @param {number} [options.skidInfo=0]
 * @param {number} [options.suspensionLength=0]
 * @param {number} [options.maxSuspensionTravel=1]
 * @param {boolean} [options.useCustomSlidingRotationalSpeed=false]
 * @param {number} [options.customSlidingRotationalSpeed=-0.1]
 */
function WheelInfo(options){
    options = Utils.defaults(options, {
        chassisConnectionPointLocal: new Vec3(),
        chassisConnectionPointWorld: new Vec3(),
        directionLocal: new Vec3(),
        directionWorld: new Vec3(),
        axleLocal: new Vec3(),
        axleWorld: new Vec3(),
        suspensionRestLength: 1,
        suspensionMaxLength: 2,
        radius: 1,
        suspensionStiffness: 100,
        dampingCompression: 10,
        dampingRelaxation: 10,
        frictionSlip: 10000,
        steering: 0,
        rotation: 0,
        deltaRotation: 0,
        rollInfluence: 0.01,
        maxSuspensionForce: Number.MAX_VALUE,
        isFrontWheel: true,
        clippedInvContactDotSuspension: 1,
        suspensionRelativeVelocity: 0,
        suspensionForce: 0,
        skidInfo: 0,
        suspensionLength: 0,
        maxSuspensionTravel: 1,
        useCustomSlidingRotationalSpeed: false,
        customSlidingRotationalSpeed: -0.1
    });

    /**
     * Max travel distance of the suspension, in meters.
     * @property {number} maxSuspensionTravel
     */
    this.maxSuspensionTravel = options.maxSuspensionTravel;

    /**
     * Speed to apply to the wheel rotation when the wheel is sliding.
     * @property {number} customSlidingRotationalSpeed
     */
    this.customSlidingRotationalSpeed = options.customSlidingRotationalSpeed;

    /**
     * If the customSlidingRotationalSpeed should be used.
     * @property {Boolean} useCustomSlidingRotationalSpeed
     */
    this.useCustomSlidingRotationalSpeed = options.useCustomSlidingRotationalSpeed;

    /**
     * @property {Boolean} sliding
     */
    this.sliding = false;

    /**
     * Connection point, defined locally in the chassis body frame.
     * @property {Vec3} chassisConnectionPointLocal
     */
    this.chassisConnectionPointLocal = options.chassisConnectionPointLocal.clone();

    /**
     * @property {Vec3} chassisConnectionPointWorld
     */
    this.chassisConnectionPointWorld = options.chassisConnectionPointWorld.clone();

    /**
     * @property {Vec3} directionLocal
     */
    this.directionLocal = options.directionLocal.clone();

    /**
     * @property {Vec3} directionWorld
     */
    this.directionWorld = options.directionWorld.clone();

    /**
     * @property {Vec3} axleLocal
     */
    this.axleLocal = options.axleLocal.clone();

    /**
     * @property {Vec3} axleWorld
     */
    this.axleWorld = options.axleWorld.clone();

    /**
     * @property {number} suspensionRestLength
     */
    this.suspensionRestLength = options.suspensionRestLength;

    /**
     * @property {number} suspensionMaxLength
     */
    this.suspensionMaxLength = options.suspensionMaxLength;

    /**
     * @property {number} radius
     */
    this.radius = options.radius;

    /**
     * @property {number} suspensionStiffness
     */
    this.suspensionStiffness = options.suspensionStiffness;

    /**
     * @property {number} dampingCompression
     */
    this.dampingCompression = options.dampingCompression;

    /**
     * @property {number} dampingRelaxation
     */
    this.dampingRelaxation = options.dampingRelaxation;

    /**
     * @property {number} frictionSlip
     */
    this.frictionSlip = options.frictionSlip;

    /**
     * @property {number} steering
     */
    this.steering = 0;

    /**
     * Rotation value, in radians.
     * @property {number} rotation
     */
    this.rotation = 0;

    /**
     * @property {number} deltaRotation
     */
    this.deltaRotation = 0;

    /**
     * @property {number} rollInfluence
     */
    this.rollInfluence = options.rollInfluence;

    /**
     * @property {number} maxSuspensionForce
     */
    this.maxSuspensionForce = options.maxSuspensionForce;

    /**
     * @property {number} engineForce
     */
    this.engineForce = 0;

    /**
     * @property {number} brake
     */
    this.brake = 0;

    /**
     * @property {number} isFrontWheel
     */
    this.isFrontWheel = options.isFrontWheel;

    /**
     * @property {number} clippedInvContactDotSuspension
     */
    this.clippedInvContactDotSuspension = 1;

    /**
     * @property {number} suspensionRelativeVelocity
     */
    this.suspensionRelativeVelocity = 0;

    /**
     * @property {number} suspensionForce
     */
    this.suspensionForce = 0;

    /**
     * @property {number} skidInfo
     */
    this.skidInfo = 0;

    /**
     * @property {number} suspensionLength
     */
    this.suspensionLength = 0;

    /**
     * @property {number} sideImpulse
     */
    this.sideImpulse = 0;

    /**
     * @property {number} forwardImpulse
     */
    this.forwardImpulse = 0;

    /**
     * The result from raycasting
     * @property {RaycastResult} raycastResult
     */
    this.raycastResult = new RaycastResult();

    /**
     * Wheel world transform
     * @property {Transform} worldTransform
     */
    this.worldTransform = new Transform();

    /**
     * @property {boolean} isInContact
     */
    this.isInContact = false;
}

var chassis_velocity_at_contactPoint = new Vec3();
var relpos = new Vec3();
var chassis_velocity_at_contactPoint = new Vec3();
WheelInfo.prototype.updateWheel = function(chassis){
    var raycastResult = this.raycastResult;

    if (this.isInContact){
        var project= raycastResult.hitNormalWorld.dot(raycastResult.directionWorld);
        raycastResult.hitPointWorld.vsub(chassis.position, relpos);
        chassis.getVelocityAtWorldPoint(relpos, chassis_velocity_at_contactPoint);
        var projVel = raycastResult.hitNormalWorld.dot( chassis_velocity_at_contactPoint );
        if (project >= -0.1) {
            this.suspensionRelativeVelocity = 0.0;
            this.clippedInvContactDotSuspension = 1.0 / 0.1;
        } else {
            var inv = -1 / project;
            this.suspensionRelativeVelocity = projVel * inv;
            this.clippedInvContactDotSuspension = inv;
        }

    } else {
        // Not in contact : position wheel in a nice (rest length) position
        raycastResult.suspensionLength = this.suspensionRestLength;
        this.suspensionRelativeVelocity = 0.0;
        raycastResult.directionWorld.scale(-1, raycastResult.hitNormalWorld);
        this.clippedInvContactDotSuspension = 1.0;
    }
};
},{"../collision/RaycastResult":10,"../math/Transform":29,"../math/Vec3":30,"../utils/Utils":53}],37:[function(_dereq_,module,exports){
module.exports = Box;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

/**
 * A 3d box shape.
 * @class Box
 * @constructor
 * @param {Vec3} halfExtents
 * @author schteppe
 * @extends Shape
 */
function Box(halfExtents){
    Shape.call(this);

    this.type = Shape.types.BOX;

    /**
     * @property halfExtents
     * @type {Vec3}
     */
    this.halfExtents = halfExtents;

    /**
     * Used by the contact generator to make contacts with other convex polyhedra for example
     * @property convexPolyhedronRepresentation
     * @type {ConvexPolyhedron}
     */
    this.convexPolyhedronRepresentation = null;

    this.updateConvexPolyhedronRepresentation();
    this.updateBoundingSphereRadius();
}
Box.prototype = new Shape();
Box.prototype.constructor = Box;

/**
 * Updates the local convex polyhedron representation used for some collisions.
 * @method updateConvexPolyhedronRepresentation
 */
Box.prototype.updateConvexPolyhedronRepresentation = function(){
    var sx = this.halfExtents.x;
    var sy = this.halfExtents.y;
    var sz = this.halfExtents.z;
    var V = Vec3;

    var vertices = [
        new V(-sx,-sy,-sz),
        new V( sx,-sy,-sz),
        new V( sx, sy,-sz),
        new V(-sx, sy,-sz),
        new V(-sx,-sy, sz),
        new V( sx,-sy, sz),
        new V( sx, sy, sz),
        new V(-sx, sy, sz)
    ];

    var indices = [
        [3,2,1,0], // -z
        [4,5,6,7], // +z
        [5,4,0,1], // -y
        [2,3,7,6], // +y
        [0,4,7,3], // -x
        [1,2,6,5], // +x
    ];

    var axes = [
        new V(0, 0, 1),
        new V(0, 1, 0),
        new V(1, 0, 0)
    ];

    var h = new ConvexPolyhedron(vertices, indices);
    this.convexPolyhedronRepresentation = h;
    h.material = this.material;
};

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3}
 */
Box.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    Box.calculateInertia(this.halfExtents, mass, target);
    return target;
};

Box.calculateInertia = function(halfExtents,mass,target){
    var e = halfExtents;
    target.x = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.z*2*e.z );
    target.y = 1.0 / 12.0 * mass * (   2*e.x*2*e.x + 2*e.z*2*e.z );
    target.z = 1.0 / 12.0 * mass * (   2*e.y*2*e.y + 2*e.x*2*e.x );
};

/**
 * Get the box 6 side normals
 * @method getSideNormals
 * @param {array}      sixTargetVectors An array of 6 vectors, to store the resulting side normals in.
 * @param {Quaternion} quat             Orientation to apply to the normal vectors. If not provided, the vectors will be in respect to the local frame.
 * @return {array}
 */
Box.prototype.getSideNormals = function(sixTargetVectors,quat){
    var sides = sixTargetVectors;
    var ex = this.halfExtents;
    sides[0].set(  ex.x,     0,     0);
    sides[1].set(     0,  ex.y,     0);
    sides[2].set(     0,     0,  ex.z);
    sides[3].set( -ex.x,     0,     0);
    sides[4].set(     0, -ex.y,     0);
    sides[5].set(     0,     0, -ex.z);

    if(quat!==undefined){
        for(var i=0; i!==sides.length; i++){
            quat.vmult(sides[i],sides[i]);
        }
    }

    return sides;
};

Box.prototype.volume = function(){
    return 8.0 * this.halfExtents.x * this.halfExtents.y * this.halfExtents.z;
};

Box.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = this.halfExtents.norm();
};

var worldCornerTempPos = new Vec3();
var worldCornerTempNeg = new Vec3();
Box.prototype.forEachWorldCorner = function(pos,quat,callback){

    var e = this.halfExtents;
    var corners = [[  e.x,  e.y,  e.z],
                   [ -e.x,  e.y,  e.z],
                   [ -e.x, -e.y,  e.z],
                   [ -e.x, -e.y, -e.z],
                   [  e.x, -e.y, -e.z],
                   [  e.x,  e.y, -e.z],
                   [ -e.x,  e.y, -e.z],
                   [  e.x, -e.y,  e.z]];
    for(var i=0; i<corners.length; i++){
        worldCornerTempPos.set(corners[i][0],corners[i][1],corners[i][2]);
        quat.vmult(worldCornerTempPos,worldCornerTempPos);
        pos.vadd(worldCornerTempPos,worldCornerTempPos);
        callback(worldCornerTempPos.x,
                 worldCornerTempPos.y,
                 worldCornerTempPos.z);
    }
};

var worldCornersTemp = [
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3(),
    new Vec3()
];
Box.prototype.calculateWorldAABB = function(pos,quat,min,max){

    var e = this.halfExtents;
    worldCornersTemp[0].set(e.x, e.y, e.z);
    worldCornersTemp[1].set(-e.x,  e.y, e.z);
    worldCornersTemp[2].set(-e.x, -e.y, e.z);
    worldCornersTemp[3].set(-e.x, -e.y, -e.z);
    worldCornersTemp[4].set(e.x, -e.y, -e.z);
    worldCornersTemp[5].set(e.x,  e.y, -e.z);
    worldCornersTemp[6].set(-e.x,  e.y, -e.z);
    worldCornersTemp[7].set(e.x, -e.y,  e.z);

    var wc = worldCornersTemp[0];
    quat.vmult(wc, wc);
    pos.vadd(wc, wc);
    max.copy(wc);
    min.copy(wc);
    for(var i=1; i<8; i++){
        var wc = worldCornersTemp[i];
        quat.vmult(wc, wc);
        pos.vadd(wc, wc);
        var x = wc.x;
        var y = wc.y;
        var z = wc.z;
        if(x > max.x){
            max.x = x;
        }
        if(y > max.y){
            max.y = y;
        }
        if(z > max.z){
            max.z = z;
        }

        if(x < min.x){
            min.x = x;
        }
        if(y < min.y){
            min.y = y;
        }
        if(z < min.z){
            min.z = z;
        }
    }

    // Get each axis max
    // min.set(Infinity,Infinity,Infinity);
    // max.set(-Infinity,-Infinity,-Infinity);
    // this.forEachWorldCorner(pos,quat,function(x,y,z){
    //     if(x > max.x){
    //         max.x = x;
    //     }
    //     if(y > max.y){
    //         max.y = y;
    //     }
    //     if(z > max.z){
    //         max.z = z;
    //     }

    //     if(x < min.x){
    //         min.x = x;
    //     }
    //     if(y < min.y){
    //         min.y = y;
    //     }
    //     if(z < min.z){
    //         min.z = z;
    //     }
    // });
};

},{"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],38:[function(_dereq_,module,exports){
module.exports = ConvexPolyhedron;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Transform = _dereq_('../math/Transform');

/**
 * A set of polygons describing a convex shape.
 * @class ConvexPolyhedron
 * @constructor
 * @extends Shape
 * @description The shape MUST be convex for the code to work properly. No polygons may be coplanar (contained
 * in the same 3D plane), instead these should be merged into one polygon.
 *
 * @param {array} points An array of Vec3's
 * @param {array} faces Array of integer arrays, describing which vertices that is included in each face.
 *
 * @author qiao / https://github.com/qiao (original author, see https://github.com/qiao/three.js/commit/85026f0c769e4000148a67d45a9e9b9c5108836f)
 * @author schteppe / https://github.com/schteppe
 * @see http://www.altdevblogaday.com/2011/05/13/contact-generation-between-3d-convex-meshes/
 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
 *
 * @todo Move the clipping functions to ContactGenerator?
 * @todo Automatically merge coplanar polygons in constructor.
 */
function ConvexPolyhedron(points, faces, uniqueAxes) {
    var that = this;
    Shape.call(this);
    this.type = Shape.types.CONVEXPOLYHEDRON;

    /**
     * Array of Vec3
     * @property vertices
     * @type {Array}
     */
    this.vertices = points||[];

    this.worldVertices = []; // World transformed version of .vertices
    this.worldVerticesNeedsUpdate = true;

    /**
     * Array of integer arrays, indicating which vertices each face consists of
     * @property faces
     * @type {Array}
     */
    this.faces = faces||[];

    /**
     * Array of Vec3
     * @property faceNormals
     * @type {Array}
     */
    this.faceNormals = [];
    this.computeNormals();

    this.worldFaceNormalsNeedsUpdate = true;
    this.worldFaceNormals = []; // World transformed version of .faceNormals

    /**
     * Array of Vec3
     * @property uniqueEdges
     * @type {Array}
     */
    this.uniqueEdges = [];

    /**
     * If given, these locally defined, normalized axes are the only ones being checked when doing separating axis check.
     * @property {Array} uniqueAxes
     */
    this.uniqueAxes = uniqueAxes ? uniqueAxes.slice() : null;

    this.computeEdges();
    this.updateBoundingSphereRadius();
}
ConvexPolyhedron.prototype = new Shape();
ConvexPolyhedron.prototype.constructor = ConvexPolyhedron;

var computeEdges_tmpEdge = new Vec3();
/**
 * Computes uniqueEdges
 * @method computeEdges
 */
ConvexPolyhedron.prototype.computeEdges = function(){
    var faces = this.faces;
    var vertices = this.vertices;
    var nv = vertices.length;
    var edges = this.uniqueEdges;

    edges.length = 0;

    var edge = computeEdges_tmpEdge;

    for(var i=0; i !== faces.length; i++){
        var face = faces[i];
        var numVertices = face.length;
        for(var j = 0; j !== numVertices; j++){
            var k = ( j+1 ) % numVertices;
            vertices[face[j]].vsub(vertices[face[k]], edge);
            edge.normalize();
            var found = false;
            for(var p=0; p !== edges.length; p++){
                if (edges[p].almostEquals(edge) || edges[p].almostEquals(edge)){
                    found = true;
                    break;
                }
            }

            if (!found){
                edges.push(edge.clone());
            }
        }
    }
};

/**
 * Compute the normals of the faces. Will reuse existing Vec3 objects in the .faceNormals array if they exist.
 * @method computeNormals
 */
ConvexPolyhedron.prototype.computeNormals = function(){
    this.faceNormals.length = this.faces.length;

    // Generate normals
    for(var i=0; i<this.faces.length; i++){

        // Check so all vertices exists for this face
        for(var j=0; j<this.faces[i].length; j++){
            if(!this.vertices[this.faces[i][j]]){
                throw new Error("Vertex "+this.faces[i][j]+" not found!");
            }
        }

        var n = this.faceNormals[i] || new Vec3();
        this.getFaceNormal(i,n);
        n.negate(n);
        this.faceNormals[i] = n;
        var vertex = this.vertices[this.faces[i][0]];
        if(n.dot(vertex) < 0){
            console.error(".faceNormals[" + i + "] = Vec3("+n.toString()+") looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.");
            for(var j=0; j<this.faces[i].length; j++){
                console.warn(".vertices["+this.faces[i][j]+"] = Vec3("+this.vertices[this.faces[i][j]].toString()+")");
            }
        }
    }
};

/**
 * Get face normal given 3 vertices
 * @static
 * @method getFaceNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */
var cb = new Vec3();
var ab = new Vec3();
ConvexPolyhedron.computeNormal = function ( va, vb, vc, target ) {
    vb.vsub(va,ab);
    vc.vsub(vb,cb);
    cb.cross(ab,target);
    if ( !target.isZero() ) {
        target.normalize();
    }
};

/**
 * Compute the normal of a face from its vertices
 * @method getFaceNormal
 * @param  {Number} i
 * @param  {Vec3} target
 */
ConvexPolyhedron.prototype.getFaceNormal = function(i,target){
    var f = this.faces[i];
    var va = this.vertices[f[0]];
    var vb = this.vertices[f[1]];
    var vc = this.vertices[f[2]];
    return ConvexPolyhedron.computeNormal(va,vb,vc,target);
};

/**
 * @method clipAgainstHull
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @param {Vec3} separatingNormal
 * @param {Number} minDist Clamp distance
 * @param {Number} maxDist
 * @param {array} result The an array of contact point objects, see clipFaceAgainstHull
 * @see http://bullet.googlecode.com/svn/trunk/src/BulletCollision/NarrowPhaseCollision/btPolyhedralContactClipping.cpp
 */
var cah_WorldNormal = new Vec3();
ConvexPolyhedron.prototype.clipAgainstHull = function(posA,quatA,hullB,posB,quatB,separatingNormal,minDist,maxDist,result){
    var WorldNormal = cah_WorldNormal;
    var hullA = this;
    var curMaxDist = maxDist;
    var closestFaceB = -1;
    var dmax = -Number.MAX_VALUE;
    for(var face=0; face < hullB.faces.length; face++){
        WorldNormal.copy(hullB.faceNormals[face]);
        quatB.vmult(WorldNormal,WorldNormal);
        //posB.vadd(WorldNormal,WorldNormal);
        var d = WorldNormal.dot(separatingNormal);
        if (d > dmax){
            dmax = d;
            closestFaceB = face;
        }
    }
    var worldVertsB1 = [];
    var polyB = hullB.faces[closestFaceB];
    var numVertices = polyB.length;
    for(var e0=0; e0<numVertices; e0++){
        var b = hullB.vertices[polyB[e0]];
        var worldb = new Vec3();
        worldb.copy(b);
        quatB.vmult(worldb,worldb);
        posB.vadd(worldb,worldb);
        worldVertsB1.push(worldb);
    }

    if (closestFaceB>=0){
        this.clipFaceAgainstHull(separatingNormal,
                                 posA,
                                 quatA,
                                 worldVertsB1,
                                 minDist,
                                 maxDist,
                                 result);
    }
};

/**
 * Find the separating axis between this hull and another
 * @method findSeparatingAxis
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @param {Vec3} target The target vector to save the axis in
 * @return {bool} Returns false if a separation is found, else true
 */
var fsa_faceANormalWS3 = new Vec3(),
    fsa_Worldnormal1 = new Vec3(),
    fsa_deltaC = new Vec3(),
    fsa_worldEdge0 = new Vec3(),
    fsa_worldEdge1 = new Vec3(),
    fsa_Cross = new Vec3();
ConvexPolyhedron.prototype.findSeparatingAxis = function(hullB,posA,quatA,posB,quatB,target, faceListA, faceListB){
    var faceANormalWS3 = fsa_faceANormalWS3,
        Worldnormal1 = fsa_Worldnormal1,
        deltaC = fsa_deltaC,
        worldEdge0 = fsa_worldEdge0,
        worldEdge1 = fsa_worldEdge1,
        Cross = fsa_Cross;

    var dmin = Number.MAX_VALUE;
    var hullA = this;
    var curPlaneTests=0;

    if(!hullA.uniqueAxes){

        var numFacesA = faceListA ? faceListA.length : hullA.faces.length;

        // Test face normals from hullA
        for(var i=0; i<numFacesA; i++){
            var fi = faceListA ? faceListA[i] : i;

            // Get world face normal
            faceANormalWS3.copy(hullA.faceNormals[fi]);
            quatA.vmult(faceANormalWS3,faceANormalWS3);

            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(faceANormalWS3);
            }
        }

    } else {

        // Test unique axes
        for(var i = 0; i !== hullA.uniqueAxes.length; i++){

            // Get world axis
            quatA.vmult(hullA.uniqueAxes[i],faceANormalWS3);

            var d = hullA.testSepAxis(faceANormalWS3, hullB, posA, quatA, posB, quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(faceANormalWS3);
            }
        }
    }

    if(!hullB.uniqueAxes){

        // Test face normals from hullB
        var numFacesB = faceListB ? faceListB.length : hullB.faces.length;
        for(var i=0;i<numFacesB;i++){

            var fi = faceListB ? faceListB[i] : i;

            Worldnormal1.copy(hullB.faceNormals[fi]);
            quatB.vmult(Worldnormal1,Worldnormal1);
            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(Worldnormal1);
            }
        }
    } else {

        // Test unique axes in B
        for(var i = 0; i !== hullB.uniqueAxes.length; i++){
            quatB.vmult(hullB.uniqueAxes[i],Worldnormal1);

            curPlaneTests++;
            var d = hullA.testSepAxis(Worldnormal1, hullB,posA,quatA,posB,quatB);
            if(d===false){
                return false;
            }

            if(d<dmin){
                dmin = d;
                target.copy(Worldnormal1);
            }
        }
    }

    // Test edges
    for(var e0=0; e0 !== hullA.uniqueEdges.length; e0++){

        // Get world edge
        quatA.vmult(hullA.uniqueEdges[e0],worldEdge0);

        for(var e1=0; e1 !== hullB.uniqueEdges.length; e1++){

            // Get world edge 2
            quatB.vmult(hullB.uniqueEdges[e1], worldEdge1);
            worldEdge0.cross(worldEdge1,Cross);

            if(!Cross.almostZero()){
                Cross.normalize();
                var dist = hullA.testSepAxis(Cross, hullB, posA, quatA, posB, quatB);
                if(dist === false){
                    return false;
                }
                if(dist < dmin){
                    dmin = dist;
                    target.copy(Cross);
                }
            }
        }
    }

    posB.vsub(posA,deltaC);
    if((deltaC.dot(target))>0.0){
        target.negate(target);
    }

    return true;
};

var maxminA=[], maxminB=[];

/**
 * Test separating axis against two hulls. Both hulls are projected onto the axis and the overlap size is returned if there is one.
 * @method testSepAxis
 * @param {Vec3} axis
 * @param {ConvexPolyhedron} hullB
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Vec3} posB
 * @param {Quaternion} quatB
 * @return {number} The overlap depth, or FALSE if no penetration.
 */
ConvexPolyhedron.prototype.testSepAxis = function(axis, hullB, posA, quatA, posB, quatB){
    var hullA=this;
    ConvexPolyhedron.project(hullA, axis, posA, quatA, maxminA);
    ConvexPolyhedron.project(hullB, axis, posB, quatB, maxminB);
    var maxA = maxminA[0];
    var minA = maxminA[1];
    var maxB = maxminB[0];
    var minB = maxminB[1];
    if(maxA<minB || maxB<minA){
        return false; // Separated
    }
    var d0 = maxA - minB;
    var d1 = maxB - minA;
    var depth = d0<d1 ? d0:d1;
    return depth;
};

var cli_aabbmin = new Vec3(),
    cli_aabbmax = new Vec3();

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 */
ConvexPolyhedron.prototype.calculateLocalInertia = function(mass,target){
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabbmin,cli_aabbmax);
    var x = cli_aabbmax.x - cli_aabbmin.x,
        y = cli_aabbmax.y - cli_aabbmin.y,
        z = cli_aabbmax.z - cli_aabbmin.z;
    target.x = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z );
    target.y = 1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z );
    target.z = 1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x );
};

/**
 * @method getPlaneConstantOfFace
 * @param  {Number} face_i Index of the face
 * @return {Number}
 */
ConvexPolyhedron.prototype.getPlaneConstantOfFace = function(face_i){
    var f = this.faces[face_i];
    var n = this.faceNormals[face_i];
    var v = this.vertices[f[0]];
    var c = -n.dot(v);
    return c;
};

/**
 * Clip a face against a hull.
 * @method clipFaceAgainstHull
 * @param {Vec3} separatingNormal
 * @param {Vec3} posA
 * @param {Quaternion} quatA
 * @param {Array} worldVertsB1 An array of Vec3 with vertices in the world frame.
 * @param {Number} minDist Distance clamping
 * @param {Number} maxDist
 * @param Array result Array to store resulting contact points in. Will be objects with properties: point, depth, normal. These are represented in world coordinates.
 */
var cfah_faceANormalWS = new Vec3(),
    cfah_edge0 = new Vec3(),
    cfah_WorldEdge0 = new Vec3(),
    cfah_worldPlaneAnormal1 = new Vec3(),
    cfah_planeNormalWS1 = new Vec3(),
    cfah_worldA1 = new Vec3(),
    cfah_localPlaneNormal = new Vec3(),
    cfah_planeNormalWS = new Vec3();
ConvexPolyhedron.prototype.clipFaceAgainstHull = function(separatingNormal, posA, quatA, worldVertsB1, minDist, maxDist,result){
    var faceANormalWS = cfah_faceANormalWS,
        edge0 = cfah_edge0,
        WorldEdge0 = cfah_WorldEdge0,
        worldPlaneAnormal1 = cfah_worldPlaneAnormal1,
        planeNormalWS1 = cfah_planeNormalWS1,
        worldA1 = cfah_worldA1,
        localPlaneNormal = cfah_localPlaneNormal,
        planeNormalWS = cfah_planeNormalWS;

    var hullA = this;
    var worldVertsB2 = [];
    var pVtxIn = worldVertsB1;
    var pVtxOut = worldVertsB2;
    // Find the face with normal closest to the separating axis
    var closestFaceA = -1;
    var dmin = Number.MAX_VALUE;
    for(var face=0; face<hullA.faces.length; face++){
        faceANormalWS.copy(hullA.faceNormals[face]);
        quatA.vmult(faceANormalWS,faceANormalWS);
        //posA.vadd(faceANormalWS,faceANormalWS);
        var d = faceANormalWS.dot(separatingNormal);
        if (d < dmin){
            dmin = d;
            closestFaceA = face;
        }
    }
    if (closestFaceA < 0){
        // console.log("--- did not find any closest face... ---");
        return;
    }
    //console.log("closest A: ",closestFaceA);
    // Get the face and construct connected faces
    var polyA = hullA.faces[closestFaceA];
    polyA.connectedFaces = [];
    for(var i=0; i<hullA.faces.length; i++){
        for(var j=0; j<hullA.faces[i].length; j++){
            if(polyA.indexOf(hullA.faces[i][j])!==-1 /* Sharing a vertex*/ && i!==closestFaceA /* Not the one we are looking for connections from */ && polyA.connectedFaces.indexOf(i)===-1 /* Not already added */ ){
                polyA.connectedFaces.push(i);
            }
        }
    }
    // Clip the polygon to the back of the planes of all faces of hull A, that are adjacent to the witness face
    var numContacts = pVtxIn.length;
    var numVerticesA = polyA.length;
    var res = [];
    for(var e0=0; e0<numVerticesA; e0++){
        var a = hullA.vertices[polyA[e0]];
        var b = hullA.vertices[polyA[(e0+1)%numVerticesA]];
        a.vsub(b,edge0);
        WorldEdge0.copy(edge0);
        quatA.vmult(WorldEdge0,WorldEdge0);
        posA.vadd(WorldEdge0,WorldEdge0);
        worldPlaneAnormal1.copy(this.faceNormals[closestFaceA]);//transA.getBasis()* btVector3(polyA.m_plane[0],polyA.m_plane[1],polyA.m_plane[2]);
        quatA.vmult(worldPlaneAnormal1,worldPlaneAnormal1);
        posA.vadd(worldPlaneAnormal1,worldPlaneAnormal1);
        WorldEdge0.cross(worldPlaneAnormal1,planeNormalWS1);
        planeNormalWS1.negate(planeNormalWS1);
        worldA1.copy(a);
        quatA.vmult(worldA1,worldA1);
        posA.vadd(worldA1,worldA1);
        var planeEqWS1 = -worldA1.dot(planeNormalWS1);
        var planeEqWS;
        if(true){
            var otherFace = polyA.connectedFaces[e0];
            localPlaneNormal.copy(this.faceNormals[otherFace]);
            var localPlaneEq = this.getPlaneConstantOfFace(otherFace);

            planeNormalWS.copy(localPlaneNormal);
            quatA.vmult(planeNormalWS,planeNormalWS);
            //posA.vadd(planeNormalWS,planeNormalWS);
            var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
        } else  {
            planeNormalWS.copy(planeNormalWS1);
            planeEqWS = planeEqWS1;
        }

        // Clip face against our constructed plane
        this.clipFaceAgainstPlane(pVtxIn, pVtxOut, planeNormalWS, planeEqWS);

        // Throw away all clipped points, but save the reamining until next clip
        while(pVtxIn.length){
            pVtxIn.shift();
        }
        while(pVtxOut.length){
            pVtxIn.push(pVtxOut.shift());
        }
    }

    //console.log("Resulting points after clip:",pVtxIn);

    // only keep contact points that are behind the witness face
    localPlaneNormal.copy(this.faceNormals[closestFaceA]);

    var localPlaneEq = this.getPlaneConstantOfFace(closestFaceA);
    planeNormalWS.copy(localPlaneNormal);
    quatA.vmult(planeNormalWS,planeNormalWS);

    var planeEqWS = localPlaneEq - planeNormalWS.dot(posA);
    for (var i=0; i<pVtxIn.length; i++){
        var depth = planeNormalWS.dot(pVtxIn[i]) + planeEqWS; //???
        /*console.log("depth calc from normal=",planeNormalWS.toString()," and constant "+planeEqWS+" and vertex ",pVtxIn[i].toString()," gives "+depth);*/
        if (depth <=minDist){
            console.log("clamped: depth="+depth+" to minDist="+(minDist+""));
            depth = minDist;
        }

        if (depth <=maxDist){
            var point = pVtxIn[i];
            if(depth<=0){
                /*console.log("Got contact point ",point.toString(),
                  ", depth=",depth,
                  "contact normal=",separatingNormal.toString(),
                  "plane",planeNormalWS.toString(),
                  "planeConstant",planeEqWS);*/
                var p = {
                    point:point,
                    normal:planeNormalWS,
                    depth: depth,
                };
                result.push(p);
            }
        }
    }
};

/**
 * Clip a face in a hull against the back of a plane.
 * @method clipFaceAgainstPlane
 * @param {Array} inVertices
 * @param {Array} outVertices
 * @param {Vec3} planeNormal
 * @param {Number} planeConstant The constant in the mathematical plane equation
 */
ConvexPolyhedron.prototype.clipFaceAgainstPlane = function(inVertices,outVertices, planeNormal, planeConstant){
    var n_dot_first, n_dot_last;
    var numVerts = inVertices.length;

    if(numVerts < 2){
        return outVertices;
    }

    var firstVertex = inVertices[inVertices.length-1],
        lastVertex =   inVertices[0];

    n_dot_first = planeNormal.dot(firstVertex) + planeConstant;

    for(var vi = 0; vi < numVerts; vi++){
        lastVertex = inVertices[vi];
        n_dot_last = planeNormal.dot(lastVertex) + planeConstant;
        if(n_dot_first < 0){
            if(n_dot_last < 0){
                // Start < 0, end < 0, so output lastVertex
                var newv = new Vec3();
                newv.copy(lastVertex);
                outVertices.push(newv);
            } else {
                // Start < 0, end >= 0, so output intersection
                var newv = new Vec3();
                firstVertex.lerp(lastVertex,
                                 n_dot_first / (n_dot_first - n_dot_last),
                                 newv);
                outVertices.push(newv);
            }
        } else {
            if(n_dot_last<0){
                // Start >= 0, end < 0 so output intersection and end
                var newv = new Vec3();
                firstVertex.lerp(lastVertex,
                                 n_dot_first / (n_dot_first - n_dot_last),
                                 newv);
                outVertices.push(newv);
                outVertices.push(lastVertex);
            }
        }
        firstVertex = lastVertex;
        n_dot_first = n_dot_last;
    }
    return outVertices;
};

// Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
ConvexPolyhedron.prototype.computeWorldVertices = function(position,quat){
    var N = this.vertices.length;
    while(this.worldVertices.length < N){
        this.worldVertices.push( new Vec3() );
    }

    var verts = this.vertices,
        worldVerts = this.worldVertices;
    for(var i=0; i!==N; i++){
        quat.vmult( verts[i] , worldVerts[i] );
        position.vadd( worldVerts[i] , worldVerts[i] );
    }

    this.worldVerticesNeedsUpdate = false;
};

var computeLocalAABB_worldVert = new Vec3();
ConvexPolyhedron.prototype.computeLocalAABB = function(aabbmin,aabbmax){
    var n = this.vertices.length,
        vertices = this.vertices,
        worldVert = computeLocalAABB_worldVert;

    aabbmin.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
    aabbmax.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);

    for(var i=0; i<n; i++){
        var v = vertices[i];
        if     (v.x < aabbmin.x){
            aabbmin.x = v.x;
        } else if(v.x > aabbmax.x){
            aabbmax.x = v.x;
        }
        if     (v.y < aabbmin.y){
            aabbmin.y = v.y;
        } else if(v.y > aabbmax.y){
            aabbmax.y = v.y;
        }
        if     (v.z < aabbmin.z){
            aabbmin.z = v.z;
        } else if(v.z > aabbmax.z){
            aabbmax.z = v.z;
        }
    }
};

/**
 * Updates .worldVertices and sets .worldVerticesNeedsUpdate to false.
 * @method computeWorldFaceNormals
 * @param  {Quaternion} quat
 */
ConvexPolyhedron.prototype.computeWorldFaceNormals = function(quat){
    var N = this.faceNormals.length;
    while(this.worldFaceNormals.length < N){
        this.worldFaceNormals.push( new Vec3() );
    }

    var normals = this.faceNormals,
        worldNormals = this.worldFaceNormals;
    for(var i=0; i!==N; i++){
        quat.vmult( normals[i] , worldNormals[i] );
    }

    this.worldFaceNormalsNeedsUpdate = false;
};

/**
 * @method updateBoundingSphereRadius
 */
ConvexPolyhedron.prototype.updateBoundingSphereRadius = function(){
    // Assume points are distributed with local (0,0,0) as center
    var max2 = 0;
    var verts = this.vertices;
    for(var i=0, N=verts.length; i!==N; i++) {
        var norm2 = verts[i].norm2();
        if(norm2 > max2){
            max2 = norm2;
        }
    }
    this.boundingSphereRadius = Math.sqrt(max2);
};

var tempWorldVertex = new Vec3();

/**
 * @method calculateWorldAABB
 * @param {Vec3}        pos
 * @param {Quaternion}  quat
 * @param {Vec3}        min
 * @param {Vec3}        max
 */
ConvexPolyhedron.prototype.calculateWorldAABB = function(pos,quat,min,max){
    var n = this.vertices.length, verts = this.vertices;
    var minx,miny,minz,maxx,maxy,maxz;
    for(var i=0; i<n; i++){
        tempWorldVertex.copy(verts[i]);
        quat.vmult(tempWorldVertex,tempWorldVertex);
        pos.vadd(tempWorldVertex,tempWorldVertex);
        var v = tempWorldVertex;
        if     (v.x < minx || minx===undefined){
            minx = v.x;
        } else if(v.x > maxx || maxx===undefined){
            maxx = v.x;
        }

        if     (v.y < miny || miny===undefined){
            miny = v.y;
        } else if(v.y > maxy || maxy===undefined){
            maxy = v.y;
        }

        if     (v.z < minz || minz===undefined){
            minz = v.z;
        } else if(v.z > maxz || maxz===undefined){
            maxz = v.z;
        }
    }
    min.set(minx,miny,minz);
    max.set(maxx,maxy,maxz);
};

/**
 * Get approximate convex volume
 * @method volume
 * @return {Number}
 */
ConvexPolyhedron.prototype.volume = function(){
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
};

/**
 * Get an average of all the vertices positions
 * @method getAveragePointLocal
 * @param  {Vec3} target
 * @return {Vec3}
 */
ConvexPolyhedron.prototype.getAveragePointLocal = function(target){
    target = target || new Vec3();
    var n = this.vertices.length,
        verts = this.vertices;
    for(var i=0; i<n; i++){
        target.vadd(verts[i],target);
    }
    target.mult(1/n,target);
    return target;
};

/**
 * Transform all local points. Will change the .vertices
 * @method transformAllPoints
 * @param  {Vec3} offset
 * @param  {Quaternion} quat
 */
ConvexPolyhedron.prototype.transformAllPoints = function(offset,quat){
    var n = this.vertices.length,
        verts = this.vertices;

    // Apply rotation
    if(quat){
        // Rotate vertices
        for(var i=0; i<n; i++){
            var v = verts[i];
            quat.vmult(v,v);
        }
        // Rotate face normals
        for(var i=0; i<this.faceNormals.length; i++){
            var v = this.faceNormals[i];
            quat.vmult(v,v);
        }
        /*
        // Rotate edges
        for(var i=0; i<this.uniqueEdges.length; i++){
            var v = this.uniqueEdges[i];
            quat.vmult(v,v);
        }*/
    }

    // Apply offset
    if(offset){
        for(var i=0; i<n; i++){
            var v = verts[i];
            v.vadd(offset,v);
        }
    }
};

/**
 * Checks whether p is inside the polyhedra. Must be in local coords. The point lies outside of the convex hull of the other points if and only if the direction of all the vectors from it to those other points are on less than one half of a sphere around it.
 * @method pointIsInside
 * @param  {Vec3} p      A point given in local coordinates
 * @return {Boolean}
 */
var ConvexPolyhedron_pointIsInside = new Vec3();
var ConvexPolyhedron_vToP = new Vec3();
var ConvexPolyhedron_vToPointInside = new Vec3();
ConvexPolyhedron.prototype.pointIsInside = function(p){
    var n = this.vertices.length,
        verts = this.vertices,
        faces = this.faces,
        normals = this.faceNormals;
    var positiveResult = null;
    var N = this.faces.length;
    var pointInside = ConvexPolyhedron_pointIsInside;
    this.getAveragePointLocal(pointInside);
    for(var i=0; i<N; i++){
        var numVertices = this.faces[i].length;
        var n = normals[i];
        var v = verts[faces[i][0]]; // We only need one point in the face

        // This dot product determines which side of the edge the point is
        var vToP = ConvexPolyhedron_vToP;
        p.vsub(v,vToP);
        var r1 = n.dot(vToP);

        var vToPointInside = ConvexPolyhedron_vToPointInside;
        pointInside.vsub(v,vToPointInside);
        var r2 = n.dot(vToPointInside);

        if((r1<0 && r2>0) || (r1>0 && r2<0)){
            return false; // Encountered some other sign. Exit.
        } else {
        }
    }

    // If we got here, all dot products were of the same sign.
    return positiveResult ? 1 : -1;
};

/**
 * Get max and min dot product of a convex hull at position (pos,quat) projected onto an axis. Results are saved in the array maxmin.
 * @static
 * @method project
 * @param {ConvexPolyhedron} hull
 * @param {Vec3} axis
 * @param {Vec3} pos
 * @param {Quaternion} quat
 * @param {array} result result[0] and result[1] will be set to maximum and minimum, respectively.
 */
var project_worldVertex = new Vec3();
var project_localAxis = new Vec3();
var project_localOrigin = new Vec3();
ConvexPolyhedron.project = function(hull, axis, pos, quat, result){
    var n = hull.vertices.length,
        worldVertex = project_worldVertex,
        localAxis = project_localAxis,
        max = 0,
        min = 0,
        localOrigin = project_localOrigin,
        vs = hull.vertices;

    localOrigin.setZero();

    // Transform the axis to local
    Transform.vectorToLocalFrame(pos, quat, axis, localAxis);
    Transform.pointToLocalFrame(pos, quat, localOrigin, localOrigin);
    var add = localOrigin.dot(localAxis);

    min = max = vs[0].dot(localAxis);

    for(var i = 1; i < n; i++){
        var val = vs[i].dot(localAxis);

        if(val > max){
            max = val;
        }

        if(val < min){
            min = val;
        }
    }

    min -= add;
    max -= add;

    if(min > max){
        // Inconsistent - swap
        var temp = min;
        min = max;
        max = temp;
    }
    // Output
    result[0] = max;
    result[1] = min;
};

},{"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"./Shape":43}],39:[function(_dereq_,module,exports){
module.exports = Cylinder;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');

/**
 * @class Cylinder
 * @constructor
 * @extends ConvexPolyhedron
 * @author schteppe / https://github.com/schteppe
 * @param {Number} radiusTop
 * @param {Number} radiusBottom
 * @param {Number} height
 * @param {Number} numSegments The number of segments to build the cylinder out of
 */
function Cylinder( radiusTop, radiusBottom, height , numSegments ) {
    var N = numSegments,
        verts = [],
        axes = [],
        faces = [],
        bottomface = [],
        topface = [],
        cos = Math.cos,
        sin = Math.sin;

    // First bottom point
    verts.push(new Vec3(radiusBottom*cos(0),
                               radiusBottom*sin(0),
                               -height*0.5));
    bottomface.push(0);

    // First top point
    verts.push(new Vec3(radiusTop*cos(0),
                               radiusTop*sin(0),
                               height*0.5));
    topface.push(1);

    for(var i=0; i<N; i++){
        var theta = 2*Math.PI/N * (i+1);
        var thetaN = 2*Math.PI/N * (i+0.5);
        if(i<N-1){
            // Bottom
            verts.push(new Vec3(radiusBottom*cos(theta),
                                       radiusBottom*sin(theta),
                                       -height*0.5));
            bottomface.push(2*i+2);
            // Top
            verts.push(new Vec3(radiusTop*cos(theta),
                                       radiusTop*sin(theta),
                                       height*0.5));
            topface.push(2*i+3);

            // Face
            faces.push([2*i+2, 2*i+3, 2*i+1,2*i]);
        } else {
            faces.push([0,1, 2*i+1, 2*i]); // Connect
        }

        // Axis: we can cut off half of them if we have even number of segments
        if(N % 2 === 1 || i < N / 2){
            axes.push(new Vec3(cos(thetaN), sin(thetaN), 0));
        }
    }
    faces.push(topface);
    axes.push(new Vec3(0,0,1));

    // Reorder bottom face
    var temp = [];
    for(var i=0; i<bottomface.length; i++){
        temp.push(bottomface[bottomface.length - i - 1]);
    }
    faces.push(temp);

    this.type = Shape.types.CONVEXPOLYHEDRON;
    ConvexPolyhedron.call( this, verts, faces, axes );
}

Cylinder.prototype = new ConvexPolyhedron();

},{"../math/Quaternion":28,"../math/Vec3":30,"./ConvexPolyhedron":38,"./Shape":43}],40:[function(_dereq_,module,exports){
var Shape = _dereq_('./Shape');
var ConvexPolyhedron = _dereq_('./ConvexPolyhedron');
var Vec3 = _dereq_('../math/Vec3');
var Utils = _dereq_('../utils/Utils');

module.exports = Heightfield;

/**
 * Heightfield shape class. Height data is given as an array. These data points are spread out evenly with a given distance.
 * @class Heightfield
 * @extends Shape
 * @constructor
 * @param {Array} data An array of Y values that will be used to construct the terrain.
 * @param {object} options
 * @param {Number} [options.minValue] Minimum value of the data points in the data array. Will be computed automatically if not given.
 * @param {Number} [options.maxValue] Maximum value.
 * @param {Number} [options.elementSize=0.1] World spacing between the data points in X direction.
 * @todo Should be possible to use along all axes, not just y
 *
 * @example
 *     // Generate some height data (y-values).
 *     var data = [];
 *     for(var i = 0; i < 1000; i++){
 *         var y = 0.5 * Math.cos(0.2 * i);
 *         data.push(y);
 *     }
 *
 *     // Create the heightfield shape
 *     var heightfieldShape = new Heightfield(data, {
 *         elementSize: 1 // Distance between the data points in X and Y directions
 *     });
 *     var heightfieldBody = new Body();
 *     heightfieldBody.addShape(heightfieldShape);
 *     world.addBody(heightfieldBody);
 */
function Heightfield(data, options){
    options = Utils.defaults(options, {
        maxValue : null,
        minValue : null,
        elementSize : 1
    });

    /**
     * An array of numbers, or height values, that are spread out along the x axis.
     * @property {array} data
     */
    this.data = data;

    /**
     * Max value of the data
     * @property {number} maxValue
     */
    this.maxValue = options.maxValue;

    /**
     * Max value of the data
     * @property {number} minValue
     */
    this.minValue = options.minValue;

    /**
     * The width of each element
     * @property {number} elementSize
     * @todo elementSizeX and Y
     */
    this.elementSize = options.elementSize;

    if(options.minValue === null){
        this.updateMinValue();
    }
    if(options.maxValue === null){
        this.updateMaxValue();
    }

    this.cacheEnabled = true;

    Shape.call(this);

    this.pillarConvex = new ConvexPolyhedron();
    this.pillarOffset = new Vec3();

    this.type = Shape.types.HEIGHTFIELD;
    this.updateBoundingSphereRadius();

    // "i_j_isUpper" => { convex: ..., offset: ... }
    // for example:
    // _cachedPillars["0_2_1"]
    this._cachedPillars = {};
}
Heightfield.prototype = new Shape();

/**
 * Call whenever you change the data array.
 * @method update
 */
Heightfield.prototype.update = function(){
    this._cachedPillars = {};
};

/**
 * Update the .minValue property
 * @method updateMinValue
 */
Heightfield.prototype.updateMinValue = function(){
    var data = this.data;
    var minValue = data[0][0];
    for(var i=0; i !== data.length; i++){
        for(var j=0; j !== data[i].length; j++){
            var v = data[i][j];
            if(v < minValue){
                minValue = v;
            }
        }
    }
    this.minValue = minValue;
};

/**
 * Update the .maxValue property
 * @method updateMaxValue
 */
Heightfield.prototype.updateMaxValue = function(){
    var data = this.data;
    var maxValue = data[0][0];
    for(var i=0; i !== data.length; i++){
        for(var j=0; j !== data[i].length; j++){
            var v = data[i][j];
            if(v > maxValue){
                maxValue = v;
            }
        }
    }
    this.maxValue = maxValue;
};

/**
 * Set the height value at an index. Don't forget to update maxValue and minValue after you're done.
 * @method setHeightValueAtIndex
 * @param {integer} xi
 * @param {integer} yi
 * @param {number} value
 */
Heightfield.prototype.setHeightValueAtIndex = function(xi, yi, value){
    var data = this.data;
    data[xi][yi] = value;

    // Invalidate cache
    this.clearCachedConvexTrianglePillar(xi, yi, false);
    if(xi > 0){
        this.clearCachedConvexTrianglePillar(xi - 1, yi, true);
        this.clearCachedConvexTrianglePillar(xi - 1, yi, false);
    }
    if(yi > 0){
        this.clearCachedConvexTrianglePillar(xi, yi - 1, true);
        this.clearCachedConvexTrianglePillar(xi, yi - 1, false);
    }
    if(yi > 0 && xi > 0){
        this.clearCachedConvexTrianglePillar(xi - 1, yi - 1, true);
    }
};

/**
 * Get max/min in a rectangle in the matrix data
 * @method getRectMinMax
 * @param  {integer} iMinX
 * @param  {integer} iMinY
 * @param  {integer} iMaxX
 * @param  {integer} iMaxY
 * @param  {array} [result] An array to store the results in.
 * @return {array} The result array, if it was passed in. Minimum will be at position 0 and max at 1.
 */
Heightfield.prototype.getRectMinMax = function (iMinX, iMinY, iMaxX, iMaxY, result) {
    result = result || [];

    // Get max and min of the data
    var data = this.data,
        max = this.minValue; // Set first value
    for(var i = iMinX; i <= iMaxX; i++){
        for(var j = iMinY; j <= iMaxY; j++){
            var height = data[i][j];
            if(height > max){
                max = height;
            }
        }
    }

    result[0] = this.minValue;
    result[1] = max;
};

/**
 * Get the index of a local position on the heightfield. The indexes indicate the rectangles, so if your terrain is made of N x N height data points, you will have rectangle indexes ranging from 0 to N-1.
 * @method getIndexOfPosition
 * @param  {number} x
 * @param  {number} y
 * @param  {array} result Two-element array
 * @param  {boolean} clamp If the position should be clamped to the heightfield edge.
 * @return {boolean}
 */
Heightfield.prototype.getIndexOfPosition = function (x, y, result, clamp) {

    // Get the index of the data points to test against
    var w = this.elementSize;
    var data = this.data;
    var xi = Math.floor(x / w);
    var yi = Math.floor(y / w);

    result[0] = xi;
    result[1] = yi;

    if(clamp){
        // Clamp index to edges
        if(xi < 0){ xi = 0; }
        if(yi < 0){ yi = 0; }
        if(xi >= data.length - 1){ xi = data.length - 1; }
        if(yi >= data[0].length - 1){ yi = data[0].length - 1; }
    }

    // Bail out if we are out of the terrain
    if(xi < 0 || yi < 0 || xi >= data.length-1 || yi >= data[0].length-1){
        return false;
    }

    return true;
};

Heightfield.prototype.getHeightAt = function(x, y, edgeClamp){
    var idx = [];
    this.getIndexOfPosition(x, y, idx, edgeClamp);

    // TODO: get upper or lower triangle, then use barycentric interpolation to get the height in the triangle.
    var minmax = [];
    this.getRectMinMax(idx[0], idx[1] + 1, idx[0], idx[1] + 1, minmax);

    return (minmax[0] + minmax[1]) / 2; // average
};

Heightfield.prototype.getCacheConvexTrianglePillarKey = function(xi, yi, getUpperTriangle){
    return xi + '_' + yi + '_' + (getUpperTriangle ? 1 : 0);
};

Heightfield.prototype.getCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    return this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
};

Heightfield.prototype.setCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle, convex, offset){
    this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)] = {
        convex: convex,
        offset: offset
    };
};

Heightfield.prototype.clearCachedConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(xi, yi, getUpperTriangle)];
};

/**
 * Get a triangle in the terrain in the form of a triangular convex shape.
 * @method getConvexTrianglePillar
 * @param  {integer} i
 * @param  {integer} j
 * @param  {boolean} getUpperTriangle
 */
Heightfield.prototype.getConvexTrianglePillar = function(xi, yi, getUpperTriangle){
    var result = this.pillarConvex;
    var offsetResult = this.pillarOffset;

    if(this.cacheEnabled){
        var data = this.getCachedConvexTrianglePillar(xi, yi, getUpperTriangle);
        if(data){
            this.pillarConvex = data.convex;
            this.pillarOffset = data.offset;
            return;
        }

        result = new ConvexPolyhedron();
        offsetResult = new Vec3();

        this.pillarConvex = result;
        this.pillarOffset = offsetResult;
    }

    var data = this.data;
    var elementSize = this.elementSize;
    var faces = result.faces;

    // Reuse verts if possible
    result.vertices.length = 6;
    for (var i = 0; i < 6; i++) {
        if(!result.vertices[i]){
            result.vertices[i] = new Vec3();
        }
    }

    // Reuse faces if possible
    faces.length = 5;
    for (var i = 0; i < 5; i++) {
        if(!faces[i]){
            faces[i] = [];
        }
    }

    var verts = result.vertices;

    var h = (Math.min(
        data[xi][yi],
        data[xi+1][yi],
        data[xi][yi+1],
        data[xi+1][yi+1]
    ) - this.minValue ) / 2 + this.minValue;

    if (!getUpperTriangle) {

        // Center of the triangle pillar - all polygons are given relative to this one
        offsetResult.set(
            (xi + 0.25) * elementSize, // sort of center of a triangle
            (yi + 0.25) * elementSize,
            h // vertical center
        );

        // Top triangle verts
        verts[0].set(
            -0.25 * elementSize,
            -0.25 * elementSize,
            data[xi][yi] - h
        );
        verts[1].set(
            0.75 * elementSize,
            -0.25 * elementSize,
            data[xi + 1][yi] - h
        );
        verts[2].set(
            -0.25 * elementSize,
            0.75 * elementSize,
            data[xi][yi + 1] - h
        );

        // bottom triangle verts
        verts[3].set(
            -0.25 * elementSize,
            -0.25 * elementSize,
            -h-1
        );
        verts[4].set(
            0.75 * elementSize,
            -0.25 * elementSize,
            -h-1
        );
        verts[5].set(
            -0.25 * elementSize,
            0.75  * elementSize,
            -h-1
        );

        // top triangle
        faces[0][0] = 0;
        faces[0][1] = 1;
        faces[0][2] = 2;

        // bottom triangle
        faces[1][0] = 5;
        faces[1][1] = 4;
        faces[1][2] = 3;

        // -x facing quad
        faces[2][0] = 0;
        faces[2][1] = 2;
        faces[2][2] = 5;
        faces[2][3] = 3;

        // -y facing quad
        faces[3][0] = 1;
        faces[3][1] = 0;
        faces[3][2] = 3;
        faces[3][3] = 4;

        // +xy facing quad
        faces[4][0] = 4;
        faces[4][1] = 5;
        faces[4][2] = 2;
        faces[4][3] = 1;


    } else {

        // Center of the triangle pillar - all polygons are given relative to this one
        offsetResult.set(
            (xi + 0.75) * elementSize, // sort of center of a triangle
            (yi + 0.75) * elementSize,
            h // vertical center
        );

        // Top triangle verts
        verts[0].set(
            0.25 * elementSize,
            0.25 * elementSize,
            data[xi + 1][yi + 1] - h
        );
        verts[1].set(
            -0.75 * elementSize,
            0.25 * elementSize,
            data[xi][yi + 1] - h
        );
        verts[2].set(
            0.25 * elementSize,
            -0.75 * elementSize,
            data[xi + 1][yi] - h
        );

        // bottom triangle verts
        verts[3].set(
            0.25 * elementSize,
            0.25 * elementSize,
            - h-1
        );
        verts[4].set(
            -0.75 * elementSize,
            0.25 * elementSize,
            - h-1
        );
        verts[5].set(
            0.25 * elementSize,
            -0.75 * elementSize,
            - h-1
        );

        // Top triangle
        faces[0][0] = 0;
        faces[0][1] = 1;
        faces[0][2] = 2;

        // bottom triangle
        faces[1][0] = 5;
        faces[1][1] = 4;
        faces[1][2] = 3;

        // +x facing quad
        faces[2][0] = 2;
        faces[2][1] = 5;
        faces[2][2] = 3;
        faces[2][3] = 0;

        // +y facing quad
        faces[3][0] = 3;
        faces[3][1] = 4;
        faces[3][2] = 1;
        faces[3][3] = 0;

        // -xy facing quad
        faces[4][0] = 1;
        faces[4][1] = 4;
        faces[4][2] = 5;
        faces[4][3] = 2;
    }

    result.computeNormals();
    result.computeEdges();
    result.updateBoundingSphereRadius();

    this.setCachedConvexTrianglePillar(xi, yi, getUpperTriangle, result, offsetResult);
};

Heightfield.prototype.calculateLocalInertia = function(mass, target){
    target = target || new Vec3();
    target.set(0, 0, 0);
    return target;
};

Heightfield.prototype.volume = function(){
    return Number.MAX_VALUE; // The terrain is infinite
};

Heightfield.prototype.calculateWorldAABB = function(pos, quat, min, max){
    // TODO: do it properly
    min.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    max.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
};

Heightfield.prototype.updateBoundingSphereRadius = function(){
    // Use the bounding box of the min/max values
    var data = this.data,
        s = this.elementSize;
    this.boundingSphereRadius = new Vec3(data.length * s, data[0].length * s, Math.max(Math.abs(this.maxValue), Math.abs(this.minValue))).norm();
};

},{"../math/Vec3":30,"../utils/Utils":53,"./ConvexPolyhedron":38,"./Shape":43}],41:[function(_dereq_,module,exports){
module.exports = Particle;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Particle shape.
 * @class Particle
 * @constructor
 * @author schteppe
 * @extends Shape
 */
function Particle(){
    Shape.call(this);

    this.type = Shape.types.PARTICLE;
}
Particle.prototype = new Shape();
Particle.prototype.constructor = Particle;

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3}
 */
Particle.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    target.set(0, 0, 0);
    return target;
};

Particle.prototype.volume = function(){
    return 0;
};

Particle.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = 0;
};

Particle.prototype.calculateWorldAABB = function(pos,quat,min,max){
    // Get each axis max
    min.copy(pos);
    max.copy(pos);
};

},{"../math/Vec3":30,"./Shape":43}],42:[function(_dereq_,module,exports){
module.exports = Plane;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');

/**
 * A plane, facing in the Z direction. The plane has its surface at z=0 and everything below z=0 is assumed to be solid plane. To make the plane face in some other direction than z, you must put it inside a RigidBody and rotate that body. See the demos.
 * @class Plane
 * @constructor
 * @extends Shape
 * @author schteppe
 */
function Plane(){
    Shape.call(this);
    this.type = Shape.types.PLANE;

    // World oriented normal
    this.worldNormal = new Vec3();
    this.worldNormalNeedsUpdate = true;

    this.boundingSphereRadius = Number.MAX_VALUE;
}
Plane.prototype = new Shape();
Plane.prototype.constructor = Plane;

Plane.prototype.computeWorldNormal = function(quat){
    var n = this.worldNormal;
    n.set(0,0,1);
    quat.vmult(n,n);
    this.worldNormalNeedsUpdate = false;
};

Plane.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    return target;
};

Plane.prototype.volume = function(){
    return Number.MAX_VALUE; // The plane is infinite...
};

var tempNormal = new Vec3();
Plane.prototype.calculateWorldAABB = function(pos, quat, min, max){
    // The plane AABB is infinite, except if the normal is pointing along any axis
    tempNormal.set(0,0,1); // Default plane normal is z
    quat.vmult(tempNormal,tempNormal);
    var maxVal = Number.MAX_VALUE;
    min.set(-maxVal, -maxVal, -maxVal);
    max.set(maxVal, maxVal, maxVal);

    if(tempNormal.x === 1){ max.x = pos.x; }
    if(tempNormal.y === 1){ max.y = pos.y; }
    if(tempNormal.z === 1){ max.z = pos.z; }

    if(tempNormal.x === -1){ min.x = pos.x; }
    if(tempNormal.y === -1){ min.y = pos.y; }
    if(tempNormal.z === -1){ min.z = pos.z; }
};

Plane.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = Number.MAX_VALUE;
};
},{"../math/Vec3":30,"./Shape":43}],43:[function(_dereq_,module,exports){
module.exports = Shape;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Material = _dereq_('../material/Material');

/**
 * Base class for shapes
 * @class Shape
 * @constructor
 * @author schteppe
 * @todo Should have a mechanism for caching bounding sphere radius instead of calculating it each time
 */
function Shape(){

    /**
     * Identifyer of the Shape.
     * @property {number} id
     */
    this.id = Shape.idCounter++;

    /**
     * The type of this shape. Must be set to an int > 0 by subclasses.
     * @property type
     * @type {Number}
     * @see Shape.types
     */
    this.type = 0;

    /**
     * The local bounding sphere radius of this shape.
     * @property {Number} boundingSphereRadius
     */
    this.boundingSphereRadius = 0;

    /**
     * Whether to produce contact forces when in contact with other bodies. Note that contacts will be generated, but they will be disabled.
     * @property {boolean} collisionResponse
     */
    this.collisionResponse = true;

    /**
     * @property {Material} material
     */
    this.material = null;
}
Shape.prototype.constructor = Shape;

/**
 * Computes the bounding sphere radius. The result is stored in the property .boundingSphereRadius
 * @method updateBoundingSphereRadius
 * @return {Number}
 */
Shape.prototype.updateBoundingSphereRadius = function(){
    throw "computeBoundingSphereRadius() not implemented for shape type "+this.type;
};

/**
 * Get the volume of this shape
 * @method volume
 * @return {Number}
 */
Shape.prototype.volume = function(){
    throw "volume() not implemented for shape type "+this.type;
};

/**
 * Calculates the inertia in the local frame for this shape.
 * @method calculateLocalInertia
 * @return {Vec3}
 * @see http://en.wikipedia.org/wiki/List_of_moments_of_inertia
 */
Shape.prototype.calculateLocalInertia = function(mass,target){
    throw "calculateLocalInertia() not implemented for shape type "+this.type;
};

Shape.idCounter = 0;

/**
 * The available shape types.
 * @static
 * @property types
 * @type {Object}
 */
Shape.types = {
    SPHERE:1,
    PLANE:2,
    BOX:4,
    COMPOUND:8,
    CONVEXPOLYHEDRON:16,
    HEIGHTFIELD:32,
    PARTICLE:64,
    CYLINDER:128,
    TRIMESH:256
};


},{"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"./Shape":43}],44:[function(_dereq_,module,exports){
module.exports = Sphere;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');

/**
 * Spherical shape
 * @class Sphere
 * @constructor
 * @extends Shape
 * @param {Number} radius The radius of the sphere, a non-negative number.
 * @author schteppe / http://github.com/schteppe
 */
function Sphere(radius){
    Shape.call(this);

    /**
     * @property {Number} radius
     */
    this.radius = radius!==undefined ? Number(radius) : 1.0;
    this.type = Shape.types.SPHERE;

    if(this.radius < 0){
        throw new Error('The sphere radius cannot be negative.');
    }

    this.updateBoundingSphereRadius();
}
Sphere.prototype = new Shape();
Sphere.prototype.constructor = Sphere;

Sphere.prototype.calculateLocalInertia = function(mass,target){
    target = target || new Vec3();
    var I = 2.0*mass*this.radius*this.radius/5.0;
    target.x = I;
    target.y = I;
    target.z = I;
    return target;
};

Sphere.prototype.volume = function(){
    return 4.0 * Math.PI * this.radius / 3.0;
};

Sphere.prototype.updateBoundingSphereRadius = function(){
    this.boundingSphereRadius = this.radius;
};

Sphere.prototype.calculateWorldAABB = function(pos,quat,min,max){
    var r = this.radius;
    var axes = ['x','y','z'];
    for(var i=0; i<axes.length; i++){
        var ax = axes[i];
        min[ax] = pos[ax] - r;
        max[ax] = pos[ax] + r;
    }
};

},{"../math/Vec3":30,"./Shape":43}],45:[function(_dereq_,module,exports){
module.exports = Trimesh;

var Shape = _dereq_('./Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Transform = _dereq_('../math/Transform');
var AABB = _dereq_('../collision/AABB');
var Octree = _dereq_('../utils/Octree');

/**
 * @class Trimesh
 * @constructor
 * @param {array} vertices
 * @param {array} indices
 * @extends Shape
 * @example
 *     // How to make a mesh with a single triangle
 *     var vertices = [
 *         0, 0, 0, // vertex 0
 *         1, 0, 0, // vertex 1
 *         0, 1, 0  // vertex 2
 *     ];
 *     var indices = [
 *         0, 1, 2  // triangle 0
 *     ];
 *     var trimeshShape = new Trimesh(vertices, indices);
 */
function Trimesh(vertices, indices) {
    Shape.call(this);
    this.type = Shape.types.TRIMESH;

    /**
     * @property vertices
     * @type {Array}
     */
    this.vertices = new Float32Array(vertices);

    /**
     * Array of integers, indicating which vertices each triangle consists of. The length of this array is thus 3 times the number of triangles.
     * @property indices
     * @type {Array}
     */
    this.indices = new Int16Array(indices);

    /**
     * The normals data.
     * @property normals
     * @type {Array}
     */
    this.normals = new Float32Array(indices.length);

    /**
     * The local AABB of the mesh.
     * @property aabb
     * @type {Array}
     */
    this.aabb = new AABB();

    /**
     * References to vertex pairs, making up all unique edges in the trimesh.
     * @property {array} edges
     */
    this.edges = null;

    /**
     * Local scaling of the mesh. Use .setScale() to set it.
     * @property {Vec3} scale
     */
    this.scale = new Vec3(1, 1, 1);

    /**
     * The indexed triangles. Use .updateTree() to update it.
     * @property {Octree} tree
     */
    this.tree = new Octree();

    this.updateEdges();
    this.updateNormals();
    this.updateAABB();
    this.updateBoundingSphereRadius();
    this.updateTree();
}
Trimesh.prototype = new Shape();
Trimesh.prototype.constructor = Trimesh;

var computeNormals_n = new Vec3();

/**
 * @method updateTree
 */
Trimesh.prototype.updateTree = function(){
    var tree = this.tree;

    tree.reset();
    tree.aabb.copy(this.aabb);
    var scale = this.scale; // The local mesh AABB is scaled, but the octree AABB should be unscaled
    tree.aabb.lowerBound.x *= 1 / scale.x;
    tree.aabb.lowerBound.y *= 1 / scale.y;
    tree.aabb.lowerBound.z *= 1 / scale.z;
    tree.aabb.upperBound.x *= 1 / scale.x;
    tree.aabb.upperBound.y *= 1 / scale.y;
    tree.aabb.upperBound.z *= 1 / scale.z;

    // Insert all triangles
    var triangleAABB = new AABB();
    var a = new Vec3();
    var b = new Vec3();
    var c = new Vec3();
    var points = [a, b, c];
    for (var i = 0; i < this.indices.length / 3; i++) {
        //this.getTriangleVertices(i, a, b, c);

        // Get unscaled triangle verts
        var i3 = i * 3;
        this._getUnscaledVertex(this.indices[i3], a);
        this._getUnscaledVertex(this.indices[i3 + 1], b);
        this._getUnscaledVertex(this.indices[i3 + 2], c);

        triangleAABB.setFromPoints(points);
        tree.insert(triangleAABB, i);
    }
    tree.removeEmptyNodes();
};

var unscaledAABB = new AABB();

/**
 * Get triangles in a local AABB from the trimesh.
 * @method getTrianglesInAABB
 * @param  {AABB} aabb
 * @param  {array} result An array of integers, referencing the queried triangles.
 */
Trimesh.prototype.getTrianglesInAABB = function(aabb, result){
    unscaledAABB.copy(aabb);

    // Scale it to local
    var scale = this.scale;
    var isx = scale.x;
    var isy = scale.y;
    var isz = scale.z;
    var l = unscaledAABB.lowerBound;
    var u = unscaledAABB.upperBound;
    l.x /= isx;
    l.y /= isy;
    l.z /= isz;
    u.x /= isx;
    u.y /= isy;
    u.z /= isz;

    return this.tree.aabbQuery(unscaledAABB, result);
};

/**
 * @method setScale
 * @param {Vec3} scale
 */
Trimesh.prototype.setScale = function(scale){
    var wasUniform = this.scale.x === this.scale.y === this.scale.z;
    var isUniform = scale.x === scale.y === scale.z;

    if(!(wasUniform && isUniform)){
        // Non-uniform scaling. Need to update normals.
        this.updateNormals();
    }
    this.scale.copy(scale);
    this.updateAABB();
    this.updateBoundingSphereRadius();
};

/**
 * Compute the normals of the faces. Will save in the .normals array.
 * @method updateNormals
 */
Trimesh.prototype.updateNormals = function(){
    var n = computeNormals_n;

    // Generate normals
    var normals = this.normals;
    for(var i=0; i < this.indices.length / 3; i++){
        var i3 = i * 3;

        var a = this.indices[i3],
            b = this.indices[i3 + 1],
            c = this.indices[i3 + 2];

        this.getVertex(a, va);
        this.getVertex(b, vb);
        this.getVertex(c, vc);

        Trimesh.computeNormal(vb, va, vc, n);

        normals[i3] = n.x;
        normals[i3 + 1] = n.y;
        normals[i3 + 2] = n.z;
    }
};

/**
 * Update the .edges property
 * @method updateEdges
 */
Trimesh.prototype.updateEdges = function(){
    var edges = {};
    var add = function(indexA, indexB){
        var key = a < b ? a + '_' + b : b + '_' + a;
        edges[key] = true;
    };
    for(var i=0; i < this.indices.length / 3; i++){
        var i3 = i * 3;
        var a = this.indices[i3],
            b = this.indices[i3 + 1],
            c = this.indices[i3 + 2];
        add(a,b);
        add(b,c);
        add(c,a);
    }
    var keys = Object.keys(edges);
    this.edges = new Int16Array(keys.length * 2);
    for (var i = 0; i < keys.length; i++) {
        var indices = keys[i].split('_');
        this.edges[2 * i] = parseInt(indices[0], 10);
        this.edges[2 * i + 1] = parseInt(indices[1], 10);
    }
};

/**
 * Get an edge vertex
 * @method getEdgeVertex
 * @param  {number} edgeIndex
 * @param  {number} firstOrSecond 0 or 1, depending on which one of the vertices you need.
 * @param  {Vec3} vertexStore Where to store the result
 */
Trimesh.prototype.getEdgeVertex = function(edgeIndex, firstOrSecond, vertexStore){
    var vertexIndex = this.edges[edgeIndex * 2 + (firstOrSecond ? 1 : 0)];
    this.getVertex(vertexIndex, vertexStore);
};

var getEdgeVector_va = new Vec3();
var getEdgeVector_vb = new Vec3();

/**
 * Get a vector along an edge.
 * @method getEdgeVector
 * @param  {number} edgeIndex
 * @param  {Vec3} vectorStore
 */
Trimesh.prototype.getEdgeVector = function(edgeIndex, vectorStore){
    var va = getEdgeVector_va;
    var vb = getEdgeVector_vb;
    this.getEdgeVertex(edgeIndex, 0, va);
    this.getEdgeVertex(edgeIndex, 1, vb);
    vb.vsub(va, vectorStore);
};

/**
 * Get face normal given 3 vertices
 * @static
 * @method computeNormal
 * @param {Vec3} va
 * @param {Vec3} vb
 * @param {Vec3} vc
 * @param {Vec3} target
 */
var cb = new Vec3();
var ab = new Vec3();
Trimesh.computeNormal = function ( va, vb, vc, target ) {
    vb.vsub(va,ab);
    vc.vsub(vb,cb);
    cb.cross(ab,target);
    if ( !target.isZero() ) {
        target.normalize();
    }
};

var va = new Vec3();
var vb = new Vec3();
var vc = new Vec3();

/**
 * Get vertex i.
 * @method getVertex
 * @param  {number} i
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype.getVertex = function(i, out){
    var scale = this.scale;
    this._getUnscaledVertex(i, out);
    out.x *= scale.x;
    out.y *= scale.y;
    out.z *= scale.z;
    return out;
};

/**
 * Get raw vertex i
 * @private
 * @method _getUnscaledVertex
 * @param  {number} i
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype._getUnscaledVertex = function(i, out){
    var i3 = i * 3;
    var vertices = this.vertices;
    return out.set(
        vertices[i3],
        vertices[i3 + 1],
        vertices[i3 + 2]
    );
};

/**
 * Get a vertex from the trimesh,transformed by the given position and quaternion.
 * @method getWorldVertex
 * @param  {number} i
 * @param  {Vec3} pos
 * @param  {Quaternion} quat
 * @param  {Vec3} out
 * @return {Vec3} The "out" vector object
 */
Trimesh.prototype.getWorldVertex = function(i, pos, quat, out){
    this.getVertex(i, out);
    Transform.pointToWorldFrame(pos, quat, out, out);
    return out;
};

/**
 * Get the three vertices for triangle i.
 * @method getTriangleVertices
 * @param  {number} i
 * @param  {Vec3} a
 * @param  {Vec3} b
 * @param  {Vec3} c
 */
Trimesh.prototype.getTriangleVertices = function(i, a, b, c){
    var i3 = i * 3;
    this.getVertex(this.indices[i3], a);
    this.getVertex(this.indices[i3 + 1], b);
    this.getVertex(this.indices[i3 + 2], c);
};

/**
 * Compute the normal of triangle i.
 * @method getNormal
 * @param  {Number} i
 * @param  {Vec3} target
 * @return {Vec3} The "target" vector object
 */
Trimesh.prototype.getNormal = function(i, target){
    var i3 = i * 3;
    return target.set(
        this.normals[i3],
        this.normals[i3 + 1],
        this.normals[i3 + 2]
    );
};

var cli_aabb = new AABB();

/**
 * @method calculateLocalInertia
 * @param  {Number} mass
 * @param  {Vec3} target
 * @return {Vec3} The "target" vector object
 */
Trimesh.prototype.calculateLocalInertia = function(mass,target){
    // Approximate with box inertia
    // Exact inertia calculation is overkill, but see http://geometrictools.com/Documentation/PolyhedralMassProperties.pdf for the correct way to do it
    this.computeLocalAABB(cli_aabb);
    var x = cli_aabb.upperBound.x - cli_aabb.lowerBound.x,
        y = cli_aabb.upperBound.y - cli_aabb.lowerBound.y,
        z = cli_aabb.upperBound.z - cli_aabb.lowerBound.z;
    return target.set(
        1.0 / 12.0 * mass * ( 2*y*2*y + 2*z*2*z ),
        1.0 / 12.0 * mass * ( 2*x*2*x + 2*z*2*z ),
        1.0 / 12.0 * mass * ( 2*y*2*y + 2*x*2*x )
    );
};

var computeLocalAABB_worldVert = new Vec3();

/**
 * Compute the local AABB for the trimesh
 * @method computeLocalAABB
 * @param  {AABB} aabb
 */
Trimesh.prototype.computeLocalAABB = function(aabb){
    var l = aabb.lowerBound,
        u = aabb.upperBound,
        n = this.vertices.length,
        vertices = this.vertices,
        v = computeLocalAABB_worldVert;

    this.getVertex(0, v);
    l.copy(v);
    u.copy(v);

    for(var i=0; i !== n; i++){
        this.getVertex(i, v);

        if(v.x < l.x){
            l.x = v.x;
        } else if(v.x > u.x){
            u.x = v.x;
        }

        if(v.y < l.y){
            l.y = v.y;
        } else if(v.y > u.y){
            u.y = v.y;
        }

        if(v.z < l.z){
            l.z = v.z;
        } else if(v.z > u.z){
            u.z = v.z;
        }
    }
};


/**
 * Update the .aabb property
 * @method updateAABB
 */
Trimesh.prototype.updateAABB = function(){
    this.computeLocalAABB(this.aabb);
};

/**
 * Will update the .boundingSphereRadius property
 * @method updateBoundingSphereRadius
 */
Trimesh.prototype.updateBoundingSphereRadius = function(){
    // Assume points are distributed with local (0,0,0) as center
    var max2 = 0;
    var vertices = this.vertices;
    var v = new Vec3();
    for(var i=0, N=vertices.length / 3; i !== N; i++) {
        this.getVertex(i, v);
        var norm2 = v.norm2();
        if(norm2 > max2){
            max2 = norm2;
        }
    }
    this.boundingSphereRadius = Math.sqrt(max2);
};

var tempWorldVertex = new Vec3();
var calculateWorldAABB_frame = new Transform();
var calculateWorldAABB_aabb = new AABB();

/**
 * @method calculateWorldAABB
 * @param {Vec3}        pos
 * @param {Quaternion}  quat
 * @param {Vec3}        min
 * @param {Vec3}        max
 */
Trimesh.prototype.calculateWorldAABB = function(pos,quat,min,max){
    /*
    var n = this.vertices.length / 3,
        verts = this.vertices;
    var minx,miny,minz,maxx,maxy,maxz;

    var v = tempWorldVertex;
    for(var i=0; i<n; i++){
        this.getVertex(i, v);
        quat.vmult(v, v);
        pos.vadd(v, v);
        if (v.x < minx || minx===undefined){
            minx = v.x;
        } else if(v.x > maxx || maxx===undefined){
            maxx = v.x;
        }

        if (v.y < miny || miny===undefined){
            miny = v.y;
        } else if(v.y > maxy || maxy===undefined){
            maxy = v.y;
        }

        if (v.z < minz || minz===undefined){
            minz = v.z;
        } else if(v.z > maxz || maxz===undefined){
            maxz = v.z;
        }
    }
    min.set(minx,miny,minz);
    max.set(maxx,maxy,maxz);
    */

    // Faster approximation using local AABB
    var frame = calculateWorldAABB_frame;
    var result = calculateWorldAABB_aabb;
    frame.position = pos;
    frame.quaternion = quat;
    this.aabb.toWorldFrame(frame, result);
    min.copy(result.lowerBound);
    max.copy(result.upperBound);
};

/**
 * Get approximate volume
 * @method volume
 * @return {Number}
 */
Trimesh.prototype.volume = function(){
    return 4.0 * Math.PI * this.boundingSphereRadius / 3.0;
};

/**
 * Create a Trimesh instance, shaped as a torus.
 * @static
 * @method createTorus
 * @param  {number} [radius=1]
 * @param  {number} [tube=0.5]
 * @param  {number} [radialSegments=8]
 * @param  {number} [tubularSegments=6]
 * @param  {number} [arc=6.283185307179586]
 * @return {Trimesh} A torus
 */
Trimesh.createTorus = function (radius, tube, radialSegments, tubularSegments, arc) {
    radius = radius || 1;
    tube = tube || 0.5;
    radialSegments = radialSegments || 8;
    tubularSegments = tubularSegments || 6;
    arc = arc || Math.PI * 2;

    var vertices = [];
    var indices = [];

    for ( var j = 0; j <= radialSegments; j ++ ) {
        for ( var i = 0; i <= tubularSegments; i ++ ) {
            var u = i / tubularSegments * arc;
            var v = j / radialSegments * Math.PI * 2;

            var x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
            var y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
            var z = tube * Math.sin( v );

            vertices.push( x, y, z );
        }
    }

    for ( var j = 1; j <= radialSegments; j ++ ) {
        for ( var i = 1; i <= tubularSegments; i ++ ) {
            var a = ( tubularSegments + 1 ) * j + i - 1;
            var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
            var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
            var d = ( tubularSegments + 1 ) * j + i;

            indices.push(a, b, d);
            indices.push(b, c, d);
        }
    }

    return new Trimesh(vertices, indices);
};

},{"../collision/AABB":3,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../utils/Octree":50,"./Shape":43}],46:[function(_dereq_,module,exports){
module.exports = GSSolver;

var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Solver = _dereq_('./Solver');

/**
 * Constraint equation Gauss-Seidel solver.
 * @class GSSolver
 * @constructor
 * @todo The spook parameters should be specified for each constraint, not globally.
 * @author schteppe / https://github.com/schteppe
 * @see https://www8.cs.umu.se/kurser/5DV058/VT09/lectures/spooknotes.pdf
 * @extends Solver
 */
function GSSolver(){
    Solver.call(this);

    /**
     * The number of solver iterations determines quality of the constraints in the world. The more iterations, the more correct simulation. More iterations need more computations though. If you have a large gravity force in your world, you will need more iterations.
     * @property iterations
     * @type {Number}
     * @todo write more about solver and iterations in the wiki
     */
    this.iterations = 10;

    /**
     * When tolerance is reached, the system is assumed to be converged.
     * @property tolerance
     * @type {Number}
     */
    this.tolerance = 1e-7;
}
GSSolver.prototype = new Solver();

var GSSolver_solve_lambda = []; // Just temporary number holders that we want to reuse each solve.
var GSSolver_solve_invCs = [];
var GSSolver_solve_Bs = [];
GSSolver.prototype.solve = function(dt,world){
    var iter = 0,
        maxIter = this.iterations,
        tolSquared = this.tolerance*this.tolerance,
        equations = this.equations,
        Neq = equations.length,
        bodies = world.bodies,
        Nbodies = bodies.length,
        h = dt,
        q, B, invC, deltalambda, deltalambdaTot, GWlambda, lambdaj;

    // Update solve mass
    if(Neq !== 0){
        for(var i=0; i!==Nbodies; i++){
            bodies[i].updateSolveMassProperties();
        }
    }

    // Things that does not change during iteration can be computed once
    var invCs = GSSolver_solve_invCs,
        Bs = GSSolver_solve_Bs,
        lambda = GSSolver_solve_lambda;
    invCs.length = Neq;
    Bs.length = Neq;
    lambda.length = Neq;
    for(var i=0; i!==Neq; i++){
        var c = equations[i];
        lambda[i] = 0.0;
        Bs[i] = c.computeB(h);
        invCs[i] = 1.0 / c.computeC();
    }

    if(Neq !== 0){

        // Reset vlambda
        for(var i=0; i!==Nbodies; i++){
            var b=bodies[i],
                vlambda=b.vlambda,
                wlambda=b.wlambda;
            vlambda.set(0,0,0);
            if(wlambda){
                wlambda.set(0,0,0);
            }
        }

        // Iterate over equations
        for(iter=0; iter!==maxIter; iter++){

            // Accumulate the total error for each iteration.
            deltalambdaTot = 0.0;

            for(var j=0; j!==Neq; j++){

                var c = equations[j];

                // Compute iteration
                B = Bs[j];
                invC = invCs[j];
                lambdaj = lambda[j];
                GWlambda = c.computeGWlambda();
                deltalambda = invC * ( B - GWlambda - c.eps * lambdaj );

                // Clamp if we are not within the min/max interval
                if(lambdaj + deltalambda < c.minForce){
                    deltalambda = c.minForce - lambdaj;
                } else if(lambdaj + deltalambda > c.maxForce){
                    deltalambda = c.maxForce - lambdaj;
                }
                lambda[j] += deltalambda;

                deltalambdaTot += deltalambda > 0.0 ? deltalambda : -deltalambda; // abs(deltalambda)

                c.addToWlambda(deltalambda);
            }

            // If the total error is small enough - stop iterate
            if(deltalambdaTot*deltalambdaTot < tolSquared){
                break;
            }
        }

        // Add result to velocity
        for(var i=0; i!==Nbodies; i++){
            var b=bodies[i],
                v=b.velocity,
                w=b.angularVelocity;
            v.vadd(b.vlambda, v);
            if(w){
                w.vadd(b.wlambda, w);
            }
        }
    }

    return iter;
};

},{"../math/Quaternion":28,"../math/Vec3":30,"./Solver":47}],47:[function(_dereq_,module,exports){
module.exports = Solver;

/**
 * Constraint equation solver base class.
 * @class Solver
 * @constructor
 * @author schteppe / https://github.com/schteppe
 */
function Solver(){
    /**
     * All equations to be solved
     * @property {Array} equations
     */
    this.equations = [];
}

/**
 * Should be implemented in subclasses!
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
Solver.prototype.solve = function(dt,world){
    // Should return the number of iterations done!
    return 0;
};

/**
 * Add an equation
 * @method addEquation
 * @param {Equation} eq
 */
Solver.prototype.addEquation = function(eq){
    if (eq.enabled) {
        this.equations.push(eq);
    }
};

/**
 * Remove an equation
 * @method removeEquation
 * @param {Equation} eq
 */
Solver.prototype.removeEquation = function(eq){
    var eqs = this.equations;
    var i = eqs.indexOf(eq);
    if(i !== -1){
        eqs.splice(i,1);
    }
};

/**
 * Add all equations
 * @method removeAllEquations
 */
Solver.prototype.removeAllEquations = function(){
    this.equations.length = 0;
};


},{}],48:[function(_dereq_,module,exports){
module.exports = SplitSolver;

var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var Solver = _dereq_('./Solver');
var Body = _dereq_('../objects/Body');

/**
 * Splits the equations into islands and solves them independently. Can improve performance.
 * @class SplitSolver
 * @constructor
 * @extends Solver
 * @param {Solver} subsolver
 */
function SplitSolver(subsolver){
    Solver.call(this);
    this.iterations = 10;
    this.tolerance = 1e-7;
    this.subsolver = subsolver;
    this.nodes = [];
    this.nodePool = [];

    // Create needed nodes, reuse if possible
    while(this.nodePool.length < 128){
        this.nodePool.push(this.createNode());
    }
}
SplitSolver.prototype = new Solver();

// Returns the number of subsystems
var SplitSolver_solve_nodes = []; // All allocated node objects
var SplitSolver_solve_nodePool = []; // All allocated node objects
var SplitSolver_solve_eqs = [];   // Temp array
var SplitSolver_solve_bds = [];   // Temp array
var SplitSolver_solve_dummyWorld = {bodies:[]}; // Temp object

var STATIC = Body.STATIC;
function getUnvisitedNode(nodes){
    var Nnodes = nodes.length;
    for(var i=0; i!==Nnodes; i++){
        var node = nodes[i];
        if(!node.visited && !(node.body.type & STATIC)){
            return node;
        }
    }
    return false;
}

var queue = [];
function bfs(root,visitFunc,bds,eqs){
    queue.push(root);
    root.visited = true;
    visitFunc(root,bds,eqs);
    while(queue.length) {
        var node = queue.pop();
        // Loop over unvisited child nodes
        var child;
        while((child = getUnvisitedNode(node.children))) {
            child.visited = true;
            visitFunc(child,bds,eqs);
            queue.push(child);
        }
    }
}

function visitFunc(node,bds,eqs){
    bds.push(node.body);
    var Neqs = node.eqs.length;
    for(var i=0; i!==Neqs; i++){
        var eq = node.eqs[i];
        if(eqs.indexOf(eq) === -1){
            eqs.push(eq);
        }
    }
}

SplitSolver.prototype.createNode = function(){
    return { body:null, children:[], eqs:[], visited:false };
};

/**
 * Solve the subsystems
 * @method solve
 * @param  {Number} dt
 * @param  {World} world
 */
SplitSolver.prototype.solve = function(dt,world){
    var nodes=SplitSolver_solve_nodes,
        nodePool=this.nodePool,
        bodies=world.bodies,
        equations=this.equations,
        Neq=equations.length,
        Nbodies=bodies.length,
        subsolver=this.subsolver;

    // Create needed nodes, reuse if possible
    while(nodePool.length < Nbodies){
        nodePool.push(this.createNode());
    }
    nodes.length = Nbodies;
    for (var i = 0; i < Nbodies; i++) {
        nodes[i] = nodePool[i];
    }

    // Reset node values
    for(var i=0; i!==Nbodies; i++){
        var node = nodes[i];
        node.body = bodies[i];
        node.children.length = 0;
        node.eqs.length = 0;
        node.visited = false;
    }
    for(var k=0; k!==Neq; k++){
        var eq=equations[k],
            i=bodies.indexOf(eq.bi),
            j=bodies.indexOf(eq.bj),
            ni=nodes[i],
            nj=nodes[j];
        ni.children.push(nj);
        ni.eqs.push(eq);
        nj.children.push(ni);
        nj.eqs.push(eq);
    }

    var child, n=0, eqs=SplitSolver_solve_eqs;

    subsolver.tolerance = this.tolerance;
    subsolver.iterations = this.iterations;

    var dummyWorld = SplitSolver_solve_dummyWorld;
    while((child = getUnvisitedNode(nodes))){
        eqs.length = 0;
        dummyWorld.bodies.length = 0;
        bfs(child, visitFunc, dummyWorld.bodies, eqs);

        var Neqs = eqs.length;

        eqs = eqs.sort(sortById);

        for(var i=0; i!==Neqs; i++){
            subsolver.addEquation(eqs[i]);
        }

        var iter = subsolver.solve(dt,dummyWorld);
        subsolver.removeAllEquations();
        n++;
    }

    return n;
};

function sortById(a, b){
    return b.id - a.id;
}
},{"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"./Solver":47}],49:[function(_dereq_,module,exports){
/**
 * Base class for objects that dispatches events.
 * @class EventTarget
 * @constructor
 */
var EventTarget = function () {

};

module.exports = EventTarget;

EventTarget.prototype = {
    constructor: EventTarget,

    /**
     * Add an event listener
     * @method addEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventTarget} The self object, for chainability.
     */
    addEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ this._listeners = {}; }
        var listeners = this._listeners;
        if ( listeners[ type ] === undefined ) {
            listeners[ type ] = [];
        }
        if ( listeners[ type ].indexOf( listener ) === - 1 ) {
            listeners[ type ].push( listener );
        }
        return this;
    },

    /**
     * Check if an event listener is added
     * @method hasEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {Boolean}
     */
    hasEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ return false; }
        var listeners = this._listeners;
        if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {
            return true;
        }
        return false;
    },

    /**
     * Remove an event listener
     * @method removeEventListener
     * @param  {String} type
     * @param  {Function} listener
     * @return {EventTarget} The self object, for chainability.
     */
    removeEventListener: function ( type, listener ) {
        if ( this._listeners === undefined ){ return this; }
        var listeners = this._listeners;
        if ( listeners[type] === undefined ){ return this; }
        var index = listeners[ type ].indexOf( listener );
        if ( index !== - 1 ) {
            listeners[ type ].splice( index, 1 );
        }
        return this;
    },

    /**
     * Emit an event.
     * @method dispatchEvent
     * @param  {Object} event
     * @param  {String} event.type
     * @return {EventTarget} The self object, for chainability.
     */
    dispatchEvent: function ( event ) {
        if ( this._listeners === undefined ){ return this; }
        var listeners = this._listeners;
        var listenerArray = listeners[ event.type ];
        if ( listenerArray !== undefined ) {
            event.target = this;
            for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {
                listenerArray[ i ].call( this, event );
            }
        }
        return this;
    }
};

},{}],50:[function(_dereq_,module,exports){
var AABB = _dereq_('../collision/AABB');
var Vec3 = _dereq_('../math/Vec3');

module.exports = Octree;

/**
 * @class OctreeNode
 * @param {object} [options]
 * @param {Octree} [options.root]
 * @param {AABB} [options.aabb]
 */
function OctreeNode(options){
    options = options || {};

    /**
     * The root node
     * @property {OctreeNode} root
     */
    this.root = options.root || null;

    /**
     * Boundary of this node
     * @property {AABB} aabb
     */
    this.aabb = options.aabb ? options.aabb.clone() : new AABB();

    /**
     * Contained data at the current node level.
     * @property {Array} data
     */
    this.data = [];

    /**
     * Children to this node
     * @property {Array} children
     */
    this.children = [];
}

/**
 * @class Octree
 * @param {AABB} aabb The total AABB of the tree
 * @param {object} [options]
 * @param {number} [options.maxDepth=8]
 * @extends OctreeNode
 */
function Octree(aabb, options){
    options = options || {};
    options.root = null;
    options.aabb = aabb;
    OctreeNode.call(this, options);

    /**
     * Maximum subdivision depth
     * @property {number} maxDepth
     */
    this.maxDepth = typeof(options.maxDepth) !== 'undefined' ? options.maxDepth : 8;
}
Octree.prototype = new OctreeNode();

OctreeNode.prototype.reset = function(aabb, options){
    this.children.length = this.data.length = 0;
};

/**
 * Insert data into this node
 * @method insert
 * @param  {AABB} aabb
 * @param  {object} elementData
 * @return {boolean} True if successful, otherwise false
 */
OctreeNode.prototype.insert = function(aabb, elementData, level){
    var nodeData = this.data;
    level = level || 0;

    // Ignore objects that do not belong in this node
    if (!this.aabb.contains(aabb)){
        return false; // object cannot be added
    }

    var children = this.children;

    if(level < (this.maxDepth || this.root.maxDepth)){
        // Subdivide if there are no children yet
        var subdivided = false;
        if (!children.length){
            this.subdivide();
            subdivided = true;
        }

        // add to whichever node will accept it
        for (var i = 0; i !== 8; i++) {
            if (children[i].insert(aabb, elementData, level + 1)){
                return true;
            }
        }

        if(subdivided){
            // No children accepted! Might as well just remove em since they contain none
            children.length = 0;
        }
    }

    // Too deep, or children didnt want it. add it in current node
    nodeData.push(elementData);

    return true;
};

var halfDiagonal = new Vec3();

/**
 * Create 8 equally sized children nodes and put them in the .children array.
 * @method subdivide
 */
OctreeNode.prototype.subdivide = function() {
    var aabb = this.aabb;
    var l = aabb.lowerBound;
    var u = aabb.upperBound;

    var children = this.children;

    children.push(
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,0) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,1,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,0,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(1,0,1) }) }),
        new OctreeNode({ aabb: new AABB({ lowerBound: new Vec3(0,1,0) }) })
    );

    u.vsub(l, halfDiagonal);
    halfDiagonal.scale(0.5, halfDiagonal);

    var root = this.root || this;

    for (var i = 0; i !== 8; i++) {
        var child = children[i];

        // Set current node as root
        child.root = root;

        // Compute bounds
        var lowerBound = child.aabb.lowerBound;
        lowerBound.x *= halfDiagonal.x;
        lowerBound.y *= halfDiagonal.y;
        lowerBound.z *= halfDiagonal.z;

        lowerBound.vadd(l, lowerBound);

        // Upper bound is always lower bound + halfDiagonal
        lowerBound.vadd(halfDiagonal, child.aabb.upperBound);
    }
};

/**
 * Get all data, potentially within an AABB
 * @method aabbQuery
 * @param  {AABB} aabb
 * @param  {array} result
 * @return {array} The "result" object
 */
OctreeNode.prototype.aabbQuery = function(aabb, result) {

    var nodeData = this.data;

    // abort if the range does not intersect this node
    // if (!this.aabb.overlaps(aabb)){
    //     return result;
    // }

    // Add objects at this level
    // Array.prototype.push.apply(result, nodeData);

    // Add child data
    // @todo unwrap recursion into a queue / loop, that's faster in JS
    var children = this.children;


    // for (var i = 0, N = this.children.length; i !== N; i++) {
    //     children[i].aabbQuery(aabb, result);
    // }

    var queue = [this];
    while (queue.length) {
        var node = queue.pop();
        if (node.aabb.overlaps(aabb)){
            Array.prototype.push.apply(result, node.data);
        }
        Array.prototype.push.apply(queue, node.children);
    }

    return result;
};

var tmpAABB = new AABB();

/**
 * Get all data, potentially intersected by a ray.
 * @method rayQuery
 * @param  {Ray} ray
 * @param  {Transform} treeTransform
 * @param  {array} result
 * @return {array} The "result" object
 */
OctreeNode.prototype.rayQuery = function(ray, treeTransform, result) {

    // Use aabb query for now.
    // @todo implement real ray query which needs less lookups
    ray.getAABB(tmpAABB);
    tmpAABB.toLocalFrame(treeTransform, tmpAABB);
    this.aabbQuery(tmpAABB, result);

    return result;
};

/**
 * @method removeEmptyNodes
 */
OctreeNode.prototype.removeEmptyNodes = function() {
    var queue = [this];
    while (queue.length) {
        var node = queue.pop();
        for (var i = node.children.length - 1; i >= 0; i--) {
            if(!node.children[i].data.length){
                node.children.splice(i, 1);
            }
        }
        Array.prototype.push.apply(queue, node.children);
    }
};

},{"../collision/AABB":3,"../math/Vec3":30}],51:[function(_dereq_,module,exports){
module.exports = Pool;

/**
 * For pooling objects that can be reused.
 * @class Pool
 * @constructor
 */
function Pool(){
    /**
     * The pooled objects
     * @property {Array} objects
     */
    this.objects = [];

    /**
     * Constructor of the objects
     * @property {mixed} type
     */
    this.type = Object;
}

/**
 * Release an object after use
 * @method release
 * @param {Object} obj
 */
Pool.prototype.release = function(){
    var Nargs = arguments.length;
    for(var i=0; i!==Nargs; i++){
        this.objects.push(arguments[i]);
    }
};

/**
 * Get an object
 * @method get
 * @return {mixed}
 */
Pool.prototype.get = function(){
    if(this.objects.length===0){
        return this.constructObject();
    } else {
        return this.objects.pop();
    }
};

/**
 * Construct an object. Should be implmented in each subclass.
 * @method constructObject
 * @return {mixed}
 */
Pool.prototype.constructObject = function(){
    throw new Error("constructObject() not implemented in this Pool subclass yet!");
};

},{}],52:[function(_dereq_,module,exports){
module.exports = TupleDictionary;

/**
 * @class TupleDictionary
 * @constructor
 */
function TupleDictionary() {

    /**
     * The data storage
     * @property data
     * @type {Object}
     */
    this.data = { keys:[] };
}

/**
 * @method get
 * @param  {Number} i
 * @param  {Number} j
 * @return {Number}
 */
TupleDictionary.prototype.get = function(i, j) {
    if (i > j) {
        // swap
        var temp = j;
        j = i;
        i = temp;
    }
    return this.data[i+'-'+j];
};

/**
 * @method set
 * @param  {Number} i
 * @param  {Number} j
 * @param {Number} value
 */
TupleDictionary.prototype.set = function(i, j, value) {
    if (i > j) {
        var temp = j;
        j = i;
        i = temp;
    }
    var key = i+'-'+j;

    // Check if key already exists
    if(!this.get(i,j)){
        this.data.keys.push(key);
    }

    this.data[key] = value;
};

/**
 * @method reset
 */
TupleDictionary.prototype.reset = function() {
    var data = this.data,
        keys = data.keys;
    while(keys.length > 0){
        var key = keys.pop();
        delete data[key];
    }
};

},{}],53:[function(_dereq_,module,exports){
function Utils(){}

module.exports = Utils;

/**
 * Extend an options object with default values.
 * @static
 * @method defaults
 * @param  {object} options The options object. May be falsy: in this case, a new object is created and returned.
 * @param  {object} defaults An object containing default values.
 * @return {object} The modified options object.
 */
Utils.defaults = function(options, defaults){
    options = options || {};

    for(var key in defaults){
        if(!(key in options)){
            options[key] = defaults[key];
        }
    }

    return options;
};

},{}],54:[function(_dereq_,module,exports){
module.exports = Vec3Pool;

var Vec3 = _dereq_('../math/Vec3');
var Pool = _dereq_('./Pool');

/**
 * @class Vec3Pool
 * @constructor
 * @extends Pool
 */
function Vec3Pool(){
    Pool.call(this);
    this.type = Vec3;
}
Vec3Pool.prototype = new Pool();

/**
 * Construct a vector
 * @method constructObject
 * @return {Vec3}
 */
Vec3Pool.prototype.constructObject = function(){
    return new Vec3();
};

},{"../math/Vec3":30,"./Pool":51}],55:[function(_dereq_,module,exports){
module.exports = Narrowphase;

var AABB = _dereq_('../collision/AABB');
var Shape = _dereq_('../shapes/Shape');
var Ray = _dereq_('../collision/Ray');
var Vec3 = _dereq_('../math/Vec3');
var Transform = _dereq_('../math/Transform');
var ConvexPolyhedron = _dereq_('../shapes/ConvexPolyhedron');
var Quaternion = _dereq_('../math/Quaternion');
var Solver = _dereq_('../solver/Solver');
var Vec3Pool = _dereq_('../utils/Vec3Pool');
var ContactEquation = _dereq_('../equations/ContactEquation');
var FrictionEquation = _dereq_('../equations/FrictionEquation');

/**
 * Helper class for the World. Generates ContactEquations.
 * @class Narrowphase
 * @constructor
 * @todo Sphere-ConvexPolyhedron contacts
 * @todo Contact reduction
 * @todo  should move methods to prototype
 */
function Narrowphase(world){

    /**
     * Internal storage of pooled contact points.
     * @property {Array} contactPointPool
     */
    this.contactPointPool = [];

    this.frictionEquationPool = [];

    this.result = [];
    this.frictionResult = [];

    /**
     * Pooled vectors.
     * @property {Vec3Pool} v3pool
     */
    this.v3pool = new Vec3Pool();

    this.world = world;
    this.currentContactMaterial = null;

    /**
     * @property {Boolean} enableFrictionReduction
     */
    this.enableFrictionReduction = false;
}

/**
 * Make a contact object, by using the internal pool or creating a new one.
 * @method createContactEquation
 * @return {ContactEquation}
 */
Narrowphase.prototype.createContactEquation = function(bi, bj, si, sj, rsi, rsj){
    var c;
    if(this.contactPointPool.length){
        c = this.contactPointPool.pop();
        c.bi = bi;
        c.bj = bj;
    } else {
        c = new ContactEquation(bi, bj);
    }

    c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

    var cm = this.currentContactMaterial;

    c.restitution = cm.restitution;

    c.setSpookParams(
        cm.contactEquationStiffness,
        cm.contactEquationRelaxation,
        this.world.dt
    );

    var matA = si.material || bi.material;
    var matB = sj.material || bj.material;
    if(matA && matB && matA.restitution >= 0 && matB.restitution >= 0){
        c.restitution = matA.restitution * matB.restitution;
    }

    c.si = rsi || si;
    c.sj = rsj || sj;

    return c;
};

Narrowphase.prototype.createFrictionEquationsFromContact = function(contactEquation, outArray){
    var bodyA = contactEquation.bi;
    var bodyB = contactEquation.bj;
    var shapeA = contactEquation.si;
    var shapeB = contactEquation.sj;

    var world = this.world;
    var cm = this.currentContactMaterial;

    // If friction or restitution were specified in the material, use them
    var friction = cm.friction;
    var matA = shapeA.material || bodyA.material;
    var matB = shapeB.material || bodyB.material;
    if(matA && matB && matA.friction >= 0 && matB.friction >= 0){
        friction = matA.friction * matB.friction;
    }

    if(friction > 0){

        // Create 2 tangent equations
        var mug = friction * world.gravity.length();
        var reducedMass = (bodyA.invMass + bodyB.invMass);
        if(reducedMass > 0){
            reducedMass = 1/reducedMass;
        }
        var pool = this.frictionEquationPool;
        var c1 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);
        var c2 = pool.length ? pool.pop() : new FrictionEquation(bodyA,bodyB,mug*reducedMass);

        c1.bi = c2.bi = bodyA;
        c1.bj = c2.bj = bodyB;
        c1.minForce = c2.minForce = -mug*reducedMass;
        c1.maxForce = c2.maxForce = mug*reducedMass;

        // Copy over the relative vectors
        c1.ri.copy(contactEquation.ri);
        c1.rj.copy(contactEquation.rj);
        c2.ri.copy(contactEquation.ri);
        c2.rj.copy(contactEquation.rj);

        // Construct tangents
        contactEquation.ni.tangents(c1.t, c2.t);

        // Set spook params
        c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);
        c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, world.dt);

        c1.enabled = c2.enabled = contactEquation.enabled;

        outArray.push(c1, c2);

        return true;
    }

    return false;
};

var averageNormal = new Vec3();
var averageContactPointA = new Vec3();
var averageContactPointB = new Vec3();

// Take the average N latest contact point on the plane.
Narrowphase.prototype.createFrictionFromAverage = function(numContacts){
    // The last contactEquation
    var c = this.result[this.result.length - 1];

    // Create the result: two "average" friction equations
    if (!this.createFrictionEquationsFromContact(c, this.frictionResult) || numContacts === 1) {
        return;
    }

    var f1 = this.frictionResult[this.frictionResult.length - 2];
    var f2 = this.frictionResult[this.frictionResult.length - 1];

    averageNormal.setZero();
    averageContactPointA.setZero();
    averageContactPointB.setZero();

    var bodyA = c.bi;
    var bodyB = c.bj;
    for(var i=0; i!==numContacts; i++){
        c = this.result[this.result.length - 1 - i];
        if(c.bodyA !== bodyA){
            averageNormal.vadd(c.ni, averageNormal); // vec2.add(eq.t, eq.t, c.normalA);
            averageContactPointA.vadd(c.ri, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            averageContactPointB.vadd(c.rj, averageContactPointB);
        } else {
            averageNormal.vsub(c.ni, averageNormal); // vec2.sub(eq.t, eq.t, c.normalA);
            averageContactPointA.vadd(c.rj, averageContactPointA); // vec2.add(eq.contactPointA, eq.contactPointA, c.contactPointA);
            averageContactPointB.vadd(c.ri, averageContactPointB);
        }
    }

    var invNumContacts = 1 / numContacts;
    averageContactPointA.scale(invNumContacts, f1.ri); // vec2.scale(eq.contactPointA, eq.contactPointA, invNumContacts);
    averageContactPointB.scale(invNumContacts, f1.rj); // vec2.scale(eq.contactPointB, eq.contactPointB, invNumContacts);
    f2.ri.copy(f1.ri); // Should be the same
    f2.rj.copy(f1.rj);
    averageNormal.normalize();
    averageNormal.tangents(f1.t, f2.t);
    // return eq;
};


var tmpVec1 = new Vec3();
var tmpVec2 = new Vec3();
var tmpQuat1 = new Quaternion();
var tmpQuat2 = new Quaternion();

/**
 * Generate all contacts between a list of body pairs
 * @method getContacts
 * @param {array} p1 Array of body indices
 * @param {array} p2 Array of body indices
 * @param {World} world
 * @param {array} result Array to store generated contacts
 * @param {array} oldcontacts Optional. Array of reusable contact objects
 */
Narrowphase.prototype.getContacts = function(p1, p2, world, result, oldcontacts, frictionResult, frictionPool){
    // Save old contact objects
    this.contactPointPool = oldcontacts;
    this.frictionEquationPool = frictionPool;
    this.result = result;
    this.frictionResult = frictionResult;

    var qi = tmpQuat1;
    var qj = tmpQuat2;
    var xi = tmpVec1;
    var xj = tmpVec2;

    for(var k=0, N=p1.length; k!==N; k++){

        // Get current collision bodies
        var bi = p1[k],
            bj = p2[k];

        // Get contact material
        var bodyContactMaterial = null;
        if(bi.material && bj.material){
            bodyContactMaterial = world.getContactMaterial(bi.material,bj.material) || null;
        }

        for (var i = 0; i < bi.shapes.length; i++) {
            bi.quaternion.mult(bi.shapeOrientations[i], qi);
            bi.quaternion.vmult(bi.shapeOffsets[i], xi);
            xi.vadd(bi.position, xi);
            var si = bi.shapes[i];

            for (var j = 0; j < bj.shapes.length; j++) {

                // Compute world transform of shapes
                bj.quaternion.mult(bj.shapeOrientations[j], qj);
                bj.quaternion.vmult(bj.shapeOffsets[j], xj);
                xj.vadd(bj.position, xj);
                var sj = bj.shapes[j];

                if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
                    continue;
                }

                // Get collision material
                var shapeContactMaterial = null;
                if(si.material && sj.material){
                    shapeContactMaterial = world.getContactMaterial(si.material,sj.material) || null;
                }

                this.currentContactMaterial = shapeContactMaterial || bodyContactMaterial || world.defaultContactMaterial;

                // Get contacts
                var resolver = this[si.type | sj.type];
                if(resolver){
                    if (si.type < sj.type) {
                        resolver.call(this, si, sj, xi, xj, qi, qj, bi, bj, si, sj);
                    } else {
                        resolver.call(this, sj, si, xj, xi, qj, qi, bj, bi, si, sj);
                    }
                }
            }
        }
    }
};

var numWarnings = 0;
var maxWarnings = 10;

function warn(msg){
    if(numWarnings > maxWarnings){
        return;
    }

    numWarnings++;

    console.warn(msg);
}

Narrowphase.prototype[Shape.types.BOX | Shape.types.BOX] =
Narrowphase.prototype.boxBox = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    sj.convexPolyhedronRepresentation.material = sj.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    this.convexConvex(si.convexPolyhedronRepresentation,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj,si,sj);
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.boxConvex = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexConvex(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.PARTICLE] =
Narrowphase.prototype.boxParticle = function(si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexParticle(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj,si,sj);
};

/**
 * @method sphereSphere
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE] =
Narrowphase.prototype.sphereSphere = function(si,sj,xi,xj,qi,qj,bi,bj){
    // We will have only one contact in this case
    var r = this.createContactEquation(bi,bj,si,sj);

    // Contact normal
    xj.vsub(xi, r.ni);
    r.ni.normalize();

    // Contact point locations
    r.ri.copy(r.ni);
    r.rj.copy(r.ni);
    r.ri.mult(si.radius, r.ri);
    r.rj.mult(-sj.radius, r.rj);

    r.ri.vadd(xi, r.ri);
    r.ri.vsub(bi.position, r.ri);

    r.rj.vadd(xj, r.rj);
    r.rj.vsub(bj.position, r.rj);

    this.result.push(r);

    this.createFrictionEquationsFromContact(r, this.frictionResult);
};

/**
 * @method planeTrimesh
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
var planeTrimesh_normal = new Vec3();
var planeTrimesh_relpos = new Vec3();
var planeTrimesh_projected = new Vec3();
Narrowphase.prototype[Shape.types.PLANE | Shape.types.TRIMESH] =
Narrowphase.prototype.planeTrimesh = function(
    planeShape,
    trimeshShape,
    planePos,
    trimeshPos,
    planeQuat,
    trimeshQuat,
    planeBody,
    trimeshBody
){
    // Make contacts!
    var v = new Vec3();

    var normal = planeTrimesh_normal;
    normal.set(0,0,1);
    planeQuat.vmult(normal,normal); // Turn normal according to plane

    for(var i=0; i<trimeshShape.vertices.length / 3; i++){

        // Get world vertex from trimesh
        trimeshShape.getVertex(i, v);

        // Safe up
        var v2 = new Vec3();
        v2.copy(v);
        Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

        // Check plane side
        var relpos = planeTrimesh_relpos;
        v.vsub(planePos, relpos);
        var dot = normal.dot(relpos);

        if(dot <= 0.0){
            var r = this.createContactEquation(planeBody,trimeshBody,planeShape,trimeshShape);

            r.ni.copy(normal); // Contact normal is the plane normal

            // Get vertex position projected on plane
            var projected = planeTrimesh_projected;
            normal.scale(relpos.dot(normal), projected);
            v.vsub(projected,projected);

            // ri is the projected world position minus plane position
            r.ri.copy(projected);
            r.ri.vsub(planeBody.position, r.ri);

            r.rj.copy(v);
            r.rj.vsub(trimeshBody.position, r.rj);

            // Store result
            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
    }
};

/**
 * @method sphereTrimesh
 * @param  {Shape}      sphereShape
 * @param  {Shape}      trimeshShape
 * @param  {Vec3}       spherePos
 * @param  {Vec3}       trimeshPos
 * @param  {Quaternion} sphereQuat
 * @param  {Quaternion} trimeshQuat
 * @param  {Body}       sphereBody
 * @param  {Body}       trimeshBody
 */
var sphereTrimesh_normal = new Vec3();
var sphereTrimesh_relpos = new Vec3();
var sphereTrimesh_projected = new Vec3();
var sphereTrimesh_v = new Vec3();
var sphereTrimesh_v2 = new Vec3();
var sphereTrimesh_edgeVertexA = new Vec3();
var sphereTrimesh_edgeVertexB = new Vec3();
var sphereTrimesh_edgeVector = new Vec3();
var sphereTrimesh_edgeVectorUnit = new Vec3();
var sphereTrimesh_localSpherePos = new Vec3();
var sphereTrimesh_tmp = new Vec3();
var sphereTrimesh_va = new Vec3();
var sphereTrimesh_vb = new Vec3();
var sphereTrimesh_vc = new Vec3();
var sphereTrimesh_localSphereAABB = new AABB();
var sphereTrimesh_triangles = [];
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.TRIMESH] =
Narrowphase.prototype.sphereTrimesh = function (
    sphereShape,
    trimeshShape,
    spherePos,
    trimeshPos,
    sphereQuat,
    trimeshQuat,
    sphereBody,
    trimeshBody
) {

    var edgeVertexA = sphereTrimesh_edgeVertexA;
    var edgeVertexB = sphereTrimesh_edgeVertexB;
    var edgeVector = sphereTrimesh_edgeVector;
    var edgeVectorUnit = sphereTrimesh_edgeVectorUnit;
    var localSpherePos = sphereTrimesh_localSpherePos;
    var tmp = sphereTrimesh_tmp;
    var localSphereAABB = sphereTrimesh_localSphereAABB;
    var v2 = sphereTrimesh_v2;
    var relpos = sphereTrimesh_relpos;
    var triangles = sphereTrimesh_triangles;

    // Convert sphere position to local in the trimesh
    Transform.pointToLocalFrame(trimeshPos, trimeshQuat, spherePos, localSpherePos);

    // Get the aabb of the sphere locally in the trimesh
    var sphereRadius = sphereShape.radius;
    localSphereAABB.lowerBound.set(
        localSpherePos.x - sphereRadius,
        localSpherePos.y - sphereRadius,
        localSpherePos.z - sphereRadius
    );
    localSphereAABB.upperBound.set(
        localSpherePos.x + sphereRadius,
        localSpherePos.y + sphereRadius,
        localSpherePos.z + sphereRadius
    );

    trimeshShape.getTrianglesInAABB(localSphereAABB, triangles);
    //for (var i = 0; i < trimeshShape.indices.length / 3; i++) triangles.push(i); // All

    // Vertices
    var v = sphereTrimesh_v;
    var radiusSquared = sphereShape.radius * sphereShape.radius;
    for(var i=0; i<triangles.length; i++){
        for (var j = 0; j < 3; j++) {

            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], v);

            // Check vertex overlap in sphere
            v.vsub(localSpherePos, relpos);

            if(relpos.norm2() <= radiusSquared){

                // Safe up
                v2.copy(v);
                Transform.pointToWorldFrame(trimeshPos, trimeshQuat, v2, v);

                v.vsub(spherePos, relpos);

                var r = this.createContactEquation(sphereBody,trimeshBody,sphereShape,trimeshShape);
                r.ni.copy(relpos);
                r.ni.normalize();

                // ri is the vector from sphere center to the sphere surface
                r.ri.copy(r.ni);
                r.ri.scale(sphereShape.radius, r.ri);
                r.ri.vadd(spherePos, r.ri);
                r.ri.vsub(sphereBody.position, r.ri);

                r.rj.copy(v);
                r.rj.vsub(trimeshBody.position, r.rj);

                // Store result
                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
    }

    // Check all edges
    for(var i=0; i<triangles.length; i++){
        for (var j = 0; j < 3; j++) {

            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + j], edgeVertexA);
            trimeshShape.getVertex(trimeshShape.indices[triangles[i] * 3 + ((j+1)%3)], edgeVertexB);
            edgeVertexB.vsub(edgeVertexA, edgeVector);

            // Project sphere position to the edge
            localSpherePos.vsub(edgeVertexB, tmp);
            var positionAlongEdgeB = tmp.dot(edgeVector);

            localSpherePos.vsub(edgeVertexA, tmp);
            var positionAlongEdgeA = tmp.dot(edgeVector);

            if(positionAlongEdgeA > 0 && positionAlongEdgeB < 0){

                // Now check the orthogonal distance from edge to sphere center
                localSpherePos.vsub(edgeVertexA, tmp);

                edgeVectorUnit.copy(edgeVector);
                edgeVectorUnit.normalize();
                positionAlongEdgeA = tmp.dot(edgeVectorUnit);

                edgeVectorUnit.scale(positionAlongEdgeA, tmp);
                tmp.vadd(edgeVertexA, tmp);

                // tmp is now the sphere center position projected to the edge, defined locally in the trimesh frame
                var dist = tmp.distanceTo(localSpherePos);
                if(dist < sphereShape.radius){
                    var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);

                    tmp.vsub(localSpherePos, r.ni);
                    r.ni.normalize();
                    r.ni.scale(sphereShape.radius, r.ri);

                    Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
                    tmp.vsub(trimeshBody.position, r.rj);

                    Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
                    Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
            }
        }
    }

    // Triangle faces
    var va = sphereTrimesh_va;
    var vb = sphereTrimesh_vb;
    var vc = sphereTrimesh_vc;
    var normal = sphereTrimesh_normal;
    for(var i=0, N = triangles.length; i !== N; i++){
        trimeshShape.getTriangleVertices(triangles[i], va, vb, vc);
        trimeshShape.getNormal(triangles[i], normal);
        localSpherePos.vsub(va, tmp);
        var dist = tmp.dot(normal);
        normal.scale(dist, tmp);
        localSpherePos.vsub(tmp, tmp);

        // tmp is now the sphere position projected to the triangle plane
        dist = tmp.distanceTo(localSpherePos);
        if(Ray.pointInTriangle(tmp, va, vb, vc) && dist < sphereShape.radius){
            var r = this.createContactEquation(sphereBody, trimeshBody, sphereShape, trimeshShape);

            tmp.vsub(localSpherePos, r.ni);
            r.ni.normalize();
            r.ni.scale(sphereShape.radius, r.ri);

            Transform.pointToWorldFrame(trimeshPos, trimeshQuat, tmp, tmp);
            tmp.vsub(trimeshBody.position, r.rj);

            Transform.vectorToWorldFrame(trimeshQuat, r.ni, r.ni);
            Transform.vectorToWorldFrame(trimeshQuat, r.ri, r.ri);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        }
    }

    triangles.length = 0;
};

var point_on_plane_to_sphere = new Vec3();
var plane_to_sphere_ortho = new Vec3();

/**
 * @method spherePlane
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.PLANE] =
Narrowphase.prototype.spherePlane = function(si,sj,xi,xj,qi,qj,bi,bj){
    // We will have one contact in this case
    var r = this.createContactEquation(bi,bj,si,sj);

    // Contact normal
    r.ni.set(0,0,1);
    qj.vmult(r.ni, r.ni);
    r.ni.negate(r.ni); // body i is the sphere, flip normal
    r.ni.normalize(); // Needed?

    // Vector from sphere center to contact point
    r.ni.mult(si.radius, r.ri);

    // Project down sphere on plane
    xi.vsub(xj, point_on_plane_to_sphere);
    r.ni.mult(r.ni.dot(point_on_plane_to_sphere), plane_to_sphere_ortho);
    point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,r.rj); // The sphere position projected to plane

    if(-point_on_plane_to_sphere.dot(r.ni) <= si.radius){

        // Make it relative to the body
        var ri = r.ri;
        var rj = r.rj;
        ri.vadd(xi, ri);
        ri.vsub(bi.position, ri);
        rj.vadd(xj, rj);
        rj.vsub(bj.position, rj);

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

// See http://bulletphysics.com/Bullet/BulletFull/SphereTriangleDetector_8cpp_source.html
var pointInPolygon_edge = new Vec3();
var pointInPolygon_edge_x_normal = new Vec3();
var pointInPolygon_vtp = new Vec3();
function pointInPolygon(verts, normal, p){
    var positiveResult = null;
    var N = verts.length;
    for(var i=0; i!==N; i++){
        var v = verts[i];

        // Get edge to the next vertex
        var edge = pointInPolygon_edge;
        verts[(i+1) % (N)].vsub(v,edge);

        // Get cross product between polygon normal and the edge
        var edge_x_normal = pointInPolygon_edge_x_normal;
        //var edge_x_normal = new Vec3();
        edge.cross(normal,edge_x_normal);

        // Get vector between point and current vertex
        var vertex_to_p = pointInPolygon_vtp;
        p.vsub(v,vertex_to_p);

        // This dot product determines which side of the edge the point is
        var r = edge_x_normal.dot(vertex_to_p);

        // If all such dot products have same sign, we are inside the polygon.
        if(positiveResult===null || (r>0 && positiveResult===true) || (r<=0 && positiveResult===false)){
            if(positiveResult===null){
                positiveResult = r>0;
            }
            continue;
        } else {
            return false; // Encountered some other sign. Exit.
        }
    }

    // If we got here, all dot products were of the same sign.
    return true;
}

var box_to_sphere = new Vec3();
var sphereBox_ns = new Vec3();
var sphereBox_ns1 = new Vec3();
var sphereBox_ns2 = new Vec3();
var sphereBox_sides = [new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3(),new Vec3()];
var sphereBox_sphere_to_corner = new Vec3();
var sphereBox_side_ns = new Vec3();
var sphereBox_side_ns1 = new Vec3();
var sphereBox_side_ns2 = new Vec3();

/**
 * @method sphereBox
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.BOX] =
Narrowphase.prototype.sphereBox = function(si,sj,xi,xj,qi,qj,bi,bj){
    var v3pool = this.v3pool;

    // we refer to the box as body j
    var sides = sphereBox_sides;
    xi.vsub(xj,box_to_sphere);
    sj.getSideNormals(sides,qj);
    var R =     si.radius;
    var penetrating_sides = [];

    // Check side (plane) intersections
    var found = false;

    // Store the resulting side penetration info
    var side_ns = sphereBox_side_ns;
    var side_ns1 = sphereBox_side_ns1;
    var side_ns2 = sphereBox_side_ns2;
    var side_h = null;
    var side_penetrations = 0;
    var side_dot1 = 0;
    var side_dot2 = 0;
    var side_distance = null;
    for(var idx=0,nsides=sides.length; idx!==nsides && found===false; idx++){
        // Get the plane side normal (ns)
        var ns = sphereBox_ns;
        ns.copy(sides[idx]);

        var h = ns.norm();
        ns.normalize();

        // The normal/distance dot product tells which side of the plane we are
        var dot = box_to_sphere.dot(ns);

        if(dot<h+R && dot>0){
            // Intersects plane. Now check the other two dimensions
            var ns1 = sphereBox_ns1;
            var ns2 = sphereBox_ns2;
            ns1.copy(sides[(idx+1)%3]);
            ns2.copy(sides[(idx+2)%3]);
            var h1 = ns1.norm();
            var h2 = ns2.norm();
            ns1.normalize();
            ns2.normalize();
            var dot1 = box_to_sphere.dot(ns1);
            var dot2 = box_to_sphere.dot(ns2);
            if(dot1<h1 && dot1>-h1 && dot2<h2 && dot2>-h2){
                var dist = Math.abs(dot-h-R);
                if(side_distance===null || dist < side_distance){
                    side_distance = dist;
                    side_dot1 = dot1;
                    side_dot2 = dot2;
                    side_h = h;
                    side_ns.copy(ns);
                    side_ns1.copy(ns1);
                    side_ns2.copy(ns2);
                    side_penetrations++;
                }
            }
        }
    }
    if(side_penetrations){
        found = true;
        var r = this.createContactEquation(bi,bj,si,sj);
        side_ns.mult(-R,r.ri); // Sphere r
        r.ni.copy(side_ns);
        r.ni.negate(r.ni); // Normal should be out of sphere
        side_ns.mult(side_h,side_ns);
        side_ns1.mult(side_dot1,side_ns1);
        side_ns.vadd(side_ns1,side_ns);
        side_ns2.mult(side_dot2,side_ns2);
        side_ns.vadd(side_ns2,r.rj);

        // Make relative to bodies
        r.ri.vadd(xi, r.ri);
        r.ri.vsub(bi.position, r.ri);
        r.rj.vadd(xj, r.rj);
        r.rj.vsub(bj.position, r.rj);

        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }

    // Check corners
    var rj = v3pool.get();
    var sphere_to_corner = sphereBox_sphere_to_corner;
    for(var j=0; j!==2 && !found; j++){
        for(var k=0; k!==2 && !found; k++){
            for(var l=0; l!==2 && !found; l++){
                rj.set(0,0,0);
                if(j){
                    rj.vadd(sides[0],rj);
                } else {
                    rj.vsub(sides[0],rj);
                }
                if(k){
                    rj.vadd(sides[1],rj);
                } else {
                    rj.vsub(sides[1],rj);
                }
                if(l){
                    rj.vadd(sides[2],rj);
                } else {
                    rj.vsub(sides[2],rj);
                }

                // World position of corner
                xj.vadd(rj,sphere_to_corner);
                sphere_to_corner.vsub(xi,sphere_to_corner);

                if(sphere_to_corner.norm2() < R*R){
                    found = true;
                    var r = this.createContactEquation(bi,bj,si,sj);
                    r.ri.copy(sphere_to_corner);
                    r.ri.normalize();
                    r.ni.copy(r.ri);
                    r.ri.mult(R,r.ri);
                    r.rj.copy(rj);

                    // Make relative to bodies
                    r.ri.vadd(xi, r.ri);
                    r.ri.vsub(bi.position, r.ri);
                    r.rj.vadd(xj, r.rj);
                    r.rj.vsub(bj.position, r.rj);

                    this.result.push(r);
                    this.createFrictionEquationsFromContact(r, this.frictionResult);
                }
            }
        }
    }
    v3pool.release(rj);
    rj = null;

    // Check edges
    var edgeTangent = v3pool.get();
    var edgeCenter = v3pool.get();
    var r = v3pool.get(); // r = edge center to sphere center
    var orthogonal = v3pool.get();
    var dist = v3pool.get();
    var Nsides = sides.length;
    for(var j=0; j!==Nsides && !found; j++){
        for(var k=0; k!==Nsides && !found; k++){
            if(j%3 !== k%3){
                // Get edge tangent
                sides[k].cross(sides[j],edgeTangent);
                edgeTangent.normalize();
                sides[j].vadd(sides[k], edgeCenter);
                r.copy(xi);
                r.vsub(edgeCenter,r);
                r.vsub(xj,r);
                var orthonorm = r.dot(edgeTangent); // distance from edge center to sphere center in the tangent direction
                edgeTangent.mult(orthonorm,orthogonal); // Vector from edge center to sphere center in the tangent direction

                // Find the third side orthogonal to this one
                var l = 0;
                while(l===j%3 || l===k%3){
                    l++;
                }

                // vec from edge center to sphere projected to the plane orthogonal to the edge tangent
                dist.copy(xi);
                dist.vsub(orthogonal,dist);
                dist.vsub(edgeCenter,dist);
                dist.vsub(xj,dist);

                // Distances in tangent direction and distance in the plane orthogonal to it
                var tdist = Math.abs(orthonorm);
                var ndist = dist.norm();

                if(tdist < sides[l].norm() && ndist<R){
                    found = true;
                    var res = this.createContactEquation(bi,bj,si,sj);
                    edgeCenter.vadd(orthogonal,res.rj); // box rj
                    res.rj.copy(res.rj);
                    dist.negate(res.ni);
                    res.ni.normalize();

                    res.ri.copy(res.rj);
                    res.ri.vadd(xj,res.ri);
                    res.ri.vsub(xi,res.ri);
                    res.ri.normalize();
                    res.ri.mult(R,res.ri);

                    // Make relative to bodies
                    res.ri.vadd(xi, res.ri);
                    res.ri.vsub(bi.position, res.ri);
                    res.rj.vadd(xj, res.rj);
                    res.rj.vsub(bj.position, res.rj);

                    this.result.push(res);
                    this.createFrictionEquationsFromContact(res, this.frictionResult);
                }
            }
        }
    }
    v3pool.release(edgeTangent,edgeCenter,r,orthogonal,dist);
};

var convex_to_sphere = new Vec3();
var sphereConvex_edge = new Vec3();
var sphereConvex_edgeUnit = new Vec3();
var sphereConvex_sphereToCorner = new Vec3();
var sphereConvex_worldCorner = new Vec3();
var sphereConvex_worldNormal = new Vec3();
var sphereConvex_worldPoint = new Vec3();
var sphereConvex_worldSpherePointClosestToPlane = new Vec3();
var sphereConvex_penetrationVec = new Vec3();
var sphereConvex_sphereToWorldPoint = new Vec3();

/**
 * @method sphereConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.sphereConvex = function(si,sj,xi,xj,qi,qj,bi,bj){
    var v3pool = this.v3pool;
    xi.vsub(xj,convex_to_sphere);
    var normals = sj.faceNormals;
    var faces = sj.faces;
    var verts = sj.vertices;
    var R =     si.radius;
    var penetrating_sides = [];

    // if(convex_to_sphere.norm2() > si.boundingSphereRadius + sj.boundingSphereRadius){
    //     return;
    // }

    // Check corners
    for(var i=0; i!==verts.length; i++){
        var v = verts[i];

        // World position of corner
        var worldCorner = sphereConvex_worldCorner;
        qj.vmult(v,worldCorner);
        xj.vadd(worldCorner,worldCorner);
        var sphere_to_corner = sphereConvex_sphereToCorner;
        worldCorner.vsub(xi, sphere_to_corner);
        if(sphere_to_corner.norm2() < R * R){
            found = true;
            var r = this.createContactEquation(bi,bj,si,sj);
            r.ri.copy(sphere_to_corner);
            r.ri.normalize();
            r.ni.copy(r.ri);
            r.ri.mult(R,r.ri);
            worldCorner.vsub(xj,r.rj);

            // Should be relative to the body.
            r.ri.vadd(xi, r.ri);
            r.ri.vsub(bi.position, r.ri);

            // Should be relative to the body.
            r.rj.vadd(xj, r.rj);
            r.rj.vsub(bj.position, r.rj);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
            return;
        }
    }

    // Check side (plane) intersections
    var found = false;
    for(var i=0, nfaces=faces.length; i!==nfaces && found===false; i++){
        var normal = normals[i];
        var face = faces[i];

        // Get world-transformed normal of the face
        var worldNormal = sphereConvex_worldNormal;
        qj.vmult(normal,worldNormal);

        // Get a world vertex from the face
        var worldPoint = sphereConvex_worldPoint;
        qj.vmult(verts[face[0]],worldPoint);
        worldPoint.vadd(xj,worldPoint);

        // Get a point on the sphere, closest to the face normal
        var worldSpherePointClosestToPlane = sphereConvex_worldSpherePointClosestToPlane;
        worldNormal.mult(-R, worldSpherePointClosestToPlane);
        xi.vadd(worldSpherePointClosestToPlane, worldSpherePointClosestToPlane);

        // Vector from a face point to the closest point on the sphere
        var penetrationVec = sphereConvex_penetrationVec;
        worldSpherePointClosestToPlane.vsub(worldPoint,penetrationVec);

        // The penetration. Negative value means overlap.
        var penetration = penetrationVec.dot(worldNormal);

        var worldPointToSphere = sphereConvex_sphereToWorldPoint;
        xi.vsub(worldPoint, worldPointToSphere);

        if(penetration < 0 && worldPointToSphere.dot(worldNormal)>0){
            // Intersects plane. Now check if the sphere is inside the face polygon
            var faceVerts = []; // Face vertices, in world coords
            for(var j=0, Nverts=face.length; j!==Nverts; j++){
                var worldVertex = v3pool.get();
                qj.vmult(verts[face[j]], worldVertex);
                xj.vadd(worldVertex,worldVertex);
                faceVerts.push(worldVertex);
            }

            if(pointInPolygon(faceVerts,worldNormal,xi)){ // Is the sphere center in the face polygon?
                found = true;
                var r = this.createContactEquation(bi,bj,si,sj);

                worldNormal.mult(-R, r.ri); // Contact offset, from sphere center to contact
                worldNormal.negate(r.ni); // Normal pointing out of sphere

                var penetrationVec2 = v3pool.get();
                worldNormal.mult(-penetration, penetrationVec2);
                var penetrationSpherePoint = v3pool.get();
                worldNormal.mult(-R, penetrationSpherePoint);

                //xi.vsub(xj).vadd(penetrationSpherePoint).vadd(penetrationVec2 , r.rj);
                xi.vsub(xj,r.rj);
                r.rj.vadd(penetrationSpherePoint,r.rj);
                r.rj.vadd(penetrationVec2 , r.rj);

                // Should be relative to the body.
                r.rj.vadd(xj, r.rj);
                r.rj.vsub(bj.position, r.rj);

                // Should be relative to the body.
                r.ri.vadd(xi, r.ri);
                r.ri.vsub(bi.position, r.ri);

                v3pool.release(penetrationVec2);
                v3pool.release(penetrationSpherePoint);

                this.result.push(r);
                this.createFrictionEquationsFromContact(r, this.frictionResult);

                // Release world vertices
                for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                    v3pool.release(faceVerts[j]);
                }

                return; // We only expect *one* face contact
            } else {
                // Edge?
                for(var j=0; j!==face.length; j++){

                    // Get two world transformed vertices
                    var v1 = v3pool.get();
                    var v2 = v3pool.get();
                    qj.vmult(verts[face[(j+1)%face.length]], v1);
                    qj.vmult(verts[face[(j+2)%face.length]], v2);
                    xj.vadd(v1, v1);
                    xj.vadd(v2, v2);

                    // Construct edge vector
                    var edge = sphereConvex_edge;
                    v2.vsub(v1,edge);

                    // Construct the same vector, but normalized
                    var edgeUnit = sphereConvex_edgeUnit;
                    edge.unit(edgeUnit);

                    // p is xi projected onto the edge
                    var p = v3pool.get();
                    var v1_to_xi = v3pool.get();
                    xi.vsub(v1, v1_to_xi);
                    var dot = v1_to_xi.dot(edgeUnit);
                    edgeUnit.mult(dot, p);
                    p.vadd(v1, p);

                    // Compute a vector from p to the center of the sphere
                    var xi_to_p = v3pool.get();
                    p.vsub(xi, xi_to_p);

                    // Collision if the edge-sphere distance is less than the radius
                    // AND if p is in between v1 and v2
                    if(dot > 0 && dot*dot<edge.norm2() && xi_to_p.norm2() < R*R){ // Collision if the edge-sphere distance is less than the radius
                        // Edge contact!
                        var r = this.createContactEquation(bi,bj,si,sj);
                        p.vsub(xj,r.rj);

                        p.vsub(xi,r.ni);
                        r.ni.normalize();

                        r.ni.mult(R,r.ri);

                        // Should be relative to the body.
                        r.rj.vadd(xj, r.rj);
                        r.rj.vsub(bj.position, r.rj);

                        // Should be relative to the body.
                        r.ri.vadd(xi, r.ri);
                        r.ri.vsub(bi.position, r.ri);

                        this.result.push(r);
                        this.createFrictionEquationsFromContact(r, this.frictionResult);

                        // Release world vertices
                        for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                            v3pool.release(faceVerts[j]);
                        }

                        v3pool.release(v1);
                        v3pool.release(v2);
                        v3pool.release(p);
                        v3pool.release(xi_to_p);
                        v3pool.release(v1_to_xi);

                        return;
                    }

                    v3pool.release(v1);
                    v3pool.release(v2);
                    v3pool.release(p);
                    v3pool.release(xi_to_p);
                    v3pool.release(v1_to_xi);
                }
            }

            // Release world vertices
            for(var j=0, Nfaceverts=faceVerts.length; j!==Nfaceverts; j++){
                v3pool.release(faceVerts[j]);
            }
        }
    }
};

var planeBox_normal = new Vec3();
var plane_to_corner = new Vec3();

/**
 * @method planeBox
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.BOX] =
Narrowphase.prototype.planeBox = function(si,sj,xi,xj,qi,qj,bi,bj){
    sj.convexPolyhedronRepresentation.material = sj.material;
    sj.convexPolyhedronRepresentation.collisionResponse = sj.collisionResponse;
    this.planeConvex(si,sj.convexPolyhedronRepresentation,xi,xj,qi,qj,bi,bj);
};

var planeConvex_v = new Vec3();
var planeConvex_normal = new Vec3();
var planeConvex_relpos = new Vec3();
var planeConvex_projected = new Vec3();

/**
 * @method planeConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.planeConvex = function(
    planeShape,
    convexShape,
    planePosition,
    convexPosition,
    planeQuat,
    convexQuat,
    planeBody,
    convexBody
){
    // Simply return the points behind the plane.
    var worldVertex = planeConvex_v,
        worldNormal = planeConvex_normal;
    worldNormal.set(0,0,1);
    planeQuat.vmult(worldNormal,worldNormal); // Turn normal according to plane orientation

    var numContacts = 0;
    var relpos = planeConvex_relpos;
    for(var i = 0; i !== convexShape.vertices.length; i++){

        // Get world convex vertex
        worldVertex.copy(convexShape.vertices[i]);
        convexQuat.vmult(worldVertex, worldVertex);
        convexPosition.vadd(worldVertex, worldVertex);
        worldVertex.vsub(planePosition, relpos);

        var dot = worldNormal.dot(relpos);
        if(dot <= 0.0){

            var r = this.createContactEquation(planeBody, convexBody, planeShape, convexShape);

            // Get vertex position projected on plane
            var projected = planeConvex_projected;
            worldNormal.mult(worldNormal.dot(relpos),projected);
            worldVertex.vsub(projected, projected);
            projected.vsub(planePosition, r.ri); // From plane to vertex projected on plane

            r.ni.copy(worldNormal); // Contact normal is the plane normal out from plane

            // rj is now just the vector from the convex center to the vertex
            worldVertex.vsub(convexPosition, r.rj);

            // Make it relative to the body
            r.ri.vadd(planePosition, r.ri);
            r.ri.vsub(planeBody.position, r.ri);
            r.rj.vadd(convexPosition, r.rj);
            r.rj.vsub(convexBody.position, r.rj);

            this.result.push(r);
            numContacts++;
            if(!this.enableFrictionReduction){
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
    }

    if(this.enableFrictionReduction && numContacts){
        this.createFrictionFromAverage(numContacts);
    }
};

var convexConvex_sepAxis = new Vec3();
var convexConvex_q = new Vec3();

/**
 * @method convexConvex
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.convexConvex = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
    var sepAxis = convexConvex_sepAxis;

    if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
        return;
    }

    if(si.findSeparatingAxis(sj,xi,qi,xj,qj,sepAxis,faceListA,faceListB)){
        var res = [];
        var q = convexConvex_q;
        si.clipAgainstHull(xi,qi,sj,xj,qj,sepAxis,-100,100,res);
        var numContacts = 0;
        for(var j = 0; j !== res.length; j++){
            var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
                ri = r.ri,
                rj = r.rj;
            sepAxis.negate(r.ni);
            res[j].normal.negate(q);
            q.mult(res[j].depth, q);
            res[j].point.vadd(q, ri);
            rj.copy(res[j].point);

            // Contact points are in world coordinates. Transform back to relative
            ri.vsub(xi,ri);
            rj.vsub(xj,rj);

            // Make relative to bodies
            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);

            this.result.push(r);
            numContacts++;
            if(!this.enableFrictionReduction){
                this.createFrictionEquationsFromContact(r, this.frictionResult);
            }
        }
        if(this.enableFrictionReduction && numContacts){
            this.createFrictionFromAverage(numContacts);
        }
    }
};


/**
 * @method convexTrimesh
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
// Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.TRIMESH] =
// Narrowphase.prototype.convexTrimesh = function(si,sj,xi,xj,qi,qj,bi,bj,rsi,rsj,faceListA,faceListB){
//     var sepAxis = convexConvex_sepAxis;

//     if(xi.distanceTo(xj) > si.boundingSphereRadius + sj.boundingSphereRadius){
//         return;
//     }

//     // Construct a temp hull for each triangle
//     var hullB = new ConvexPolyhedron();

//     hullB.faces = [[0,1,2]];
//     var va = new Vec3();
//     var vb = new Vec3();
//     var vc = new Vec3();
//     hullB.vertices = [
//         va,
//         vb,
//         vc
//     ];

//     for (var i = 0; i < sj.indices.length / 3; i++) {

//         var triangleNormal = new Vec3();
//         sj.getNormal(i, triangleNormal);
//         hullB.faceNormals = [triangleNormal];

//         sj.getTriangleVertices(i, va, vb, vc);

//         var d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);
//         if(!d){
//             triangleNormal.scale(-1, triangleNormal);
//             d = si.testSepAxis(triangleNormal, hullB, xi, qi, xj, qj);

//             if(!d){
//                 continue;
//             }
//         }

//         var res = [];
//         var q = convexConvex_q;
//         si.clipAgainstHull(xi,qi,hullB,xj,qj,triangleNormal,-100,100,res);
//         for(var j = 0; j !== res.length; j++){
//             var r = this.createContactEquation(bi,bj,si,sj,rsi,rsj),
//                 ri = r.ri,
//                 rj = r.rj;
//             r.ni.copy(triangleNormal);
//             r.ni.negate(r.ni);
//             res[j].normal.negate(q);
//             q.mult(res[j].depth, q);
//             res[j].point.vadd(q, ri);
//             rj.copy(res[j].point);

//             // Contact points are in world coordinates. Transform back to relative
//             ri.vsub(xi,ri);
//             rj.vsub(xj,rj);

//             // Make relative to bodies
//             ri.vadd(xi, ri);
//             ri.vsub(bi.position, ri);
//             rj.vadd(xj, rj);
//             rj.vsub(bj.position, rj);

//             result.push(r);
//         }
//     }
// };

var particlePlane_normal = new Vec3();
var particlePlane_relpos = new Vec3();
var particlePlane_projected = new Vec3();

/**
 * @method particlePlane
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PLANE | Shape.types.PARTICLE] =
Narrowphase.prototype.planeParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
    var normal = particlePlane_normal;
    normal.set(0,0,1);
    bj.quaternion.vmult(normal,normal); // Turn normal according to plane orientation
    var relpos = particlePlane_relpos;
    xi.vsub(bj.position,relpos);
    var dot = normal.dot(relpos);
    if(dot <= 0.0){
        var r = this.createContactEquation(bi,bj,si,sj);
        r.ni.copy(normal); // Contact normal is the plane normal
        r.ni.negate(r.ni);
        r.ri.set(0,0,0); // Center of particle

        // Get particle position projected on plane
        var projected = particlePlane_projected;
        normal.mult(normal.dot(xi),projected);
        xi.vsub(projected,projected);
        //projected.vadd(bj.position,projected);

        // rj is now the projected world position minus plane position
        r.rj.copy(projected);
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

var particleSphere_normal = new Vec3();

/**
 * @method particleSphere
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.SPHERE] =
Narrowphase.prototype.sphereParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
    // The normal is the unit vector from sphere center to particle center
    var normal = particleSphere_normal;
    normal.set(0,0,1);
    xi.vsub(xj,normal);
    var lengthSquared = normal.norm2();

    if(lengthSquared <= sj.radius * sj.radius){
        var r = this.createContactEquation(bi,bj,si,sj);
        normal.normalize();
        r.rj.copy(normal);
        r.rj.mult(sj.radius,r.rj);
        r.ni.copy(normal); // Contact normal
        r.ni.negate(r.ni);
        r.ri.set(0,0,0); // Center of particle
        this.result.push(r);
        this.createFrictionEquationsFromContact(r, this.frictionResult);
    }
};

// WIP
var cqj = new Quaternion();
var convexParticle_local = new Vec3();
var convexParticle_normal = new Vec3();
var convexParticle_penetratedFaceNormal = new Vec3();
var convexParticle_vertexToParticle = new Vec3();
var convexParticle_worldPenetrationVec = new Vec3();

/**
 * @method convexParticle
 * @param  {Array}      result
 * @param  {Shape}      si
 * @param  {Shape}      sj
 * @param  {Vec3}       xi
 * @param  {Vec3}       xj
 * @param  {Quaternion} qi
 * @param  {Quaternion} qj
 * @param  {Body}       bi
 * @param  {Body}       bj
 */
Narrowphase.prototype[Shape.types.PARTICLE | Shape.types.CONVEXPOLYHEDRON] =
Narrowphase.prototype.convexParticle = function(sj,si,xj,xi,qj,qi,bj,bi){
    var penetratedFaceIndex = -1;
    var penetratedFaceNormal = convexParticle_penetratedFaceNormal;
    var worldPenetrationVec = convexParticle_worldPenetrationVec;
    var minPenetration = null;
    var numDetectedFaces = 0;

    // Convert particle position xi to local coords in the convex
    var local = convexParticle_local;
    local.copy(xi);
    local.vsub(xj,local); // Convert position to relative the convex origin
    qj.conjugate(cqj);
    cqj.vmult(local,local);

    if(sj.pointIsInside(local)){

        if(sj.worldVerticesNeedsUpdate){
            sj.computeWorldVertices(xj,qj);
        }
        if(sj.worldFaceNormalsNeedsUpdate){
            sj.computeWorldFaceNormals(qj);
        }

        // For each world polygon in the polyhedra
        for(var i=0,nfaces=sj.faces.length; i!==nfaces; i++){

            // Construct world face vertices
            var verts = [ sj.worldVertices[ sj.faces[i][0] ] ];
            var normal = sj.worldFaceNormals[i];

            // Check how much the particle penetrates the polygon plane.
            xi.vsub(verts[0],convexParticle_vertexToParticle);
            var penetration = -normal.dot(convexParticle_vertexToParticle);
            if(minPenetration===null || Math.abs(penetration)<Math.abs(minPenetration)){
                minPenetration = penetration;
                penetratedFaceIndex = i;
                penetratedFaceNormal.copy(normal);
                numDetectedFaces++;
            }
        }

        if(penetratedFaceIndex!==-1){
            // Setup contact
            var r = this.createContactEquation(bi,bj,si,sj);
            penetratedFaceNormal.mult(minPenetration, worldPenetrationVec);

            // rj is the particle position projected to the face
            worldPenetrationVec.vadd(xi,worldPenetrationVec);
            worldPenetrationVec.vsub(xj,worldPenetrationVec);
            r.rj.copy(worldPenetrationVec);
            //var projectedToFace = xi.vsub(xj).vadd(worldPenetrationVec);
            //projectedToFace.copy(r.rj);

            //qj.vmult(r.rj,r.rj);
            penetratedFaceNormal.negate( r.ni ); // Contact normal
            r.ri.set(0,0,0); // Center of particle

            var ri = r.ri,
                rj = r.rj;

            // Make relative to bodies
            ri.vadd(xi, ri);
            ri.vsub(bi.position, ri);
            rj.vadd(xj, rj);
            rj.vsub(bj.position, rj);

            this.result.push(r);
            this.createFrictionEquationsFromContact(r, this.frictionResult);
        } else {
            console.warn("Point found inside convex, but did not find penetrating face!");
        }
    }
};

Narrowphase.prototype[Shape.types.BOX | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.boxHeightfield = function (si,sj,xi,xj,qi,qj,bi,bj){
    si.convexPolyhedronRepresentation.material = si.material;
    si.convexPolyhedronRepresentation.collisionResponse = si.collisionResponse;
    this.convexHeightfield(si.convexPolyhedronRepresentation,sj,xi,xj,qi,qj,bi,bj);
};

var convexHeightfield_tmp1 = new Vec3();
var convexHeightfield_tmp2 = new Vec3();
var convexHeightfield_faceList = [0];

/**
 * @method convexHeightfield
 */
Narrowphase.prototype[Shape.types.CONVEXPOLYHEDRON | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.convexHeightfield = function (
    convexShape,
    hfShape,
    convexPos,
    hfPos,
    convexQuat,
    hfQuat,
    convexBody,
    hfBody
){
    var data = hfShape.data,
        w = hfShape.elementSize,
        radius = convexShape.boundingSphereRadius,
        worldPillarOffset = convexHeightfield_tmp2,
        faceList = convexHeightfield_faceList;

    // Get sphere position to heightfield local!
    var localConvexPos = convexHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, convexPos, localConvexPos);

    // Get the index of the data points to test against
    var iMinX = Math.floor((localConvexPos.x - radius) / w) - 1,
        iMaxX = Math.ceil((localConvexPos.x + radius) / w) + 1,
        iMinY = Math.floor((localConvexPos.y - radius) / w) - 1,
        iMaxY = Math.ceil((localConvexPos.y + radius) / w) + 1;

    // Bail out if we are out of the terrain
    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMinY > data[0].length){
        return;
    }

    // Clamp index to edges
    if(iMinX < 0){ iMinX = 0; }
    if(iMaxX < 0){ iMaxX = 0; }
    if(iMinY < 0){ iMinY = 0; }
    if(iMaxY < 0){ iMaxY = 0; }
    if(iMinX >= data.length){ iMinX = data.length - 1; }
    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

    var minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // Bail out if we're cant touch the bounding height box
    if(localConvexPos.z - radius > max || localConvexPos.z + radius < min){
        return;
    }

    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            // Lower triangle
            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
            }

            // Upper triangle
            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (convexPos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + convexShape.boundingSphereRadius) {
                this.convexConvex(convexShape, hfShape.pillarConvex, convexPos, worldPillarOffset, convexQuat, hfQuat, convexBody, hfBody, null, null, faceList, null);
            }
        }
    }
};

var sphereHeightfield_tmp1 = new Vec3();
var sphereHeightfield_tmp2 = new Vec3();

/**
 * @method sphereHeightfield
 */
Narrowphase.prototype[Shape.types.SPHERE | Shape.types.HEIGHTFIELD] =
Narrowphase.prototype.sphereHeightfield = function (
    sphereShape,
    hfShape,
    spherePos,
    hfPos,
    sphereQuat,
    hfQuat,
    sphereBody,
    hfBody
){
    var data = hfShape.data,
        radius = sphereShape.radius,
        w = hfShape.elementSize,
        worldPillarOffset = sphereHeightfield_tmp2;

    // Get sphere position to heightfield local!
    var localSpherePos = sphereHeightfield_tmp1;
    Transform.pointToLocalFrame(hfPos, hfQuat, spherePos, localSpherePos);

    // Get the index of the data points to test against
    var iMinX = Math.floor((localSpherePos.x - radius) / w) - 1,
        iMaxX = Math.ceil((localSpherePos.x + radius) / w) + 1,
        iMinY = Math.floor((localSpherePos.y - radius) / w) - 1,
        iMaxY = Math.ceil((localSpherePos.y + radius) / w) + 1;

    // Bail out if we are out of the terrain
    if(iMaxX < 0 || iMaxY < 0 || iMinX > data.length || iMaxY > data[0].length){
        return;
    }

    // Clamp index to edges
    if(iMinX < 0){ iMinX = 0; }
    if(iMaxX < 0){ iMaxX = 0; }
    if(iMinY < 0){ iMinY = 0; }
    if(iMaxY < 0){ iMaxY = 0; }
    if(iMinX >= data.length){ iMinX = data.length - 1; }
    if(iMaxX >= data.length){ iMaxX = data.length - 1; }
    if(iMaxY >= data[0].length){ iMaxY = data[0].length - 1; }
    if(iMinY >= data[0].length){ iMinY = data[0].length - 1; }

    var minMax = [];
    hfShape.getRectMinMax(iMinX, iMinY, iMaxX, iMaxY, minMax);
    var min = minMax[0];
    var max = minMax[1];

    // Bail out if we're cant touch the bounding height box
    if(localSpherePos.z - radius > max || localSpherePos.z + radius < min){
        return;
    }

    var result = this.result;
    for(var i = iMinX; i < iMaxX; i++){
        for(var j = iMinY; j < iMaxY; j++){

            var numContactsBefore = result.length;

            // Lower triangle
            hfShape.getConvexTrianglePillar(i, j, false);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
            }

            // Upper triangle
            hfShape.getConvexTrianglePillar(i, j, true);
            Transform.pointToWorldFrame(hfPos, hfQuat, hfShape.pillarOffset, worldPillarOffset);
            if (spherePos.distanceTo(worldPillarOffset) < hfShape.pillarConvex.boundingSphereRadius + sphereShape.boundingSphereRadius) {
                this.sphereConvex(sphereShape, hfShape.pillarConvex, spherePos, worldPillarOffset, sphereQuat, hfQuat, sphereBody, hfBody);
            }

            var numContacts = result.length - numContactsBefore;

            if(numContacts > 2){
                return;
            }
            /*
            // Skip all but 1
            for (var k = 0; k < numContacts - 1; k++) {
                result.pop();
            }
            */
        }
    }
};

},{"../collision/AABB":3,"../collision/Ray":9,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../math/Quaternion":28,"../math/Transform":29,"../math/Vec3":30,"../shapes/ConvexPolyhedron":38,"../shapes/Shape":43,"../solver/Solver":47,"../utils/Vec3Pool":54}],56:[function(_dereq_,module,exports){
/* global performance */

module.exports = World;

var Shape = _dereq_('../shapes/Shape');
var Vec3 = _dereq_('../math/Vec3');
var Quaternion = _dereq_('../math/Quaternion');
var GSSolver = _dereq_('../solver/GSSolver');
var Vec3Pool = _dereq_('../utils/Vec3Pool');
var ContactEquation = _dereq_('../equations/ContactEquation');
var FrictionEquation = _dereq_('../equations/FrictionEquation');
var Narrowphase = _dereq_('./Narrowphase');
var EventTarget = _dereq_('../utils/EventTarget');
var ArrayCollisionMatrix = _dereq_('../collision/ArrayCollisionMatrix');
var Material = _dereq_('../material/Material');
var ContactMaterial = _dereq_('../material/ContactMaterial');
var Body = _dereq_('../objects/Body');
var TupleDictionary = _dereq_('../utils/TupleDictionary');
var RaycastResult = _dereq_('../collision/RaycastResult');
var AABB = _dereq_('../collision/AABB');
var Ray = _dereq_('../collision/Ray');
var NaiveBroadphase = _dereq_('../collision/NaiveBroadphase');

/**
 * The physics world
 * @class World
 * @constructor
 * @extends EventTarget
 */
function World(){
    EventTarget.apply(this);

    /**
     * Currently / last used timestep. Is set to -1 if not available. This value is updated before each internal step, which means that it is "fresh" inside event callbacks.
     * @property {Number} dt
     */
    this.dt = -1;

    /**
     * Makes bodies go to sleep when they've been inactive
     * @property allowSleep
     * @type {Boolean}
     */
    this.allowSleep = false;

    /**
     * All the current contacts (instances of ContactEquation) in the world.
     * @property contacts
     * @type {Array}
     */
    this.contacts = [];
    this.frictionEquations = [];

    /**
     * How often to normalize quaternions. Set to 0 for every step, 1 for every second etc.. A larger value increases performance. If bodies tend to explode, set to a smaller value (zero to be sure nothing can go wrong).
     * @property quatNormalizeSkip
     * @type {Number}
     */
    this.quatNormalizeSkip = 0;

    /**
     * Set to true to use fast quaternion normalization. It is often enough accurate to use. If bodies tend to explode, set to false.
     * @property quatNormalizeFast
     * @type {Boolean}
     * @see Quaternion.normalizeFast
     * @see Quaternion.normalize
     */
    this.quatNormalizeFast = false;

    /**
     * The wall-clock time since simulation start
     * @property time
     * @type {Number}
     */
    this.time = 0.0;

    /**
     * Number of timesteps taken since start
     * @property stepnumber
     * @type {Number}
     */
    this.stepnumber = 0;

    /// Default and last timestep sizes
    this.default_dt = 1/60;

    this.nextId = 0;
    /**
     * @property gravity
     * @type {Vec3}
     */
    this.gravity = new Vec3();

    /**
     * @property broadphase
     * @type {Broadphase}
     */
    this.broadphase = new NaiveBroadphase();

    /**
     * @property bodies
     * @type {Array}
     */
    this.bodies = [];

    /**
     * @property solver
     * @type {Solver}
     */
    this.solver = new GSSolver();

    /**
     * @property constraints
     * @type {Array}
     */
    this.constraints = [];

    /**
     * @property narrowphase
     * @type {Narrowphase}
     */
    this.narrowphase = new Narrowphase(this);

    /**
     * @property {ArrayCollisionMatrix} collisionMatrix
	 * @type {ArrayCollisionMatrix}
	 */
	this.collisionMatrix = new ArrayCollisionMatrix();

    /**
     * CollisionMatrix from the previous step.
     * @property {ArrayCollisionMatrix} collisionMatrixPrevious
	 * @type {ArrayCollisionMatrix}
	 */
	this.collisionMatrixPrevious = new ArrayCollisionMatrix();

    /**
     * All added materials
     * @property materials
     * @type {Array}
     */
    this.materials = [];

    /**
     * @property contactmaterials
     * @type {Array}
     */
    this.contactmaterials = [];

    /**
     * Used to look up a ContactMaterial given two instances of Material.
     * @property {TupleDictionary} contactMaterialTable
     */
    this.contactMaterialTable = new TupleDictionary();

    this.defaultMaterial = new Material("default");

    /**
     * This contact material is used if no suitable contactmaterial is found for a contact.
     * @property defaultContactMaterial
     * @type {ContactMaterial}
     */
    this.defaultContactMaterial = new ContactMaterial(this.defaultMaterial, this.defaultMaterial, { friction: 0.3, restitution: 0.0 });

    /**
     * @property doProfiling
     * @type {Boolean}
     */
    this.doProfiling = false;

    /**
     * @property profile
     * @type {Object}
     */
    this.profile = {
        solve:0,
        makeContactConstraints:0,
        broadphase:0,
        integrate:0,
        narrowphase:0,
    };

    /**
     * @property subsystems
     * @type {Array}
     */
    this.subsystems = [];

    this.addBodyEvent = {
        type:"addBody",
        body : null,
    };

    this.removeBodyEvent = {
        type:"removeBody",
        body : null,
    };
}
World.prototype = new EventTarget();

// Temp stuff
var tmpAABB1 = new AABB();
var tmpArray1 = [];
var tmpRay = new Ray();

/**
 * Get the contact material between materials m1 and m2
 * @method getContactMaterial
 * @param {Material} m1
 * @param {Material} m2
 * @return {ContactMaterial} The contact material if it was found.
 */
World.prototype.getContactMaterial = function(m1,m2){
    return this.contactMaterialTable.get(m1.id,m2.id); //this.contactmaterials[this.mats2cmat[i+j*this.materials.length]];
};

/**
 * Get number of objects in the world.
 * @method numObjects
 * @return {Number}
 * @deprecated
 */
World.prototype.numObjects = function(){
    return this.bodies.length;
};

/**
 * Store old collision state info
 * @method collisionMatrixTick
 */
World.prototype.collisionMatrixTick = function(){
	var temp = this.collisionMatrixPrevious;
	this.collisionMatrixPrevious = this.collisionMatrix;
	this.collisionMatrix = temp;
	this.collisionMatrix.reset();
};

/**
 * Add a rigid body to the simulation.
 * @method add
 * @param {Body} body
 * @todo If the simulation has not yet started, why recrete and copy arrays for each body? Accumulate in dynamic arrays in this case.
 * @todo Adding an array of bodies should be possible. This would save some loops too
 * @deprecated Use .addBody instead
 */
World.prototype.add = World.prototype.addBody = function(body){
    if(this.bodies.indexOf(body) !== -1){
        return;
    }
    body.index = this.bodies.length;
    this.bodies.push(body);
    body.world = this;
    body.initPosition.copy(body.position);
    body.initVelocity.copy(body.velocity);
    body.timeLastSleepy = this.time;
    if(body instanceof Body){
        body.initAngularVelocity.copy(body.angularVelocity);
        body.initQuaternion.copy(body.quaternion);
    }
	this.collisionMatrix.setNumObjects(this.bodies.length);
    this.addBodyEvent.body = body;
    this.dispatchEvent(this.addBodyEvent);
};

/**
 * Add a constraint to the simulation.
 * @method addConstraint
 * @param {Constraint} c
 */
World.prototype.addConstraint = function(c){
    this.constraints.push(c);
};

/**
 * Removes a constraint
 * @method removeConstraint
 * @param {Constraint} c
 */
World.prototype.removeConstraint = function(c){
    var idx = this.constraints.indexOf(c);
    if(idx!==-1){
        this.constraints.splice(idx,1);
    }
};

/**
 * Raycast test
 * @method rayTest
 * @param {Vec3} from
 * @param {Vec3} to
 * @param {Function|RaycastResult} result
 * @deprecated Use .raycastAll, .raycastClosest or .raycastAny instead.
 */
World.prototype.rayTest = function(from, to, result){
    if(result instanceof RaycastResult){
        // Do raycastclosest
        this.raycastClosest(from, to, {
            skipBackfaces: true
        }, result);
    } else {
        // Do raycastAll
        this.raycastAll(from, to, {
            skipBackfaces: true
        }, result);
    }
};

/**
 * Ray cast against all bodies. The provided callback will be executed for each hit with a RaycastResult as single argument.
 * @method raycastAll
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {Function} callback
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAll = function(from, to, options, callback){
    options.mode = Ray.ALL;
    options.from = from;
    options.to = to;
    options.callback = callback;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and stop at the first result. Note that the order is random - but the method is fast.
 * @method raycastAny
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastAny = function(from, to, options, result){
    options.mode = Ray.ANY;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Ray cast, and return information of the closest hit.
 * @method raycastClosest
 * @param  {Vec3} from
 * @param  {Vec3} to
 * @param  {Object} options
 * @param  {number} [options.collisionFilterMask=-1]
 * @param  {number} [options.collisionFilterGroup=-1]
 * @param  {boolean} [options.skipBackfaces=false]
 * @param  {boolean} [options.checkCollisionResponse=true]
 * @param  {RaycastResult} result
 * @return {boolean} True if any body was hit.
 */
World.prototype.raycastClosest = function(from, to, options, result){
    options.mode = Ray.CLOSEST;
    options.from = from;
    options.to = to;
    options.result = result;
    return tmpRay.intersectWorld(this, options);
};

/**
 * Remove a rigid body from the simulation.
 * @method remove
 * @param {Body} body
 * @deprecated Use .removeBody instead
 */
World.prototype.remove = function(body){
    body.world = null;
    var n = this.bodies.length-1,
        bodies = this.bodies,
        idx = bodies.indexOf(body);
    if(idx !== -1){
        bodies.splice(idx, 1); // Todo: should use a garbage free method

        // Recompute index
        for(var i=0; i!==bodies.length; i++){
            bodies[i].index = i;
        }

        this.collisionMatrix.setNumObjects(n);
        this.removeBodyEvent.body = body;
        this.dispatchEvent(this.removeBodyEvent);
    }
};

/**
 * Remove a rigid body from the simulation.
 * @method removeBody
 * @param {Body} body
 */
World.prototype.removeBody = World.prototype.remove;

/**
 * Adds a material to the World.
 * @method addMaterial
 * @param {Material} m
 * @todo Necessary?
 */
World.prototype.addMaterial = function(m){
    this.materials.push(m);
};

/**
 * Adds a contact material to the World
 * @method addContactMaterial
 * @param {ContactMaterial} cmat
 */
World.prototype.addContactMaterial = function(cmat) {

    // Add contact material
    this.contactmaterials.push(cmat);

    // Add current contact material to the material table
    this.contactMaterialTable.set(cmat.materials[0].id,cmat.materials[1].id,cmat);
};

// performance.now()
if(typeof performance === 'undefined'){
    performance = {};
}
if(!performance.now){
    var nowOffset = Date.now();
    if (performance.timing && performance.timing.navigationStart){
        nowOffset = performance.timing.navigationStart;
    }
    performance.now = function(){
        return Date.now() - nowOffset;
    };
}

var step_tmp1 = new Vec3();

/**
 * Step the physics world forward in time.
 *
 * There are two modes. The simple mode is fixed timestepping without interpolation. In this case you only use the first argument. The second case uses interpolation. In that you also provide the time since the function was last used, as well as the maximum fixed timesteps to take.
 *
 * @method step
 * @param {Number} dt                       The fixed time step size to use.
 * @param {Number} [timeSinceLastCalled]    The time elapsed since the function was last called.
 * @param {Number} [maxSubSteps=10]         Maximum number of fixed steps to take per function call.
 *
 * @example
 *     // fixed timestepping without interpolation
 *     world.step(1/60);
 *
 * @see http://bulletphysics.org/mediawiki-1.5.8/index.php/Stepping_The_World
 */
World.prototype.step = function(dt, timeSinceLastCalled, maxSubSteps){
    maxSubSteps = maxSubSteps || 10;
    timeSinceLastCalled = timeSinceLastCalled || 0;

    if(timeSinceLastCalled === 0){ // Fixed, simple stepping

        this.internalStep(dt);

        // Increment time
        this.time += dt;

    } else {

        // Compute the number of fixed steps we should have taken since the last step
        var internalSteps = Math.floor((this.time + timeSinceLastCalled) / dt) - Math.floor(this.time / dt);
        internalSteps = Math.min(internalSteps,maxSubSteps);

        // Do some fixed steps to catch up
        var t0 = performance.now();
        for(var i=0; i!==internalSteps; i++){
            this.internalStep(dt);
            if(performance.now() - t0 > dt * 1000){
                // We are slower than real-time. Better bail out.
                break;
            }
        }

        // Increment internal clock
        this.time += timeSinceLastCalled;

        // Compute "Left over" time step
        var h = this.time % dt;
        var h_div_dt = h / dt;
        var interpvelo = step_tmp1;
        var bodies = this.bodies;

        for(var j=0; j !== bodies.length; j++){
            var b = bodies[j];
            if(b.type !== Body.STATIC && b.sleepState !== Body.SLEEPING){

                // Interpolate
                b.position.vsub(b.previousPosition, interpvelo);
                interpvelo.scale(h_div_dt, interpvelo);
                b.position.vadd(interpvelo, b.interpolatedPosition);

                // TODO: interpolate quaternion
                // b.interpolatedAngle = b.angle + (b.angle - b.previousAngle) * h_div_dt;

            } else {

                // For static bodies, just copy. Who else will do it?
                b.interpolatedPosition.copy(b.position);
                b.interpolatedQuaternion.copy(b.quaternion);
            }
        }
    }
};

/**
 * Step the simulation
 * @method step
 * @param {Number} dt
 */
var World_step_postStepEvent = {type:"postStep"}, // Reusable event objects to save memory
    World_step_preStepEvent = {type:"preStep"},
    World_step_collideEvent = {type:"collide", body:null, contact:null },
    World_step_oldContacts = [], // Pools for unused objects
    World_step_frictionEquationPool = [],
    World_step_p1 = [], // Reusable arrays for collision pairs
    World_step_p2 = [],
    World_step_gvec = new Vec3(), // Temporary vectors and quats
    World_step_vi = new Vec3(),
    World_step_vj = new Vec3(),
    World_step_wi = new Vec3(),
    World_step_wj = new Vec3(),
    World_step_t1 = new Vec3(),
    World_step_t2 = new Vec3(),
    World_step_rixn = new Vec3(),
    World_step_rjxn = new Vec3(),
    World_step_step_q = new Quaternion(),
    World_step_step_w = new Quaternion(),
    World_step_step_wq = new Quaternion(),
    invI_tau_dt = new Vec3();
World.prototype.internalStep = function(dt){
    this.dt = dt;

    var world = this,
        that = this,
        contacts = this.contacts,
        p1 = World_step_p1,
        p2 = World_step_p2,
        N = this.numObjects(),
        bodies = this.bodies,
        solver = this.solver,
        gravity = this.gravity,
        doProfiling = this.doProfiling,
        profile = this.profile,
        DYNAMIC = Body.DYNAMIC,
        profilingStart,
        constraints = this.constraints,
        frictionEquationPool = World_step_frictionEquationPool,
        gnorm = gravity.norm(),
        gx = gravity.x,
        gy = gravity.y,
        gz = gravity.z,
        i=0;

    if(doProfiling){
        profilingStart = performance.now();
    }

    // Add gravity to all objects
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.type & DYNAMIC){ // Only for dynamic bodies
            var f = bi.force, m = bi.mass;
            f.x += m*gx;
            f.y += m*gy;
            f.z += m*gz;
        }
    }

    // Update subsystems
    for(var i=0, Nsubsystems=this.subsystems.length; i!==Nsubsystems; i++){
        this.subsystems[i].update();
    }

    // Collision detection
    if(doProfiling){ profilingStart = performance.now(); }
    p1.length = 0; // Clean up pair arrays from last step
    p2.length = 0;
    this.broadphase.collisionPairs(this,p1,p2);
    if(doProfiling){ profile.broadphase = performance.now() - profilingStart; }

    // Remove constrained pairs with collideConnected == false
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        if(!c.collideConnected){
            for(var j = p1.length-1; j>=0; j-=1){
                if( (c.bodyA === p1[j] && c.bodyB === p2[j]) ||
                    (c.bodyB === p1[j] && c.bodyA === p2[j])){
                    p1.splice(j, 1);
                    p2.splice(j, 1);
                }
            }
        }
    }

    this.collisionMatrixTick();

    // Generate contacts
    if(doProfiling){ profilingStart = performance.now(); }
    var oldcontacts = World_step_oldContacts;
    var NoldContacts = contacts.length;

    for(i=0; i!==NoldContacts; i++){
        oldcontacts.push(contacts[i]);
    }
    contacts.length = 0;

    // Transfer FrictionEquation from current list to the pool for reuse
    var NoldFrictionEquations = this.frictionEquations.length;
    for(i=0; i!==NoldFrictionEquations; i++){
        frictionEquationPool.push(this.frictionEquations[i]);
    }
    this.frictionEquations.length = 0;

    this.narrowphase.getContacts(
        p1,
        p2,
        this,
        contacts,
        oldcontacts, // To be reused
        this.frictionEquations,
        frictionEquationPool
    );

    if(doProfiling){
        profile.narrowphase = performance.now() - profilingStart;
    }

    // Loop over all collisions
    if(doProfiling){
        profilingStart = performance.now();
    }

    // Add all friction eqs
    for (var i = 0; i < this.frictionEquations.length; i++) {
        solver.addEquation(this.frictionEquations[i]);
    }

    var ncontacts = contacts.length;
    for(var k=0; k!==ncontacts; k++){

        // Current contact
        var c = contacts[k];

        // Get current collision indeces
        var bi = c.bi,
            bj = c.bj,
            si = c.si,
            sj = c.sj;

        // Get collision properties
        var cm;
        if(bi.material && bj.material){
            cm = this.getContactMaterial(bi.material,bj.material) || this.defaultContactMaterial;
        } else {
            cm = this.defaultContactMaterial;
        }

        // c.enabled = bi.collisionResponse && bj.collisionResponse && si.collisionResponse && sj.collisionResponse;

        var mu = cm.friction;
        // c.restitution = cm.restitution;

        // If friction or restitution were specified in the material, use them
        if(bi.material && bj.material){
            if(bi.material.friction >= 0 && bj.material.friction >= 0){
                mu = bi.material.friction * bj.material.friction;
            }

            if(bi.material.restitution >= 0 && bj.material.restitution >= 0){
                c.restitution = bi.material.restitution * bj.material.restitution;
            }
        }

		// c.setSpookParams(
  //           cm.contactEquationStiffness,
  //           cm.contactEquationRelaxation,
  //           dt
  //       );

		solver.addEquation(c);

		// // Add friction constraint equation
		// if(mu > 0){

		// 	// Create 2 tangent equations
		// 	var mug = mu * gnorm;
		// 	var reducedMass = (bi.invMass + bj.invMass);
		// 	if(reducedMass > 0){
		// 		reducedMass = 1/reducedMass;
		// 	}
		// 	var pool = frictionEquationPool;
		// 	var c1 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
		// 	var c2 = pool.length ? pool.pop() : new FrictionEquation(bi,bj,mug*reducedMass);
		// 	this.frictionEquations.push(c1, c2);

		// 	c1.bi = c2.bi = bi;
		// 	c1.bj = c2.bj = bj;
		// 	c1.minForce = c2.minForce = -mug*reducedMass;
		// 	c1.maxForce = c2.maxForce = mug*reducedMass;

		// 	// Copy over the relative vectors
		// 	c1.ri.copy(c.ri);
		// 	c1.rj.copy(c.rj);
		// 	c2.ri.copy(c.ri);
		// 	c2.rj.copy(c.rj);

		// 	// Construct tangents
		// 	c.ni.tangents(c1.t, c2.t);

  //           // Set spook params
  //           c1.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);
  //           c2.setSpookParams(cm.frictionEquationStiffness, cm.frictionEquationRelaxation, dt);

  //           c1.enabled = c2.enabled = c.enabled;

		// 	// Add equations to solver
		// 	solver.addEquation(c1);
		// 	solver.addEquation(c2);
		// }

        if( bi.allowSleep &&
            bi.type === Body.DYNAMIC &&
            bi.sleepState  === Body.SLEEPING &&
            bj.sleepState  === Body.AWAKE &&
            bj.type !== Body.STATIC
        ){
            var speedSquaredB = bj.velocity.norm2() + bj.angularVelocity.norm2();
            var speedLimitSquaredB = Math.pow(bj.sleepSpeedLimit,2);
            if(speedSquaredB >= speedLimitSquaredB*2){
                bi._wakeUpAfterNarrowphase = true;
            }
        }

        if( bj.allowSleep &&
            bj.type === Body.DYNAMIC &&
            bj.sleepState  === Body.SLEEPING &&
            bi.sleepState  === Body.AWAKE &&
            bi.type !== Body.STATIC
        ){
            var speedSquaredA = bi.velocity.norm2() + bi.angularVelocity.norm2();
            var speedLimitSquaredA = Math.pow(bi.sleepSpeedLimit,2);
            if(speedSquaredA >= speedLimitSquaredA*2){
                bj._wakeUpAfterNarrowphase = true;
            }
        }

        // Now we know that i and j are in contact. Set collision matrix state
		this.collisionMatrix.set(bi, bj, true);

        if (!this.collisionMatrixPrevious.get(bi, bj)) {
            // First contact!
            // We reuse the collideEvent object, otherwise we will end up creating new objects for each new contact, even if there's no event listener attached.
            World_step_collideEvent.body = bj;
            World_step_collideEvent.contact = c;
            bi.dispatchEvent(World_step_collideEvent);

            World_step_collideEvent.body = bi;
            bj.dispatchEvent(World_step_collideEvent);
        }
    }
    if(doProfiling){
        profile.makeContactConstraints = performance.now() - profilingStart;
        profilingStart = performance.now();
    }

    // Wake up bodies
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi._wakeUpAfterNarrowphase){
            bi.wakeUp();
            bi._wakeUpAfterNarrowphase = false;
        }
    }

    // Add user-added constraints
    var Nconstraints = constraints.length;
    for(i=0; i!==Nconstraints; i++){
        var c = constraints[i];
        c.update();
        for(var j=0, Neq=c.equations.length; j!==Neq; j++){
            var eq = c.equations[j];
            solver.addEquation(eq);
        }
    }

    // Solve the constrained system
    solver.solve(dt,this);

    if(doProfiling){
        profile.solve = performance.now() - profilingStart;
    }

    // Remove all contacts from solver
    solver.removeAllEquations();

    // Apply damping, see http://code.google.com/p/bullet/issues/detail?id=74 for details
    var pow = Math.pow;
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.type & DYNAMIC){ // Only for dynamic bodies
            var ld = pow(1.0 - bi.linearDamping,dt);
            var v = bi.velocity;
            v.mult(ld,v);
            var av = bi.angularVelocity;
            if(av){
                var ad = pow(1.0 - bi.angularDamping,dt);
                av.mult(ad,av);
            }
        }
    }

    this.dispatchEvent(World_step_preStepEvent);

    // Invoke pre-step callbacks
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        if(bi.preStep){
            bi.preStep.call(bi);
        }
    }

    // Leap frog
    // vnew = v + h*f/m
    // xnew = x + h*vnew
    if(doProfiling){
        profilingStart = performance.now();
    }
    var q = World_step_step_q;
    var w = World_step_step_w;
    var wq = World_step_step_wq;
    var stepnumber = this.stepnumber;
    var DYNAMIC_OR_KINEMATIC = Body.DYNAMIC | Body.KINEMATIC;
    var quatNormalize = stepnumber % (this.quatNormalizeSkip+1) === 0;
    var quatNormalizeFast = this.quatNormalizeFast;
    var half_dt = dt * 0.5;
    var PLANE = Shape.types.PLANE,
        CONVEX = Shape.types.CONVEXPOLYHEDRON;

    for(i=0; i!==N; i++){
        var b = bodies[i],
            force = b.force,
            tau = b.torque;
        if((b.type & DYNAMIC_OR_KINEMATIC) && b.sleepState !== Body.SLEEPING){ // Only for dynamic
            var velo = b.velocity,
                angularVelo = b.angularVelocity,
                pos = b.position,
                quat = b.quaternion,
                invMass = b.invMass,
                invInertia = b.invInertiaWorld;

            velo.x += force.x * invMass * dt;
            velo.y += force.y * invMass * dt;
            velo.z += force.z * invMass * dt;

            if(b.angularVelocity){
                invInertia.vmult(tau,invI_tau_dt);
                invI_tau_dt.mult(dt,invI_tau_dt);
                invI_tau_dt.vadd(angularVelo,angularVelo);
            }

            // Use new velocity  - leap frog
            pos.x += velo.x * dt;
            pos.y += velo.y * dt;
            pos.z += velo.z * dt;

            if(b.angularVelocity){
                w.set(angularVelo.x, angularVelo.y, angularVelo.z, 0);
                w.mult(quat,wq);
                quat.x += half_dt * wq.x;
                quat.y += half_dt * wq.y;
                quat.z += half_dt * wq.z;
                quat.w += half_dt * wq.w;
                if(quatNormalize){
                    if(quatNormalizeFast){
                        quat.normalizeFast();
                    } else {
                        quat.normalize();
                    }
                }
            }

            if(b.aabb){
                b.aabbNeedsUpdate = true;
            }

            // Update world inertia
            if(b.updateInertiaWorld){
                b.updateInertiaWorld();
            }
        }
    }
    this.clearForces();

    this.broadphase.dirty = true;

    if(doProfiling){
        profile.integrate = performance.now() - profilingStart;
    }

    // Update world time
    this.time += dt;
    this.stepnumber += 1;

    this.dispatchEvent(World_step_postStepEvent);

    // Invoke post-step callbacks
    for(i=0; i!==N; i++){
        var bi = bodies[i];
        var postStep = bi.postStep;
        if(postStep){
            postStep.call(bi);
        }
    }

    // Sleeping update
    if(this.allowSleep){
        for(i=0; i!==N; i++){
            bodies[i].sleepTick(this.time);
        }
    }
};

/**
 * Sets all body forces in the world to zero.
 * @method clearForces
 */
World.prototype.clearForces = function(){
    var bodies = this.bodies;
    var N = bodies.length;
    for(var i=0; i !== N; i++){
        var b = bodies[i],
            force = b.force,
            tau = b.torque;

        b.force.set(0,0,0);
        b.torque.set(0,0,0);
    }
};

},{"../collision/AABB":3,"../collision/ArrayCollisionMatrix":4,"../collision/NaiveBroadphase":7,"../collision/Ray":9,"../collision/RaycastResult":10,"../equations/ContactEquation":19,"../equations/FrictionEquation":21,"../material/ContactMaterial":24,"../material/Material":25,"../math/Quaternion":28,"../math/Vec3":30,"../objects/Body":31,"../shapes/Shape":43,"../solver/GSSolver":46,"../utils/EventTarget":49,"../utils/TupleDictionary":52,"../utils/Vec3Pool":54,"./Narrowphase":55}]},{},[2])
(2)
});
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
module.exports = {
  parse: function (cmd) {
    let words = cmd.split(" ")
    let args = []
    for (let word of words) {
      if (word) {
        try {
          args.push(JSON.parse(word))
        } catch (error) {
          if (word !== "=")
            args.push(word)
        }
      }
    }
    return args
  },
  stringifyParam: function (val) {
    return JSON.stringify(val).replaceAll(" ", "\\u0020").replaceAll("\"_", "\"")
  }
}
},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvY2Fubm9uV29ya2VyLmpzIiwic3JjL2xpYnMvY2Fubm9uLmpzIiwic3JjL2xpYnMvY21kQ29kZWMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdDNhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyogZ2xvYmFsIEFGUkFNRSwgVEhSRUUsIENBTk5PTiAqL1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpXG4gIHJldHVyblxuXG5jb25zdCBjbWQgPSByZXF1aXJlKFwiLi9saWJzL2NtZENvZGVjXCIpXG5cbmdsb2JhbC5DQU5OT04gPSByZXF1aXJlKFwiLi9saWJzL2Nhbm5vblwiKVxuZ2xvYmFsLndvcmxkID0gbmV3IENBTk5PTi5Xb3JsZCgpXG5nbG9iYWwuYm9kaWVzID0gW11cbmdsb2JhbC5tb3ZpbmdCb2RpZXMgPSBbXVxuZ2xvYmFsLmpvaW50cyA9IFtdXG5cbmxldCB2ZWMgPSBuZXcgQ0FOTk9OLlZlYzMoKVxubGV0IHF1YXQgPSBuZXcgQ0FOTk9OLlF1YXRlcm5pb24oKVxubGV0IGN5bG9mZiA9IG5ldyBDQU5OT04uUXVhdGVybmlvbigpXG5sZXQgbGFzdFN0ZXAgPSAwXG5cbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGN5bG9mZi5zZXRGcm9tQXhpc0FuZ2xlKG5ldyBDQU5OT04uVmVjMygxLCAwLCAwKSwgTWF0aC5QSSAvIDIpXG4gIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSlcbn1cblxuZnVuY3Rpb24gb25NZXNzYWdlKGUpIHtcbiAgaWYgKHR5cGVvZiBlLmRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICBsZXQgY29tbWFuZCA9IGNtZC5wYXJzZShlLmRhdGEpXG4gICAgc3dpdGNoIChjb21tYW5kLnNoaWZ0KCkpIHtcbiAgICAgIGNhc2UgXCJ3b3JsZFwiOlxuICAgICAgICB3b3JsZENvbW1hbmQoY29tbWFuZClcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoZS5kYXRhIGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSB7XG4gICAgbGV0IGJ1ZmZlciA9IGUuZGF0YVxuICAgIGxldCBub3cgPSBEYXRlLm5vdygpXG4gICAgZm9yIChsZXQgbWlkID0gMDsgbWlkIDwgbW92aW5nQm9kaWVzLmxlbmd0aDsgbWlkKyspIHtcbiAgICAgIGxldCBib2R5ID0gbW92aW5nQm9kaWVzW21pZF1cbiAgICAgIGxldCBwID0gbWlkICogOFxuICAgICAgaWYgKCFib2R5KSBjb250aW51ZVxuICAgICAgaWYgKGJvZHkudHlwZSA9PT0gQ0FOTk9OLkJvZHkuS0lORU1BVElDKSB7XG4gICAgICAgIHZlYy5zZXQoYnVmZmVyW3ArK10sIGJ1ZmZlcltwKytdLCBidWZmZXJbcCsrXSlcbiAgICAgICAgYm9keS5wb3NpdGlvbi5jb3B5KHZlYylcbiAgICAgICAgYnVmZmVyW3ArK10gPSBib2R5LnNsZWVwU3RhdGUgPT09IENBTk5PTi5Cb2R5LlNMRUVQSU5HXG4gICAgICAgIHF1YXQuc2V0KGJ1ZmZlcltwKytdLCBidWZmZXJbcCsrXSwgYnVmZmVyW3ArK10sIGJ1ZmZlcltwKytdKVxuICAgICAgICBib2R5LnF1YXRlcm5pb24uY29weShxdWF0KVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm93IC0gbGFzdFN0ZXAgPCAxMjgpIHtcbiAgICAgIHdvcmxkLnN0ZXAoKG5vdyAtIGxhc3RTdGVwKSAvIDEwMDApXG4gICAgfVxuICAgIGZvciAobGV0IG1pZCA9IDA7IG1pZCA8IG1vdmluZ0JvZGllcy5sZW5ndGg7IG1pZCsrKSB7XG4gICAgICBsZXQgYm9keSA9IG1vdmluZ0JvZGllc1ttaWRdXG4gICAgICBsZXQgcCA9IG1pZCAqIDhcbiAgICAgIGlmICghYm9keSkgY29udGludWVcbiAgICAgIGlmIChib2R5LnR5cGUgIT09IENBTk5PTi5Cb2R5LktJTkVNQVRJQykge1xuICAgICAgICBidWZmZXJbcCsrXSA9IGJvZHkucG9zaXRpb24ueFxuICAgICAgICBidWZmZXJbcCsrXSA9IGJvZHkucG9zaXRpb24ueVxuICAgICAgICBidWZmZXJbcCsrXSA9IGJvZHkucG9zaXRpb24uelxuICAgICAgICBidWZmZXJbcCsrXSA9IGJvZHkuc2xlZXBTdGF0ZSA9PT0gQ0FOTk9OLkJvZHkuU0xFRVBJTkdcbiAgICAgICAgYnVmZmVyW3ArK10gPSBib2R5LnF1YXRlcm5pb24ueFxuICAgICAgICBidWZmZXJbcCsrXSA9IGJvZHkucXVhdGVybmlvbi55XG4gICAgICAgIGJ1ZmZlcltwKytdID0gYm9keS5xdWF0ZXJuaW9uLnpcbiAgICAgICAgYnVmZmVyW3ArK10gPSBib2R5LnF1YXRlcm5pb24ud1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0TWVzc2FnZShidWZmZXIsIFtidWZmZXIuYnVmZmVyXSlcbiAgICBsYXN0U3RlcCA9IG5vd1xuICB9XG59XG5cbmZ1bmN0aW9uIHdvcmxkQ29tbWFuZChwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXNbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICBwYXJhbXMuc2hpZnQoKVxuICB9XG4gIHN3aXRjaCAocGFyYW1zLnNoaWZ0KCkpIHtcbiAgICBjYXNlIFwiYm9keVwiOlxuICAgICAgYm9keUNvbW1hbmQocGFyYW1zKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiam9pbnRcIjpcbiAgICAgIGpvaW50Q29tbWFuZChwYXJhbXMpXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJncmF2aXR5XCI6XG4gICAgICB3b3JsZC5ncmF2aXR5LmNvcHkocGFyYW1zWzBdKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5mdW5jdGlvbiBib2R5Q29tbWFuZChwYXJhbXMpIHtcbiAgbGV0IGlkID0gcGFyYW1zLnNoaWZ0KClcbiAgbGV0IGJvZHkgPSBib2RpZXNbaWRdXG4gIGlmICghYm9keSAmJiBwYXJhbXNbMF0gIT09IFwiY3JlYXRlXCIpIHJldHVyblxuICBzd2l0Y2ggKHBhcmFtcy5zaGlmdCgpKSB7XG4gICAgY2FzZSBcInNoYXBlXCI6XG4gICAgICBzaGFwZUNvbW1hbmQoYm9keSwgcGFyYW1zKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiY3JlYXRlXCI6XG4gICAgICBpZiAoYm9keSkge1xuICAgICAgICB3b3JsZC5yZW1vdmVCb2R5KGJvZHkpXG4gICAgICAgIGlmIChib2R5Ll9taWRfICE9PSBudWxsKVxuICAgICAgICAgIG1vdmluZ0JvZGllc1tib2R5Ll9taWRfXSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGJvZHkgPSBuZXcgQ0FOTk9OLkJvZHkoe1xuICAgICAgICB0eXBlOiBwYXJhbXNbMF0udHlwZSA9PT0gXCJkeW5hbWljXCIgPyBDQU5OT04uQm9keS5EWU5BTUlDIDogcGFyYW1zWzBdLnR5cGUgPT09IFwia2luZW1hdGljXCIgPyBDQU5OT04uQm9keS5LSU5FTUFUSUMgOiBDQU5OT04uQm9keS5TVEFUSUMsXG4gICAgICAgIHNsZWVwU3BlZWRMaW1pdDogMSxcbiAgICAgICAgcG9zaXRpb246IG5ldyBDQU5OT04uVmVjMygpLmNvcHkocGFyYW1zWzBdLnBvc2l0aW9uKSxcbiAgICAgICAgcXVhdGVybmlvbjogbmV3IENBTk5PTi5RdWF0ZXJuaW9uKCkuY29weShwYXJhbXNbMF0ucXVhdGVybmlvbiksXG4gICAgICB9KVxuICAgICAgYm9keS5faWRfID0gaWRcbiAgICAgIGJvZHkuX21pZF8gPSBwYXJhbXNbMF0ubWlkXG4gICAgICBpZiAoYm9keS5fbWlkXyAhPT0gbnVsbClcbiAgICAgICAgbW92aW5nQm9kaWVzW2JvZHkuX21pZF9dID0gYm9keVxuICAgICAgYm9keS5fc2hhcGVzXyA9IFtdXG4gICAgICB3b3JsZC5hZGRCb2R5KGJvZGllc1tpZF0gPSBib2R5KVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwicmVtb3ZlXCI6XG4gICAgICB3b3JsZC5yZW1vdmVCb2R5KGJvZHkpXG4gICAgICBib2RpZXNbaWRdID0gbnVsbFxuICAgICAgaWYgKGJvZHkuX21pZF8gIT09IG51bGwpXG4gICAgICAgIG1vdmluZ0JvZGllc1tib2R5Ll9taWRfXSA9IG51bGxcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICBib2R5LnBvc2l0aW9uLmNvcHkocGFyYW1zWzBdKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwicXVhdGVybmlvblwiOlxuICAgICAgYm9keS5xdWF0ZXJuaW9uLmNvcHkocGFyYW1zWzBdKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwidHlwZVwiOlxuICAgICAgYm9keS50eXBlID0gcGFyYW1zWzBdID09PSBcImR5bmFtaWNcIiA/IENBTk5PTi5Cb2R5LkRZTkFNSUMgOiBwYXJhbXNbMF0gPT09IFwia2luZW1hdGljXCIgPyBDQU5OT04uQm9keS5LSU5FTUFUSUMgOiBDQU5OT04uQm9keS5TVEFUSUNcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIm1hc3NcIjpcbiAgICAgIGJvZHkubWFzcyA9IGJvZHkudHlwZSA9PT0gQ0FOTk9OLkJvZHkuU1RBVElDID8gMCA6IHBhcmFtc1swXVxuICAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJiZWxvbmdzVG9cIjpcbiAgICAgIGJvZHkuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSBwYXJhbXNbMF1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcImNvbGxpZGVzV2l0aFwiOlxuICAgICAgYm9keS5jb2xsaXNpb25GaWx0ZXJNYXNrID0gcGFyYW1zWzBdXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJlbWl0c1dpdGhcIjpcbiAgICAgIGlmIChwYXJhbXNbMF0gJiYgIWJvZHkuX2VtaXRzV2l0aF8pIHtcbiAgICAgICAgYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY29sbGlkZVwiLCBvbkNvbGxpZGUpXG4gICAgICB9XG4gICAgICBpZiAoYm9keS5fZW1pdHNXaXRoXyAmJiAhcGFyYW1zWzBdKSB7XG4gICAgICAgIGJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNvbGxpZGVcIiwgb25Db2xsaWRlKVxuICAgICAgfVxuICAgICAgYm9keS5fZW1pdHNXaXRoXyA9IHBhcmFtc1swXVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwic2xlZXBpbmdcIjpcbiAgICAgIGlmIChwYXJhbXNbMF0pIGJvZHkuc2xlZXAoKVxuICAgICAgZWxzZSBib2R5Lndha2VVcCgpXG4gICAgICBicmVha1xuICB9XG59XG5cbmZ1bmN0aW9uIGpvaW50Q29tbWFuZChwYXJhbXMpIHtcbiAgbGV0IGlkID0gcGFyYW1zLnNoaWZ0KClcbiAgbGV0IGpvaW50ID0gam9pbnRzW2lkXVxuICBpZiAoIWpvaW50ICYmIHBhcmFtc1swXSAhPT0gXCJjcmVhdGVcIikgcmV0dXJuXG4gIHN3aXRjaCAocGFyYW1zLnNoaWZ0KCkpIHtcbiAgICBjYXNlIFwiY3JlYXRlXCI6XG4gICAgICBpZiAoam9pbnQpIHtcbiAgICAgICAgd29ybGQucmVtb3ZlQ29uc3RyYWludChqb2ludClcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAocGFyYW1zWzBdLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImhpbmdlXCI6XG4gICAgICAgICAgam9pbnQgPSBuZXcgQ0FOTk9OLkhpbmdlQ29uc3RyYWludChcbiAgICAgICAgICAgIGJvZGllc1twYXJhbXNbMF0uYm9keTFdLFxuICAgICAgICAgICAgYm9kaWVzW3BhcmFtc1swXS5ib2R5Ml0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHBpdm90QTogbmV3IENBTk5PTi5WZWMzKCkuY29weShwYXJhbXNbMF0ucGl2b3QxKSxcbiAgICAgICAgICAgICAgcGl2b3RCOiBuZXcgQ0FOTk9OLlZlYzMoKS5jb3B5KHBhcmFtc1swXS5waXZvdDIpLFxuICAgICAgICAgICAgICBheGlzQTogbmV3IENBTk5PTi5WZWMzKCkuY29weShwYXJhbXNbMF0uYXhpczEpLFxuICAgICAgICAgICAgICBheGlzQjogbmV3IENBTk5PTi5WZWMzKCkuY29weShwYXJhbXNbMF0uYXhpczIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgXCJkaXN0YW5jZVwiOlxuICAgICAgICAgIGpvaW50ID0gbmV3IENBTk5PTi5EaXN0YW5jZUNvbnN0cmFpbnQoXG4gICAgICAgICAgICBib2RpZXNbcGFyYW1zWzBdLmJvZHkxXSxcbiAgICAgICAgICAgIGJvZGllc1twYXJhbXNbMF0uYm9keTJdXG4gICAgICAgICAgKVxuICAgICAgICAgIGJyZWFrXG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBqb2ludCA9IG5ldyBDQU5OT04uUG9pbnRUb1BvaW50Q29uc3RyYWludChcbiAgICAgICAgICAgIGJvZGllc1twYXJhbXNbMF0uYm9keTFdLFxuICAgICAgICAgICAgbmV3IENBTk5PTi5WZWMzKCkuY29weShwYXJhbXNbMF0ucGl2b3QxKSxcbiAgICAgICAgICAgIGJvZGllc1twYXJhbXNbMF0uYm9keTJdLFxuICAgICAgICAgICAgbmV3IENBTk5PTi5WZWMzKCkuY29weShwYXJhbXNbMF0ucGl2b3QyKVxuICAgICAgICAgIClcbiAgICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgam9pbnQuY29sbGlkZUNvbm5lY3RlZCA9IHBhcmFtc1swXS5jb2xsaXNpb25cbiAgICAgIGpvaW50Ll9pZF8gPSBpZFxuICAgICAgd29ybGQuYWRkQ29uc3RyYWludChqb2ludHNbaWRdID0gam9pbnQpXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgIHdvcmxkLnJlbW92ZUNvbnN0cmFpbnQoam9pbnQpXG4gICAgICBqb2ludHNbaWRdID0gbnVsbFxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGFwZUNvbW1hbmQoYm9keSwgcGFyYW1zKSB7XG4gIGlmICghYm9keSkgcmV0dXJuXG4gIGxldCBpZCA9IHBhcmFtcy5zaGlmdCgpXG4gIGxldCBzaGFwZSA9IGJvZHkuX3NoYXBlc19baWRdXG4gIGlmICghc2hhcGUgJiYgcGFyYW1zWzBdICE9PSBcImNyZWF0ZVwiKSByZXR1cm5cbiAgc3dpdGNoIChwYXJhbXMuc2hpZnQoKSkge1xuICAgIGNhc2UgXCJjcmVhdGVcIjpcbiAgICAgIGlmIChzaGFwZSlcbiAgICAgICAgYm9keS5yZW1vdmVTaGFwZShzaGFwZSlcbiAgICAgIGxldCBxdWF0ID0gKG5ldyBDQU5OT04uUXVhdGVybmlvbigpKS5jb3B5KHBhcmFtc1swXS5xdWF0ZXJuaW9uKVxuICAgICAgc3dpdGNoIChwYXJhbXNbMF0udHlwZSkge1xuICAgICAgICBjYXNlIFwic3BoZXJlXCI6IHNoYXBlID0gbmV3IENBTk5PTi5TcGhlcmUocGFyYW1zWzBdLnNpemUueCAvIDIpOyBicmVha1xuICAgICAgICBjYXNlIFwiY3lsaW5kZXJcIjogc2hhcGUgPSBuZXcgQ0FOTk9OLkN5bGluZGVyKHBhcmFtc1swXS5zaXplLnggLyAyLCBwYXJhbXNbMF0uc2l6ZS54IC8gMiwgcGFyYW1zWzBdLnNpemUueSwgMTYpOyBxdWF0Lm11bHQoY3lsb2ZmLCBxdWF0KTsgYnJlYWtcbiAgICAgICAgZGVmYXVsdDogc2hhcGUgPSBuZXcgQ0FOTk9OLkJveChuZXcgQ0FOTk9OLlZlYzMoKS5jb3B5KHBhcmFtc1swXS5zaXplKS5zY2FsZSgwLjUpKVxuICAgICAgfVxuICAgICAgc2hhcGUuX2lkXyA9IGlkXG4gICAgICBib2R5LmFkZFNoYXBlKGJvZHkuX3NoYXBlc19baWRdID0gc2hhcGUsIChuZXcgQ0FOTk9OLlZlYzMoKSkuY29weShwYXJhbXNbMF0ucG9zaXRpb24pLCBxdWF0KVxuICAgICAgYm9keS51cGRhdGVNYXNzUHJvcGVydGllcygpXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgIGJvZHkucmVtb3ZlU2hhcGUoc2hhcGUpXG4gICAgICBib2R5Ll9zaGFwZXNfW2lkXSA9IG51bGxcbiAgICAgIGJvZHkudXBkYXRlTWFzc1Byb3BlcnRpZXMoKVxuICAgICAgYnJlYWtcbiAgfVxufVxuXG5cblxuXG5mdW5jdGlvbiBvbkNvbGxpZGUoZSkge1xuICBsZXQgYjEgPSBlLmNvbnRhY3QuYmlcbiAgbGV0IGIyID0gZS5jb250YWN0LmJqXG4gIGlmICh0aGlzID09PSBiMSAmJiAoYjEuX2VtaXRzV2l0aF8gJiBiMi5jb2xsaXNpb25GaWx0ZXJHcm91cCkpIHtcbiAgICBwb3N0TWVzc2FnZShcIndvcmxkIGJvZHkgXCIgKyBiMS5faWRfICsgXCIgZW1pdHMgXCIgKyBjbWQuc3RyaW5naWZ5UGFyYW0oe1xuICAgICAgZXZlbnQ6IFwiY29sbGlzaW9uXCIsXG4gICAgICBib2R5MTogYjEuX2lkXyxcbiAgICAgIGJvZHkyOiBiMi5faWRfLFxuICAgICAgc2hhcGUxOiBlLmNvbnRhY3Quc2kuX2lkXyxcbiAgICAgIHNoYXBlMjogZS5jb250YWN0LnNqLl9pZF9cbiAgICB9KSlcbiAgfVxuICBpZiAodGhpcyA9PT0gYjIgJiYgKGIyLl9lbWl0c1dpdGhfICYgYjEuY29sbGlzaW9uRmlsdGVyR3JvdXApKSB7XG4gICAgcG9zdE1lc3NhZ2UoXCJ3b3JsZCBib2R5IFwiICsgYjIuX2lkXyArIFwiIGVtaXRzIFwiICsgY21kLnN0cmluZ2lmeVBhcmFtKHtcbiAgICAgIGV2ZW50OiBcImNvbGxpc2lvblwiLFxuICAgICAgYm9keTE6IGIyLl9pZF8sXG4gICAgICBib2R5MjogYjEuX2lkXyxcbiAgICAgIHNoYXBlMTogZS5jb250YWN0LnNqLl9pZF8sXG4gICAgICBzaGFwZTI6IGUuY29udGFjdC5zaS5faWRfXG4gICAgfSkpXG4gIH1cbn1cbmluaXQoKSIsIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgY2Fubm9uLmpzIEF1dGhvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvblxuICogb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAqIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICogcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksXG4gKiBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXNcbiAqIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gKiBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORFxuICogTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRVxuICogTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTlxuICogT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4gKiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4hZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZmYWxzZSlkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuQ0FOTk9OPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkoezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJjYW5ub25cIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC42LjJcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkEgbGlnaHR3ZWlnaHQgM0QgcGh5c2ljcyBlbmdpbmUgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LlwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qc1wiLFxuICBcImF1dGhvclwiOiBcIlN0ZWZhbiBIZWRtYW4gPHNjaHRlcHBlQGdtYWlsLmNvbT4gKGh0dHA6Ly9zdGVmZmUuc2UpXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwiY2Fubm9uLmpzXCIsXG4gICAgXCJjYW5ub25cIixcbiAgICBcInBoeXNpY3NcIixcbiAgICBcImVuZ2luZVwiLFxuICAgIFwiM2RcIlxuICBdLFxuICBcIm1haW5cIjogXCIuL2J1aWxkL2Nhbm5vbi5qc1wiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIipcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qcy5naXRcIlxuICB9LFxuICBcImJ1Z3NcIjoge1xuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlL2Nhbm5vbi5qcy9pc3N1ZXNcIlxuICB9LFxuICBcImxpY2Vuc2VzXCI6IFtcbiAgICB7XG4gICAgICBcInR5cGVcIjogXCJNSVRcIlxuICAgIH1cbiAgXSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwianNoaW50XCI6IFwibGF0ZXN0XCIsXG4gICAgXCJ1Z2xpZnktanNcIjogXCJsYXRlc3RcIixcbiAgICBcIm5vZGV1bml0XCI6IFwiXjAuOS4wXCIsXG4gICAgXCJncnVudFwiOiBcIn4wLjQuMFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi1qc2hpbnRcIjogXCJ+MC4xLjFcIixcbiAgICBcImdydW50LWNvbnRyaWItbm9kZXVuaXRcIjogXCJeMC40LjFcIixcbiAgICBcImdydW50LWNvbnRyaWItY29uY2F0XCI6IFwifjAuMS4zXCIsXG4gICAgXCJncnVudC1jb250cmliLXVnbGlmeVwiOiBcIl4wLjUuMVwiLFxuICAgIFwiZ3J1bnQtYnJvd3NlcmlmeVwiOiBcIl4yLjEuNFwiLFxuICAgIFwiZ3J1bnQtY29udHJpYi15dWlkb2NcIjogXCJeMC41LjJcIixcbiAgICBcImJyb3dzZXJpZnlcIjogXCIqXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge31cbn1cblxufSx7fV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBFeHBvcnQgY2xhc3Nlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVyc2lvbiA6ICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uLFxuXG4gICAgQUFCQiA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9BQUJCJyksXG4gICAgQXJyYXlDb2xsaXNpb25NYXRyaXggOiAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9BcnJheUNvbGxpc2lvbk1hdHJpeCcpLFxuICAgIEJvZHkgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL0JvZHknKSxcbiAgICBCb3ggOiAgICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0JveCcpLFxuICAgIEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vQnJvYWRwaGFzZScpLFxuICAgIENvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb25zdHJhaW50cy9Db25zdHJhaW50JyksXG4gICAgQ29udGFjdEVxdWF0aW9uIDogICAgICAgICAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKSxcbiAgICBOYXJyb3dwaGFzZSA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vd29ybGQvTmFycm93cGhhc2UnKSxcbiAgICBDb25lVHdpc3RDb25zdHJhaW50IDogICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvQ29uZVR3aXN0Q29uc3RyYWludCcpLFxuICAgIENvbnRhY3RNYXRlcmlhbCA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9Db250YWN0TWF0ZXJpYWwnKSxcbiAgICBDb252ZXhQb2x5aGVkcm9uIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKSxcbiAgICBDeWxpbmRlciA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL0N5bGluZGVyJyksXG4gICAgRGlzdGFuY2VDb25zdHJhaW50IDogICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0Rpc3RhbmNlQ29uc3RyYWludCcpLFxuICAgIEVxdWF0aW9uIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvRXF1YXRpb24nKSxcbiAgICBFdmVudFRhcmdldCA6ICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvRXZlbnRUYXJnZXQnKSxcbiAgICBGcmljdGlvbkVxdWF0aW9uIDogICAgICAgICAgICAgIF9kZXJlcV8oJy4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKSxcbiAgICBHU1NvbHZlciA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL0dTU29sdmVyJyksXG4gICAgR3JpZEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZScpLFxuICAgIEhlaWdodGZpZWxkIDogICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvSGVpZ2h0ZmllbGQnKSxcbiAgICBIaW5nZUNvbnN0cmFpbnQgOiAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50JyksXG4gICAgTG9ja0NvbnN0cmFpbnQgOiAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50JyksXG4gICAgTWF0MyA6ICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL21hdGgvTWF0MycpLFxuICAgIE1hdGVyaWFsIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRlcmlhbC9NYXRlcmlhbCcpLFxuICAgIE5haXZlQnJvYWRwaGFzZSA6ICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyksXG4gICAgT2JqZWN0Q29sbGlzaW9uTWF0cml4IDogICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9PYmplY3RDb2xsaXNpb25NYXRyaXgnKSxcbiAgICBQb29sIDogICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvUG9vbCcpLFxuICAgIFBhcnRpY2xlIDogICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvUGFydGljbGUnKSxcbiAgICBQbGFuZSA6ICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc2hhcGVzL1BsYW5lJyksXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludCA6ICAgICAgICBfZGVyZXFfKCcuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKSxcbiAgICBRdWF0ZXJuaW9uIDogICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vbWF0aC9RdWF0ZXJuaW9uJyksXG4gICAgUmF5IDogICAgICAgICAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL2NvbGxpc2lvbi9SYXknKSxcbiAgICBSYXljYXN0VmVoaWNsZSA6ICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vb2JqZWN0cy9SYXljYXN0VmVoaWNsZScpLFxuICAgIFJheWNhc3RSZXN1bHQgOiAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpLFxuICAgIFJpZ2lkVmVoaWNsZSA6ICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1JpZ2lkVmVoaWNsZScpLFxuICAgIFJvdGF0aW9uYWxFcXVhdGlvbiA6ICAgICAgICAgICAgX2RlcmVxXygnLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyksXG4gICAgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gOiAgICAgICBfZGVyZXFfKCcuL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpLFxuICAgIFNBUEJyb2FkcGhhc2UgOiAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9jb2xsaXNpb24vU0FQQnJvYWRwaGFzZScpLFxuICAgIFNQSFN5c3RlbSA6ICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1NQSFN5c3RlbScpLFxuICAgIFNoYXBlIDogICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvU2hhcGUnKSxcbiAgICBTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vc29sdmVyL1NvbHZlcicpLFxuICAgIFNwaGVyZSA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvU3BoZXJlJyksXG4gICAgU3BsaXRTb2x2ZXIgOiAgICAgICAgICAgICAgICAgICBfZGVyZXFfKCcuL3NvbHZlci9TcGxpdFNvbHZlcicpLFxuICAgIFNwcmluZyA6ICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9vYmplY3RzL1NwcmluZycpLFxuICAgIFRyaW1lc2ggOiAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9zaGFwZXMvVHJpbWVzaCcpLFxuICAgIFZlYzMgOiAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlcmVxXygnLi9tYXRoL1ZlYzMnKSxcbiAgICBWZWMzUG9vbCA6ICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vdXRpbHMvVmVjM1Bvb2wnKSxcbiAgICBXb3JsZCA6ICAgICAgICAgICAgICAgICAgICAgICAgIF9kZXJlcV8oJy4vd29ybGQvV29ybGQnKSxcbn07XG5cbn0se1wiLi4vcGFja2FnZS5qc29uXCI6MSxcIi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXhcIjo0LFwiLi9jb2xsaXNpb24vQnJvYWRwaGFzZVwiOjUsXCIuL2NvbGxpc2lvbi9HcmlkQnJvYWRwaGFzZVwiOjYsXCIuL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjo3LFwiLi9jb2xsaXNpb24vT2JqZWN0Q29sbGlzaW9uTWF0cml4XCI6OCxcIi4vY29sbGlzaW9uL1JheVwiOjksXCIuL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0XCI6MTAsXCIuL2NvbGxpc2lvbi9TQVBCcm9hZHBoYXNlXCI6MTEsXCIuL2NvbnN0cmFpbnRzL0NvbmVUd2lzdENvbnN0cmFpbnRcIjoxMixcIi4vY29uc3RyYWludHMvQ29uc3RyYWludFwiOjEzLFwiLi9jb25zdHJhaW50cy9EaXN0YW5jZUNvbnN0cmFpbnRcIjoxNCxcIi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50XCI6MTUsXCIuL2NvbnN0cmFpbnRzL0xvY2tDb25zdHJhaW50XCI6MTYsXCIuL2NvbnN0cmFpbnRzL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxNyxcIi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjE5LFwiLi9lcXVhdGlvbnMvRXF1YXRpb25cIjoyMCxcIi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMSxcIi4vZXF1YXRpb25zL1JvdGF0aW9uYWxFcXVhdGlvblwiOjIyLFwiLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb25cIjoyMyxcIi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsXCI6MjQsXCIuL21hdGVyaWFsL01hdGVyaWFsXCI6MjUsXCIuL21hdGgvTWF0M1wiOjI3LFwiLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4vbWF0aC9WZWMzXCI6MzAsXCIuL29iamVjdHMvQm9keVwiOjMxLFwiLi9vYmplY3RzL1JheWNhc3RWZWhpY2xlXCI6MzIsXCIuL29iamVjdHMvUmlnaWRWZWhpY2xlXCI6MzMsXCIuL29iamVjdHMvU1BIU3lzdGVtXCI6MzQsXCIuL29iamVjdHMvU3ByaW5nXCI6MzUsXCIuL3NoYXBlcy9Cb3hcIjozNyxcIi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb25cIjozOCxcIi4vc2hhcGVzL0N5bGluZGVyXCI6MzksXCIuL3NoYXBlcy9IZWlnaHRmaWVsZFwiOjQwLFwiLi9zaGFwZXMvUGFydGljbGVcIjo0MSxcIi4vc2hhcGVzL1BsYW5lXCI6NDIsXCIuL3NoYXBlcy9TaGFwZVwiOjQzLFwiLi9zaGFwZXMvU3BoZXJlXCI6NDQsXCIuL3NoYXBlcy9UcmltZXNoXCI6NDUsXCIuL3NvbHZlci9HU1NvbHZlclwiOjQ2LFwiLi9zb2x2ZXIvU29sdmVyXCI6NDcsXCIuL3NvbHZlci9TcGxpdFNvbHZlclwiOjQ4LFwiLi91dGlscy9FdmVudFRhcmdldFwiOjQ5LFwiLi91dGlscy9Qb29sXCI6NTEsXCIuL3V0aWxzL1ZlYzNQb29sXCI6NTQsXCIuL3dvcmxkL05hcnJvd3BoYXNlXCI6NTUsXCIuL3dvcmxkL1dvcmxkXCI6NTZ9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFBQkI7XG5cbi8qKlxuICogQXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBjbGFzcy5cbiAqIEBjbGFzcyBBQUJCXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7VmVjM30gICBbb3B0aW9ucy51cHBlckJvdW5kXVxuICogQHBhcmFtIHtWZWMzfSAgIFtvcHRpb25zLmxvd2VyQm91bmRdXG4gKi9cbmZ1bmN0aW9uIEFBQkIob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcHJvcGVydHkgbG93ZXJCb3VuZFxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMubG93ZXJCb3VuZCA9IG5ldyBWZWMzKCk7XG4gICAgaWYob3B0aW9ucy5sb3dlckJvdW5kKXtcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kLmNvcHkob3B0aW9ucy5sb3dlckJvdW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdXBwZXIgYm91bmQgb2YgdGhlIGJvdW5kaW5nIGJveC5cbiAgICAgKiBAcHJvcGVydHkgdXBwZXJCb3VuZFxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMudXBwZXJCb3VuZCA9IG5ldyBWZWMzKCk7XG4gICAgaWYob3B0aW9ucy51cHBlckJvdW5kKXtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kLmNvcHkob3B0aW9ucy51cHBlckJvdW5kKTtcbiAgICB9XG59XG5cbnZhciB0bXAgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNldCB0aGUgQUFCQiBib3VuZHMgZnJvbSBhIHNldCBvZiBwb2ludHMuXG4gKiBAbWV0aG9kIHNldEZyb21Qb2ludHNcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyBBbiBhcnJheSBvZiBWZWMzJ3MuXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBza2luU2l6ZVxuICogQHJldHVybiB7QUFCQn0gVGhlIHNlbGYgb2JqZWN0XG4gKi9cbkFBQkIucHJvdG90eXBlLnNldEZyb21Qb2ludHMgPSBmdW5jdGlvbihwb2ludHMsIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBza2luU2l6ZSl7XG4gICAgdmFyIGwgPSB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgIHUgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIHEgPSBxdWF0ZXJuaW9uO1xuXG4gICAgLy8gU2V0IHRvIHRoZSBmaXJzdCBwb2ludFxuICAgIGwuY29weShwb2ludHNbMF0pO1xuICAgIGlmKHEpe1xuICAgICAgICBxLnZtdWx0KGwsIGwpO1xuICAgIH1cbiAgICB1LmNvcHkobCk7XG5cbiAgICBmb3IodmFyIGkgPSAxOyBpPHBvaW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXG4gICAgICAgIGlmKHEpe1xuICAgICAgICAgICAgcS52bXVsdChwLCB0bXApO1xuICAgICAgICAgICAgcCA9IHRtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHAueCA+IHUueCl7IHUueCA9IHAueDsgfVxuICAgICAgICBpZihwLnggPCBsLngpeyBsLnggPSBwLng7IH1cbiAgICAgICAgaWYocC55ID4gdS55KXsgdS55ID0gcC55OyB9XG4gICAgICAgIGlmKHAueSA8IGwueSl7IGwueSA9IHAueTsgfVxuICAgICAgICBpZihwLnogPiB1LnopeyB1LnogPSBwLno7IH1cbiAgICAgICAgaWYocC56IDwgbC56KXsgbC56ID0gcC56OyB9XG4gICAgfVxuXG4gICAgLy8gQWRkIG9mZnNldFxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbi52YWRkKGwsIGwpO1xuICAgICAgICBwb3NpdGlvbi52YWRkKHUsIHUpO1xuICAgIH1cblxuICAgIGlmKHNraW5TaXplKXtcbiAgICAgICAgbC54IC09IHNraW5TaXplO1xuICAgICAgICBsLnkgLT0gc2tpblNpemU7XG4gICAgICAgIGwueiAtPSBza2luU2l6ZTtcbiAgICAgICAgdS54ICs9IHNraW5TaXplO1xuICAgICAgICB1LnkgKz0gc2tpblNpemU7XG4gICAgICAgIHUueiArPSBza2luU2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29weSBib3VuZHMgZnJvbSBhbiBBQUJCIHRvIHRoaXMgQUFCQlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiIFNvdXJjZSB0byBjb3B5IGZyb21cbiAqIEByZXR1cm4ge0FBQkJ9IFRoZSB0aGlzIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eVxuICovXG5BQUJCLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdGhpcy5sb3dlckJvdW5kLmNvcHkoYWFiYi5sb3dlckJvdW5kKTtcbiAgICB0aGlzLnVwcGVyQm91bmQuY29weShhYWJiLnVwcGVyQm91bmQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9uZSBhbiBBQUJCXG4gKiBAbWV0aG9kIGNsb25lXG4gKi9cbkFBQkIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IEFBQkIoKS5jb3B5KHRoaXMpO1xufTtcblxuLyoqXG4gKiBFeHRlbmQgdGhpcyBBQUJCIHNvIHRoYXQgaXQgY292ZXJzIHRoZSBnaXZlbiBBQUJCIHRvby5cbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKi9cbkFBQkIucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIC8vIEV4dGVuZCBsb3dlciBib3VuZFxuICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kLng7XG4gICAgaWYodGhpcy5sb3dlckJvdW5kLnggPiBsKXtcbiAgICAgICAgdGhpcy5sb3dlckJvdW5kLnggPSBsO1xuICAgIH1cblxuICAgIC8vIFVwcGVyXG4gICAgdmFyIHUgPSBhYWJiLnVwcGVyQm91bmQueDtcbiAgICBpZih0aGlzLnVwcGVyQm91bmQueCA8IHUpe1xuICAgICAgICB0aGlzLnVwcGVyQm91bmQueCA9IHU7XG4gICAgfVxuXG4gICAgLy8gRXh0ZW5kIGxvd2VyIGJvdW5kXG4gICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQueTtcbiAgICBpZih0aGlzLmxvd2VyQm91bmQueSA+IGwpe1xuICAgICAgICB0aGlzLmxvd2VyQm91bmQueSA9IGw7XG4gICAgfVxuXG4gICAgLy8gVXBwZXJcbiAgICB2YXIgdSA9IGFhYmIudXBwZXJCb3VuZC55O1xuICAgIGlmKHRoaXMudXBwZXJCb3VuZC55IDwgdSl7XG4gICAgICAgIHRoaXMudXBwZXJCb3VuZC55ID0gdTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbmQgbG93ZXIgYm91bmRcbiAgICB2YXIgbCA9IGFhYmIubG93ZXJCb3VuZC56O1xuICAgIGlmKHRoaXMubG93ZXJCb3VuZC56ID4gbCl7XG4gICAgICAgIHRoaXMubG93ZXJCb3VuZC56ID0gbDtcbiAgICB9XG5cbiAgICAvLyBVcHBlclxuICAgIHZhciB1ID0gYWFiYi51cHBlckJvdW5kLno7XG4gICAgaWYodGhpcy51cHBlckJvdW5kLnogPCB1KXtcbiAgICAgICAgdGhpcy51cHBlckJvdW5kLnogPSB1O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBBQUJCIG92ZXJsYXBzIHRoaXMgQUFCQi5cbiAqIEBtZXRob2Qgb3ZlcmxhcHNcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkFBQkIucHJvdG90eXBlLm92ZXJsYXBzID0gZnVuY3Rpb24oYWFiYil7XG4gICAgdmFyIGwxID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1MSA9IHRoaXMudXBwZXJCb3VuZCxcbiAgICAgICAgbDIgPSBhYWJiLmxvd2VyQm91bmQsXG4gICAgICAgIHUyID0gYWFiYi51cHBlckJvdW5kO1xuXG4gICAgLy8gICAgICBsMiAgICAgICAgdTJcbiAgICAvLyAgICAgIHwtLS0tLS0tLS18XG4gICAgLy8gfC0tLS0tLS0tfFxuICAgIC8vIGwxICAgICAgIHUxXG5cbiAgICByZXR1cm4gKChsMi54IDw9IHUxLnggJiYgdTEueCA8PSB1Mi54KSB8fCAobDEueCA8PSB1Mi54ICYmIHUyLnggPD0gdTEueCkpICYmXG4gICAgICAgICAgICgobDIueSA8PSB1MS55ICYmIHUxLnkgPD0gdTIueSkgfHwgKGwxLnkgPD0gdTIueSAmJiB1Mi55IDw9IHUxLnkpKSAmJlxuICAgICAgICAgICAoKGwyLnogPD0gdTEueiAmJiB1MS56IDw9IHUyLnopIHx8IChsMS56IDw9IHUyLnogJiYgdTIueiA8PSB1MS56KSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gQUFCQiBpcyBmdWxseSBjb250YWluZWQgaW4gdGhpcyBBQUJCLlxuICogQG1ldGhvZCBjb250YWluc1xuICogQHBhcmFtIHtBQUJCfSBhYWJiXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5BQUJCLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsMSA9IHRoaXMubG93ZXJCb3VuZCxcbiAgICAgICAgdTEgPSB0aGlzLnVwcGVyQm91bmQsXG4gICAgICAgIGwyID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1MiA9IGFhYmIudXBwZXJCb3VuZDtcblxuICAgIC8vICAgICAgbDIgICAgICAgIHUyXG4gICAgLy8gICAgICB8LS0tLS0tLS0tfFxuICAgIC8vIHwtLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gbDEgICAgICAgICAgICAgIHUxXG5cbiAgICByZXR1cm4gKFxuICAgICAgICAobDEueCA8PSBsMi54ICYmIHUxLnggPj0gdTIueCkgJiZcbiAgICAgICAgKGwxLnkgPD0gbDIueSAmJiB1MS55ID49IHUyLnkpICYmXG4gICAgICAgIChsMS56IDw9IGwyLnogJiYgdTEueiA+PSB1Mi56KVxuICAgICk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZ2V0Q29ybmVyc1xuICogQHBhcmFtIHtWZWMzfSBhXG4gKiBAcGFyYW0ge1ZlYzN9IGJcbiAqIEBwYXJhbSB7VmVjM30gY1xuICogQHBhcmFtIHtWZWMzfSBkXG4gKiBAcGFyYW0ge1ZlYzN9IGVcbiAqIEBwYXJhbSB7VmVjM30gZlxuICogQHBhcmFtIHtWZWMzfSBnXG4gKiBAcGFyYW0ge1ZlYzN9IGhcbiAqL1xuQUFCQi5wcm90b3R5cGUuZ2V0Q29ybmVycyA9IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpe1xuICAgIHZhciBsID0gdGhpcy5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gdGhpcy51cHBlckJvdW5kO1xuXG4gICAgYS5jb3B5KGwpO1xuICAgIGIuc2V0KCB1LngsIGwueSwgbC56ICk7XG4gICAgYy5zZXQoIHUueCwgdS55LCBsLnogKTtcbiAgICBkLnNldCggbC54LCB1LnksIHUueiApO1xuICAgIGUuc2V0KCB1LngsIGwueSwgbC56ICk7XG4gICAgZi5zZXQoIGwueCwgdS55LCBsLnogKTtcbiAgICBnLnNldCggbC54LCBsLnksIHUueiApO1xuICAgIGguY29weSh1KTtcbn07XG5cbnZhciB0cmFuc2Zvcm1JbnRvRnJhbWVfY29ybmVycyA9IFtcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKClcbl07XG5cbi8qKlxuICogR2V0IHRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBBQUJCIGluIGFub3RoZXIgZnJhbWUuXG4gKiBAbWV0aG9kIHRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7VHJhbnNmb3JtfSBmcmFtZVxuICogQHBhcmFtICB7QUFCQn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgXCJ0YXJnZXRcIiBBQUJCIG9iamVjdC5cbiAqL1xuQUFCQi5wcm90b3R5cGUudG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIHRhcmdldCl7XG5cbiAgICB2YXIgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xuICAgIHZhciBhID0gY29ybmVyc1swXTtcbiAgICB2YXIgYiA9IGNvcm5lcnNbMV07XG4gICAgdmFyIGMgPSBjb3JuZXJzWzJdO1xuICAgIHZhciBkID0gY29ybmVyc1szXTtcbiAgICB2YXIgZSA9IGNvcm5lcnNbNF07XG4gICAgdmFyIGYgPSBjb3JuZXJzWzVdO1xuICAgIHZhciBnID0gY29ybmVyc1s2XTtcbiAgICB2YXIgaCA9IGNvcm5lcnNbN107XG5cbiAgICAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lXG4gICAgdGhpcy5nZXRDb3JuZXJzKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZW0gdG8gbmV3IGxvY2FsIGZyYW1lXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IDg7IGkrKyl7XG4gICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xuICAgICAgICBmcmFtZS5wb2ludFRvTG9jYWwoY29ybmVyLCBjb3JuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbVBvaW50cyhjb3JuZXJzKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSByZXByZXNlbnRhdGlvbiBvZiBhbiBBQUJCIGluIHRoZSBnbG9iYWwgZnJhbWUuXG4gKiBAbWV0aG9kIHRvV29ybGRGcmFtZVxuICogQHBhcmFtICB7VHJhbnNmb3JtfSBmcmFtZVxuICogQHBhcmFtICB7QUFCQn0gdGFyZ2V0XG4gKiBAcmV0dXJuIHtBQUJCfSBUaGUgXCJ0YXJnZXRcIiBBQUJCIG9iamVjdC5cbiAqL1xuQUFCQi5wcm90b3R5cGUudG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24oZnJhbWUsIHRhcmdldCl7XG5cbiAgICB2YXIgY29ybmVycyA9IHRyYW5zZm9ybUludG9GcmFtZV9jb3JuZXJzO1xuICAgIHZhciBhID0gY29ybmVyc1swXTtcbiAgICB2YXIgYiA9IGNvcm5lcnNbMV07XG4gICAgdmFyIGMgPSBjb3JuZXJzWzJdO1xuICAgIHZhciBkID0gY29ybmVyc1szXTtcbiAgICB2YXIgZSA9IGNvcm5lcnNbNF07XG4gICAgdmFyIGYgPSBjb3JuZXJzWzVdO1xuICAgIHZhciBnID0gY29ybmVyc1s2XTtcbiAgICB2YXIgaCA9IGNvcm5lcnNbN107XG5cbiAgICAvLyBHZXQgY29ybmVycyBpbiBjdXJyZW50IGZyYW1lXG4gICAgdGhpcy5nZXRDb3JuZXJzKGEsIGIsIGMsIGQsIGUsIGYsIGcsIGgpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHRoZW0gdG8gbmV3IGxvY2FsIGZyYW1lXG4gICAgZm9yKHZhciBpPTA7IGkgIT09IDg7IGkrKyl7XG4gICAgICAgIHZhciBjb3JuZXIgPSBjb3JuZXJzW2ldO1xuICAgICAgICBmcmFtZS5wb2ludFRvV29ybGQoY29ybmVyLCBjb3JuZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQuc2V0RnJvbVBvaW50cyhjb3JuZXJzKTtcbn07XG5cbn0se1wiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi91dGlscy9VdGlsc1wiOjUzfV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5Q29sbGlzaW9uTWF0cml4O1xuXG4vKipcbiAqIENvbGxpc2lvbiBcIm1hdHJpeFwiLiBJdCdzIGFjdHVhbGx5IGEgdHJpYW5ndWxhci1zaGFwZWQgYXJyYXkgb2Ygd2hldGhlciB0d28gYm9kaWVzIGFyZSB0b3VjaGluZyB0aGlzIHN0ZXAsIGZvciByZWZlcmVuY2UgbmV4dCBzdGVwXG4gKiBAY2xhc3MgQXJyYXlDb2xsaXNpb25NYXRyaXhcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBcnJheUNvbGxpc2lvbk1hdHJpeCgpIHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXRyaXggc3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSBtYXRyaXhcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG5cdHRoaXMubWF0cml4ID0gW107XG59XG5cbi8qKlxuICogR2V0IGFuIGVsZW1lbnRcbiAqIEBtZXRob2QgZ2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSwgaikge1xuXHRpID0gaS5pbmRleDtcblx0aiA9IGouaW5kZXg7XG4gICAgaWYgKGogPiBpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gajtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGkgPSB0ZW1wO1xuICAgIH1cblx0cmV0dXJuIHRoaXMubWF0cml4WyhpKihpICsgMSk+PjEpICsgai0xXTtcbn07XG5cbi8qKlxuICogU2V0IGFuIGVsZW1lbnRcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHBhcmFtIHtOdW1iZXJ9IGpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICovXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcblx0aSA9IGkuaW5kZXg7XG5cdGogPSBqLmluZGV4O1xuICAgIGlmIChqID4gaSkge1xuICAgICAgICB2YXIgdGVtcCA9IGo7XG4gICAgICAgIGogPSBpO1xuICAgICAgICBpID0gdGVtcDtcbiAgICB9XG5cdHRoaXMubWF0cml4WyhpKihpICsgMSk+PjEpICsgai0xXSA9IHZhbHVlID8gMSA6IDA7XG59O1xuXG4vKipcbiAqIFNldHMgYWxsIGVsZW1lbnRzIHRvIHplcm9cbiAqIEBtZXRob2QgcmVzZXRcbiAqL1xuQXJyYXlDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdGZvciAodmFyIGk9MCwgbD10aGlzLm1hdHJpeC5sZW5ndGg7IGkhPT1sOyBpKyspIHtcblx0XHR0aGlzLm1hdHJpeFtpXT0wO1xuXHR9XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heCBudW1iZXIgb2Ygb2JqZWN0c1xuICogQG1ldGhvZCBzZXROdW1PYmplY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gblxuICovXG5BcnJheUNvbGxpc2lvbk1hdHJpeC5wcm90b3R5cGUuc2V0TnVtT2JqZWN0cyA9IGZ1bmN0aW9uKG4pIHtcblx0dGhpcy5tYXRyaXgubGVuZ3RoID0gbioobi0xKT4+MTtcbn07XG5cbn0se31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgUGxhbmUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvUGxhbmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGJyb2FkcGhhc2UgaW1wbGVtZW50YXRpb25zXG4gKiBAY2xhc3MgQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIEJyb2FkcGhhc2UoKXtcbiAgICAvKipcbiAgICAqIFRoZSB3b3JsZCB0byBzZWFyY2ggZm9yIGNvbGxpc2lvbnMgaW4uXG4gICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAqIEB0eXBlIHtXb3JsZH1cbiAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSWYgc2V0IHRvIHRydWUsIHRoZSBicm9hZHBoYXNlIHVzZXMgYm91bmRpbmcgYm94ZXMgZm9yIGludGVyc2VjdGlvbiB0ZXN0LCBlbHNlIGl0IHVzZXMgYm91bmRpbmcgc3BoZXJlcy5cbiAgICAgKiBAcHJvcGVydHkgdXNlQm91bmRpbmdCb3hlc1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudXNlQm91bmRpbmdCb3hlcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdHMgaW4gdGhlIHdvcmxkIG1vdmVkLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGlydHlcbiAgICAgKi9cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvbGxpc2lvbiBwYWlycyBmcm9tIHRoZSB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGQgVGhlIHdvcmxkIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHtBcnJheX0gcDEgRW1wdHkgYXJyYXkgdG8gYmUgZmlsbGVkIHdpdGggYm9keSBvYmplY3RzXG4gKiBAcGFyYW0ge0FycmF5fSBwMiBFbXB0eSBhcnJheSB0byBiZSBmaWxsZWQgd2l0aCBib2R5IG9iamVjdHNcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwMSxwMil7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY29sbGlzaW9uUGFpcnMgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIEJyb2FkUGhhc2UgY2xhc3MhXCIpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGJvZHkgcGFpciBuZWVkcyB0byBiZSBpbnRlcnNlY3Rpb24gdGVzdGVkIGF0IGFsbC5cbiAqIEBtZXRob2QgbmVlZEJyb2FkcGhhc2VDb2xsaXNpb25cbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cbnZhciBCcm9hZHBoYXNlX25lZWRCcm9hZHBoYXNlQ29sbGlzaW9uX1NUQVRJQ19PUl9LSU5FTUFUSUMgPSBCb2R5LlNUQVRJQyB8IEJvZHkuS0lORU1BVElDO1xuQnJvYWRwaGFzZS5wcm90b3R5cGUubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24gPSBmdW5jdGlvbihib2R5QSxib2R5Qil7XG5cbiAgICAvLyBDaGVjayBjb2xsaXNpb24gZmlsdGVyIG1hc2tzXG4gICAgaWYoIChib2R5QS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIGJvZHlCLmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCB8fCAoYm9keUIuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5QS5jb2xsaXNpb25GaWx0ZXJNYXNrKT09PTApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgdHlwZXNcbiAgICBpZigoKGJvZHlBLnR5cGUgJiBCcm9hZHBoYXNlX25lZWRCcm9hZHBoYXNlQ29sbGlzaW9uX1NUQVRJQ19PUl9LSU5FTUFUSUMpIT09MCB8fCBib2R5QS5zbGVlcFN0YXRlID09PSBCb2R5LlNMRUVQSU5HKSAmJlxuICAgICAgICgoYm9keUIudHlwZSAmIEJyb2FkcGhhc2VfbmVlZEJyb2FkcGhhc2VDb2xsaXNpb25fU1RBVElDX09SX0tJTkVNQVRJQykhPT0wIHx8IGJvZHlCLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcpKSB7XG4gICAgICAgIC8vIEJvdGggYm9kaWVzIGFyZSBzdGF0aWMsIGtpbmVtYXRpYyBvciBzbGVlcGluZy4gU2tpcC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgdm9sdW1lcyBvZiB0d28gYm9kaWVzIGludGVyc2VjdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0aW9uVGVzdFxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHthcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge2FycmF5fSBwYWlyczJcbiAgKi9cbkJyb2FkcGhhc2UucHJvdG90eXBlLmludGVyc2VjdGlvblRlc3QgPSBmdW5jdGlvbihib2R5QSwgYm9keUIsIHBhaXJzMSwgcGFpcnMyKXtcbiAgICBpZih0aGlzLnVzZUJvdW5kaW5nQm94ZXMpe1xuICAgICAgICB0aGlzLmRvQm91bmRpbmdCb3hCcm9hZHBoYXNlKGJvZHlBLGJvZHlCLHBhaXJzMSxwYWlyczIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9Cb3VuZGluZ1NwaGVyZUJyb2FkcGhhc2UoYm9keUEsYm9keUIscGFpcnMxLHBhaXJzMik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgc3BoZXJlcyBvZiB0d28gYm9kaWVzIGFyZSBpbnRlcnNlY3RpbmcuXG4gKiBAbWV0aG9kIGRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczEgYm9keUEgaXMgYXBwZW5kZWQgdG8gdGhpcyBhcnJheSBpZiBpbnRlcnNlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMiBib2R5QiBpcyBhcHBlbmRlZCB0byB0aGlzIGFycmF5IGlmIGludGVyc2VjdGlvblxuICovXG52YXIgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19yID0gbmV3IFZlYzMoKSwgLy8gVGVtcCBvYmplY3RzXG4gICAgQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19ub3JtYWwgPSAgbmV3IFZlYzMoKSxcbiAgICBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3F1YXQgPSAgbmV3IFF1YXRlcm5pb24oKSxcbiAgICBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3JlbHBvcyAgPSAgbmV3IFZlYzMoKTtcbkJyb2FkcGhhc2UucHJvdG90eXBlLmRvQm91bmRpbmdTcGhlcmVCcm9hZHBoYXNlID0gZnVuY3Rpb24oYm9keUEsYm9keUIscGFpcnMxLHBhaXJzMil7XG4gICAgdmFyIHIgPSBCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX3I7XG4gICAgYm9keUIucG9zaXRpb24udnN1Yihib2R5QS5wb3NpdGlvbixyKTtcbiAgICB2YXIgYm91bmRpbmdSYWRpdXNTdW0yID0gTWF0aC5wb3coYm9keUEuYm91bmRpbmdSYWRpdXMgKyBib2R5Qi5ib3VuZGluZ1JhZGl1cywgMik7XG4gICAgdmFyIG5vcm0yID0gci5ub3JtMigpO1xuICAgIGlmKG5vcm0yIDwgYm91bmRpbmdSYWRpdXNTdW0yKXtcbiAgICAgICAgcGFpcnMxLnB1c2goYm9keUEpO1xuICAgICAgICBwYWlyczIucHVzaChib2R5Qik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRpbmcgYm94ZXMgb2YgdHdvIGJvZGllcyBhcmUgaW50ZXJzZWN0aW5nLlxuICogQG1ldGhvZCBkb0JvdW5kaW5nQm94QnJvYWRwaGFzZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuZG9Cb3VuZGluZ0JveEJyb2FkcGhhc2UgPSBmdW5jdGlvbihib2R5QSxib2R5QixwYWlyczEscGFpcnMyKXtcbiAgICBpZihib2R5QS5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICBib2R5QS5jb21wdXRlQUFCQigpO1xuICAgIH1cbiAgICBpZihib2R5Qi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICBib2R5Qi5jb21wdXRlQUFCQigpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIEFBQkIgLyBBQUJCXG4gICAgaWYoYm9keUEuYWFiYi5vdmVybGFwcyhib2R5Qi5hYWJiKSl7XG4gICAgICAgIHBhaXJzMS5wdXNoKGJvZHlBKTtcbiAgICAgICAgcGFpcnMyLnB1c2goYm9keUIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGUgcGFpcnMgZnJvbSB0aGUgcGFpciBhcnJheXMuXG4gKiBAbWV0aG9kIG1ha2VQYWlyc1VuaXF1ZVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMxXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyczJcbiAqL1xudmFyIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAgPSB7IGtleXM6W10gfSxcbiAgICBCcm9hZHBoYXNlX21ha2VQYWlyc1VuaXF1ZV9wMSA9IFtdLFxuICAgIEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3AyID0gW107XG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5tYWtlUGFpcnNVbmlxdWUgPSBmdW5jdGlvbihwYWlyczEscGFpcnMyKXtcbiAgICB2YXIgdCA9IEJyb2FkcGhhc2VfbWFrZVBhaXJzVW5pcXVlX3RlbXAsXG4gICAgICAgIHAxID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDEsXG4gICAgICAgIHAyID0gQnJvYWRwaGFzZV9tYWtlUGFpcnNVbmlxdWVfcDIsXG4gICAgICAgIE4gPSBwYWlyczEubGVuZ3RoO1xuXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBwMVtpXSA9IHBhaXJzMVtpXTtcbiAgICAgICAgcDJbaV0gPSBwYWlyczJbaV07XG4gICAgfVxuXG4gICAgcGFpcnMxLmxlbmd0aCA9IDA7XG4gICAgcGFpcnMyLmxlbmd0aCA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBpZDEgPSBwMVtpXS5pZCxcbiAgICAgICAgICAgIGlkMiA9IHAyW2ldLmlkO1xuICAgICAgICB2YXIga2V5ID0gaWQxIDwgaWQyID8gaWQxK1wiLFwiK2lkMiA6ICBpZDIrXCIsXCIraWQxO1xuICAgICAgICB0W2tleV0gPSBpO1xuICAgICAgICB0LmtleXMucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGZvcih2YXIgaT0wOyBpIT09dC5rZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGtleSA9IHQua2V5cy5wb3AoKSxcbiAgICAgICAgICAgIHBhaXJJbmRleCA9IHRba2V5XTtcbiAgICAgICAgcGFpcnMxLnB1c2gocDFbcGFpckluZGV4XSk7XG4gICAgICAgIHBhaXJzMi5wdXNoKHAyW3BhaXJJbmRleF0pO1xuICAgICAgICBkZWxldGUgdFtrZXldO1xuICAgIH1cbn07XG5cbi8qKlxuICogVG8gYmUgaW1wbGVtZW50ZWQgYnkgc3ViY2Fzc2VzXG4gKiBAbWV0aG9kIHNldFdvcmxkXG4gKiBAcGFyYW0ge1dvcmxkfSB3b3JsZFxuICovXG5Ccm9hZHBoYXNlLnByb3RvdHlwZS5zZXRXb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGJvdW5kaW5nIHNwaGVyZXMgb2YgdHdvIGJvZGllcyBvdmVybGFwLlxuICogQG1ldGhvZCBib3VuZGluZ1NwaGVyZUNoZWNrXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgYnNjX2Rpc3QgPSBuZXcgVmVjMygpO1xuQnJvYWRwaGFzZS5ib3VuZGluZ1NwaGVyZUNoZWNrID0gZnVuY3Rpb24oYm9keUEsYm9keUIpe1xuICAgIHZhciBkaXN0ID0gYnNjX2Rpc3Q7XG4gICAgYm9keUEucG9zaXRpb24udnN1Yihib2R5Qi5wb3NpdGlvbixkaXN0KTtcbiAgICByZXR1cm4gTWF0aC5wb3coYm9keUEuc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBib2R5Qi5zaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cywyKSA+IGRpc3Qubm9ybTIoKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgdGhlIGJvZGllcyB3aXRoaW4gdGhlIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuQnJvYWRwaGFzZS5wcm90b3R5cGUuYWFiYlF1ZXJ5ID0gZnVuY3Rpb24od29ybGQsIGFhYmIsIHJlc3VsdCl7XG4gICAgY29uc29sZS53YXJuKCcuYWFiYlF1ZXJ5IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiB0aGlzIEJyb2FkcGhhc2Ugc3ViY2xhc3MuJyk7XG4gICAgcmV0dXJuIFtdO1xufTtcbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4uL29iamVjdHMvQm9keVwiOjMxLFwiLi4vc2hhcGVzL1BsYW5lXCI6NDIsXCIuLi9zaGFwZXMvU2hhcGVcIjo0M31dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBHcmlkQnJvYWRwaGFzZTtcblxudmFyIEJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuL0Jyb2FkcGhhc2UnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcblxuLyoqXG4gKiBBeGlzIGFsaWduZWQgdW5pZm9ybSBncmlkIGJyb2FkcGhhc2UuXG4gKiBAY2xhc3MgR3JpZEJyb2FkcGhhc2VcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICogQHRvZG8gTmVlZHMgc3VwcG9ydCBmb3IgbW9yZSB0aGFuIGp1c3QgcGxhbmVzIGFuZCBzcGhlcmVzLlxuICogQHBhcmFtIHtWZWMzfSBhYWJiTWluXG4gKiBAcGFyYW0ge1ZlYzN9IGFhYmJNYXhcbiAqIEBwYXJhbSB7TnVtYmVyfSBueCBOdW1iZXIgb2YgYm94ZXMgYWxvbmcgeFxuICogQHBhcmFtIHtOdW1iZXJ9IG55IE51bWJlciBvZiBib3hlcyBhbG9uZyB5XG4gKiBAcGFyYW0ge051bWJlcn0gbnogTnVtYmVyIG9mIGJveGVzIGFsb25nIHpcbiAqL1xuZnVuY3Rpb24gR3JpZEJyb2FkcGhhc2UoYWFiYk1pbixhYWJiTWF4LG54LG55LG56KXtcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMubnggPSBueCB8fCAxMDtcbiAgICB0aGlzLm55ID0gbnkgfHwgMTA7XG4gICAgdGhpcy5ueiA9IG56IHx8IDEwO1xuICAgIHRoaXMuYWFiYk1pbiA9IGFhYmJNaW4gfHwgbmV3IFZlYzMoMTAwLDEwMCwxMDApO1xuICAgIHRoaXMuYWFiYk1heCA9IGFhYmJNYXggfHwgbmV3IFZlYzMoLTEwMCwtMTAwLC0xMDApO1xuXHR2YXIgbmJpbnMgPSB0aGlzLm54ICogdGhpcy5ueSAqIHRoaXMubno7XG5cdGlmIChuYmlucyA8PSAwKSB7XG5cdFx0dGhyb3cgXCJHcmlkQnJvYWRwaGFzZTogRWFjaCBkaW1lbnNpb24ncyBuIG11c3QgYmUgPjBcIjtcblx0fVxuICAgIHRoaXMuYmlucyA9IFtdO1xuXHR0aGlzLmJpbkxlbmd0aHMgPSBbXTsgLy9SYXRoZXIgdGhhbiBjb250aW51YWxseSByZXNpemluZyBhcnJheXMgKHRocmFzaGluZyB0aGUgbWVtb3J5KSwganVzdCByZWNvcmQgbGVuZ3RoIGFuZCBhbGxvdyB0aGVtIHRvIGdyb3dcblx0dGhpcy5iaW5zLmxlbmd0aCA9IG5iaW5zO1xuXHR0aGlzLmJpbkxlbmd0aHMubGVuZ3RoID0gbmJpbnM7XG5cdGZvciAodmFyIGk9MDtpPG5iaW5zO2krKykge1xuXHRcdHRoaXMuYmluc1tpXT1bXTtcblx0XHR0aGlzLmJpbkxlbmd0aHNbaV09MDtcblx0fVxufVxuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlID0gbmV3IEJyb2FkcGhhc2UoKTtcbkdyaWRCcm9hZHBoYXNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdyaWRCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gKi9cbnZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19kID0gbmV3IFZlYzMoKTtcbnZhciBHcmlkQnJvYWRwaGFzZV9jb2xsaXNpb25QYWlyc19iaW5Qb3MgPSBuZXcgVmVjMygpO1xuR3JpZEJyb2FkcGhhc2UucHJvdG90eXBlLmNvbGxpc2lvblBhaXJzID0gZnVuY3Rpb24od29ybGQscGFpcnMxLHBhaXJzMil7XG4gICAgdmFyIE4gPSB3b3JsZC5udW1PYmplY3RzKCksXG4gICAgICAgIGJvZGllcyA9IHdvcmxkLmJvZGllcztcblxuICAgIHZhciBtYXggPSB0aGlzLmFhYmJNYXgsXG4gICAgICAgIG1pbiA9IHRoaXMuYWFiYk1pbixcbiAgICAgICAgbnggPSB0aGlzLm54LFxuICAgICAgICBueSA9IHRoaXMubnksXG4gICAgICAgIG56ID0gdGhpcy5uejtcblxuXHR2YXIgeHN0ZXAgPSBueSpuejtcblx0dmFyIHlzdGVwID0gbno7XG5cdHZhciB6c3RlcCA9IDE7XG5cbiAgICB2YXIgeG1heCA9IG1heC54LFxuICAgICAgICB5bWF4ID0gbWF4LnksXG4gICAgICAgIHptYXggPSBtYXgueixcbiAgICAgICAgeG1pbiA9IG1pbi54LFxuICAgICAgICB5bWluID0gbWluLnksXG4gICAgICAgIHptaW4gPSBtaW4uejtcblxuICAgIHZhciB4bXVsdCA9IG54IC8gKHhtYXgteG1pbiksXG4gICAgICAgIHltdWx0ID0gbnkgLyAoeW1heC15bWluKSxcbiAgICAgICAgem11bHQgPSBueiAvICh6bWF4LXptaW4pO1xuXG4gICAgdmFyIGJpbnNpemVYID0gKHhtYXggLSB4bWluKSAvIG54LFxuICAgICAgICBiaW5zaXplWSA9ICh5bWF4IC0geW1pbikgLyBueSxcbiAgICAgICAgYmluc2l6ZVogPSAoem1heCAtIHptaW4pIC8gbno7XG5cblx0dmFyIGJpblJhZGl1cyA9IE1hdGguc3FydChiaW5zaXplWCpiaW5zaXplWCArIGJpbnNpemVZKmJpbnNpemVZICsgYmluc2l6ZVoqYmluc2l6ZVopICogMC41O1xuXG4gICAgdmFyIHR5cGVzID0gU2hhcGUudHlwZXM7XG4gICAgdmFyIFNQSEVSRSA9ICAgICAgICAgICAgdHlwZXMuU1BIRVJFLFxuICAgICAgICBQTEFORSA9ICAgICAgICAgICAgIHR5cGVzLlBMQU5FLFxuICAgICAgICBCT1ggPSAgICAgICAgICAgICAgIHR5cGVzLkJPWCxcbiAgICAgICAgQ09NUE9VTkQgPSAgICAgICAgICB0eXBlcy5DT01QT1VORCxcbiAgICAgICAgQ09OVkVYUE9MWUhFRFJPTiA9ICB0eXBlcy5DT05WRVhQT0xZSEVEUk9OO1xuXG4gICAgdmFyIGJpbnM9dGhpcy5iaW5zLFxuXHRcdGJpbkxlbmd0aHM9dGhpcy5iaW5MZW5ndGhzLFxuICAgICAgICBOYmlucz10aGlzLmJpbnMubGVuZ3RoO1xuXG4gICAgLy8gUmVzZXQgYmluc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJpbnM7IGkrKyl7XG4gICAgICAgIGJpbkxlbmd0aHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBjZWlsID0gTWF0aC5jZWlsO1xuXHR2YXIgbWluID0gTWF0aC5taW47XG5cdHZhciBtYXggPSBNYXRoLm1heDtcblxuXHRmdW5jdGlvbiBhZGRCb3hUb0JpbnMoeDAseTAsejAseDEseTEsejEsYmkpIHtcblx0XHR2YXIgeG9mZjAgPSAoKHgwIC0geG1pbikgKiB4bXVsdCl8MCxcblx0XHRcdHlvZmYwID0gKCh5MCAtIHltaW4pICogeW11bHQpfDAsXG5cdFx0XHR6b2ZmMCA9ICgoejAgLSB6bWluKSAqIHptdWx0KXwwLFxuXHRcdFx0eG9mZjEgPSBjZWlsKCh4MSAtIHhtaW4pICogeG11bHQpLFxuXHRcdFx0eW9mZjEgPSBjZWlsKCh5MSAtIHltaW4pICogeW11bHQpLFxuXHRcdFx0em9mZjEgPSBjZWlsKCh6MSAtIHptaW4pICogem11bHQpO1xuXG5cdFx0aWYgKHhvZmYwIDwgMCkgeyB4b2ZmMCA9IDA7IH0gZWxzZSBpZiAoeG9mZjAgPj0gbngpIHsgeG9mZjAgPSBueCAtIDE7IH1cblx0XHRpZiAoeW9mZjAgPCAwKSB7IHlvZmYwID0gMDsgfSBlbHNlIGlmICh5b2ZmMCA+PSBueSkgeyB5b2ZmMCA9IG55IC0gMTsgfVxuXHRcdGlmICh6b2ZmMCA8IDApIHsgem9mZjAgPSAwOyB9IGVsc2UgaWYgKHpvZmYwID49IG56KSB7IHpvZmYwID0gbnogLSAxOyB9XG5cdFx0aWYgKHhvZmYxIDwgMCkgeyB4b2ZmMSA9IDA7IH0gZWxzZSBpZiAoeG9mZjEgPj0gbngpIHsgeG9mZjEgPSBueCAtIDE7IH1cblx0XHRpZiAoeW9mZjEgPCAwKSB7IHlvZmYxID0gMDsgfSBlbHNlIGlmICh5b2ZmMSA+PSBueSkgeyB5b2ZmMSA9IG55IC0gMTsgfVxuXHRcdGlmICh6b2ZmMSA8IDApIHsgem9mZjEgPSAwOyB9IGVsc2UgaWYgKHpvZmYxID49IG56KSB7IHpvZmYxID0gbnogLSAxOyB9XG5cblx0XHR4b2ZmMCAqPSB4c3RlcDtcblx0XHR5b2ZmMCAqPSB5c3RlcDtcblx0XHR6b2ZmMCAqPSB6c3RlcDtcblx0XHR4b2ZmMSAqPSB4c3RlcDtcblx0XHR5b2ZmMSAqPSB5c3RlcDtcblx0XHR6b2ZmMSAqPSB6c3RlcDtcblxuXHRcdGZvciAodmFyIHhvZmYgPSB4b2ZmMDsgeG9mZiA8PSB4b2ZmMTsgeG9mZiArPSB4c3RlcCkge1xuXHRcdFx0Zm9yICh2YXIgeW9mZiA9IHlvZmYwOyB5b2ZmIDw9IHlvZmYxOyB5b2ZmICs9IHlzdGVwKSB7XG5cdFx0XHRcdGZvciAodmFyIHpvZmYgPSB6b2ZmMDsgem9mZiA8PSB6b2ZmMTsgem9mZiArPSB6c3RlcCkge1xuXHRcdFx0XHRcdHZhciBpZHggPSB4b2ZmK3lvZmYrem9mZjtcblx0XHRcdFx0XHRiaW5zW2lkeF1bYmluTGVuZ3Roc1tpZHhdKytdID0gYmk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuICAgIC8vIFB1dCBhbGwgYm9kaWVzIGludG8gdGhlIGJpbnNcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgdmFyIHNpID0gYmkuc2hhcGU7XG5cbiAgICAgICAgc3dpdGNoKHNpLnR5cGUpe1xuICAgICAgICBjYXNlIFNQSEVSRTpcbiAgICAgICAgICAgIC8vIFB1dCBpbiBiaW5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIG92ZXJsYXAgd2l0aCBvdGhlciBiaW5zXG4gICAgICAgICAgICB2YXIgeCA9IGJpLnBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgeSA9IGJpLnBvc2l0aW9uLnksXG4gICAgICAgICAgICAgICAgeiA9IGJpLnBvc2l0aW9uLno7XG4gICAgICAgICAgICB2YXIgciA9IHNpLnJhZGl1cztcblxuXHRcdFx0YWRkQm94VG9CaW5zKHgtciwgeS1yLCB6LXIsIHgrciwgeStyLCB6K3IsIGJpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUExBTkU6XG4gICAgICAgICAgICBpZihzaS53b3JsZE5vcm1hbE5lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgICAgICBzaS5jb21wdXRlV29ybGROb3JtYWwoYmkucXVhdGVybmlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcGxhbmVOb3JtYWwgPSBzaS53b3JsZE5vcm1hbDtcblxuXHRcdFx0Ly9SZWxhdGl2ZSBwb3NpdGlvbiBmcm9tIG9yaWdpbiBvZiBwbGFuZSBvYmplY3QgdG8gdGhlIGZpcnN0IGJpblxuXHRcdFx0Ly9JbmNyZW1lbnRlZCBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGJpbnNcblx0XHRcdHZhciB4cmVzZXQgPSB4bWluICsgYmluc2l6ZVgqMC41IC0gYmkucG9zaXRpb24ueCxcblx0XHRcdFx0eXJlc2V0ID0geW1pbiArIGJpbnNpemVZKjAuNSAtIGJpLnBvc2l0aW9uLnksXG5cdFx0XHRcdHpyZXNldCA9IHptaW4gKyBiaW5zaXplWiowLjUgLSBiaS5wb3NpdGlvbi56O1xuXG4gICAgICAgICAgICB2YXIgZCA9IEdyaWRCcm9hZHBoYXNlX2NvbGxpc2lvblBhaXJzX2Q7XG5cdFx0XHRkLnNldCh4cmVzZXQsIHlyZXNldCwgenJlc2V0KTtcblxuXHRcdFx0Zm9yICh2YXIgeGkgPSAwLCB4b2ZmID0gMDsgeGkgIT09IG54OyB4aSsrLCB4b2ZmICs9IHhzdGVwLCBkLnkgPSB5cmVzZXQsIGQueCArPSBiaW5zaXplWCkge1xuXHRcdFx0XHRmb3IgKHZhciB5aSA9IDAsIHlvZmYgPSAwOyB5aSAhPT0gbnk7IHlpKyssIHlvZmYgKz0geXN0ZXAsIGQueiA9IHpyZXNldCwgZC55ICs9IGJpbnNpemVZKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgemkgPSAwLCB6b2ZmID0gMDsgemkgIT09IG56OyB6aSsrLCB6b2ZmICs9IHpzdGVwLCBkLnogKz0gYmluc2l6ZVopIHtcblx0XHRcdFx0XHRcdGlmIChkLmRvdChwbGFuZU5vcm1hbCkgPCBiaW5SYWRpdXMpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGlkeCA9IHhvZmYgKyB5b2ZmICsgem9mZjtcblx0XHRcdFx0XHRcdFx0Ymluc1tpZHhdW2Jpbkxlbmd0aHNbaWR4XSsrXSA9IGJpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcblx0XHRcdGlmIChiaS5hYWJiTmVlZHNVcGRhdGUpIHtcblx0XHRcdFx0YmkuY29tcHV0ZUFBQkIoKTtcblx0XHRcdH1cblxuXHRcdFx0YWRkQm94VG9CaW5zKFxuXHRcdFx0XHRiaS5hYWJiLmxvd2VyQm91bmQueCxcblx0XHRcdFx0YmkuYWFiYi5sb3dlckJvdW5kLnksXG5cdFx0XHRcdGJpLmFhYmIubG93ZXJCb3VuZC56LFxuXHRcdFx0XHRiaS5hYWJiLnVwcGVyQm91bmQueCxcblx0XHRcdFx0YmkuYWFiYi51cHBlckJvdW5kLnksXG5cdFx0XHRcdGJpLmFhYmIudXBwZXJCb3VuZC56LFxuXHRcdFx0XHRiaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGVhY2ggYmluXG4gICAgZm9yKHZhciBpPTA7IGkhPT1OYmluczsgaSsrKXtcblx0XHR2YXIgYmluTGVuZ3RoID0gYmluTGVuZ3Roc1tpXTtcblx0XHQvL1NraXAgYmlucyB3aXRoIG5vIHBvdGVudGlhbCBjb2xsaXNpb25zXG5cdFx0aWYgKGJpbkxlbmd0aCA+IDEpIHtcblx0XHRcdHZhciBiaW4gPSBiaW5zW2ldO1xuXG5cdFx0XHQvLyBEbyBOXjIgYnJvYWRwaGFzZSBpbnNpZGVcblx0XHRcdGZvcih2YXIgeGk9MDsgeGkhPT1iaW5MZW5ndGg7IHhpKyspe1xuXHRcdFx0XHR2YXIgYmkgPSBiaW5beGldO1xuXHRcdFx0XHRmb3IodmFyIHlpPTA7IHlpIT09eGk7IHlpKyspe1xuXHRcdFx0XHRcdHZhciBiaiA9IGJpblt5aV07XG5cdFx0XHRcdFx0aWYodGhpcy5uZWVkQnJvYWRwaGFzZUNvbGxpc2lvbihiaSxiaikpe1xuXHRcdFx0XHRcdFx0dGhpcy5pbnRlcnNlY3Rpb25UZXN0KGJpLGJqLHBhaXJzMSxwYWlyczIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cbiAgICB9XG5cbi8vXHRmb3IgKHZhciB6aSA9IDAsIHpvZmY9MDsgemkgPCBuejsgemkrKywgem9mZis9IHpzdGVwKSB7XG4vL1x0XHRjb25zb2xlLmxvZyhcImxheWVyIFwiK3ppKTtcbi8vXHRcdGZvciAodmFyIHlpID0gMCwgeW9mZj0wOyB5aSA8IG55OyB5aSsrLCB5b2ZmICs9IHlzdGVwKSB7XG4vL1x0XHRcdHZhciByb3cgPSAnJztcbi8vXHRcdFx0Zm9yICh2YXIgeGkgPSAwLCB4b2ZmPTA7IHhpIDwgbng7IHhpKyssIHhvZmYgKz0geHN0ZXApIHtcbi8vXHRcdFx0XHR2YXIgaWR4ID0geG9mZiArIHlvZmYgKyB6b2ZmO1xuLy9cdFx0XHRcdHJvdyArPSAnICcgKyBiaW5MZW5ndGhzW2lkeF07XG4vL1x0XHRcdH1cbi8vXHRcdFx0Y29uc29sZS5sb2cocm93KTtcbi8vXHRcdH1cbi8vXHR9XG5cbiAgICB0aGlzLm1ha2VQYWlyc1VuaXF1ZShwYWlyczEscGFpcnMyKTtcbn07XG5cbn0se1wiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi9zaGFwZXMvU2hhcGVcIjo0MyxcIi4vQnJvYWRwaGFzZVwiOjV9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gTmFpdmVCcm9hZHBoYXNlO1xuXG52YXIgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4vQnJvYWRwaGFzZScpO1xudmFyIEFBQkIgPSBfZGVyZXFfKCcuL0FBQkInKTtcblxuLyoqXG4gKiBOYWl2ZSBicm9hZHBoYXNlIGltcGxlbWVudGF0aW9uLCB1c2VkIGluIGxhY2sgb2YgYmV0dGVyIG9uZXMuXG4gKiBAY2xhc3MgTmFpdmVCcm9hZHBoYXNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjcmlwdGlvbiBUaGUgbmFpdmUgYnJvYWRwaGFzZSBsb29rcyBhdCBhbGwgcG9zc2libGUgcGFpcnMgd2l0aG91dCByZXN0cmljdGlvbiwgdGhlcmVmb3JlIGl0IGhhcyBjb21wbGV4aXR5IE5eMiAod2hpY2ggaXMgYmFkKVxuICogQGV4dGVuZHMgQnJvYWRwaGFzZVxuICovXG5mdW5jdGlvbiBOYWl2ZUJyb2FkcGhhc2UoKXtcbiAgICBCcm9hZHBoYXNlLmFwcGx5KHRoaXMpO1xufVxuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5OYWl2ZUJyb2FkcGhhc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTmFpdmVCcm9hZHBoYXNlO1xuXG4vKipcbiAqIEdldCBhbGwgdGhlIGNvbGxpc2lvbiBwYWlycyBpbiB0aGUgcGh5c2ljcyB3b3JsZFxuICogQG1ldGhvZCBjb2xsaXNpb25QYWlyc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzMVxuICogQHBhcmFtIHtBcnJheX0gcGFpcnMyXG4gKi9cbk5haXZlQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwYWlyczEscGFpcnMyKXtcbiAgICB2YXIgYm9kaWVzID0gd29ybGQuYm9kaWVzLFxuICAgICAgICBuID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgaSxqLGJpLGJqO1xuXG4gICAgLy8gTmFpdmUgTl4yIGZ0dyFcbiAgICBmb3IoaT0wOyBpIT09bjsgaSsrKXtcbiAgICAgICAgZm9yKGo9MDsgaiE9PWk7IGorKyl7XG5cbiAgICAgICAgICAgIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICAgICAgYmogPSBib2RpZXNbal07XG5cbiAgICAgICAgICAgIGlmKCF0aGlzLm5lZWRCcm9hZHBoYXNlQ29sbGlzaW9uKGJpLGJqKSl7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uVGVzdChiaSxiaixwYWlyczEscGFpcnMyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcblxuLyoqXG4gKiBSZXR1cm5zIGFsbCB0aGUgYm9kaWVzIHdpdGhpbiBhbiBBQUJCLlxuICogQG1ldGhvZCBhYWJiUXVlcnlcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IHRvIHN0b3JlIHJlc3VsdGluZyBib2RpZXMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuTmFpdmVCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgd29ybGQuYm9kaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSB3b3JsZC5ib2RpZXNbaV07XG5cbiAgICAgICAgaWYoYi5hYWJiTmVlZHNVcGRhdGUpe1xuICAgICAgICAgICAgYi5jb21wdXRlQUFCQigpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVWdseSBoYWNrIHVudGlsIEJvZHkgZ2V0cyBhYWJiXG4gICAgICAgIGlmKGIuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xufSx7XCIuL0FBQkJcIjozLFwiLi9Ccm9hZHBoYXNlXCI6NX1dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RDb2xsaXNpb25NYXRyaXg7XG5cbi8qKlxuICogUmVjb3JkcyB3aGF0IG9iamVjdHMgYXJlIGNvbGxpZGluZyB3aXRoIGVhY2ggb3RoZXJcbiAqIEBjbGFzcyBPYmplY3RDb2xsaXNpb25NYXRyaXhcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPYmplY3RDb2xsaXNpb25NYXRyaXgoKSB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF0cml4IHN0b3JhZ2VcbiAgICAgKiBAcHJvcGVydHkgbWF0cml4XG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblx0dGhpcy5tYXRyaXggPSB7fTtcbn1cblxuLyoqXG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XG5cdGkgPSBpLmlkO1xuXHRqID0gai5pZDtcbiAgICBpZiAoaiA+IGkpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuXHRyZXR1cm4gaSsnLScraiBpbiB0aGlzLm1hdHJpeDtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7TnVtYmVyfSBqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAqL1xuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihpLCBqLCB2YWx1ZSkge1xuXHRpID0gaS5pZDtcblx0aiA9IGouaWQ7XG4gICAgaWYgKGogPiBpKSB7XG4gICAgICAgIHZhciB0ZW1wID0gajtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGkgPSB0ZW1wO1xuXHR9XG5cdGlmICh2YWx1ZSkge1xuXHRcdHRoaXMubWF0cml4W2krJy0nK2pdID0gdHJ1ZTtcblx0fVxuXHRlbHNlIHtcblx0XHRkZWxldGUgdGhpcy5tYXRyaXhbaSsnLScral07XG5cdH1cbn07XG5cbi8qKlxuICogRW1wdHkgdGhlIG1hdHJpeFxuICogQG1ldGhvZCByZXNldFxuICovXG5PYmplY3RDb2xsaXNpb25NYXRyaXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMubWF0cml4ID0ge307XG59O1xuXG4vKipcbiAqIFNldCBtYXggbnVtYmVyIG9mIG9iamVjdHNcbiAqIEBtZXRob2Qgc2V0TnVtT2JqZWN0c1xuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqL1xuT2JqZWN0Q29sbGlzaW9uTWF0cml4LnByb3RvdHlwZS5zZXROdW1PYmplY3RzID0gZnVuY3Rpb24obikge1xufTtcblxufSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFJheTtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb24nKTtcbnZhciBCb3ggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQm94Jyk7XG52YXIgUmF5Y2FzdFJlc3VsdCA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXljYXN0UmVzdWx0Jyk7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcblxuLyoqXG4gKiBBIGxpbmUgaW4gM0Qgc3BhY2UgdGhhdCBpbnRlcnNlY3RzIGJvZGllcyBhbmQgcmV0dXJuIHBvaW50cy5cbiAqIEBjbGFzcyBSYXlcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0ge1ZlYzN9IHRvXG4gKi9cbmZ1bmN0aW9uIFJheShmcm9tLCB0byl7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBmcm9tXG4gICAgICovXG4gICAgdGhpcy5mcm9tID0gZnJvbSA/IGZyb20uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHRvXG4gICAgICovXG4gICAgdGhpcy50byA9IHRvID8gdG8uY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gX2RpcmVjdGlvblxuICAgICAqL1xuICAgIHRoaXMuX2RpcmVjdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlY2lzaW9uIG9mIHRoZSByYXkuIFVzZWQgd2hlbiBjaGVja2luZyBwYXJhbGxlbGl0eSBldGMuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHByZWNpc2lvblxuICAgICAqL1xuICAgIHRoaXMucHJlY2lzaW9uID0gMC4wMDAxO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdGhlIFJheSB0byB0YWtlIC5jb2xsaXNpb25SZXNwb25zZSBmbGFncyBpbnRvIGFjY291bnQgb24gYm9kaWVzIGFuZCBzaGFwZXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBjaGVja0NvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jaGVja0NvbGxpc2lvblJlc3BvbnNlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCB0aGUgcmF5IHNraXBzIGFueSBoaXRzIHdpdGggbm9ybWFsLmRvdChyYXlEaXJlY3Rpb24pIDwgMC5cbiAgICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IHNraXBCYWNrZmFjZXNcbiAgICAgKi9cbiAgICB0aGlzLnNraXBCYWNrZmFjZXMgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJNYXNrXG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpc2lvbkZpbHRlck1hc2sgPSAtMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJHcm91cFxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25GaWx0ZXJHcm91cCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGludGVyc2VjdGlvbiBtb2RlLiBTaG91bGQgYmUgUmF5LkFOWSwgUmF5LkFMTCBvciBSYXkuQ0xPU0VTVC5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbW9kZVxuICAgICAqL1xuICAgIHRoaXMubW9kZSA9IFJheS5BTlk7XG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IHJlc3VsdCBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAgICAgKi9cbiAgICB0aGlzLnJlc3VsdCA9IG5ldyBSYXljYXN0UmVzdWx0KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGR1cmluZyBpbnRlcnNlY3RXb3JsZCgpIGlmIHRoZSByYXkgaGl0IGFueXRoaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gaGFzSGl0XG4gICAgICovXG4gICAgdGhpcy5oYXNIaXQgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQsIHVzZXItcHJvdmlkZWQgcmVzdWx0IGNhbGxiYWNrLiBXaWxsIGJlIHVzZWQgaWYgbW9kZSBpcyBSYXkuQUxMLlxuICAgICAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgdGhpcy5jYWxsYmFjayA9IGZ1bmN0aW9uKHJlc3VsdCl7fTtcbn1cblJheS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSYXk7XG5cblJheS5DTE9TRVNUID0gMTtcblJheS5BTlkgPSAyO1xuUmF5LkFMTCA9IDQ7XG5cbnZhciB0bXBBQUJCID0gbmV3IEFBQkIoKTtcbnZhciB0bXBBcnJheSA9IFtdO1xuXG4vKipcbiAqIERvIGl0ZXJzZWN0aW9uIGFnYWluc3QgYWxsIGJvZGllcyBpbiB0aGUgZ2l2ZW4gV29ybGQuXG4gKiBAbWV0aG9kIGludGVyc2VjdFdvcmxkXG4gKiBAcGFyYW0gIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgcmF5IGhpdCBhbnl0aGluZywgb3RoZXJ3aXNlIGZhbHNlLlxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdFdvcmxkID0gZnVuY3Rpb24gKHdvcmxkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IFJheS5BTlk7XG4gICAgdGhpcy5yZXN1bHQgPSBvcHRpb25zLnJlc3VsdCB8fCBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuICAgIHRoaXMuc2tpcEJhY2tmYWNlcyA9ICEhb3B0aW9ucy5za2lwQmFja2ZhY2VzO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2spICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IC0xO1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IC0xO1xuICAgIGlmKG9wdGlvbnMuZnJvbSl7XG4gICAgICAgIHRoaXMuZnJvbS5jb3B5KG9wdGlvbnMuZnJvbSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMudG8pe1xuICAgICAgICB0aGlzLnRvLmNvcHkob3B0aW9ucy50byk7XG4gICAgfVxuICAgIHRoaXMuY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrIHx8IGZ1bmN0aW9uKCl7fTtcbiAgICB0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG4gICAgdGhpcy5yZXN1bHQucmVzZXQoKTtcbiAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcblxuICAgIHRoaXMuZ2V0QUFCQih0bXBBQUJCKTtcbiAgICB0bXBBcnJheS5sZW5ndGggPSAwO1xuICAgIHdvcmxkLmJyb2FkcGhhc2UuYWFiYlF1ZXJ5KHdvcmxkLCB0bXBBQUJCLCB0bXBBcnJheSk7XG4gICAgdGhpcy5pbnRlcnNlY3RCb2RpZXModG1wQXJyYXkpO1xuXG4gICAgcmV0dXJuIHRoaXMuaGFzSGl0O1xufTtcblxudmFyIHYxID0gbmV3IFZlYzMoKSxcbiAgICB2MiA9IG5ldyBWZWMzKCk7XG5cbi8qXG4gKiBBcyBwZXIgXCJCYXJ5Y2VudHJpYyBUZWNobmlxdWVcIiBhcyBuYW1lZCBoZXJlIGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWwgQnV0IHdpdGhvdXQgdGhlIGRpdmlzaW9uXG4gKi9cblJheS5wb2ludEluVHJpYW5nbGUgPSBwb2ludEluVHJpYW5nbGU7XG5mdW5jdGlvbiBwb2ludEluVHJpYW5nbGUocCwgYSwgYiwgYykge1xuICAgIGMudnN1YihhLHYwKTtcbiAgICBiLnZzdWIoYSx2MSk7XG4gICAgcC52c3ViKGEsdjIpO1xuXG4gICAgdmFyIGRvdDAwID0gdjAuZG90KCB2MCApO1xuICAgIHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcbiAgICB2YXIgZG90MDIgPSB2MC5kb3QoIHYyICk7XG4gICAgdmFyIGRvdDExID0gdjEuZG90KCB2MSApO1xuICAgIHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcblxuICAgIHZhciB1LHY7XG5cbiAgICByZXR1cm4gICggKHUgPSBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMikgPj0gMCApICYmXG4gICAgICAgICAgICAoICh2ID0gZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIpID49IDAgKSAmJlxuICAgICAgICAgICAgKCB1ICsgdiA8ICggZG90MDAgKiBkb3QxMSAtIGRvdDAxICogZG90MDEgKSApO1xufVxuXG4vKipcbiAqIFNob290IGEgcmF5IGF0IGEgYm9keSwgZ2V0IGJhY2sgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGhpdC5cbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm9keVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtSYXljYXN0UmVzdWx0fSBbcmVzdWx0XSBEZXByZWNhdGVkIC0gc2V0IHRoZSByZXN1bHQgcHJvcGVydHkgb2YgdGhlIFJheSBpbnN0ZWFkLlxuICovXG52YXIgaW50ZXJzZWN0Qm9keV94aSA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0Qm9keV9xaSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZHkgPSBmdW5jdGlvbiAoYm9keSwgcmVzdWx0KSB7XG4gICAgaWYocmVzdWx0KXtcbiAgICAgICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZURpcmVjdGlvbigpO1xuICAgIH1cbiAgICB2YXIgY2hlY2tDb2xsaXNpb25SZXNwb25zZSA9IHRoaXMuY2hlY2tDb2xsaXNpb25SZXNwb25zZTtcblxuICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIWJvZHkuY29sbGlzaW9uUmVzcG9uc2Upe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoKHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgJiBib2R5LmNvbGxpc2lvbkZpbHRlck1hc2spPT09MCB8fCAoYm9keS5jb2xsaXNpb25GaWx0ZXJHcm91cCAmIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayk9PT0wKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4aSA9IGludGVyc2VjdEJvZHlfeGk7XG4gICAgdmFyIHFpID0gaW50ZXJzZWN0Qm9keV9xaTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBOID0gYm9keS5zaGFwZXMubGVuZ3RoOyBpIDwgTjsgaSsrKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IGJvZHkuc2hhcGVzW2ldO1xuXG4gICAgICAgIGlmKGNoZWNrQ29sbGlzaW9uUmVzcG9uc2UgJiYgIXNoYXBlLmNvbGxpc2lvblJlc3BvbnNlKXtcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBTa2lwXG4gICAgICAgIH1cblxuICAgICAgICBib2R5LnF1YXRlcm5pb24ubXVsdChib2R5LnNoYXBlT3JpZW50YXRpb25zW2ldLCBxaSk7XG4gICAgICAgIGJvZHkucXVhdGVybmlvbi52bXVsdChib2R5LnNoYXBlT2Zmc2V0c1tpXSwgeGkpO1xuICAgICAgICB4aS52YWRkKGJvZHkucG9zaXRpb24sIHhpKTtcblxuICAgICAgICB0aGlzLmludGVyc2VjdFNoYXBlKFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBxaSxcbiAgICAgICAgICAgIHhpLFxuICAgICAgICAgICAgYm9keVxuICAgICAgICApO1xuXG4gICAgICAgIGlmKHRoaXMucmVzdWx0Ll9zaG91bGRTdG9wKXtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEJvZGllc1xuICogQHBhcmFtIHtBcnJheX0gYm9kaWVzIEFuIGFycmF5IG9mIEJvZHkgb2JqZWN0cy5cbiAqIEBwYXJhbSB7UmF5Y2FzdFJlc3VsdH0gW3Jlc3VsdF0gRGVwcmVjYXRlZFxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJvZGllcyA9IGZ1bmN0aW9uIChib2RpZXMsIHJlc3VsdCkge1xuICAgIGlmKHJlc3VsdCl7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICB0aGlzLl91cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB9XG5cbiAgICBmb3IgKCB2YXIgaSA9IDAsIGwgPSBib2RpZXMubGVuZ3RoOyAhdGhpcy5yZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGw7IGkgKysgKSB7XG4gICAgICAgIHRoaXMuaW50ZXJzZWN0Qm9keShib2RpZXNbaV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgX2RpcmVjdGlvbiB2ZWN0b3IuXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBfdXBkYXRlRGlyZWN0aW9uXG4gKi9cblJheS5wcm90b3R5cGUuX3VwZGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy50by52c3ViKHRoaXMuZnJvbSwgdGhpcy5fZGlyZWN0aW9uKTtcbiAgICB0aGlzLl9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0U2hhcGVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0ge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTaGFwZSA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSl7XG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG5cblxuICAgIC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlXG4gICAgdmFyIGRpc3RhbmNlID0gZGlzdGFuY2VGcm9tSW50ZXJzZWN0aW9uKGZyb20sIHRoaXMuX2RpcmVjdGlvbiwgcG9zaXRpb24pO1xuICAgIGlmICggZGlzdGFuY2UgPiBzaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnRlcnNlY3RNZXRob2QgPSB0aGlzW3NoYXBlLnR5cGVdO1xuICAgIGlmKGludGVyc2VjdE1ldGhvZCl7XG4gICAgICAgIGludGVyc2VjdE1ldGhvZC5jYWxsKHRoaXMsIHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSk7XG4gICAgfVxufTtcblxudmFyIHZlY3RvciA9IG5ldyBWZWMzKCk7XG52YXIgbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RQb2ludCA9IG5ldyBWZWMzKCk7XG5cbnZhciBhID0gbmV3IFZlYzMoKTtcbnZhciBiID0gbmV3IFZlYzMoKTtcbnZhciBjID0gbmV3IFZlYzMoKTtcbnZhciBkID0gbmV3IFZlYzMoKTtcblxudmFyIHRtcFJheWNhc3RSZXN1bHQgPSBuZXcgUmF5Y2FzdFJlc3VsdCgpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Qm94XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEJveCA9IGZ1bmN0aW9uKHNoYXBlLCBxdWF0LCBwb3NpdGlvbiwgYm9keSl7XG4gICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiwgcXVhdCwgcG9zaXRpb24sIGJvZHkpO1xufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0Qm94O1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0UGxhbmVcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmUgPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHZhciB0byA9IHRoaXMudG87XG4gICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbjtcblxuICAgIC8vIEdldCBwbGFuZSBub3JtYWxcbiAgICB2YXIgd29ybGROb3JtYWwgPSBuZXcgVmVjMygwLCAwLCAxKTtcbiAgICBxdWF0LnZtdWx0KHdvcmxkTm9ybWFsLCB3b3JsZE5vcm1hbCk7XG5cbiAgICB2YXIgbGVuID0gbmV3IFZlYzMoKTtcbiAgICBmcm9tLnZzdWIocG9zaXRpb24sIGxlbik7XG4gICAgdmFyIHBsYW5lVG9Gcm9tID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG4gICAgdG8udnN1Yihwb3NpdGlvbiwgbGVuKTtcbiAgICB2YXIgcGxhbmVUb1RvID0gbGVuLmRvdCh3b3JsZE5vcm1hbCk7XG5cbiAgICBpZihwbGFuZVRvRnJvbSAqIHBsYW5lVG9UbyA+IDApe1xuICAgICAgICAvLyBcImZyb21cIiBhbmQgXCJ0b1wiIGFyZSBvbiB0aGUgc2FtZSBzaWRlIG9mIHRoZSBwbGFuZS4uLiBiYWlsIG91dFxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoZnJvbS5kaXN0YW5jZVRvKHRvKSA8IHBsYW5lVG9Gcm9tKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuX2RvdF9kaXIgPSB3b3JsZE5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcblxuICAgIGlmIChNYXRoLmFicyhuX2RvdF9kaXIpIDwgdGhpcy5wcmVjaXNpb24pIHtcbiAgICAgICAgLy8gTm8gaW50ZXJzZWN0aW9uXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGxhbmVQb2ludFRvRnJvbSA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIGRpcl9zY2FsZWRfd2l0aF90ID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XG5cbiAgICBmcm9tLnZzdWIocG9zaXRpb24sIHBsYW5lUG9pbnRUb0Zyb20pO1xuICAgIHZhciB0ID0gLXdvcmxkTm9ybWFsLmRvdChwbGFuZVBvaW50VG9Gcm9tKSAvIG5fZG90X2RpcjtcbiAgICBkaXJlY3Rpb24uc2NhbGUodCwgZGlyX3NjYWxlZF93aXRoX3QpO1xuICAgIGZyb20udmFkZChkaXJfc2NhbGVkX3dpdGhfdCwgaGl0UG9pbnRXb3JsZCk7XG5cbiAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbih3b3JsZE5vcm1hbCwgaGl0UG9pbnRXb3JsZCwgc2hhcGUsIGJvZHksIC0xKTtcbn07XG5SYXkucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0UGxhbmU7XG5cbi8qKlxuICogR2V0IHRoZSB3b3JsZCBBQUJCIG9mIHRoZSByYXkuXG4gKiBAbWV0aG9kIGdldEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuUmF5LnByb3RvdHlwZS5nZXRBQUJCID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnggPSBNYXRoLm1pbih0by54LCBmcm9tLngpO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnkgPSBNYXRoLm1pbih0by55LCBmcm9tLnkpO1xuICAgIHJlc3VsdC5sb3dlckJvdW5kLnogPSBNYXRoLm1pbih0by56LCBmcm9tLnopO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnggPSBNYXRoLm1heCh0by54LCBmcm9tLngpO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnkgPSBNYXRoLm1heCh0by55LCBmcm9tLnkpO1xuICAgIHJlc3VsdC51cHBlckJvdW5kLnogPSBNYXRoLm1heCh0by56LCBmcm9tLnopO1xufTtcblxudmFyIGludGVyc2VjdENvbnZleE9wdGlvbnMgPSB7XG4gICAgZmFjZUxpc3Q6IFswXVxufTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdEhlaWdodGZpZWxkXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICovXG5SYXkucHJvdG90eXBlLmludGVyc2VjdEhlaWdodGZpZWxkID0gZnVuY3Rpb24oc2hhcGUsIHF1YXQsIHBvc2l0aW9uLCBib2R5KXtcbiAgICB2YXIgZGF0YSA9IHNoYXBlLmRhdGEsXG4gICAgICAgIHcgPSBzaGFwZS5lbGVtZW50U2l6ZSxcbiAgICAgICAgd29ybGRQaWxsYXJPZmZzZXQgPSBuZXcgVmVjMygpO1xuXG4gICAgLy8gQ29udmVydCB0aGUgcmF5IHRvIGxvY2FsIGhlaWdodGZpZWxkIGNvb3JkaW5hdGVzXG4gICAgdmFyIGxvY2FsUmF5ID0gbmV3IFJheSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgbG9jYWxSYXkuZnJvbSwgbG9jYWxSYXkuZnJvbSk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBsb2NhbFJheS50bywgbG9jYWxSYXkudG8pO1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIGluZGV4ID0gW107XG4gICAgdmFyIGlNaW5YID0gbnVsbDtcbiAgICB2YXIgaU1pblkgPSBudWxsO1xuICAgIHZhciBpTWF4WCA9IG51bGw7XG4gICAgdmFyIGlNYXhZID0gbnVsbDtcblxuICAgIHZhciBpbnNpZGUgPSBzaGFwZS5nZXRJbmRleE9mUG9zaXRpb24obG9jYWxSYXkuZnJvbS54LCBsb2NhbFJheS5mcm9tLnksIGluZGV4LCBmYWxzZSk7XG4gICAgaWYoaW5zaWRlKXtcbiAgICAgICAgaU1pblggPSBpbmRleFswXTtcbiAgICAgICAgaU1pblkgPSBpbmRleFsxXTtcbiAgICAgICAgaU1heFggPSBpbmRleFswXTtcbiAgICAgICAgaU1heFkgPSBpbmRleFsxXTtcbiAgICB9XG4gICAgaW5zaWRlID0gc2hhcGUuZ2V0SW5kZXhPZlBvc2l0aW9uKGxvY2FsUmF5LnRvLngsIGxvY2FsUmF5LnRvLnksIGluZGV4LCBmYWxzZSk7XG4gICAgaWYoaW5zaWRlKXtcbiAgICAgICAgaWYgKGlNaW5YID09PSBudWxsIHx8IGluZGV4WzBdIDwgaU1pblgpIHsgaU1pblggPSBpbmRleFswXTsgfVxuICAgICAgICBpZiAoaU1heFggPT09IG51bGwgfHwgaW5kZXhbMF0gPiBpTWF4WCkgeyBpTWF4WCA9IGluZGV4WzBdOyB9XG4gICAgICAgIGlmIChpTWluWSA9PT0gbnVsbCB8fCBpbmRleFsxXSA8IGlNaW5ZKSB7IGlNaW5ZID0gaW5kZXhbMV07IH1cbiAgICAgICAgaWYgKGlNYXhZID09PSBudWxsIHx8IGluZGV4WzFdID4gaU1heFkpIHsgaU1heFkgPSBpbmRleFsxXTsgfVxuICAgIH1cblxuICAgIGlmKGlNaW5YID09PSBudWxsKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtaW5NYXggPSBbXTtcbiAgICBzaGFwZS5nZXRSZWN0TWluTWF4KGlNaW5YLCBpTWluWSwgaU1heFgsIGlNYXhZLCBtaW5NYXgpO1xuICAgIHZhciBtaW4gPSBtaW5NYXhbMF07XG4gICAgdmFyIG1heCA9IG1pbk1heFsxXTtcblxuICAgIC8vIC8vIEJhaWwgb3V0IGlmIHRoZSByYXkgY2FuJ3QgdG91Y2ggdGhlIGJvdW5kaW5nIGJveFxuICAgIC8vIC8vIFRPRE9cbiAgICAvLyB2YXIgYWFiYiA9IG5ldyBBQUJCKCk7XG4gICAgLy8gdGhpcy5nZXRBQUJCKGFhYmIpO1xuICAgIC8vIGlmKGFhYmIuaW50ZXJzZWN0cygpKXtcbiAgICAvLyAgICAgcmV0dXJuO1xuICAgIC8vIH1cblxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDw9IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKXtcblxuICAgICAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIGZhbHNlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgcXVhdCwgc2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmludGVyc2VjdENvbnZleChzaGFwZS5waWxsYXJDb252ZXgsIHF1YXQsIHdvcmxkUGlsbGFyT2Zmc2V0LCBib2R5LCBpbnRlcnNlY3RDb252ZXhPcHRpb25zKTtcblxuICAgICAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXBwZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIHNoYXBlLmdldENvbnZleFRyaWFuZ2xlUGlsbGFyKGksIGosIHRydWUpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBzaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0Q29udmV4KHNoYXBlLnBpbGxhckNvbnZleCwgcXVhdCwgd29ybGRQaWxsYXJPZmZzZXQsIGJvZHksIGludGVyc2VjdENvbnZleE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuSEVJR0hURklFTERdID0gUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RIZWlnaHRmaWVsZDtcblxudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfaW50ZXJzZWN0aW9uUG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIFJheV9pbnRlcnNlY3RTcGhlcmVfbm9ybWFsID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFNwaGVyZVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSAge1NoYXBlfSBzaGFwZVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RTcGhlcmUgPSBmdW5jdGlvbihzaGFwZSwgcXVhdCwgcG9zaXRpb24sIGJvZHkpe1xuICAgIHZhciBmcm9tID0gdGhpcy5mcm9tLFxuICAgICAgICB0byA9IHRoaXMudG8sXG4gICAgICAgIHIgPSBzaGFwZS5yYWRpdXM7XG5cbiAgICB2YXIgYSA9IE1hdGgucG93KHRvLnggLSBmcm9tLngsIDIpICsgTWF0aC5wb3codG8ueSAtIGZyb20ueSwgMikgKyBNYXRoLnBvdyh0by56IC0gZnJvbS56LCAyKTtcbiAgICB2YXIgYiA9IDIgKiAoKHRvLnggLSBmcm9tLngpICogKGZyb20ueCAtIHBvc2l0aW9uLngpICsgKHRvLnkgLSBmcm9tLnkpICogKGZyb20ueSAtIHBvc2l0aW9uLnkpICsgKHRvLnogLSBmcm9tLnopICogKGZyb20ueiAtIHBvc2l0aW9uLnopKTtcbiAgICB2YXIgYyA9IE1hdGgucG93KGZyb20ueCAtIHBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3coZnJvbS55IC0gcG9zaXRpb24ueSwgMikgKyBNYXRoLnBvdyhmcm9tLnogLSBwb3NpdGlvbi56LCAyKSAtIE1hdGgucG93KHIsIDIpO1xuXG4gICAgdmFyIGRlbHRhID0gTWF0aC5wb3coYiwgMikgLSA0ICogYSAqIGM7XG5cbiAgICB2YXIgaW50ZXJzZWN0aW9uUG9pbnQgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX2ludGVyc2VjdGlvblBvaW50O1xuICAgIHZhciBub3JtYWwgPSBSYXlfaW50ZXJzZWN0U3BoZXJlX25vcm1hbDtcblxuICAgIGlmKGRlbHRhIDwgMCl7XG4gICAgICAgIC8vIE5vIGludGVyc2VjdGlvblxuICAgICAgICByZXR1cm47XG5cbiAgICB9IGVsc2UgaWYoZGVsdGEgPT09IDApe1xuICAgICAgICAvLyBzaW5nbGUgaW50ZXJzZWN0aW9uIHBvaW50XG4gICAgICAgIGZyb20ubGVycCh0bywgZGVsdGEsIGludGVyc2VjdGlvblBvaW50KTtcblxuICAgICAgICBpbnRlcnNlY3Rpb25Qb2ludC52c3ViKHBvc2l0aW9uLCBub3JtYWwpO1xuICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG5cbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3Rpb25Qb2ludCwgc2hhcGUsIGJvZHksIC0xKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkMSA9ICgtIGIgLSBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7XG4gICAgICAgIHZhciBkMiA9ICgtIGIgKyBNYXRoLnNxcnQoZGVsdGEpKSAvICgyICogYSk7XG5cbiAgICAgICAgaWYoZDEgPj0gMCAmJiBkMSA8PSAxKXtcbiAgICAgICAgICAgIGZyb20ubGVycCh0bywgZDEsIGludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5yZXN1bHQuX3Nob3VsZFN0b3Ape1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoZDIgPj0gMCAmJiBkMiA8PSAxKXtcbiAgICAgICAgICAgIGZyb20ubGVycCh0bywgZDIsIGludGVyc2VjdGlvblBvaW50KTtcbiAgICAgICAgICAgIGludGVyc2VjdGlvblBvaW50LnZzdWIocG9zaXRpb24sIG5vcm1hbCk7XG4gICAgICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEludGVyc2VjdGlvbihub3JtYWwsIGludGVyc2VjdGlvblBvaW50LCBzaGFwZSwgYm9keSwgLTEpO1xuICAgICAgICB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0U3BoZXJlO1xuXG5cbnZhciBpbnRlcnNlY3RDb252ZXhfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0Q29udmV4X21pbkRpc3RJbnRlcnNlY3QgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdENvbnZleF92ZWN0b3IgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgaW50ZXJzZWN0Q29udmV4XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKiBAcGFyYW0gIHtWZWMzfSBwb3NpdGlvblxuICogQHBhcmFtICB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHthcnJheX0gW29wdGlvbnMuZmFjZUxpc3RdXG4gKi9cblJheS5wcm90b3R5cGUuaW50ZXJzZWN0Q29udmV4ID0gZnVuY3Rpb24gaW50ZXJzZWN0Q29udmV4KFxuICAgIHNoYXBlLFxuICAgIHF1YXQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keSxcbiAgICBvcHRpb25zXG4pe1xuICAgIHZhciBtaW5EaXN0Tm9ybWFsID0gaW50ZXJzZWN0Q29udmV4X21pbkRpc3ROb3JtYWw7XG4gICAgdmFyIG5vcm1hbCA9IGludGVyc2VjdENvbnZleF9ub3JtYWw7XG4gICAgdmFyIHZlY3RvciA9IGludGVyc2VjdENvbnZleF92ZWN0b3I7XG4gICAgdmFyIG1pbkRpc3RJbnRlcnNlY3QgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdEludGVyc2VjdDtcbiAgICB2YXIgZmFjZUxpc3QgPSAob3B0aW9ucyAmJiBvcHRpb25zLmZhY2VMaXN0KSB8fCBudWxsO1xuXG4gICAgLy8gQ2hlY2tpbmcgZmFjZXNcbiAgICB2YXIgZmFjZXMgPSBzaGFwZS5mYWNlcyxcbiAgICAgICAgdmVydGljZXMgPSBzaGFwZS52ZXJ0aWNlcyxcbiAgICAgICAgbm9ybWFscyA9IHNoYXBlLmZhY2VOb3JtYWxzO1xuICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb247XG5cbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBmcm9tVG9EaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyh0byk7XG5cbiAgICB2YXIgbWluRGlzdCA9IC0xO1xuICAgIHZhciBOZmFjZXMgPSBmYWNlTGlzdCA/IGZhY2VMaXN0Lmxlbmd0aCA6IGZhY2VzLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgIXJlc3VsdC5fc2hvdWxkU3RvcCAmJiBqIDwgTmZhY2VzOyBqKyspIHtcbiAgICAgICAgdmFyIGZpID0gZmFjZUxpc3QgPyBmYWNlTGlzdFtqXSA6IGo7XG5cbiAgICAgICAgdmFyIGZhY2UgPSBmYWNlc1tmaV07XG4gICAgICAgIHZhciBmYWNlTm9ybWFsID0gbm9ybWFsc1tmaV07XG4gICAgICAgIHZhciBxID0gcXVhdDtcbiAgICAgICAgdmFyIHggPSBwb3NpdGlvbjtcblxuICAgICAgICAvLyBkZXRlcm1pbmUgaWYgcmF5IGludGVyc2VjdHMgdGhlIHBsYW5lIG9mIHRoZSBmYWNlXG4gICAgICAgIC8vIG5vdGU6IHRoaXMgd29ya3MgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBmYWNlIG5vcm1hbFxuXG4gICAgICAgIC8vIEdldCBwbGFuZSBwb2ludCBpbiB3b3JsZCBjb29yZGluYXRlcy4uLlxuICAgICAgICB2ZWN0b3IuY29weSh2ZXJ0aWNlc1tmYWNlWzBdXSk7XG4gICAgICAgIHEudm11bHQodmVjdG9yLHZlY3Rvcik7XG4gICAgICAgIHZlY3Rvci52YWRkKHgsdmVjdG9yKTtcblxuICAgICAgICAvLyAuLi5idXQgbWFrZSBpdCByZWxhdGl2ZSB0byB0aGUgcmF5IGZyb20uIFdlJ2xsIGZpeCB0aGlzIGxhdGVyLlxuICAgICAgICB2ZWN0b3IudnN1Yihmcm9tLHZlY3Rvcik7XG5cbiAgICAgICAgLy8gR2V0IHBsYW5lIG5vcm1hbFxuICAgICAgICBxLnZtdWx0KGZhY2VOb3JtYWwsbm9ybWFsKTtcblxuICAgICAgICAvLyBJZiB0aGlzIGRvdCBwcm9kdWN0IGlzIG5lZ2F0aXZlLCB3ZSBoYXZlIHNvbWV0aGluZyBpbnRlcmVzdGluZ1xuICAgICAgICB2YXIgZG90ID0gZGlyZWN0aW9uLmRvdChub3JtYWwpO1xuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsXG4gICAgICAgIGlmICggTWF0aC5hYnMoIGRvdCApIDwgdGhpcy5wcmVjaXNpb24gKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsYyBkaXN0YW5jZSB0byBwbGFuZVxuICAgICAgICB2YXIgc2NhbGFyID0gbm9ybWFsLmRvdCh2ZWN0b3IpIC8gZG90O1xuXG4gICAgICAgIC8vIGlmIG5lZ2F0aXZlIGRpc3RhbmNlLCB0aGVuIHBsYW5lIGlzIGJlaGluZCByYXlcbiAgICAgICAgaWYgKHNjYWxhciA8IDApe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiAoZG90IDwgMCkge1xuXG4gICAgICAgIC8vIEludGVyc2VjdGlvbiBwb2ludCBpcyBmcm9tICsgZGlyZWN0aW9uICogc2NhbGFyXG4gICAgICAgIGRpcmVjdGlvbi5tdWx0KHNjYWxhcixpbnRlcnNlY3RQb2ludCk7XG4gICAgICAgIGludGVyc2VjdFBvaW50LnZhZGQoZnJvbSxpbnRlcnNlY3RQb2ludCk7XG5cbiAgICAgICAgLy8gYSBpcyB0aGUgcG9pbnQgd2UgY29tcGFyZSBwb2ludHMgYiBhbmQgYyB3aXRoLlxuICAgICAgICBhLmNvcHkodmVydGljZXNbZmFjZVswXV0pO1xuICAgICAgICBxLnZtdWx0KGEsYSk7XG4gICAgICAgIHgudmFkZChhLGEpO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDE7ICFyZXN1bHQuX3Nob3VsZFN0b3AgJiYgaSA8IGZhY2UubGVuZ3RoIC0gMTsgaSsrKXtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSAzIHZlcnRpY2VzIHRvIHdvcmxkIGNvb3Jkc1xuICAgICAgICAgICAgYi5jb3B5KHZlcnRpY2VzW2ZhY2VbaV1dKTtcbiAgICAgICAgICAgIGMuY29weSh2ZXJ0aWNlc1tmYWNlW2krMV1dKTtcbiAgICAgICAgICAgIHEudm11bHQoYixiKTtcbiAgICAgICAgICAgIHEudm11bHQoYyxjKTtcbiAgICAgICAgICAgIHgudmFkZChiLGIpO1xuICAgICAgICAgICAgeC52YWRkKGMsYyk7XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlVG8oZnJvbSk7XG5cbiAgICAgICAgICAgIGlmKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBhLCBiLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGIsIGEsIGMpKSB8fCBkaXN0YW5jZSA+IGZyb21Ub0Rpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24obm9ybWFsLCBpbnRlcnNlY3RQb2ludCwgc2hhcGUsIGJvZHksIGZpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB9XG4gICAgfVxufTtcblJheS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPSBSYXkucHJvdG90eXBlLmludGVyc2VjdENvbnZleDtcblxudmFyIGludGVyc2VjdFRyaW1lc2hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbSA9IG5ldyBWZWMzKCk7XG52YXIgaW50ZXJzZWN0VHJpbWVzaF9sb2NhbFRvID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3dvcmxkSW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIGludGVyc2VjdFRyaW1lc2hfbG9jYWxBQUJCID0gbmV3IEFBQkIoKTtcbnZhciBpbnRlcnNlY3RUcmltZXNoX3RyaWFuZ2xlcyA9IFtdO1xudmFyIGludGVyc2VjdFRyaW1lc2hfdHJlZVRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm0oKTtcblxuLyoqXG4gKiBAbWV0aG9kIGludGVyc2VjdFRyaW1lc2hcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc2l0aW9uXG4gKiBAcGFyYW0gIHtCb2R5fSBib2R5XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAdG9kbyBPcHRpbWl6ZSBieSB0cmFuc2Zvcm1pbmcgdGhlIHdvcmxkIHRvIGxvY2FsIHNwYWNlIGZpcnN0LlxuICogQHRvZG8gVXNlIE9jdHJlZSBsb29rdXBcbiAqL1xuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RUcmltZXNoID0gZnVuY3Rpb24gaW50ZXJzZWN0VHJpbWVzaChcbiAgICBtZXNoLFxuICAgIHF1YXQsXG4gICAgcG9zaXRpb24sXG4gICAgYm9keSxcbiAgICBvcHRpb25zXG4pe1xuICAgIHZhciBub3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX25vcm1hbDtcbiAgICB2YXIgdHJpYW5nbGVzID0gaW50ZXJzZWN0VHJpbWVzaF90cmlhbmdsZXM7XG4gICAgdmFyIHRyZWVUcmFuc2Zvcm0gPSBpbnRlcnNlY3RUcmltZXNoX3RyZWVUcmFuc2Zvcm07XG4gICAgdmFyIG1pbkRpc3ROb3JtYWwgPSBpbnRlcnNlY3RDb252ZXhfbWluRGlzdE5vcm1hbDtcbiAgICB2YXIgdmVjdG9yID0gaW50ZXJzZWN0Q29udmV4X3ZlY3RvcjtcbiAgICB2YXIgbWluRGlzdEludGVyc2VjdCA9IGludGVyc2VjdENvbnZleF9taW5EaXN0SW50ZXJzZWN0O1xuICAgIHZhciBsb2NhbEFBQkIgPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsQUFCQjtcbiAgICB2YXIgbG9jYWxEaXJlY3Rpb24gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRGlyZWN0aW9uO1xuICAgIHZhciBsb2NhbEZyb20gPSBpbnRlcnNlY3RUcmltZXNoX2xvY2FsRnJvbTtcbiAgICB2YXIgbG9jYWxUbyA9IGludGVyc2VjdFRyaW1lc2hfbG9jYWxUbztcbiAgICB2YXIgd29ybGRJbnRlcnNlY3RQb2ludCA9IGludGVyc2VjdFRyaW1lc2hfd29ybGRJbnRlcnNlY3RQb2ludDtcbiAgICB2YXIgd29ybGROb3JtYWwgPSBpbnRlcnNlY3RUcmltZXNoX3dvcmxkTm9ybWFsO1xuICAgIHZhciBmYWNlTGlzdCA9IChvcHRpb25zICYmIG9wdGlvbnMuZmFjZUxpc3QpIHx8IG51bGw7XG5cbiAgICAvLyBDaGVja2luZyBmYWNlc1xuICAgIHZhciBpbmRpY2VzID0gbWVzaC5pbmRpY2VzLFxuICAgICAgICB2ZXJ0aWNlcyA9IG1lc2gudmVydGljZXMsXG4gICAgICAgIG5vcm1hbHMgPSBtZXNoLmZhY2VOb3JtYWxzO1xuXG4gICAgdmFyIGZyb20gPSB0aGlzLmZyb207XG4gICAgdmFyIHRvID0gdGhpcy50bztcbiAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uO1xuXG4gICAgdmFyIG1pbkRpc3QgPSAtMTtcbiAgICB0cmVlVHJhbnNmb3JtLnBvc2l0aW9uLmNvcHkocG9zaXRpb24pO1xuICAgIHRyZWVUcmFuc2Zvcm0ucXVhdGVybmlvbi5jb3B5KHF1YXQpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJheSB0byBsb2NhbCBzcGFjZSFcbiAgICBUcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lKHBvc2l0aW9uLCBxdWF0LCBkaXJlY3Rpb24sIGxvY2FsRGlyZWN0aW9uKTtcbiAgICAvL2JvZHkudmVjdG9yVG9Mb2NhbEZyYW1lKGRpcmVjdGlvbiwgbG9jYWxEaXJlY3Rpb24pO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShwb3NpdGlvbiwgcXVhdCwgZnJvbSwgbG9jYWxGcm9tKTtcbiAgICAvL2JvZHkucG9pbnRUb0xvY2FsRnJhbWUoZnJvbSwgbG9jYWxGcm9tKTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zaXRpb24sIHF1YXQsIHRvLCBsb2NhbFRvKTtcbiAgICAvL2JvZHkucG9pbnRUb0xvY2FsRnJhbWUodG8sIGxvY2FsVG8pO1xuICAgIHZhciBmcm9tVG9EaXN0YW5jZVNxdWFyZWQgPSBsb2NhbEZyb20uZGlzdGFuY2VTcXVhcmVkKGxvY2FsVG8pO1xuXG4gICAgbWVzaC50cmVlLnJheVF1ZXJ5KHRoaXMsIHRyZWVUcmFuc2Zvcm0sIHRyaWFuZ2xlcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7ICF0aGlzLnJlc3VsdC5fc2hvdWxkU3RvcCAmJiBpICE9PSBOOyBpKyspIHtcbiAgICAgICAgdmFyIHRyaWFuZ2xlc0luZGV4ID0gdHJpYW5nbGVzW2ldO1xuXG4gICAgICAgIG1lc2guZ2V0Tm9ybWFsKHRyaWFuZ2xlc0luZGV4LCBub3JtYWwpO1xuXG4gICAgICAgIC8vIGRldGVybWluZSBpZiByYXkgaW50ZXJzZWN0cyB0aGUgcGxhbmUgb2YgdGhlIGZhY2VcbiAgICAgICAgLy8gbm90ZTogdGhpcyB3b3JrcyByZWdhcmRsZXNzIG9mIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGZhY2Ugbm9ybWFsXG5cbiAgICAgICAgLy8gR2V0IHBsYW5lIHBvaW50IGluIHdvcmxkIGNvb3JkaW5hdGVzLi4uXG4gICAgICAgIG1lc2guZ2V0VmVydGV4KGluZGljZXNbdHJpYW5nbGVzSW5kZXggKiAzXSwgYSk7XG5cbiAgICAgICAgLy8gLi4uYnV0IG1ha2UgaXQgcmVsYXRpdmUgdG8gdGhlIHJheSBmcm9tLiBXZSdsbCBmaXggdGhpcyBsYXRlci5cbiAgICAgICAgYS52c3ViKGxvY2FsRnJvbSx2ZWN0b3IpO1xuXG4gICAgICAgIC8vIEdldCBwbGFuZSBub3JtYWxcbiAgICAgICAgLy8gcXVhdC52bXVsdChub3JtYWwsIG5vcm1hbCk7XG5cbiAgICAgICAgLy8gSWYgdGhpcyBkb3QgcHJvZHVjdCBpcyBuZWdhdGl2ZSwgd2UgaGF2ZSBzb21ldGhpbmcgaW50ZXJlc3RpbmdcbiAgICAgICAgdmFyIGRvdCA9IGxvY2FsRGlyZWN0aW9uLmRvdChub3JtYWwpO1xuXG4gICAgICAgIC8vIEJhaWwgb3V0IGlmIHJheSBhbmQgcGxhbmUgYXJlIHBhcmFsbGVsXG4gICAgICAgIC8vIGlmIChNYXRoLmFicyggZG90ICkgPCB0aGlzLnByZWNpc2lvbil7XG4gICAgICAgIC8vICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNhbGMgZGlzdGFuY2UgdG8gcGxhbmVcbiAgICAgICAgdmFyIHNjYWxhciA9IG5vcm1hbC5kb3QodmVjdG9yKSAvIGRvdDtcblxuICAgICAgICAvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5XG4gICAgICAgIGlmIChzY2FsYXIgPCAwKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIHBvaW50IGlzIGZyb20gKyBkaXJlY3Rpb24gKiBzY2FsYXJcbiAgICAgICAgbG9jYWxEaXJlY3Rpb24uc2NhbGUoc2NhbGFyLGludGVyc2VjdFBvaW50KTtcbiAgICAgICAgaW50ZXJzZWN0UG9pbnQudmFkZChsb2NhbEZyb20saW50ZXJzZWN0UG9pbnQpO1xuXG4gICAgICAgIC8vIEdldCB0cmlhbmdsZSB2ZXJ0aWNlc1xuICAgICAgICBtZXNoLmdldFZlcnRleChpbmRpY2VzW3RyaWFuZ2xlc0luZGV4ICogMyArIDFdLCBiKTtcbiAgICAgICAgbWVzaC5nZXRWZXJ0ZXgoaW5kaWNlc1t0cmlhbmdsZXNJbmRleCAqIDMgKyAyXSwgYyk7XG5cbiAgICAgICAgdmFyIHNxdWFyZWREaXN0YW5jZSA9IGludGVyc2VjdFBvaW50LmRpc3RhbmNlU3F1YXJlZChsb2NhbEZyb20pO1xuXG4gICAgICAgIGlmKCEocG9pbnRJblRyaWFuZ2xlKGludGVyc2VjdFBvaW50LCBiLCBhLCBjKSB8fCBwb2ludEluVHJpYW5nbGUoaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGMpKSB8fCBzcXVhcmVkRGlzdGFuY2UgPiBmcm9tVG9EaXN0YW5jZVNxdWFyZWQpe1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0cmFuc2Zvcm0gaW50ZXJzZWN0cG9pbnQgYW5kIG5vcm1hbCB0byB3b3JsZFxuICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHF1YXQsIG5vcm1hbCwgd29ybGROb3JtYWwpO1xuICAgICAgICAvL2JvZHkudmVjdG9yVG9Xb3JsZEZyYW1lKG5vcm1hbCwgd29ybGROb3JtYWwpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUocG9zaXRpb24sIHF1YXQsIGludGVyc2VjdFBvaW50LCB3b3JsZEludGVyc2VjdFBvaW50KTtcbiAgICAgICAgLy9ib2R5LnBvaW50VG9Xb3JsZEZyYW1lKGludGVyc2VjdFBvaW50LCB3b3JsZEludGVyc2VjdFBvaW50KTtcbiAgICAgICAgdGhpcy5yZXBvcnRJbnRlcnNlY3Rpb24od29ybGROb3JtYWwsIHdvcmxkSW50ZXJzZWN0UG9pbnQsIG1lc2gsIGJvZHksIHRyaWFuZ2xlc0luZGV4KTtcbiAgICB9XG4gICAgdHJpYW5nbGVzLmxlbmd0aCA9IDA7XG59O1xuUmF5LnByb3RvdHlwZVtTaGFwZS50eXBlcy5UUklNRVNIXSA9IFJheS5wcm90b3R5cGUuaW50ZXJzZWN0VHJpbWVzaDtcblxuXG4vKipcbiAqIEBtZXRob2QgcmVwb3J0SW50ZXJzZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtICB7VmVjM30gbm9ybWFsXG4gKiBAcGFyYW0gIHtWZWMzfSBoaXRQb2ludFdvcmxkXG4gKiBAcGFyYW0gIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSAge0JvZHl9IGJvZHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGludGVyc2VjdGlvbnMgc2hvdWxkIGNvbnRpbnVlXG4gKi9cblJheS5wcm90b3R5cGUucmVwb3J0SW50ZXJzZWN0aW9uID0gZnVuY3Rpb24obm9ybWFsLCBoaXRQb2ludFdvcmxkLCBzaGFwZSwgYm9keSwgaGl0RmFjZUluZGV4KXtcbiAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICB2YXIgdG8gPSB0aGlzLnRvO1xuICAgIHZhciBkaXN0YW5jZSA9IGZyb20uZGlzdGFuY2VUbyhoaXRQb2ludFdvcmxkKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG5cbiAgICAvLyBTa2lwIGJhY2sgZmFjZXM/XG4gICAgaWYodGhpcy5za2lwQmFja2ZhY2VzICYmIG5vcm1hbC5kb3QodGhpcy5fZGlyZWN0aW9uKSA+IDApe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzdWx0LmhpdEZhY2VJbmRleCA9IHR5cGVvZihoaXRGYWNlSW5kZXgpICE9PSAndW5kZWZpbmVkJyA/IGhpdEZhY2VJbmRleCA6IC0xO1xuXG4gICAgc3dpdGNoKHRoaXMubW9kZSl7XG4gICAgY2FzZSBSYXkuQUxMOlxuICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICBoaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgc2hhcGUsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgZGlzdGFuY2VcbiAgICAgICAgKTtcbiAgICAgICAgcmVzdWx0Lmhhc0hpdCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2socmVzdWx0KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFJheS5DTE9TRVNUOlxuXG4gICAgICAgIC8vIFN0b3JlIGlmIGNsb3NlciB0aGFuIGN1cnJlbnQgY2xvc2VzdFxuICAgICAgICBpZihkaXN0YW5jZSA8IHJlc3VsdC5kaXN0YW5jZSB8fCAhcmVzdWx0Lmhhc0hpdCl7XG4gICAgICAgICAgICB0aGlzLmhhc0hpdCA9IHRydWU7XG4gICAgICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBub3JtYWwsXG4gICAgICAgICAgICAgICAgaGl0UG9pbnRXb3JsZCxcbiAgICAgICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBSYXkuQU5ZOlxuXG4gICAgICAgIC8vIFJlcG9ydCBhbmQgc3RvcC5cbiAgICAgICAgdGhpcy5oYXNIaXQgPSB0cnVlO1xuICAgICAgICByZXN1bHQuaGFzSGl0ID0gdHJ1ZTtcbiAgICAgICAgcmVzdWx0LnNldChcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIG5vcm1hbCxcbiAgICAgICAgICAgIGhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICBzaGFwZSxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICApO1xuICAgICAgICByZXN1bHQuX3Nob3VsZFN0b3AgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG52YXIgdjAgPSBuZXcgVmVjMygpLFxuICAgIGludGVyc2VjdCA9IG5ldyBWZWMzKCk7XG5mdW5jdGlvbiBkaXN0YW5jZUZyb21JbnRlcnNlY3Rpb24oZnJvbSwgZGlyZWN0aW9uLCBwb3NpdGlvbikge1xuXG4gICAgLy8gdjAgaXMgdmVjdG9yIGZyb20gZnJvbSB0byBwb3NpdGlvblxuICAgIHBvc2l0aW9uLnZzdWIoZnJvbSx2MCk7XG4gICAgdmFyIGRvdCA9IHYwLmRvdChkaXJlY3Rpb24pO1xuXG4gICAgLy8gaW50ZXJzZWN0ID0gZGlyZWN0aW9uKmRvdCArIGZyb21cbiAgICBkaXJlY3Rpb24ubXVsdChkb3QsaW50ZXJzZWN0KTtcbiAgICBpbnRlcnNlY3QudmFkZChmcm9tLGludGVyc2VjdCk7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSBwb3NpdGlvbi5kaXN0YW5jZVRvKGludGVyc2VjdCk7XG5cbiAgICByZXR1cm4gZGlzdGFuY2U7XG59XG5cblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEwLFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1RyYW5zZm9ybVwiOjI5LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi9zaGFwZXMvQm94XCI6MzcsXCIuLi9zaGFwZXMvQ29udmV4UG9seWhlZHJvblwiOjM4LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDN9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RSZXN1bHQ7XG5cbi8qKlxuICogU3RvcmFnZSBmb3IgUmF5IGNhc3RpbmcgZGF0YS5cbiAqIEBjbGFzcyBSYXljYXN0UmVzdWx0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdFJlc3VsdCgpe1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHJheUZyb21Xb3JsZFxuXHQgKi9cblx0dGhpcy5yYXlGcm9tV29ybGQgPSBuZXcgVmVjMygpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IHJheVRvV29ybGRcblx0ICovXG5cdHRoaXMucmF5VG9Xb3JsZCA9IG5ldyBWZWMzKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gaGl0Tm9ybWFsV29ybGRcblx0ICovXG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQgPSBuZXcgVmVjMygpO1xuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1ZlYzN9IGhpdFBvaW50V29ybGRcblx0ICovXG5cdHRoaXMuaGl0UG9pbnRXb3JsZCA9IG5ldyBWZWMzKCk7XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzSGl0XG5cdCAqL1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBUaGUgaGl0IHNoYXBlLCBvciBudWxsLlxuXHQgKiBAcHJvcGVydHkge1NoYXBlfSBzaGFwZVxuXHQgKi9cblx0dGhpcy5zaGFwZSA9IG51bGw7XG5cblx0LyoqXG5cdCAqIFRoZSBoaXQgYm9keSwgb3IgbnVsbC5cblx0ICogQHByb3BlcnR5IHtCb2R5fSBib2R5XG5cdCAqL1xuXHR0aGlzLmJvZHkgPSBudWxsO1xuXG5cdC8qKlxuXHQgKiBUaGUgaW5kZXggb2YgdGhlIGhpdCB0cmlhbmdsZSwgaWYgdGhlIGhpdCBzaGFwZSB3YXMgYSB0cmltZXNoLlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gaGl0RmFjZUluZGV4XG5cdCAqIEBkZWZhdWx0IC0xXG5cdCAqL1xuXHR0aGlzLmhpdEZhY2VJbmRleCA9IC0xO1xuXG5cdC8qKlxuXHQgKiBEaXN0YW5jZSB0byB0aGUgaGl0LiBXaWxsIGJlIHNldCB0byAtMSBpZiB0aGVyZSB3YXMgbm8gaGl0LlxuXHQgKiBAcHJvcGVydHkge251bWJlcn0gZGlzdGFuY2Vcblx0ICogQGRlZmF1bHQgLTFcblx0ICovXG5cdHRoaXMuZGlzdGFuY2UgPSAtMTtcblxuXHQvKipcblx0ICogSWYgdGhlIHJheSBzaG91bGQgc3RvcCB0cmF2ZXJzaW5nIHRoZSBib2RpZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gX3Nob3VsZFN0b3Bcblx0ICogQGRlZmF1bHQgZmFsc2Vcblx0ICovXG5cdHRoaXMuX3Nob3VsZFN0b3AgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXNldCBhbGwgcmVzdWx0IGRhdGEuXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuXHR0aGlzLnJheUZyb21Xb3JsZC5zZXRaZXJvKCk7XG5cdHRoaXMucmF5VG9Xb3JsZC5zZXRaZXJvKCk7XG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQuc2V0WmVybygpO1xuXHR0aGlzLmhpdFBvaW50V29ybGQuc2V0WmVybygpO1xuXHR0aGlzLmhhc0hpdCA9IGZhbHNlO1xuXHR0aGlzLnNoYXBlID0gbnVsbDtcblx0dGhpcy5ib2R5ID0gbnVsbDtcblx0dGhpcy5oaXRGYWNlSW5kZXggPSAtMTtcblx0dGhpcy5kaXN0YW5jZSA9IC0xO1xuXHR0aGlzLl9zaG91bGRTdG9wID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgYWJvcnRcbiAqL1xuUmF5Y2FzdFJlc3VsdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuXHR0aGlzLl9zaG91bGRTdG9wID0gdHJ1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7VmVjM30gcmF5RnJvbVdvcmxkXG4gKiBAcGFyYW0ge1ZlYzN9IHJheVRvV29ybGRcbiAqIEBwYXJhbSB7VmVjM30gaGl0Tm9ybWFsV29ybGRcbiAqIEBwYXJhbSB7VmVjM30gaGl0UG9pbnRXb3JsZFxuICogQHBhcmFtIHtTaGFwZX0gc2hhcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cblJheWNhc3RSZXN1bHQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKFxuXHRyYXlGcm9tV29ybGQsXG5cdHJheVRvV29ybGQsXG5cdGhpdE5vcm1hbFdvcmxkLFxuXHRoaXRQb2ludFdvcmxkLFxuXHRzaGFwZSxcblx0Ym9keSxcblx0ZGlzdGFuY2Vcbil7XG5cdHRoaXMucmF5RnJvbVdvcmxkLmNvcHkocmF5RnJvbVdvcmxkKTtcblx0dGhpcy5yYXlUb1dvcmxkLmNvcHkocmF5VG9Xb3JsZCk7XG5cdHRoaXMuaGl0Tm9ybWFsV29ybGQuY29weShoaXROb3JtYWxXb3JsZCk7XG5cdHRoaXMuaGl0UG9pbnRXb3JsZC5jb3B5KGhpdFBvaW50V29ybGQpO1xuXHR0aGlzLnNoYXBlID0gc2hhcGU7XG5cdHRoaXMuYm9keSA9IGJvZHk7XG5cdHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbn07XG59LHtcIi4uL21hdGgvVmVjM1wiOjMwfV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgQnJvYWRwaGFzZSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9Ccm9hZHBoYXNlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gU0FQQnJvYWRwaGFzZTtcblxuLyoqXG4gKiBTd2VlcCBhbmQgcHJ1bmUgYnJvYWRwaGFzZSBhbG9uZyBvbmUgYXhpcy5cbiAqXG4gKiBAY2xhc3MgU0FQQnJvYWRwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1dvcmxkfSBbd29ybGRdXG4gKiBAZXh0ZW5kcyBCcm9hZHBoYXNlXG4gKi9cbmZ1bmN0aW9uIFNBUEJyb2FkcGhhc2Uod29ybGQpe1xuICAgIEJyb2FkcGhhc2UuYXBwbHkodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGJvZGllcyBjdXJyZW50bHkgaW4gdGhlIGJyb2FkcGhhc2UuXG4gICAgICogQHByb3BlcnR5IGF4aXNMaXN0XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYXhpc0xpc3QgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3b3JsZCB0byBzZWFyY2ggaW4uXG4gICAgICogQHByb3BlcnR5IHdvcmxkXG4gICAgICogQHR5cGUge1dvcmxkfVxuICAgICAqL1xuICAgIHRoaXMud29ybGQgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXhpcyB0byBzb3J0IHRoZSBib2RpZXMgYWxvbmcuIFNldCB0byAwIGZvciB4IGF4aXMsIGFuZCAxIGZvciB5IGF4aXMuIEZvciBiZXN0IHBlcmZvcm1hbmNlLCBjaG9vc2UgYW4gYXhpcyB0aGF0IHRoZSBib2RpZXMgYXJlIHNwcmVhZCBvdXQgbW9yZSBvbi5cbiAgICAgKiBAcHJvcGVydHkgYXhpc0luZGV4XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmF4aXNJbmRleCA9IDA7XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuXG4gICAgdGhpcy5fYWRkQm9keUhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgYXhpc0xpc3QucHVzaChlLmJvZHkpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgaWR4ID0gYXhpc0xpc3QuaW5kZXhPZihlLmJvZHkpO1xuICAgICAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgICAgIGF4aXNMaXN0LnNwbGljZShpZHgsMSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYod29ybGQpe1xuICAgICAgICB0aGlzLnNldFdvcmxkKHdvcmxkKTtcbiAgICB9XG59XG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZSA9IG5ldyBCcm9hZHBoYXNlKCk7XG5cbi8qKlxuICogQ2hhbmdlIHRoZSB3b3JsZFxuICogQG1ldGhvZCBzZXRXb3JsZFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNBUEJyb2FkcGhhc2UucHJvdG90eXBlLnNldFdvcmxkID0gZnVuY3Rpb24od29ybGQpe1xuICAgIC8vIENsZWFyIHRoZSBvbGQgYXhpcyBhcnJheVxuICAgIHRoaXMuYXhpc0xpc3QubGVuZ3RoID0gMDtcblxuICAgIC8vIEFkZCBhbGwgYm9kaWVzIGZyb20gdGhlIG5ldyB3b3JsZFxuICAgIGZvcih2YXIgaT0wOyBpPHdvcmxkLmJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHRoaXMuYXhpc0xpc3QucHVzaCh3b3JsZC5ib2RpZXNbaV0pO1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBvbGQgaGFuZGxlcnMsIGlmIGFueVxuICAgIHdvcmxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhZGRCb2R5XCIsIHRoaXMuX2FkZEJvZHlIYW5kbGVyKTtcbiAgICB3b3JsZC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVtb3ZlQm9keVwiLCB0aGlzLl9yZW1vdmVCb2R5SGFuZGxlcik7XG5cbiAgICAvLyBBZGQgaGFuZGxlcnMgdG8gdXBkYXRlIHRoZSBsaXN0IG9mIGJvZGllcy5cbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKFwiYWRkQm9keVwiLCB0aGlzLl9hZGRCb2R5SGFuZGxlcik7XG4gICAgd29ybGQuYWRkRXZlbnRMaXN0ZW5lcihcInJlbW92ZUJvZHlcIiwgdGhpcy5fcmVtb3ZlQm9keUhhbmRsZXIpO1xuXG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGluc2VydGlvblNvcnRYXG4gKiBAcGFyYW0gIHtBcnJheX0gYVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFggPSBmdW5jdGlvbihhKSB7XG4gICAgZm9yKHZhciBpPTEsbD1hLmxlbmd0aDtpPGw7aSsrKSB7XG4gICAgICAgIHZhciB2ID0gYVtpXTtcbiAgICAgICAgZm9yKHZhciBqPWkgLSAxO2o+PTA7ai0tKSB7XG4gICAgICAgICAgICBpZihhW2pdLmFhYmIubG93ZXJCb3VuZC54IDw9IHYuYWFiYi5sb3dlckJvdW5kLngpe1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYVtqKzFdID0gYVtqXTtcbiAgICAgICAgfVxuICAgICAgICBhW2orMV0gPSB2O1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBpbnNlcnRpb25Tb3J0WVxuICogQHBhcmFtICB7QXJyYXl9IGFcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZID0gZnVuY3Rpb24oYSkge1xuICAgIGZvcih2YXIgaT0xLGw9YS5sZW5ndGg7aTxsO2krKykge1xuICAgICAgICB2YXIgdiA9IGFbaV07XG4gICAgICAgIGZvcih2YXIgaj1pIC0gMTtqPj0wO2otLSkge1xuICAgICAgICAgICAgaWYoYVtqXS5hYWJiLmxvd2VyQm91bmQueSA8PSB2LmFhYmIubG93ZXJCb3VuZC55KXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFbaisxXSA9IGFbal07XG4gICAgICAgIH1cbiAgICAgICAgYVtqKzFdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgaW5zZXJ0aW9uU29ydFpcbiAqIEBwYXJhbSAge0FycmF5fSBhXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WiA9IGZ1bmN0aW9uKGEpIHtcbiAgICBmb3IodmFyIGk9MSxsPWEubGVuZ3RoO2k8bDtpKyspIHtcbiAgICAgICAgdmFyIHYgPSBhW2ldO1xuICAgICAgICBmb3IodmFyIGo9aSAtIDE7aj49MDtqLS0pIHtcbiAgICAgICAgICAgIGlmKGFbal0uYWFiYi5sb3dlckJvdW5kLnogPD0gdi5hYWJiLmxvd2VyQm91bmQueil7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhW2orMV0gPSBhW2pdO1xuICAgICAgICB9XG4gICAgICAgIGFbaisxXSA9IHY7XG4gICAgfVxuICAgIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBDb2xsZWN0IGFsbCBjb2xsaXNpb24gcGFpcnNcbiAqIEBtZXRob2QgY29sbGlzaW9uUGFpcnNcbiAqIEBwYXJhbSAge1dvcmxkfSB3b3JsZFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtBcnJheX0gcDJcbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuY29sbGlzaW9uUGFpcnMgPSBmdW5jdGlvbih3b3JsZCxwMSxwMil7XG4gICAgdmFyIGJvZGllcyA9IHRoaXMuYXhpc0xpc3QsXG4gICAgICAgIE4gPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICBheGlzSW5kZXggPSB0aGlzLmF4aXNJbmRleCxcbiAgICAgICAgaSwgajtcblxuICAgIGlmKHRoaXMuZGlydHkpe1xuICAgICAgICB0aGlzLnNvcnRMaXN0KCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBMb29rIHRocm91Z2ggdGhlIGxpc3RcbiAgICBmb3IoaT0wOyBpICE9PSBOOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG5cbiAgICAgICAgZm9yKGo9aSsxOyBqIDwgTjsgaisrKXtcbiAgICAgICAgICAgIHZhciBiaiA9IGJvZGllc1tqXTtcblxuICAgICAgICAgICAgaWYoIXRoaXMubmVlZEJyb2FkcGhhc2VDb2xsaXNpb24oYmksYmopKXtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIVNBUEJyb2FkcGhhc2UuY2hlY2tCb3VuZHMoYmksYmosYXhpc0luZGV4KSl7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uVGVzdChiaSxiaixwMSxwMik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5zb3J0TGlzdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGF4aXNMaXN0ID0gdGhpcy5heGlzTGlzdDtcbiAgICB2YXIgYXhpc0luZGV4ID0gdGhpcy5heGlzSW5kZXg7XG4gICAgdmFyIE4gPSBheGlzTGlzdC5sZW5ndGg7XG5cbiAgICAvLyBVcGRhdGUgQUFCQnNcbiAgICBmb3IodmFyIGkgPSAwOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYXhpc0xpc3RbaV07XG4gICAgICAgIGlmKGJpLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiaS5jb21wdXRlQUFCQigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCB0aGUgbGlzdFxuICAgIGlmKGF4aXNJbmRleCA9PT0gMCl7XG4gICAgICAgIFNBUEJyb2FkcGhhc2UuaW5zZXJ0aW9uU29ydFgoYXhpc0xpc3QpO1xuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDEpe1xuICAgICAgICBTQVBCcm9hZHBoYXNlLmluc2VydGlvblNvcnRZKGF4aXNMaXN0KTtcbiAgICB9IGVsc2UgaWYoYXhpc0luZGV4ID09PSAyKXtcbiAgICAgICAgU0FQQnJvYWRwaGFzZS5pbnNlcnRpb25Tb3J0WihheGlzTGlzdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgYm91bmRzIG9mIHR3byBib2RpZXMgb3ZlcmxhcCwgYWxvbmcgdGhlIGdpdmVuIFNBUCBheGlzLlxuICogQHN0YXRpY1xuICogQG1ldGhvZCBjaGVja0JvdW5kc1xuICogQHBhcmFtICB7Qm9keX0gYmlcbiAqIEBwYXJhbSAge0JvZHl9IGJqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGF4aXNJbmRleFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuU0FQQnJvYWRwaGFzZS5jaGVja0JvdW5kcyA9IGZ1bmN0aW9uKGJpLCBiaiwgYXhpc0luZGV4KXtcbiAgICB2YXIgYmlQb3M7XG4gICAgdmFyIGJqUG9zO1xuXG4gICAgaWYoYXhpc0luZGV4ID09PSAwKXtcbiAgICAgICAgYmlQb3MgPSBiaS5wb3NpdGlvbi54O1xuICAgICAgICBialBvcyA9IGJqLnBvc2l0aW9uLng7XG4gICAgfSBlbHNlIGlmKGF4aXNJbmRleCA9PT0gMSl7XG4gICAgICAgIGJpUG9zID0gYmkucG9zaXRpb24ueTtcbiAgICAgICAgYmpQb3MgPSBiai5wb3NpdGlvbi55O1xuICAgIH0gZWxzZSBpZihheGlzSW5kZXggPT09IDIpe1xuICAgICAgICBiaVBvcyA9IGJpLnBvc2l0aW9uLno7XG4gICAgICAgIGJqUG9zID0gYmoucG9zaXRpb24uejtcbiAgICB9XG5cbiAgICB2YXIgcmkgPSBiaS5ib3VuZGluZ1JhZGl1cyxcbiAgICAgICAgcmogPSBiai5ib3VuZGluZ1JhZGl1cyxcbiAgICAgICAgYm91bmRBMSA9IGJpUG9zIC0gcmksXG4gICAgICAgIGJvdW5kQTIgPSBiaVBvcyArIHJpLFxuICAgICAgICBib3VuZEIxID0gYmpQb3MgLSByaixcbiAgICAgICAgYm91bmRCMiA9IGJqUG9zICsgcmo7XG5cbiAgICByZXR1cm4gYm91bmRCMSA8IGJvdW5kQTI7XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSB2YXJpYW5jZSBvZiB0aGUgYm9keSBwb3NpdGlvbnMgYW5kIGVzdGltYXRlcyB0aGUgYmVzdFxuICogYXhpcyB0byB1c2UuIFdpbGwgYXV0b21hdGljYWxseSBzZXQgcHJvcGVydHkgLmF4aXNJbmRleC5cbiAqIEBtZXRob2QgYXV0b0RldGVjdEF4aXNcbiAqL1xuU0FQQnJvYWRwaGFzZS5wcm90b3R5cGUuYXV0b0RldGVjdEF4aXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBzdW1YPTAsXG4gICAgICAgIHN1bVgyPTAsXG4gICAgICAgIHN1bVk9MCxcbiAgICAgICAgc3VtWTI9MCxcbiAgICAgICAgc3VtWj0wLFxuICAgICAgICBzdW1aMj0wLFxuICAgICAgICBib2RpZXMgPSB0aGlzLmF4aXNMaXN0LFxuICAgICAgICBOID0gYm9kaWVzLmxlbmd0aCxcbiAgICAgICAgaW52Tj0xL047XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldO1xuXG4gICAgICAgIHZhciBjZW50ZXJYID0gYi5wb3NpdGlvbi54O1xuICAgICAgICBzdW1YICs9IGNlbnRlclg7XG4gICAgICAgIHN1bVgyICs9IGNlbnRlclgqY2VudGVyWDtcblxuICAgICAgICB2YXIgY2VudGVyWSA9IGIucG9zaXRpb24ueTtcbiAgICAgICAgc3VtWSArPSBjZW50ZXJZO1xuICAgICAgICBzdW1ZMiArPSBjZW50ZXJZKmNlbnRlclk7XG5cbiAgICAgICAgdmFyIGNlbnRlclogPSBiLnBvc2l0aW9uLno7XG4gICAgICAgIHN1bVogKz0gY2VudGVyWjtcbiAgICAgICAgc3VtWjIgKz0gY2VudGVyWipjZW50ZXJaO1xuICAgIH1cblxuICAgIHZhciB2YXJpYW5jZVggPSBzdW1YMiAtIHN1bVgqc3VtWCppbnZOLFxuICAgICAgICB2YXJpYW5jZVkgPSBzdW1ZMiAtIHN1bVkqc3VtWSppbnZOLFxuICAgICAgICB2YXJpYW5jZVogPSBzdW1aMiAtIHN1bVoqc3VtWippbnZOO1xuXG4gICAgaWYodmFyaWFuY2VYID4gdmFyaWFuY2VZKXtcbiAgICAgICAgaWYodmFyaWFuY2VYID4gdmFyaWFuY2VaKXtcbiAgICAgICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMDtcbiAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgdGhpcy5heGlzSW5kZXggPSAyO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmKHZhcmlhbmNlWSA+IHZhcmlhbmNlWil7XG4gICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMTtcbiAgICB9IGVsc2V7XG4gICAgICAgIHRoaXMuYXhpc0luZGV4ID0gMjtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYWxsIHRoZSBib2RpZXMgd2l0aGluIGFuIEFBQkIuXG4gKiBAbWV0aG9kIGFhYmJRdWVyeVxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0ge2FycmF5fSByZXN1bHQgQW4gYXJyYXkgdG8gc3RvcmUgcmVzdWx0aW5nIGJvZGllcyBpbi5cbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5TQVBCcm9hZHBoYXNlLnByb3RvdHlwZS5hYWJiUXVlcnkgPSBmdW5jdGlvbih3b3JsZCwgYWFiYiwgcmVzdWx0KXtcbiAgICByZXN1bHQgPSByZXN1bHQgfHwgW107XG5cbiAgICBpZih0aGlzLmRpcnR5KXtcbiAgICAgICAgdGhpcy5zb3J0TGlzdCgpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGF4aXNJbmRleCA9IHRoaXMuYXhpc0luZGV4LCBheGlzID0gJ3gnO1xuICAgIGlmKGF4aXNJbmRleCA9PT0gMSl7IGF4aXMgPSAneSc7IH1cbiAgICBpZihheGlzSW5kZXggPT09IDIpeyBheGlzID0gJ3onOyB9XG5cbiAgICB2YXIgYXhpc0xpc3QgPSB0aGlzLmF4aXNMaXN0O1xuICAgIHZhciBsb3dlciA9IGFhYmIubG93ZXJCb3VuZFtheGlzXTtcbiAgICB2YXIgdXBwZXIgPSBhYWJiLnVwcGVyQm91bmRbYXhpc107XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGF4aXNMaXN0Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBheGlzTGlzdFtpXTtcblxuICAgICAgICBpZihiLmFhYmJOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBiLmNvbXB1dGVBQUJCKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihiLmFhYmIub3ZlcmxhcHMoYWFiYikpe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbn0se1wiLi4vY29sbGlzaW9uL0Jyb2FkcGhhc2VcIjo1LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDN9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IENvbmVUd2lzdENvbnN0cmFpbnQ7XG5cbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IF9kZXJlcV8oJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xudmFyIENvbmVFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db25lRXF1YXRpb24nKTtcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XG52YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBAY2xhc3MgQ29uZVR3aXN0Q29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBpdm90QV1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMucGl2b3RCXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzQV1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICovXG5mdW5jdGlvbiBDb25lVHdpc3RDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAvLyBTZXQgcGl2b3QgcG9pbnQgaW4gYmV0d2VlblxuICAgIHZhciBwaXZvdEEgPSBvcHRpb25zLnBpdm90QSA/IG9wdGlvbnMucGl2b3RBLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHZhciBwaXZvdEIgPSBvcHRpb25zLnBpdm90QiA/IG9wdGlvbnMucGl2b3RCLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoKTtcbiAgICB0aGlzLmF4aXNCID0gb3B0aW9ucy5heGlzQiA/IG9wdGlvbnMuYXhpc0IuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgdGhpcy5jb2xsaWRlQ29ubmVjdGVkID0gISFvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XG5cbiAgICB0aGlzLmFuZ2xlID0gdHlwZW9mKG9wdGlvbnMuYW5nbGUpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5nbGUgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb25lRXF1YXRpb259IGNvbmVFcXVhdGlvblxuICAgICAqL1xuICAgIHZhciBjID0gdGhpcy5jb25lRXF1YXRpb24gPSBuZXcgQ29uZUVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHR3aXN0RXF1YXRpb25cbiAgICAgKi9cbiAgICB2YXIgdCA9IHRoaXMudHdpc3RFcXVhdGlvbiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG4gICAgdGhpcy50d2lzdEFuZ2xlID0gdHlwZW9mKG9wdGlvbnMudHdpc3RBbmdsZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy50d2lzdEFuZ2xlIDogMDtcblxuICAgIC8vIE1ha2UgdGhlIGNvbmUgZXF1YXRpb24gcHVzaCB0aGUgYm9kaWVzIHRvd2FyZCB0aGUgY29uZSBheGlzLCBub3Qgb3V0d2FyZFxuICAgIGMubWF4Rm9yY2UgPSAwO1xuICAgIGMubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG5cbiAgICAvLyBNYWtlIHRoZSB0d2lzdCBlcXVhdGlvbiBhZGQgdG9ycXVlIHRvd2FyZCB0aGUgaW5pdGlhbCBwb3NpdGlvblxuICAgIHQubWF4Rm9yY2UgPSAwO1xuICAgIHQubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG5cbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKGMsIHQpO1xufVxuQ29uZVR3aXN0Q29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludCgpO1xuQ29uZVR3aXN0Q29uc3RyYWludC5jb25zdHJ1Y3RvciA9IENvbmVUd2lzdENvbnN0cmFpbnQ7XG5cbnZhciBDb25lVHdpc3RDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciBDb25lVHdpc3RDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuQ29uZVR3aXN0Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgYm9keUEgPSB0aGlzLmJvZHlBLFxuICAgICAgICBib2R5QiA9IHRoaXMuYm9keUIsXG4gICAgICAgIGNvbmUgPSB0aGlzLmNvbmVFcXVhdGlvbixcbiAgICAgICAgdHdpc3QgPSB0aGlzLnR3aXN0RXF1YXRpb247XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgYXhlcyB0byB0aGUgY29uZSBjb25zdHJhaW50XG4gICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKHRoaXMuYXhpc0EsIGNvbmUuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZSh0aGlzLmF4aXNCLCBjb25lLmF4aXNCKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgd29ybGQgYXhlcyBpbiB0aGUgdHdpc3QgY29uc3RyYWludFxuICAgIHRoaXMuYXhpc0EudGFuZ2VudHModHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTtcbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0EsIHR3aXN0LmF4aXNBKTtcblxuICAgIHRoaXMuYXhpc0IudGFuZ2VudHModHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUodHdpc3QuYXhpc0IsIHR3aXN0LmF4aXNCKTtcblxuICAgIGNvbmUuYW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIHR3aXN0Lm1heEFuZ2xlID0gdGhpcy50d2lzdEFuZ2xlO1xufTtcblxuXG59LHtcIi4uL2VxdWF0aW9ucy9Db25lRXF1YXRpb25cIjoxOCxcIi4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb25cIjoxOSxcIi4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb25cIjoyMixcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Db25zdHJhaW50XCI6MTMsXCIuL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxN31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQ29uc3RyYWludDtcblxudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxuLyoqXG4gKiBDb25zdHJhaW50IGJhc2UgY2xhc3NcbiAqIEBjbGFzcyBDb25zdHJhaW50XG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY29sbGlkZUNvbm5lY3RlZD10cnVlXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy53YWtlVXBCb2RpZXM9dHJ1ZV1cbiAqL1xuZnVuY3Rpb24gQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLHtcbiAgICAgICAgY29sbGlkZUNvbm5lY3RlZCA6IHRydWUsXG4gICAgICAgIHdha2VVcEJvZGllcyA6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBFcXVhdGlvbnMgdG8gYmUgc29sdmVkIGluIHRoaXMgY29uc3RyYWludFxuICAgICAqIEBwcm9wZXJ0eSBlcXVhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5lcXVhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9keX0gYm9keUFcbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGJvZHlCXG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGlkXG4gICAgICovXG4gICAgdGhpcy5pZCA9IENvbnN0cmFpbnQuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0aGUgYm9kaWVzIHRvIGNvbGxpZGUgd2hlbiB0aGV5IGFyZSBjb25uZWN0ZWQuXG4gICAgICogQHByb3BlcnR5IGNvbGxpZGVDb25uZWN0ZWRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmNvbGxpZGVDb25uZWN0ZWQgPSBvcHRpb25zLmNvbGxpZGVDb25uZWN0ZWQ7XG5cbiAgICBpZihvcHRpb25zLndha2VVcEJvZGllcyl7XG4gICAgICAgIGlmKGJvZHlBKXtcbiAgICAgICAgICAgIGJvZHlBLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGJvZHlCKXtcbiAgICAgICAgICAgIGJvZHlCLndha2VVcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhbGwgdGhlIGVxdWF0aW9ucyB3aXRoIGRhdGEuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5Db25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCB1cGRhdGUoKSBub3QgaW1wbG1lbWVudGVkIGluIHRoaXMgQ29uc3RyYWludCBzdWJjbGFzcyFcIik7XG59O1xuXG4vKipcbiAqIEVuYWJsZXMgYWxsIGVxdWF0aW9ucyBpbiB0aGUgY29uc3RyYWludC5cbiAqIEBtZXRob2QgZW5hYmxlXG4gKi9cbkNvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpPGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5lbmFibGVkID0gdHJ1ZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERpc2FibGVzIGFsbCBlcXVhdGlvbnMgaW4gdGhlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIGRpc2FibGVcbiAqL1xuQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVxcyA9IHRoaXMuZXF1YXRpb25zO1xuICAgIGZvcih2YXIgaT0wOyBpPGVxcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGVxc1tpXS5lbmFibGVkID0gZmFsc2U7XG4gICAgfVxufTtcblxuQ29uc3RyYWludC5pZENvdW50ZXIgPSAwO1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTN9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlQ29uc3RyYWludDtcblxudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG5cbi8qKlxuICogQ29uc3RyYWlucyB0d28gYm9kaWVzIHRvIGJlIGF0IGEgY29uc3RhbnQgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVycyBjZW50ZXIgb2YgbWFzcy5cbiAqIEBjbGFzcyBEaXN0YW5jZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IFtkaXN0YW5jZV0gVGhlIGRpc3RhbmNlIHRvIGtlZXAuIElmIHVuZGVmaW5lZCwgaXQgd2lsbCBiZSBzZXQgdG8gdGhlIGN1cnJlbnQgZGlzdGFuY2UgYmV0d2VlbiBib2R5QSBhbmQgYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgQ29uc3RyYWludFxuICovXG5mdW5jdGlvbiBEaXN0YW5jZUNvbnN0cmFpbnQoYm9keUEsYm9keUIsZGlzdGFuY2UsbWF4Rm9yY2Upe1xuICAgIENvbnN0cmFpbnQuY2FsbCh0aGlzLGJvZHlBLGJvZHlCKTtcblxuICAgIGlmKHR5cGVvZihkaXN0YW5jZSk9PT1cInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGRpc3RhbmNlID0gYm9keUEucG9zaXRpb24uZGlzdGFuY2VUbyhib2R5Qi5wb3NpdGlvbik7XG4gICAgfVxuXG4gICAgaWYodHlwZW9mKG1heEZvcmNlKT09PVwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgbWF4Rm9yY2UgPSAxZTY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRpc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGRpc3RhbmNlRXF1YXRpb25cbiAgICAgKi9cbiAgICB2YXIgZXEgPSB0aGlzLmRpc3RhbmNlRXF1YXRpb24gPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLCBib2R5Qik7XG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChlcSk7XG5cbiAgICAvLyBNYWtlIGl0IGJpZGlyZWN0aW9uYWxcbiAgICBlcS5taW5Gb3JjZSA9IC1tYXhGb3JjZTtcbiAgICBlcS5tYXhGb3JjZSA9ICBtYXhGb3JjZTtcbn1cbkRpc3RhbmNlQ29uc3RyYWludC5wcm90b3R5cGUgPSBuZXcgQ29uc3RyYWludCgpO1xuXG5EaXN0YW5jZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIHZhciBlcSA9IHRoaXMuZGlzdGFuY2VFcXVhdGlvbjtcbiAgICB2YXIgaGFsZkRpc3QgPSB0aGlzLmRpc3RhbmNlICogMC41O1xuICAgIHZhciBub3JtYWwgPSBlcS5uaTtcblxuICAgIGJvZHlCLnBvc2l0aW9uLnZzdWIoYm9keUEucG9zaXRpb24sIG5vcm1hbCk7XG4gICAgbm9ybWFsLm5vcm1hbGl6ZSgpO1xuICAgIG5vcm1hbC5tdWx0KGhhbGZEaXN0LCBlcS5yaSk7XG4gICAgbm9ybWFsLm11bHQoLWhhbGZEaXN0LCBlcS5yaik7XG59O1xufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MTksXCIuL0NvbnN0cmFpbnRcIjoxM31dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gSGluZ2VDb25zdHJhaW50O1xuXG52YXIgQ29uc3RyYWludCA9IF9kZXJlcV8oJy4vQ29uc3RyYWludCcpO1xudmFyIFBvaW50VG9Qb2ludENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL1BvaW50VG9Qb2ludENvbnN0cmFpbnQnKTtcbnZhciBSb3RhdGlvbmFsRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uJyk7XG52YXIgUm90YXRpb25hbE1vdG9yRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb24nKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIEhpbmdlIGNvbnN0cmFpbnQuIFRoaW5rIG9mIGl0IGFzIGEgZG9vciBoaW5nZS4gSXQgdHJpZXMgdG8ga2VlcCB0aGUgZG9vciBpbiB0aGUgY29ycmVjdCBwbGFjZSBhbmQgd2l0aCB0aGUgY29ycmVjdCBvcmllbnRhdGlvbi5cbiAqIEBjbGFzcyBIaW5nZUNvbnN0cmFpbnRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEFdIEEgcG9pbnQgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLiBUaGlzIGRlZmluZXMgdGhlIG9mZnNldCBvZiBheGlzQS5cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdIEFuIGF4aXMgdGhhdCBib2R5QSBjYW4gcm90YXRlIGFyb3VuZCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5waXZvdEJdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlPTFlNl1cbiAqIEBleHRlbmRzIFBvaW50VG9Qb2ludENvbnN0cmFpbnRcbiAqL1xuZnVuY3Rpb24gSGluZ2VDb25zdHJhaW50KGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG4gICAgdmFyIHBpdm90QSA9IG9wdGlvbnMucGl2b3RBID8gb3B0aW9ucy5waXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG4gICAgdmFyIHBpdm90QiA9IG9wdGlvbnMucGl2b3RCID8gb3B0aW9ucy5waXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogUm90YXRpb24gYXhpcywgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcbiAgICAgKi9cbiAgICB2YXIgYXhpc0EgPSB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsMCwwKTtcbiAgICBheGlzQS5ub3JtYWxpemUoKTtcblxuICAgIC8qKlxuICAgICAqIFJvdGF0aW9uIGF4aXMsIGRlZmluZWQgbG9jYWxseSBpbiBib2R5Qi5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGF4aXNCXG4gICAgICovXG4gICAgdmFyIGF4aXNCID0gdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygxLDAsMCk7XG4gICAgYXhpc0Iubm9ybWFsaXplKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMVxuICAgICAqL1xuICAgIHZhciByMSA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMSA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxFcXVhdGlvbn0gcm90YXRpb25hbEVxdWF0aW9uMlxuICAgICAqL1xuICAgIHZhciByMiA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMiA9IG5ldyBSb3RhdGlvbmFsRXF1YXRpb24oYm9keUEsYm9keUIsb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1JvdGF0aW9uYWxNb3RvckVxdWF0aW9ufSBtb3RvckVxdWF0aW9uXG4gICAgICovXG4gICAgdmFyIG1vdG9yID0gdGhpcy5tb3RvckVxdWF0aW9uID0gbmV3IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uKGJvZHlBLGJvZHlCLG1heEZvcmNlKTtcbiAgICBtb3Rvci5lbmFibGVkID0gZmFsc2U7IC8vIE5vdCBlbmFibGVkIGJ5IGRlZmF1bHRcblxuICAgIC8vIEVxdWF0aW9ucyB0byBiZSBmZWQgdG8gdGhlIHNvbHZlclxuICAgIHRoaXMuZXF1YXRpb25zLnB1c2goXG4gICAgICAgIHIxLCAvLyByb3RhdGlvbmFsMVxuICAgICAgICByMiwgLy8gcm90YXRpb25hbDJcbiAgICAgICAgbW90b3JcbiAgICApO1xufVxuSGluZ2VDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XG5IaW5nZUNvbnN0cmFpbnQuY29uc3RydWN0b3IgPSBIaW5nZUNvbnN0cmFpbnQ7XG5cbi8qKlxuICogQG1ldGhvZCBlbmFibGVNb3RvclxuICovXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLmVuYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IHRydWU7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgZGlzYWJsZU1vdG9yXG4gKi9cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24uZW5hYmxlZCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzcGVlZFxuICovXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnNldE1vdG9yU3BlZWQgPSBmdW5jdGlvbihzcGVlZCl7XG4gICAgdGhpcy5tb3RvckVxdWF0aW9uLnRhcmdldFZlbG9jaXR5ID0gc3BlZWQ7XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0TW90b3JNYXhGb3JjZVxuICogQHBhcmFtIHtudW1iZXJ9IG1heEZvcmNlXG4gKi9cbkhpbmdlQ29uc3RyYWludC5wcm90b3R5cGUuc2V0TW90b3JNYXhGb3JjZSA9IGZ1bmN0aW9uKG1heEZvcmNlKXtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWF4Rm9yY2UgPSBtYXhGb3JjZTtcbiAgICB0aGlzLm1vdG9yRXF1YXRpb24ubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG59O1xuXG52YXIgSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciBIaW5nZUNvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzIgPSBuZXcgVmVjMygpO1xuXG5IaW5nZUNvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcbiAgICAgICAgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEsXG4gICAgICAgIHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yLFxuICAgICAgICB3b3JsZEF4aXNBID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxuICAgICAgICB3b3JsZEF4aXNCID0gSGluZ2VDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyO1xuXG4gICAgdmFyIGF4aXNBID0gdGhpcy5heGlzQTtcbiAgICB2YXIgYXhpc0IgPSB0aGlzLmF4aXNCO1xuXG4gICAgUG9pbnRUb1BvaW50Q29uc3RyYWludC5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcyk7XG5cbiAgICAvLyBHZXQgd29ybGQgYXhlc1xuICAgIGJvZHlBLnF1YXRlcm5pb24udm11bHQoYXhpc0EsIHdvcmxkQXhpc0EpO1xuICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQoYXhpc0IsIHdvcmxkQXhpc0IpO1xuXG4gICAgd29ybGRBeGlzQS50YW5nZW50cyhyMS5heGlzQSwgcjIuYXhpc0EpO1xuICAgIHIxLmF4aXNCLmNvcHkod29ybGRBeGlzQik7XG4gICAgcjIuYXhpc0IuY29weSh3b3JsZEF4aXNCKTtcblxuICAgIGlmKHRoaXMubW90b3JFcXVhdGlvbi5lbmFibGVkKXtcbiAgICAgICAgYm9keUEucXVhdGVybmlvbi52bXVsdCh0aGlzLmF4aXNBLCBtb3Rvci5heGlzQSk7XG4gICAgICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5heGlzQiwgbW90b3IuYXhpc0IpO1xuICAgIH1cbn07XG5cblxufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MTksXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uXCI6MjIsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Db25zdHJhaW50XCI6MTMsXCIuL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxN31dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gTG9ja0NvbnN0cmFpbnQ7XG5cbnZhciBDb25zdHJhaW50ID0gX2RlcmVxXygnLi9Db25zdHJhaW50Jyk7XG52YXIgUG9pbnRUb1BvaW50Q29uc3RyYWludCA9IF9kZXJlcV8oJy4vUG9pbnRUb1BvaW50Q29uc3RyYWludCcpO1xudmFyIFJvdGF0aW9uYWxFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsRXF1YXRpb24nKTtcbnZhciBSb3RhdGlvbmFsTW90b3JFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbicpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogTG9jayBjb25zdHJhaW50LiBXaWxsIHJlbW92ZSBhbGwgZGVncmVlcyBvZiBmcmVlZG9tIGJldHdlZW4gdGhlIGJvZGllcy5cbiAqIEBjbGFzcyBMb2NrQ29uc3RyYWludFxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4Rm9yY2U9MWU2XVxuICogQGV4dGVuZHMgUG9pbnRUb1BvaW50Q29uc3RyYWludFxuICovXG5mdW5jdGlvbiBMb2NrQ29uc3RyYWludChib2R5QSwgYm9keUIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBtYXhGb3JjZSA9IHR5cGVvZihvcHRpb25zLm1heEZvcmNlKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heEZvcmNlIDogMWU2O1xuXG4gICAgLy8gU2V0IHBpdm90IHBvaW50IGluIGJldHdlZW5cbiAgICB2YXIgcGl2b3RBID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgcGl2b3RCID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgaGFsZldheSA9IG5ldyBWZWMzKCk7XG4gICAgYm9keUEucG9zaXRpb24udmFkZChib2R5Qi5wb3NpdGlvbiwgaGFsZldheSk7XG4gICAgaGFsZldheS5zY2FsZSgwLjUsIGhhbGZXYXkpO1xuICAgIGJvZHlCLnBvaW50VG9Mb2NhbEZyYW1lKGhhbGZXYXksIHBpdm90Qik7XG4gICAgYm9keUEucG9pbnRUb0xvY2FsRnJhbWUoaGFsZldheSwgcGl2b3RBKTtcbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LmNhbGwodGhpcywgYm9keUEsIHBpdm90QSwgYm9keUIsIHBpdm90QiwgbWF4Rm9yY2UpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjFcbiAgICAgKi9cbiAgICB2YXIgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjJcbiAgICAgKi9cbiAgICB2YXIgcjIgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjIgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtSb3RhdGlvbmFsRXF1YXRpb259IHJvdGF0aW9uYWxFcXVhdGlvbjNcbiAgICAgKi9cbiAgICB2YXIgcjMgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjMgPSBuZXcgUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLGJvZHlCLG9wdGlvbnMpO1xuXG4gICAgdGhpcy5lcXVhdGlvbnMucHVzaChyMSwgcjIsIHIzKTtcbn1cbkxvY2tDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBQb2ludFRvUG9pbnRDb25zdHJhaW50KCk7XG5Mb2NrQ29uc3RyYWludC5jb25zdHJ1Y3RvciA9IExvY2tDb25zdHJhaW50O1xuXG52YXIgTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzEgPSBuZXcgVmVjMygpO1xudmFyIExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuTG9ja0NvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QSxcbiAgICAgICAgYm9keUIgPSB0aGlzLmJvZHlCLFxuICAgICAgICBtb3RvciA9IHRoaXMubW90b3JFcXVhdGlvbixcbiAgICAgICAgcjEgPSB0aGlzLnJvdGF0aW9uYWxFcXVhdGlvbjEsXG4gICAgICAgIHIyID0gdGhpcy5yb3RhdGlvbmFsRXF1YXRpb24yLFxuICAgICAgICByMyA9IHRoaXMucm90YXRpb25hbEVxdWF0aW9uMyxcbiAgICAgICAgd29ybGRBeGlzQSA9IExvY2tDb25zdHJhaW50X3VwZGF0ZV90bXBWZWMxLFxuICAgICAgICB3b3JsZEF4aXNCID0gTG9ja0NvbnN0cmFpbnRfdXBkYXRlX3RtcFZlYzI7XG5cbiAgICBQb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZS51cGRhdGUuY2FsbCh0aGlzKTtcblxuICAgIGJvZHlBLnZlY3RvclRvV29ybGRGcmFtZShWZWMzLlVOSVRfWCwgcjEuYXhpc0EpO1xuICAgIGJvZHlCLnZlY3RvclRvV29ybGRGcmFtZShWZWMzLlVOSVRfWSwgcjEuYXhpc0IpO1xuXG4gICAgYm9keUEudmVjdG9yVG9Xb3JsZEZyYW1lKFZlYzMuVU5JVF9ZLCByMi5heGlzQSk7XG4gICAgYm9keUIudmVjdG9yVG9Xb3JsZEZyYW1lKFZlYzMuVU5JVF9aLCByMi5heGlzQik7XG5cbiAgICBib2R5QS52ZWN0b3JUb1dvcmxkRnJhbWUoVmVjMy5VTklUX1osIHIzLmF4aXNBKTtcbiAgICBib2R5Qi52ZWN0b3JUb1dvcmxkRnJhbWUoVmVjMy5VTklUX1gsIHIzLmF4aXNCKTtcbn07XG5cblxufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MTksXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbEVxdWF0aW9uXCI6MjIsXCIuLi9lcXVhdGlvbnMvUm90YXRpb25hbE1vdG9yRXF1YXRpb25cIjoyMyxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Db25zdHJhaW50XCI6MTMsXCIuL1BvaW50VG9Qb2ludENvbnN0cmFpbnRcIjoxN31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUG9pbnRUb1BvaW50Q29uc3RyYWludDtcblxudmFyIENvbnN0cmFpbnQgPSBfZGVyZXFfKCcuL0NvbnN0cmFpbnQnKTtcbnZhciBDb250YWN0RXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIENvbm5lY3RzIHR3byBib2RpZXMgYXQgZ2l2ZW4gb2Zmc2V0IHBvaW50cy5cbiAqIEBjbGFzcyBQb2ludFRvUG9pbnRDb25zdHJhaW50XG4gKiBAZXh0ZW5kcyBDb25zdHJhaW50XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7VmVjM30gcGl2b3RBIFRoZSBwb2ludCByZWxhdGl2ZSB0byB0aGUgY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgd2hpY2ggYm9keUEgaXMgY29uc3RyYWluZWQgdG8uXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCIEJvZHkgdGhhdCB3aWxsIGJlIGNvbnN0cmFpbmVkIGluIGEgc2ltaWxhciB3YXkgdG8gdGhlIHNhbWUgcG9pbnQgYXMgYm9keUEuIFdlIHdpbGwgdGhlcmVmb3JlIGdldCBhIGxpbmsgYmV0d2VlbiBib2R5QSBhbmQgYm9keUIuIElmIG5vdCBzcGVjaWZpZWQsIGJvZHlBIHdpbGwgYmUgY29uc3RyYWluZWQgdG8gYSBzdGF0aWMgcG9pbnQuXG4gKiBAcGFyYW0ge1ZlYzN9IHBpdm90QiBTZWUgcGl2b3RBLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heEZvcmNlIFRoZSBtYXhpbXVtIGZvcmNlIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gY29uc3RyYWluIHRoZSBib2RpZXMuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgICB2YXIgYm9keUEgPSBuZXcgQm9keSh7IG1hc3M6IDEgfSk7XG4gKiAgICAgdmFyIGJvZHlCID0gbmV3IEJvZHkoeyBtYXNzOiAxIH0pO1xuICogICAgIGJvZHlBLnBvc2l0aW9uLnNldCgtMSwgMCwgMCk7XG4gKiAgICAgYm9keUIucG9zaXRpb24uc2V0KDEsIDAsIDApO1xuICogICAgIGJvZHlBLmFkZFNoYXBlKHNoYXBlQSk7XG4gKiAgICAgYm9keUIuYWRkU2hhcGUoc2hhcGVCKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlBKTtcbiAqICAgICB3b3JsZC5hZGRCb2R5KGJvZHlCKTtcbiAqICAgICB2YXIgbG9jYWxQaXZvdEEgPSBuZXcgVmVjMygxLCAwLCAwKTtcbiAqICAgICB2YXIgbG9jYWxQaXZvdEIgPSBuZXcgVmVjMygtMSwgMCwgMCk7XG4gKiAgICAgdmFyIGNvbnN0cmFpbnQgPSBuZXcgUG9pbnRUb1BvaW50Q29uc3RyYWludChib2R5QSwgbG9jYWxQaXZvdEEsIGJvZHlCLCBsb2NhbFBpdm90Qik7XG4gKiAgICAgd29ybGQuYWRkQ29uc3RyYWludChjb25zdHJhaW50KTtcbiAqL1xuZnVuY3Rpb24gUG9pbnRUb1BvaW50Q29uc3RyYWludChib2R5QSxwaXZvdEEsYm9keUIscGl2b3RCLG1heEZvcmNlKXtcbiAgICBDb25zdHJhaW50LmNhbGwodGhpcyxib2R5QSxib2R5Qik7XG5cbiAgICBtYXhGb3JjZSA9IHR5cGVvZihtYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gbWF4Rm9yY2UgOiAxZTY7XG5cbiAgICAvKipcbiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlBLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcGl2b3RBXG4gICAgICovXG4gICAgdGhpcy5waXZvdEEgPSBwaXZvdEEgPyBwaXZvdEEuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBQaXZvdCwgZGVmaW5lZCBsb2NhbGx5IGluIGJvZHlCLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcGl2b3RCXG4gICAgICovXG4gICAgdGhpcy5waXZvdEIgPSBwaXZvdEIgPyBwaXZvdEIuY2xvbmUoKSA6IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0NvbnRhY3RFcXVhdGlvbn0gZXF1YXRpb25YXG4gICAgICovXG4gICAgdmFyIHggPSB0aGlzLmVxdWF0aW9uWCA9IG5ldyBDb250YWN0RXF1YXRpb24oYm9keUEsYm9keUIpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtDb250YWN0RXF1YXRpb259IGVxdWF0aW9uWVxuICAgICAqL1xuICAgIHZhciB5ID0gdGhpcy5lcXVhdGlvblkgPSBuZXcgQ29udGFjdEVxdWF0aW9uKGJvZHlBLGJvZHlCKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Q29udGFjdEVxdWF0aW9ufSBlcXVhdGlvblpcbiAgICAgKi9cbiAgICB2YXIgeiA9IHRoaXMuZXF1YXRpb25aID0gbmV3IENvbnRhY3RFcXVhdGlvbihib2R5QSxib2R5Qik7XG5cbiAgICAvLyBFcXVhdGlvbnMgdG8gYmUgZmVkIHRvIHRoZSBzb2x2ZXJcbiAgICB0aGlzLmVxdWF0aW9ucy5wdXNoKHgsIHksIHopO1xuXG4gICAgLy8gTWFrZSB0aGUgZXF1YXRpb25zIGJpZGlyZWN0aW9uYWxcbiAgICB4Lm1pbkZvcmNlID0geS5taW5Gb3JjZSA9IHoubWluRm9yY2UgPSAtbWF4Rm9yY2U7XG4gICAgeC5tYXhGb3JjZSA9IHkubWF4Rm9yY2UgPSB6Lm1heEZvcmNlID0gIG1heEZvcmNlO1xuXG4gICAgeC5uaS5zZXQoMSwgMCwgMCk7XG4gICAgeS5uaS5zZXQoMCwgMSwgMCk7XG4gICAgei5uaS5zZXQoMCwgMCwgMSk7XG59XG5Qb2ludFRvUG9pbnRDb25zdHJhaW50LnByb3RvdHlwZSA9IG5ldyBDb25zdHJhaW50KCk7XG5cblBvaW50VG9Qb2ludENvbnN0cmFpbnQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGJvZHlBID0gdGhpcy5ib2R5QTtcbiAgICB2YXIgYm9keUIgPSB0aGlzLmJvZHlCO1xuICAgIHZhciB4ID0gdGhpcy5lcXVhdGlvblg7XG4gICAgdmFyIHkgPSB0aGlzLmVxdWF0aW9uWTtcbiAgICB2YXIgeiA9IHRoaXMuZXF1YXRpb25aO1xuXG4gICAgLy8gUm90YXRlIHRoZSBwaXZvdHMgdG8gd29ybGQgc3BhY2VcbiAgICBib2R5QS5xdWF0ZXJuaW9uLnZtdWx0KHRoaXMucGl2b3RBLHgucmkpO1xuICAgIGJvZHlCLnF1YXRlcm5pb24udm11bHQodGhpcy5waXZvdEIseC5yaik7XG5cbiAgICB5LnJpLmNvcHkoeC5yaSk7XG4gICAgeS5yai5jb3B5KHgucmopO1xuICAgIHoucmkuY29weSh4LnJpKTtcbiAgICB6LnJqLmNvcHkoeC5yaik7XG59O1xufSx7XCIuLi9lcXVhdGlvbnMvQ29udGFjdEVxdWF0aW9uXCI6MTksXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vQ29uc3RyYWludFwiOjEzfV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBDb25lRXF1YXRpb247XG5cbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xuXG4vKipcbiAqIENvbmUgZXF1YXRpb24uIFdvcmtzIHRvIGtlZXAgdGhlIGdpdmVuIGJvZHkgd29ybGQgdmVjdG9ycyBhbGlnbmVkLCBvciB0aWx0ZWQgd2l0aGluIGEgZ2l2ZW4gYW5nbGUgZnJvbSBlYWNoIG90aGVyLlxuICogQGNsYXNzIENvbmVFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNBXSBMb2NhbCBheGlzIGluIEFcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0JdIExvY2FsIGF4aXMgaW4gQlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5hbmdsZV0gVGhlIFwiY29uZSBhbmdsZVwiIHRvIGtlZXBcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhGb3JjZT0xZTZdXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBDb25lRXF1YXRpb24oYm9keUEsIGJvZHlCLCBvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgbWF4Rm9yY2UgPSB0eXBlb2Yob3B0aW9ucy5tYXhGb3JjZSkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5tYXhGb3JjZSA6IDFlNjtcblxuICAgIEVxdWF0aW9uLmNhbGwodGhpcyxib2R5QSxib2R5QiwtbWF4Rm9yY2UsIG1heEZvcmNlKTtcblxuICAgIHRoaXMuYXhpc0EgPSBvcHRpb25zLmF4aXNBID8gb3B0aW9ucy5heGlzQS5jbG9uZSgpIDogbmV3IFZlYzMoMSwgMCwgMCk7XG4gICAgdGhpcy5heGlzQiA9IG9wdGlvbnMuYXhpc0IgPyBvcHRpb25zLmF4aXNCLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb25lIGFuZ2xlIHRvIGtlZXBcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYW5nbGVcbiAgICAgKi9cbiAgICB0aGlzLmFuZ2xlID0gdHlwZW9mKG9wdGlvbnMuYW5nbGUpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuYW5nbGUgOiAwO1xufVxuXG5Db25lRXF1YXRpb24ucHJvdG90eXBlID0gbmV3IEVxdWF0aW9uKCk7XG5Db25lRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZUVxdWF0aW9uO1xuXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG5cbkNvbmVFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcblxuICAgICAgICBuaSA9IHRoaXMuYXhpc0EsXG4gICAgICAgIG5qID0gdGhpcy5heGlzQixcblxuICAgICAgICBuaXhuaiA9IHRtcFZlYzEsXG4gICAgICAgIG5qeG5pID0gdG1wVmVjMixcblxuICAgICAgICBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEI7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICBuaS5jcm9zcyhuaiwgbml4bmopO1xuICAgIG5qLmNyb3NzKG5pLCBuanhuaSk7XG5cbiAgICAvLyBUaGUgYW5nbGUgYmV0d2VlbiB0d28gdmVjdG9yIGlzOlxuICAgIC8vIGNvcyh0aGV0YSkgPSBhICogYiAvIChsZW5ndGgoYSkgKiBsZW5ndGgoYikgPSB7IGxlbihhKSA9IGxlbihiKSA9IDEgfSA9IGEgKiBiXG5cbiAgICAvLyBnID0gYSAqIGJcbiAgICAvLyBnZG90ID0gKGIgeCBhKSAqIHdpICsgKGEgeCBiKSAqIHdqXG4gICAgLy8gRyA9IFswIGJ4YSAwIGF4Yl1cbiAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXVxuICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTtcblxuICAgIHZhciBnID0gTWF0aC5jb3ModGhpcy5hbmdsZSkgLSBuaS5kb3QobmopLFxuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxuXG59LHtcIi4uL21hdGgvTWF0M1wiOjI3LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL0VxdWF0aW9uXCI6MjB9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IENvbnRhY3RFcXVhdGlvbjtcblxudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XG5cbi8qKlxuICogQ29udGFjdC9ub24tcGVuZXRyYXRpb24gY29uc3RyYWludCBlcXVhdGlvblxuICogQGNsYXNzIENvbnRhY3RFcXVhdGlvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlBXG4gKiBAcGFyYW0ge0JvZHl9IGJvZHlCXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBDb250YWN0RXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSl7XG4gICAgbWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG1heEZvcmNlIDogMWU2O1xuICAgIEVxdWF0aW9uLmNhbGwodGhpcywgYm9keUEsIGJvZHlCLCAwLCBtYXhGb3JjZSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcmVzdGl0dXRpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSAwLjA7IC8vIFwiYm91bmNpbmVzc1wiOiB1MSA9IC1lKnUwXG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBnb2VzIGZyb20gdGhlIGNlbnRlciBvZiBiaSB0byB0aGUgY29udGFjdCBwb2ludC5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHJpXG4gICAgICovXG4gICAgdGhpcy5yaSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBXb3JsZC1vcmllbnRlZCB2ZWN0b3IgdGhhdCBzdGFydHMgaW4gYm9keSBqIHBvc2l0aW9uIGFuZCBnb2VzIHRvIHRoZSBjb250YWN0IHBvaW50LlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcmpcbiAgICAgKi9cbiAgICB0aGlzLnJqID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhY3Qgbm9ybWFsLCBwb2ludGluZyBvdXQgb2YgYm9keSBpLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gbmlcbiAgICAgKi9cbiAgICB0aGlzLm5pID0gbmV3IFZlYzMoKTtcbn1cblxuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZSA9IG5ldyBFcXVhdGlvbigpO1xuQ29udGFjdEVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnRhY3RFcXVhdGlvbjtcblxudmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMSA9IG5ldyBWZWMzKCk7IC8vIFRlbXAgdmVjdG9yc1xudmFyIENvbnRhY3RFcXVhdGlvbl9jb21wdXRlQl90ZW1wMiA9IG5ldyBWZWMzKCk7XG52YXIgQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAzID0gbmV3IFZlYzMoKTtcbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHJpID0gdGhpcy5yaSxcbiAgICAgICAgcmogPSB0aGlzLnJqLFxuICAgICAgICByaXhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAxLFxuICAgICAgICByanhuID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAyLFxuXG4gICAgICAgIHZpID0gYmkudmVsb2NpdHksXG4gICAgICAgIHdpID0gYmkuYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICBmaSA9IGJpLmZvcmNlLFxuICAgICAgICB0YXVpID0gYmkudG9ycXVlLFxuXG4gICAgICAgIHZqID0gYmoudmVsb2NpdHksXG4gICAgICAgIHdqID0gYmouYW5ndWxhclZlbG9jaXR5LFxuICAgICAgICBmaiA9IGJqLmZvcmNlLFxuICAgICAgICB0YXVqID0gYmoudG9ycXVlLFxuXG4gICAgICAgIHBlbmV0cmF0aW9uVmVjID0gQ29udGFjdEVxdWF0aW9uX2NvbXB1dGVCX3RlbXAzLFxuXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcblxuICAgICAgICBuID0gdGhpcy5uaTtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIHJpLmNyb3NzKG4scml4bik7XG4gICAgcmouY3Jvc3MobixyanhuKTtcblxuICAgIC8vIGcgPSB4aityaiAtKHhpK3JpKVxuICAgIC8vIEcgPSBbIC1uaSAgLXJpeG4gIG5pICByanhuIF1cbiAgICBuLm5lZ2F0ZShHQS5zcGF0aWFsKTtcbiAgICByaXhuLm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcbiAgICBHQi5zcGF0aWFsLmNvcHkobik7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KHJqeG4pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBwZW5ldHJhdGlvbiB2ZWN0b3JcbiAgICBwZW5ldHJhdGlvblZlYy5jb3B5KGJqLnBvc2l0aW9uKTtcbiAgICBwZW5ldHJhdGlvblZlYy52YWRkKHJqLHBlbmV0cmF0aW9uVmVjKTtcbiAgICBwZW5ldHJhdGlvblZlYy52c3ViKGJpLnBvc2l0aW9uLHBlbmV0cmF0aW9uVmVjKTtcbiAgICBwZW5ldHJhdGlvblZlYy52c3ViKHJpLHBlbmV0cmF0aW9uVmVjKTtcblxuICAgIHZhciBnID0gbi5kb3QocGVuZXRyYXRpb25WZWMpO1xuXG4gICAgLy8gQ29tcHV0ZSBpdGVyYXRpb25cbiAgICB2YXIgZVBsdXNPbmUgPSB0aGlzLnJlc3RpdHV0aW9uICsgMTtcbiAgICB2YXIgR1cgPSBlUGx1c09uZSAqIHZqLmRvdChuKSAtIGVQbHVzT25lICogdmkuZG90KG4pICsgd2ouZG90KHJqeG4pIC0gd2kuZG90KHJpeG4pO1xuICAgIHZhciBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuXG4gICAgdmFyIEIgPSAtIGcgKiBhIC0gR1cgKiBiIC0gaCpHaU1mO1xuXG4gICAgcmV0dXJuIEI7XG59O1xuXG52YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmkgPSBuZXcgVmVjMygpO1xudmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3ZqID0gbmV3IFZlYzMoKTtcbnZhciBDb250YWN0RXF1YXRpb25fZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbF94aSA9IG5ldyBWZWMzKCk7XG52YXIgQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGogPSBuZXcgVmVjMygpO1xudmFyIENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3JlbFZlbCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IHJlbGF0aXZlIHZlbG9jaXR5IGluIHRoZSBjb250YWN0IHBvaW50LlxuICogQG1ldGhvZCBnZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkNvbnRhY3RFcXVhdGlvbi5wcm90b3R5cGUuZ2V0SW1wYWN0VmVsb2NpdHlBbG9uZ05vcm1hbCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHZpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmk7XG4gICAgdmFyIHZqID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfdmo7XG4gICAgdmFyIHhpID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGk7XG4gICAgdmFyIHhqID0gQ29udGFjdEVxdWF0aW9uX2dldEltcGFjdFZlbG9jaXR5QWxvbmdOb3JtYWxfeGo7XG4gICAgdmFyIHJlbFZlbCA9IENvbnRhY3RFcXVhdGlvbl9nZXRJbXBhY3RWZWxvY2l0eUFsb25nTm9ybWFsX3JlbFZlbDtcblxuICAgIHRoaXMuYmkucG9zaXRpb24udmFkZCh0aGlzLnJpLCB4aSk7XG4gICAgdGhpcy5iai5wb3NpdGlvbi52YWRkKHRoaXMucmosIHhqKTtcblxuICAgIHRoaXMuYmkuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoeGksIHZpKTtcbiAgICB0aGlzLmJqLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHhqLCB2aik7XG5cbiAgICB2aS52c3ViKHZqLCByZWxWZWwpO1xuXG4gICAgcmV0dXJuIHRoaXMubmkuZG90KHJlbFZlbCk7XG59O1xuXG5cbn0se1wiLi4vbWF0aC9NYXQzXCI6MjcsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vRXF1YXRpb25cIjoyMH1dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gRXF1YXRpb247XG5cbnZhciBKYWNvYmlhbkVsZW1lbnQgPSBfZGVyZXFfKCcuLi9tYXRoL0phY29iaWFuRWxlbWVudCcpLFxuICAgIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBFcXVhdGlvbiBiYXNlIGNsYXNzXG4gKiBAY2xhc3MgRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBiaVxuICogQHBhcmFtIHtCb2R5fSBialxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbkZvcmNlIE1pbmltdW0gKHJlYWQ6IG5lZ2F0aXZlIG1heCkgZm9yY2UgdG8gYmUgYXBwbGllZCBieSB0aGUgY29uc3RyYWludC5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZSBNYXhpbXVtIChyZWFkOiBwb3NpdGl2ZSBtYXgpIGZvcmNlIHRvIGJlIGFwcGxpZWQgYnkgdGhlIGNvbnN0cmFpbnQuXG4gKi9cbmZ1bmN0aW9uIEVxdWF0aW9uKGJpLGJqLG1pbkZvcmNlLG1heEZvcmNlKXtcbiAgICB0aGlzLmlkID0gRXF1YXRpb24uaWQrKztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtaW5Gb3JjZVxuICAgICAqL1xuICAgIHRoaXMubWluRm9yY2UgPSB0eXBlb2YobWluRm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IC0xZTYgOiBtaW5Gb3JjZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhGb3JjZVxuICAgICAqL1xuICAgIHRoaXMubWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpPT09XCJ1bmRlZmluZWRcIiA/IDFlNiA6IG1heEZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJpXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5iaSA9IGJpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJqXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5iaiA9IGJqO1xuXG4gICAgLyoqXG4gICAgICogU1BPT0sgcGFyYW1ldGVyXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGFcbiAgICAgKi9cbiAgICB0aGlzLmEgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBTUE9PSyBwYXJhbWV0ZXJcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYlxuICAgICAqL1xuICAgIHRoaXMuYiA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIFNQT09LIHBhcmFtZXRlclxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBlcHNcbiAgICAgKi9cbiAgICB0aGlzLmVwcyA9IDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7SmFjb2JpYW5FbGVtZW50fSBqYWNvYmlhbkVsZW1lbnRBXG4gICAgICovXG4gICAgdGhpcy5qYWNvYmlhbkVsZW1lbnRBID0gbmV3IEphY29iaWFuRWxlbWVudCgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtKYWNvYmlhbkVsZW1lbnR9IGphY29iaWFuRWxlbWVudEJcbiAgICAgKi9cbiAgICB0aGlzLmphY29iaWFuRWxlbWVudEIgPSBuZXcgSmFjb2JpYW5FbGVtZW50KCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGVuYWJsZWRcbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgIC8vIFNldCB0eXBpY2FsIHNwb29rIHBhcmFtc1xuICAgIHRoaXMuc2V0U3Bvb2tQYXJhbXMoMWU3LDQsMS82MCk7XG59XG5FcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFcXVhdGlvbjtcblxuRXF1YXRpb24uaWQgPSAwO1xuXG4vKipcbiAqIFJlY2FsY3VsYXRlcyBhLGIsZXBzLlxuICogQG1ldGhvZCBzZXRTcG9va1BhcmFtc1xuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuc2V0U3Bvb2tQYXJhbXMgPSBmdW5jdGlvbihzdGlmZm5lc3MscmVsYXhhdGlvbix0aW1lU3RlcCl7XG4gICAgdmFyIGQgPSByZWxheGF0aW9uLFxuICAgICAgICBrID0gc3RpZmZuZXNzLFxuICAgICAgICBoID0gdGltZVN0ZXA7XG4gICAgdGhpcy5hID0gNC4wIC8gKGggKiAoMSArIDQgKiBkKSk7XG4gICAgdGhpcy5iID0gKDQuMCAqIGQpIC8gKDEgKyA0ICogZCk7XG4gICAgdGhpcy5lcHMgPSA0LjAgLyAoaCAqIGggKiBrICogKDEgKyA0ICogZCkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgUkhTIG9mIHRoZSBTUE9PSyBlcXVhdGlvblxuICogQG1ldGhvZCBjb21wdXRlQlxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihhLGIsaCl7XG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKSxcbiAgICAgICAgR3EgPSB0aGlzLmNvbXB1dGVHcSgpLFxuICAgICAgICBHaU1mID0gdGhpcy5jb21wdXRlR2lNZigpO1xuICAgIHJldHVybiAtIEdxICogYSAtIEdXICogYiAtIEdpTWYqaDtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgRypxLCB3aGVyZSBxIGFyZSB0aGUgZ2VuZXJhbGl6ZWQgYm9keSBjb29yZGluYXRlc1xuICogQG1ldGhvZCBjb21wdXRlR3FcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHcSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHhpID0gYmkucG9zaXRpb24sXG4gICAgICAgIHhqID0gYmoucG9zaXRpb247XG4gICAgcmV0dXJuIEdBLnNwYXRpYWwuZG90KHhpKSArIEdCLnNwYXRpYWwuZG90KHhqKTtcbn07XG5cbnZhciB6ZXJvID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBDb21wdXRlcyBHKlcsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1cgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICB2aSA9IGJpLnZlbG9jaXR5LFxuICAgICAgICB2aiA9IGJqLnZlbG9jaXR5LFxuICAgICAgICB3aSA9IGJpLmFuZ3VsYXJWZWxvY2l0eSB8fCB6ZXJvLFxuICAgICAgICB3aiA9IGJqLmFuZ3VsYXJWZWxvY2l0eSB8fCB6ZXJvO1xuICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnModmksd2kpICsgR0IubXVsdGlwbHlWZWN0b3JzKHZqLHdqKTtcbn07XG5cblxuLyoqXG4gKiBDb21wdXRlcyBHKldsYW1iZGEsIHdoZXJlIFcgYXJlIHRoZSBib2R5IHZlbG9jaXRpZXNcbiAqIEBtZXRob2QgY29tcHV0ZUdXbGFtYmRhXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlR1dsYW1iZGEgPSBmdW5jdGlvbigpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICB2aSA9IGJpLnZsYW1iZGEsXG4gICAgICAgIHZqID0gYmoudmxhbWJkYSxcbiAgICAgICAgd2kgPSBiaS53bGFtYmRhIHx8IHplcm8sXG4gICAgICAgIHdqID0gYmoud2xhbWJkYSB8fCB6ZXJvO1xuICAgIHJldHVybiBHQS5tdWx0aXBseVZlY3RvcnModmksd2kpICsgR0IubXVsdGlwbHlWZWN0b3JzKHZqLHdqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgRyppbnYoTSkqZiwgd2hlcmUgTSBpcyB0aGUgbWFzcyBtYXRyaXggd2l0aCBkaWFnb25hbCBibG9ja3MgZm9yIGVhY2ggYm9keSwgYW5kIGYgYXJlIHRoZSBmb3JjZXMgb24gdGhlIGJvZGllcy5cbiAqIEBtZXRob2QgY29tcHV0ZUdpTWZcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xudmFyIGlNZmkgPSBuZXcgVmVjMygpLFxuICAgIGlNZmogPSBuZXcgVmVjMygpLFxuICAgIGludklpX3ZtdWx0X3RhdWkgPSBuZXcgVmVjMygpLFxuICAgIGludklqX3ZtdWx0X3RhdWogPSBuZXcgVmVjMygpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1mID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCLFxuICAgICAgICBiaSA9IHRoaXMuYmksXG4gICAgICAgIGJqID0gdGhpcy5iaixcbiAgICAgICAgZmkgPSBiaS5mb3JjZSxcbiAgICAgICAgdGkgPSBiaS50b3JxdWUsXG4gICAgICAgIGZqID0gYmouZm9yY2UsXG4gICAgICAgIHRqID0gYmoudG9ycXVlLFxuICAgICAgICBpbnZNYXNzaSA9IGJpLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52TWFzc2ogPSBiai5pbnZNYXNzU29sdmU7XG5cbiAgICBpZihiaS5pbnZJbmVydGlhV29ybGRTb2x2ZSl7IGJpLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KHRpLGludklpX3ZtdWx0X3RhdWkpOyB9XG4gICAgZWxzZSB7IGludklpX3ZtdWx0X3RhdWkuc2V0KDAsMCwwKTsgfVxuICAgIGlmKGJqLmludkluZXJ0aWFXb3JsZFNvbHZlKXsgYmouaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQodGosaW52SWpfdm11bHRfdGF1aik7IH1cbiAgICBlbHNlIHsgaW52SWpfdm11bHRfdGF1ai5zZXQoMCwwLDApOyB9XG5cbiAgICBmaS5tdWx0KGludk1hc3NpLGlNZmkpO1xuICAgIGZqLm11bHQoaW52TWFzc2osaU1maik7XG5cbiAgICByZXR1cm4gR0EubXVsdGlwbHlWZWN0b3JzKGlNZmksaW52SWlfdm11bHRfdGF1aSkgKyBHQi5tdWx0aXBseVZlY3RvcnMoaU1maixpbnZJal92bXVsdF90YXVqKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgRyppbnYoTSkqRydcbiAqIEBtZXRob2QgY29tcHV0ZUdpTUd0XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbnZhciB0bXAgPSBuZXcgVmVjMygpO1xuRXF1YXRpb24ucHJvdG90eXBlLmNvbXB1dGVHaU1HdCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIGludk1hc3NpID0gYmkuaW52TWFzc1NvbHZlLFxuICAgICAgICBpbnZNYXNzaiA9IGJqLmludk1hc3NTb2x2ZSxcbiAgICAgICAgaW52SWkgPSBiaS5pbnZJbmVydGlhV29ybGRTb2x2ZSxcbiAgICAgICAgaW52SWogPSBiai5pbnZJbmVydGlhV29ybGRTb2x2ZSxcbiAgICAgICAgcmVzdWx0ID0gaW52TWFzc2kgKyBpbnZNYXNzajtcblxuICAgIGlmKGludklpKXtcbiAgICAgICAgaW52SWkudm11bHQoR0Eucm90YXRpb25hbCx0bXApO1xuICAgICAgICByZXN1bHQgKz0gdG1wLmRvdChHQS5yb3RhdGlvbmFsKTtcbiAgICB9XG5cbiAgICBpZihpbnZJail7XG4gICAgICAgIGludklqLnZtdWx0KEdCLnJvdGF0aW9uYWwsdG1wKTtcbiAgICAgICAgcmVzdWx0ICs9IHRtcC5kb3QoR0Iucm90YXRpb25hbCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICByZXN1bHQ7XG59O1xuXG52YXIgYWRkVG9XbGFtYmRhX3RlbXAgPSBuZXcgVmVjMygpLFxuICAgIGFkZFRvV2xhbWJkYV9HaSA9IG5ldyBWZWMzKCksXG4gICAgYWRkVG9XbGFtYmRhX0dqID0gbmV3IFZlYzMoKSxcbiAgICBhZGRUb1dsYW1iZGFfcmkgPSBuZXcgVmVjMygpLFxuICAgIGFkZFRvV2xhbWJkYV9yaiA9IG5ldyBWZWMzKCksXG4gICAgYWRkVG9XbGFtYmRhX01kaWFnID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBBZGQgY29uc3RyYWludCB2ZWxvY2l0eSB0byB0aGUgYm9kaWVzLlxuICogQG1ldGhvZCBhZGRUb1dsYW1iZGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWx0YWxhbWJkYVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuYWRkVG9XbGFtYmRhID0gZnVuY3Rpb24oZGVsdGFsYW1iZGEpe1xuICAgIHZhciBHQSA9IHRoaXMuamFjb2JpYW5FbGVtZW50QSxcbiAgICAgICAgR0IgPSB0aGlzLmphY29iaWFuRWxlbWVudEIsXG4gICAgICAgIGJpID0gdGhpcy5iaSxcbiAgICAgICAgYmogPSB0aGlzLmJqLFxuICAgICAgICB0ZW1wID0gYWRkVG9XbGFtYmRhX3RlbXA7XG5cbiAgICAvLyBBZGQgdG8gbGluZWFyIHZlbG9jaXR5XG4gICAgLy8gdl9sYW1iZGEgKz0gaW52KE0pICogZGVsdGFfbGFtYmEgKiBHXG4gICAgR0Euc3BhdGlhbC5tdWx0KGJpLmludk1hc3NTb2x2ZSAqIGRlbHRhbGFtYmRhLHRlbXApO1xuICAgIGJpLnZsYW1iZGEudmFkZCh0ZW1wLCBiaS52bGFtYmRhKTtcblxuICAgIEdCLnNwYXRpYWwubXVsdChiai5pbnZNYXNzU29sdmUgKiBkZWx0YWxhbWJkYSx0ZW1wKTtcbiAgICBiai52bGFtYmRhLnZhZGQodGVtcCwgYmoudmxhbWJkYSk7XG5cbiAgICAvLyBBZGQgdG8gYW5ndWxhciB2ZWxvY2l0eVxuICAgIGlmKGJpLmludkluZXJ0aWFXb3JsZFNvbHZlKXtcbiAgICAgICAgYmkuaW52SW5lcnRpYVdvcmxkU29sdmUudm11bHQoR0Eucm90YXRpb25hbCx0ZW1wKTtcbiAgICAgICAgdGVtcC5tdWx0KGRlbHRhbGFtYmRhLHRlbXApO1xuICAgICAgICBiaS53bGFtYmRhLnZhZGQodGVtcCxiaS53bGFtYmRhKTtcbiAgICB9XG5cbiAgICBpZihiai5pbnZJbmVydGlhV29ybGRTb2x2ZSl7XG4gICAgICAgIGJqLmludkluZXJ0aWFXb3JsZFNvbHZlLnZtdWx0KEdCLnJvdGF0aW9uYWwsdGVtcCk7XG4gICAgICAgIHRlbXAubXVsdChkZWx0YWxhbWJkYSx0ZW1wKTtcbiAgICAgICAgYmoud2xhbWJkYS52YWRkKHRlbXAsYmoud2xhbWJkYSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBkZW5vbWluYXRvciBwYXJ0IG9mIHRoZSBTUE9PSyBlcXVhdGlvbjogQyA9IEcqaW52KE0pKkcnICsgZXBzXG4gKiBAbWV0aG9kIGNvbXB1dGVJbnZDXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGVwc1xuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmNvbXB1dGVHaU1HdCgpICsgdGhpcy5lcHM7XG59O1xuXG59LHtcIi4uL21hdGgvSmFjb2JpYW5FbGVtZW50XCI6MjYsXCIuLi9tYXRoL1ZlYzNcIjozMH1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gRnJpY3Rpb25FcXVhdGlvbjtcblxudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XG5cbi8qKlxuICogQ29uc3RyYWlucyB0aGUgc2xpcHBpbmcgaW4gYSBjb250YWN0IGFsb25nIGEgdGFuZ2VudFxuICogQGNsYXNzIEZyaWN0aW9uRXF1YXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQHBhcmFtIHtCb2R5fSBib2R5QVxuICogQHBhcmFtIHtCb2R5fSBib2R5QlxuICogQHBhcmFtIHtOdW1iZXJ9IHNsaXBGb3JjZSBzaG91bGQgYmUgKy1GX2ZyaWN0aW9uID0gKy1tdSAqIEZfbm9ybWFsID0gKy1tdSAqIG0gKiBnXG4gKiBAZXh0ZW5kcyBFcXVhdGlvblxuICovXG5mdW5jdGlvbiBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgc2xpcEZvcmNlKXtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsIGJvZHlCLCAtc2xpcEZvcmNlLCBzbGlwRm9yY2UpO1xuICAgIHRoaXMucmkgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMucmogPSBuZXcgVmVjMygpO1xuICAgIHRoaXMudCA9IG5ldyBWZWMzKCk7IC8vIHRhbmdlbnRcbn1cblxuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcbkZyaWN0aW9uRXF1YXRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRnJpY3Rpb25FcXVhdGlvbjtcblxudmFyIEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDEgPSBuZXcgVmVjMygpO1xudmFyIEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIgPSBuZXcgVmVjMygpO1xuRnJpY3Rpb25FcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG4gICAgICAgIHJpID0gdGhpcy5yaSxcbiAgICAgICAgcmogPSB0aGlzLnJqLFxuICAgICAgICByaXh0ID0gRnJpY3Rpb25FcXVhdGlvbl9jb21wdXRlQl90ZW1wMSxcbiAgICAgICAgcmp4dCA9IEZyaWN0aW9uRXF1YXRpb25fY29tcHV0ZUJfdGVtcDIsXG4gICAgICAgIHQgPSB0aGlzLnQ7XG5cbiAgICAvLyBDYWx1Y2xhdGUgY3Jvc3MgcHJvZHVjdHNcbiAgICByaS5jcm9zcyh0LHJpeHQpO1xuICAgIHJqLmNyb3NzKHQscmp4dCk7XG5cbiAgICAvLyBHID0gWy10IC1yaXh0IHQgcmp4dF1cbiAgICAvLyBBbmQgcmVtZW1iZXIsIHRoaXMgaXMgYSBwdXJlIHZlbG9jaXR5IGNvbnN0cmFpbnQsIGcgaXMgYWx3YXlzIHplcm8hXG4gICAgdmFyIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcbiAgICB0Lm5lZ2F0ZShHQS5zcGF0aWFsKTtcbiAgICByaXh0Lm5lZ2F0ZShHQS5yb3RhdGlvbmFsKTtcbiAgICBHQi5zcGF0aWFsLmNvcHkodCk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KHJqeHQpO1xuXG4gICAgdmFyIEdXID0gdGhpcy5jb21wdXRlR1coKTtcbiAgICB2YXIgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxufSx7XCIuLi9tYXRoL01hdDNcIjoyNyxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9FcXVhdGlvblwiOjIwfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBSb3RhdGlvbmFsRXF1YXRpb247XG5cbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgTWF0MyA9IF9kZXJlcV8oJy4uL21hdGgvTWF0MycpO1xudmFyIEVxdWF0aW9uID0gX2RlcmVxXygnLi9FcXVhdGlvbicpO1xuXG4vKipcbiAqIFJvdGF0aW9uYWwgY29uc3RyYWludC4gV29ya3MgdG8ga2VlcCB0aGUgbG9jYWwgdmVjdG9ycyBvcnRob2dvbmFsIHRvIGVhY2ggb3RoZXIgaW4gd29ybGQgc3BhY2UuXG4gKiBAY2xhc3MgUm90YXRpb25hbEVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhpc0FdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmF4aXNCXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heEZvcmNlXVxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbEVxdWF0aW9uKGJvZHlBLCBib2R5Qiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIG1heEZvcmNlID0gdHlwZW9mKG9wdGlvbnMubWF4Rm9yY2UpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMubWF4Rm9yY2UgOiAxZTY7XG5cbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLW1heEZvcmNlLCBtYXhGb3JjZSk7XG5cbiAgICB0aGlzLmF4aXNBID0gb3B0aW9ucy5heGlzQSA/IG9wdGlvbnMuYXhpc0EuY2xvbmUoKSA6IG5ldyBWZWMzKDEsIDAsIDApO1xuICAgIHRoaXMuYXhpc0IgPSBvcHRpb25zLmF4aXNCID8gb3B0aW9ucy5heGlzQi5jbG9uZSgpIDogbmV3IFZlYzMoMCwgMSwgMCk7XG5cbiAgICB0aGlzLm1heEFuZ2xlID0gTWF0aC5QSSAvIDI7XG59XG5cblJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxFcXVhdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSb3RhdGlvbmFsRXF1YXRpb247XG5cbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcblxuUm90YXRpb25hbEVxdWF0aW9uLnByb3RvdHlwZS5jb21wdXRlQiA9IGZ1bmN0aW9uKGgpe1xuICAgIHZhciBhID0gdGhpcy5hLFxuICAgICAgICBiID0gdGhpcy5iLFxuXG4gICAgICAgIG5pID0gdGhpcy5heGlzQSxcbiAgICAgICAgbmogPSB0aGlzLmF4aXNCLFxuXG4gICAgICAgIG5peG5qID0gdG1wVmVjMSxcbiAgICAgICAgbmp4bmkgPSB0bXBWZWMyLFxuXG4gICAgICAgIEdBID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRBLFxuICAgICAgICBHQiA9IHRoaXMuamFjb2JpYW5FbGVtZW50QjtcblxuICAgIC8vIENhbHVjbGF0ZSBjcm9zcyBwcm9kdWN0c1xuICAgIG5pLmNyb3NzKG5qLCBuaXhuaik7XG4gICAgbmouY3Jvc3MobmksIG5qeG5pKTtcblxuICAgIC8vIGcgPSBuaSAqIG5qXG4gICAgLy8gZ2RvdCA9IChuaiB4IG5pKSAqIHdpICsgKG5pIHggbmopICogd2pcbiAgICAvLyBHID0gWzAgbmp4bmkgMCBuaXhual1cbiAgICAvLyBXID0gW3ZpIHdpIHZqIHdqXVxuICAgIEdBLnJvdGF0aW9uYWwuY29weShuanhuaSk7XG4gICAgR0Iucm90YXRpb25hbC5jb3B5KG5peG5qKTtcblxuICAgIHZhciBnID0gTWF0aC5jb3ModGhpcy5tYXhBbmdsZSkgLSBuaS5kb3QobmopLFxuICAgICAgICBHVyA9IHRoaXMuY29tcHV0ZUdXKCksXG4gICAgICAgIEdpTWYgPSB0aGlzLmNvbXB1dGVHaU1mKCk7XG5cbiAgICB2YXIgQiA9IC0gZyAqIGEgLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxuXG59LHtcIi4uL21hdGgvTWF0M1wiOjI3LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL0VxdWF0aW9uXCI6MjB9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uO1xuXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIE1hdDMgPSBfZGVyZXFfKCcuLi9tYXRoL01hdDMnKTtcbnZhciBFcXVhdGlvbiA9IF9kZXJlcV8oJy4vRXF1YXRpb24nKTtcblxuLyoqXG4gKiBSb3RhdGlvbmFsIG1vdG9yIGNvbnN0cmFpbnQuIFRyaWVzIHRvIGtlZXAgdGhlIHJlbGF0aXZlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIGJvZGllcyB0byBhIGdpdmVuIHZhbHVlLlxuICogQGNsYXNzIFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXhGb3JjZVxuICogQGV4dGVuZHMgRXF1YXRpb25cbiAqL1xuZnVuY3Rpb24gUm90YXRpb25hbE1vdG9yRXF1YXRpb24oYm9keUEsIGJvZHlCLCBtYXhGb3JjZSl7XG4gICAgbWF4Rm9yY2UgPSB0eXBlb2YobWF4Rm9yY2UpIT09J3VuZGVmaW5lZCcgPyBtYXhGb3JjZSA6IDFlNjtcbiAgICBFcXVhdGlvbi5jYWxsKHRoaXMsYm9keUEsYm9keUIsLW1heEZvcmNlLG1heEZvcmNlKTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpc1xuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0FcbiAgICAgKi9cbiAgICB0aGlzLmF4aXNBID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIFdvcmxkIG9yaWVudGVkIHJvdGF0aW9uYWwgYXhpc1xuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhpc0JcbiAgICAgKi9cbiAgICB0aGlzLmF4aXNCID0gbmV3IFZlYzMoKTsgLy8gV29ybGQgb3JpZW50ZWQgcm90YXRpb25hbCBheGlzXG5cbiAgICAvKipcbiAgICAgKiBNb3RvciB2ZWxvY2l0eVxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB0YXJnZXRWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0VmVsb2NpdHkgPSAwO1xufVxuXG5Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbi5wcm90b3R5cGUgPSBuZXcgRXF1YXRpb24oKTtcblJvdGF0aW9uYWxNb3RvckVxdWF0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvdGF0aW9uYWxNb3RvckVxdWF0aW9uO1xuXG5Sb3RhdGlvbmFsTW90b3JFcXVhdGlvbi5wcm90b3R5cGUuY29tcHV0ZUIgPSBmdW5jdGlvbihoKXtcbiAgICB2YXIgYSA9IHRoaXMuYSxcbiAgICAgICAgYiA9IHRoaXMuYixcbiAgICAgICAgYmkgPSB0aGlzLmJpLFxuICAgICAgICBiaiA9IHRoaXMuYmosXG5cbiAgICAgICAgYXhpc0EgPSB0aGlzLmF4aXNBLFxuICAgICAgICBheGlzQiA9IHRoaXMuYXhpc0IsXG5cbiAgICAgICAgR0EgPSB0aGlzLmphY29iaWFuRWxlbWVudEEsXG4gICAgICAgIEdCID0gdGhpcy5qYWNvYmlhbkVsZW1lbnRCO1xuXG4gICAgLy8gZyA9IDBcbiAgICAvLyBnZG90ID0gYXhpc0EgKiB3aSAtIGF4aXNCICogd2pcbiAgICAvLyBnZG90ID0gRyAqIFcgPSBHICogW3ZpIHdpIHZqIHdqXVxuICAgIC8vID0+XG4gICAgLy8gRyA9IFswIGF4aXNBIDAgLWF4aXNCXVxuXG4gICAgR0Eucm90YXRpb25hbC5jb3B5KGF4aXNBKTtcbiAgICBheGlzQi5uZWdhdGUoR0Iucm90YXRpb25hbCk7XG5cbiAgICB2YXIgR1cgPSB0aGlzLmNvbXB1dGVHVygpIC0gdGhpcy50YXJnZXRWZWxvY2l0eSxcbiAgICAgICAgR2lNZiA9IHRoaXMuY29tcHV0ZUdpTWYoKTtcblxuICAgIHZhciBCID0gLSBHVyAqIGIgLSBoICogR2lNZjtcblxuICAgIHJldHVybiBCO1xufTtcblxufSx7XCIuLi9tYXRoL01hdDNcIjoyNyxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9FcXVhdGlvblwiOjIwfV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFV0aWxzID0gX2RlcmVxXygnLi4vdXRpbHMvVXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb250YWN0TWF0ZXJpYWw7XG5cbi8qKlxuICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB0d28gbWF0ZXJpYWxzIG1lZXQuXG4gKiBAY2xhc3MgQ29udGFjdE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0xXG4gKiBAcGFyYW0ge01hdGVyaWFsfSBtMlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uPTAuM11cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5yZXN0aXR1dGlvbj0wLjNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzPTFlN11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uPTNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcz0xZTddXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb249M11cbiAqL1xuZnVuY3Rpb24gQ29udGFjdE1hdGVyaWFsKG0xLCBtMiwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZnJpY3Rpb246IDAuMyxcbiAgICAgICAgcmVzdGl0dXRpb246IDAuMyxcbiAgICAgICAgY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzOiAxZTcsXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvblJlbGF4YXRpb246IDMsXG4gICAgICAgIGZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3M6IDFlNyxcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb246IDNcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIElkZW50aWZpZXIgb2YgdGhpcyBtYXRlcmlhbFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBpZFxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBDb250YWN0TWF0ZXJpYWwuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0aWNpcGF0aW5nIG1hdGVyaWFsc1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG1hdGVyaWFsc1xuICAgICAqIEB0b2RvICBTaG91bGQgYmUgLm1hdGVyaWFsQSBhbmQgLm1hdGVyaWFsQiBpbnN0ZWFkXG4gICAgICovXG4gICAgdGhpcy5tYXRlcmlhbHMgPSBbbTEsIG0yXTtcblxuICAgIC8qKlxuICAgICAqIEZyaWN0aW9uIGNvZWZmaWNpZW50XG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb247XG5cbiAgICAvKipcbiAgICAgKiBSZXN0aXR1dGlvbiBjb2VmZmljaWVudFxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByZXN0aXR1dGlvblxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSBwcm9kdWNlZCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25TdGlmZm5lc3NcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzO1xuXG4gICAgLyoqXG4gICAgICogUmVsYXhhdGlvbiB0aW1lIG9mIHRoZSBwcm9kdWNlZCBjb250YWN0IGVxdWF0aW9uc1xuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb250YWN0RXF1YXRpb25SZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uID0gb3B0aW9ucy5jb250YWN0RXF1YXRpb25SZWxheGF0aW9uO1xuXG4gICAgLyoqXG4gICAgICogU3RpZmZuZXNzIG9mIHRoZSBwcm9kdWNlZCBmcmljdGlvbiBlcXVhdGlvbnNcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcyA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIFJlbGF4YXRpb24gdGltZSBvZiB0aGUgcHJvZHVjZWQgZnJpY3Rpb24gZXF1YXRpb25zXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUmVsYXhhdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb247XG59XG5cbkNvbnRhY3RNYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHtcIi4uL3V0aWxzL1V0aWxzXCI6NTN9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE1hdGVyaWFsO1xuXG4vKipcbiAqIERlZmluZXMgYSBwaHlzaWNzIG1hdGVyaWFsLlxuICogQGNsYXNzIE1hdGVyaWFsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gTWF0ZXJpYWwob3B0aW9ucyl7XG4gICAgdmFyIG5hbWUgPSAnJztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZpeFxuICAgIGlmKHR5cGVvZihvcHRpb25zKSA9PT0gJ3N0cmluZycpe1xuICAgICAgICBuYW1lID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH0gZWxzZSBpZih0eXBlb2Yob3B0aW9ucykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbmFtZVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcblxuICAgIC8qKlxuICAgICAqIG1hdGVyaWFsIGlkLlxuICAgICAqIEBwcm9wZXJ0eSBpZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IE1hdGVyaWFsLmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogRnJpY3Rpb24gZm9yIHRoaXMgbWF0ZXJpYWwuIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIGZyaWN0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCBpbiB0aGUgV29ybGQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBmcmljdGlvblxuICAgICAqL1xuICAgIHRoaXMuZnJpY3Rpb24gPSB0eXBlb2Yob3B0aW9ucy5mcmljdGlvbikgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5mcmljdGlvbiA6IC0xO1xuXG4gICAgLyoqXG4gICAgICogUmVzdGl0dXRpb24gZm9yIHRoaXMgbWF0ZXJpYWwuIElmIG5vbi1uZWdhdGl2ZSwgaXQgd2lsbCBiZSB1c2VkIGluc3RlYWQgb2YgdGhlIHJlc3RpdHV0aW9uIGdpdmVuIGJ5IENvbnRhY3RNYXRlcmlhbHMuIElmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgQ29udGFjdE1hdGVyaWFsLCB0aGUgdmFsdWUgZnJvbSAuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCBpbiB0aGUgV29ybGQgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXN0aXR1dGlvblxuICAgICAqL1xuICAgIHRoaXMucmVzdGl0dXRpb24gPSB0eXBlb2Yob3B0aW9ucy5yZXN0aXR1dGlvbikgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5yZXN0aXR1dGlvbiA6IC0xO1xufVxuXG5NYXRlcmlhbC5pZENvdW50ZXIgPSAwO1xuXG59LHt9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEphY29iaWFuRWxlbWVudDtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuL1ZlYzMnKTtcblxuLyoqXG4gKiBBbiBlbGVtZW50IGNvbnRhaW5pbmcgNiBlbnRyaWVzLCAzIHNwYXRpYWwgYW5kIDMgcm90YXRpb25hbCBkZWdyZWVzIG9mIGZyZWVkb20uXG4gKiBAY2xhc3MgSmFjb2JpYW5FbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSmFjb2JpYW5FbGVtZW50KCl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IHNwYXRpYWxcbiAgICAgKi9cbiAgICB0aGlzLnNwYXRpYWwgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSByb3RhdGlvbmFsXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbmFsID0gbmV3IFZlYzMoKTtcbn1cblxuLyoqXG4gKiBNdWx0aXBseSB3aXRoIG90aGVyIEphY29iaWFuRWxlbWVudFxuICogQG1ldGhvZCBtdWx0aXBseUVsZW1lbnRcbiAqIEBwYXJhbSAge0phY29iaWFuRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5KYWNvYmlhbkVsZW1lbnQucHJvdG90eXBlLm11bHRpcGx5RWxlbWVudCA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xuICAgIHJldHVybiBlbGVtZW50LnNwYXRpYWwuZG90KHRoaXMuc3BhdGlhbCkgKyBlbGVtZW50LnJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHdpdGggdHdvIHZlY3RvcnNcbiAqIEBtZXRob2QgbXVsdGlwbHlWZWN0b3JzXG4gKiBAcGFyYW0gIHtWZWMzfSBzcGF0aWFsXG4gKiBAcGFyYW0gIHtWZWMzfSByb3RhdGlvbmFsXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkphY29iaWFuRWxlbWVudC5wcm90b3R5cGUubXVsdGlwbHlWZWN0b3JzID0gZnVuY3Rpb24oc3BhdGlhbCxyb3RhdGlvbmFsKXtcbiAgICByZXR1cm4gc3BhdGlhbC5kb3QodGhpcy5zcGF0aWFsKSArIHJvdGF0aW9uYWwuZG90KHRoaXMucm90YXRpb25hbCk7XG59O1xuXG59LHtcIi4vVmVjM1wiOjMwfV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBNYXQzO1xuXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4vVmVjMycpO1xuXG4vKipcbiAqIEEgM3gzIG1hdHJpeC5cbiAqIEBjbGFzcyBNYXQzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBhcnJheSBlbGVtZW50cyBBcnJheSBvZiBuaW5lIGVsZW1lbnRzLiBPcHRpb25hbC5cbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxuICovXG5mdW5jdGlvbiBNYXQzKGVsZW1lbnRzKXtcbiAgICAvKipcbiAgICAgKiBBIHZlY3RvciBvZiBsZW5ndGggOSwgY29udGFpbmluZyBhbGwgbWF0cml4IGVsZW1lbnRzXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZWxlbWVudHNcbiAgICAgKi9cbiAgICBpZihlbGVtZW50cyl7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gWzAsMCwwLDAsMCwwLDAsMCwwXTtcbiAgICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWF0cml4IHRvIGlkZW50aXR5XG4gKiBAbWV0aG9kIGlkZW50aXR5XG4gKiBAdG9kbyBTaG91bGQgcGVyaGFwcyBiZSByZW5hbWVkIHRvIHNldElkZW50aXR5KCkgdG8gYmUgbW9yZSBjbGVhci5cbiAqIEB0b2RvIENyZWF0ZSBhbm90aGVyIGZ1bmN0aW9uIHRoYXQgaW1tZWRpYXRlbHkgY3JlYXRlcyBhbiBpZGVudGl0eSBtYXRyaXggZWcuIGV5ZSgpXG4gKi9cbk1hdDMucHJvdG90eXBlLmlkZW50aXR5ID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgZVswXSA9IDE7XG4gICAgZVsxXSA9IDA7XG4gICAgZVsyXSA9IDA7XG5cbiAgICBlWzNdID0gMDtcbiAgICBlWzRdID0gMTtcbiAgICBlWzVdID0gMDtcblxuICAgIGVbNl0gPSAwO1xuICAgIGVbN10gPSAwO1xuICAgIGVbOF0gPSAxO1xufTtcblxuLyoqXG4gKiBTZXQgYWxsIGVsZW1lbnRzIHRvIHplcm9cbiAqIEBtZXRob2Qgc2V0WmVyb1xuICovXG5NYXQzLnByb3RvdHlwZS5zZXRaZXJvID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgZVswXSA9IDA7XG4gICAgZVsxXSA9IDA7XG4gICAgZVsyXSA9IDA7XG4gICAgZVszXSA9IDA7XG4gICAgZVs0XSA9IDA7XG4gICAgZVs1XSA9IDA7XG4gICAgZVs2XSA9IDA7XG4gICAgZVs3XSA9IDA7XG4gICAgZVs4XSA9IDA7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1hdHJpeCBkaWFnb25hbCBlbGVtZW50cyBmcm9tIGEgVmVjM1xuICogQG1ldGhvZCBzZXRUcmFjZVxuICogQHBhcmFtIHtWZWMzfSB2ZWMzXG4gKi9cbk1hdDMucHJvdG90eXBlLnNldFRyYWNlID0gZnVuY3Rpb24odmVjMyl7XG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGVbMF0gPSB2ZWMzLng7XG4gICAgZVs0XSA9IHZlYzMueTtcbiAgICBlWzhdID0gdmVjMy56O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXRyaXggZGlhZ29uYWwgZWxlbWVudHNcbiAqIEBtZXRob2QgZ2V0VHJhY2VcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbk1hdDMucHJvdG90eXBlLmdldFRyYWNlID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB2YXIgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHRhcmdldC54ID0gZVswXTtcbiAgICB0YXJnZXQueSA9IGVbNF07XG4gICAgdGFyZ2V0LnogPSBlWzhdO1xufTtcblxuLyoqXG4gKiBNYXRyaXgtVmVjdG9yIG11bHRpcGxpY2F0aW9uXG4gKiBAbWV0aG9kIHZtdWx0XG4gKiBAcGFyYW0ge1ZlYzN9IHYgVGhlIHZlY3RvciB0byBtdWx0aXBseSB3aXRoXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbCwgdGFyZ2V0IHRvIHNhdmUgdGhlIHJlc3VsdCBpbi5cbiAqL1xuTWF0My5wcm90b3R5cGUudm11bHQgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgZSA9IHRoaXMuZWxlbWVudHMsXG4gICAgICAgIHggPSB2LngsXG4gICAgICAgIHkgPSB2LnksXG4gICAgICAgIHogPSB2Lno7XG4gICAgdGFyZ2V0LnggPSBlWzBdKnggKyBlWzFdKnkgKyBlWzJdKno7XG4gICAgdGFyZ2V0LnkgPSBlWzNdKnggKyBlWzRdKnkgKyBlWzVdKno7XG4gICAgdGFyZ2V0LnogPSBlWzZdKnggKyBlWzddKnkgKyBlWzhdKno7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBNYXRyaXgtc2NhbGFyIG11bHRpcGxpY2F0aW9uXG4gKiBAbWV0aG9kIHNtdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gc1xuICovXG5NYXQzLnByb3RvdHlwZS5zbXVsdCA9IGZ1bmN0aW9uKHMpe1xuICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuZWxlbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldICo9IHM7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNYXRyaXggbXVsdGlwbGljYXRpb25cbiAqIEBtZXRob2QgbW11bHRcbiAqIEBwYXJhbSB7TWF0M30gbSBNYXRyaXggdG8gbXVsdGlwbHkgd2l0aCBmcm9tIGxlZnQgc2lkZS5cbiAqIEByZXR1cm4ge01hdDN9IFRoZSByZXN1bHQuXG4gKi9cbk1hdDMucHJvdG90eXBlLm1tdWx0ID0gZnVuY3Rpb24obSx0YXJnZXQpe1xuICAgIHZhciByID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XG4gICAgZm9yKHZhciBpPTA7IGk8MzsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8MzsgaisrKXtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XG4gICAgICAgICAgICBmb3IodmFyIGs9MDsgazwzOyBrKyspe1xuICAgICAgICAgICAgICAgIHN1bSArPSBtLmVsZW1lbnRzW2krayozXSAqIHRoaXMuZWxlbWVudHNbaytqKjNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgci5lbGVtZW50c1tpK2oqM10gPSBzdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIFNjYWxlIGVhY2ggY29sdW1uIG9mIHRoZSBtYXRyaXhcbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7VmVjM30gdlxuICogQHJldHVybiB7TWF0M30gVGhlIHJlc3VsdC5cbiAqL1xuTWF0My5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBNYXQzKCk7XG4gICAgdmFyIGUgPSB0aGlzLmVsZW1lbnRzLFxuICAgICAgICB0ID0gdGFyZ2V0LmVsZW1lbnRzO1xuICAgIGZvcih2YXIgaT0wOyBpIT09MzsgaSsrKXtcbiAgICAgICAgdFszKmkgKyAwXSA9IHYueCAqIGVbMyppICsgMF07XG4gICAgICAgIHRbMyppICsgMV0gPSB2LnkgKiBlWzMqaSArIDFdO1xuICAgICAgICB0WzMqaSArIDJdID0gdi56ICogZVszKmkgKyAyXTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogU29sdmUgQXg9YlxuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtIHtWZWMzfSBiIFRoZSByaWdodCBoYW5kIHNpZGVcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdmVjdG9yIHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgc29sdXRpb24geFxuICogQHRvZG8gc2hvdWxkIHJldXNlIGFycmF5c1xuICovXG5NYXQzLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGIsdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcblxuICAgIC8vIENvbnN0cnVjdCBlcXVhdGlvbnNcbiAgICB2YXIgbnIgPSAzOyAvLyBudW0gcm93c1xuICAgIHZhciBuYyA9IDQ7IC8vIG51bSBjb2xzXG4gICAgdmFyIGVxbnMgPSBbXTtcbiAgICBmb3IodmFyIGk9MDsgaTxucipuYzsgaSsrKXtcbiAgICAgICAgZXFucy5wdXNoKDApO1xuICAgIH1cbiAgICB2YXIgaSxqO1xuICAgIGZvcihpPTA7IGk8MzsgaSsrKXtcbiAgICAgICAgZm9yKGo9MDsgajwzOyBqKyspe1xuICAgICAgICAgICAgZXFuc1tpK25jKmpdID0gdGhpcy5lbGVtZW50c1tpKzMqal07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXFuc1szKzQqMF0gPSBiLng7XG4gICAgZXFuc1szKzQqMV0gPSBiLnk7XG4gICAgZXFuc1szKzQqMl0gPSBiLno7XG5cbiAgICAvLyBDb21wdXRlIHJpZ2h0IHVwcGVyIHRyaWFuZ3VsYXIgdmVyc2lvbiBvZiB0aGUgbWF0cml4IC0gR2F1c3MgZWxpbWluYXRpb25cbiAgICB2YXIgbiA9IDMsIGsgPSBuLCBucDtcbiAgICB2YXIga3AgPSA0OyAvLyBudW0gcm93c1xuICAgIHZhciBwLCBlbHM7XG4gICAgZG8ge1xuICAgICAgICBpID0gayAtIG47XG4gICAgICAgIGlmIChlcW5zW2krbmMqaV0gPT09IDApIHtcbiAgICAgICAgICAgIC8vIHRoZSBwaXZvdCBpcyBudWxsLCBzd2FwIGxpbmVzXG4gICAgICAgICAgICBmb3IgKGogPSBpICsgMTsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChlcW5zW2krbmMqal0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbnAgPSBrcDtcbiAgICAgICAgICAgICAgICAgICAgZG8geyAgLy8gZG8gbGlnbmUoIGkgKSA9IGxpZ25lKCBpICkgKyBsaWduZSggayApXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYyppXSArPSBlcW5zW3ArbmMqal07XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcbiAgICAgICAgICAgICAgICBucCA9IGtwO1xuICAgICAgICAgICAgICAgIGRvIHsgIC8vIGRvIGxpZ25lKCBrICkgPSBsaWduZSggayApIC0gbXVsdGlwbGllciAqIGxpZ25lKCBpIClcbiAgICAgICAgICAgICAgICAgICAgcCA9IGtwIC0gbnA7XG4gICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYypqXSA9IHAgPD0gaSA/IDAgOiBlcW5zW3ArbmMqal0gLSBlcW5zW3ArbmMqaV0gKiBtdWx0aXBsaWVyIDtcbiAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW5wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAvLyBHZXQgdGhlIHNvbHV0aW9uXG4gICAgdGFyZ2V0LnogPSBlcW5zWzIqbmMrM10gLyBlcW5zWzIqbmMrMl07XG4gICAgdGFyZ2V0LnkgPSAoZXFuc1sxKm5jKzNdIC0gZXFuc1sxKm5jKzJdKnRhcmdldC56KSAvIGVxbnNbMSpuYysxXTtcbiAgICB0YXJnZXQueCA9IChlcW5zWzAqbmMrM10gLSBlcW5zWzAqbmMrMl0qdGFyZ2V0LnogLSBlcW5zWzAqbmMrMV0qdGFyZ2V0LnkpIC8gZXFuc1swKm5jKzBdO1xuXG4gICAgaWYoaXNOYU4odGFyZ2V0LngpIHx8IGlzTmFOKHRhcmdldC55KSB8fCBpc05hTih0YXJnZXQueikgfHwgdGFyZ2V0Lng9PT1JbmZpbml0eSB8fCB0YXJnZXQueT09PUluZmluaXR5IHx8IHRhcmdldC56PT09SW5maW5pdHkpe1xuICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBzb2x2ZSBlcXVhdGlvbiEgR290IHg9W1wiK3RhcmdldC50b1N0cmluZygpK1wiXSwgYj1bXCIrYi50b1N0cmluZygpK1wiXSwgQT1bXCIrdGhpcy50b1N0cmluZygpK1wiXVwiO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCBhbiBlbGVtZW50IGluIHRoZSBtYXRyaXggYnkgaW5kZXguIEluZGV4IHN0YXJ0cyBhdCAwLCBub3QgMSEhIVxuICogQG1ldGhvZCBlXG4gKiBAcGFyYW0ge051bWJlcn0gcm93XG4gKiBAcGFyYW0ge051bWJlcn0gY29sdW1uXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgT3B0aW9uYWwuIElmIHByb3ZpZGVkLCB0aGUgbWF0cml4IGVsZW1lbnQgd2lsbCBiZSBzZXQgdG8gdGhpcyB2YWx1ZS5cbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuTWF0My5wcm90b3R5cGUuZSA9IGZ1bmN0aW9uKCByb3cgLCBjb2x1bW4gLHZhbHVlKXtcbiAgICBpZih2YWx1ZT09PXVuZGVmaW5lZCl7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzW2NvbHVtbiszKnJvd107XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IHZhbHVlXG4gICAgICAgIHRoaXMuZWxlbWVudHNbY29sdW1uKzMqcm93XSA9IHZhbHVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29weSBhbm90aGVyIG1hdHJpeCBpbnRvIHRoaXMgbWF0cml4IG9iamVjdC5cbiAqIEBtZXRob2QgY29weVxuICogQHBhcmFtIHtNYXQzfSBzb3VyY2VcbiAqIEByZXR1cm4ge01hdDN9IHRoaXNcbiAqL1xuTWF0My5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gICAgZm9yKHZhciBpPTA7IGkgPCBzb3VyY2UuZWxlbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldID0gc291cmNlLmVsZW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4LlxuICogQG1ldGhvZCB0b1N0cmluZ1xuICogQHJldHVybiBzdHJpbmdcbiAqL1xuTWF0My5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpe1xuICAgIHZhciByID0gXCJcIjtcbiAgICB2YXIgc2VwID0gXCIsXCI7XG4gICAgZm9yKHZhciBpPTA7IGk8OTsgaSsrKXtcbiAgICAgICAgciArPSB0aGlzLmVsZW1lbnRzW2ldICsgc2VwO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbn07XG5cbi8qKlxuICogcmV2ZXJzZSB0aGUgbWF0cml4XG4gKiBAbWV0aG9kIHJldmVyc2VcbiAqIEBwYXJhbSB7TWF0M30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgbWF0cml4IHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtNYXQzfSBUaGUgc29sdXRpb24geFxuICovXG5NYXQzLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24odGFyZ2V0KXtcblxuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgTWF0MygpO1xuXG4gICAgLy8gQ29uc3RydWN0IGVxdWF0aW9uc1xuICAgIHZhciBuciA9IDM7IC8vIG51bSByb3dzXG4gICAgdmFyIG5jID0gNjsgLy8gbnVtIGNvbHNcbiAgICB2YXIgZXFucyA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPG5yKm5jOyBpKyspe1xuICAgICAgICBlcW5zLnB1c2goMCk7XG4gICAgfVxuICAgIHZhciBpLGo7XG4gICAgZm9yKGk9MDsgaTwzOyBpKyspe1xuICAgICAgICBmb3Ioaj0wOyBqPDM7IGorKyl7XG4gICAgICAgICAgICBlcW5zW2krbmMqal0gPSB0aGlzLmVsZW1lbnRzW2krMypqXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcW5zWzMrNiowXSA9IDE7XG4gICAgZXFuc1szKzYqMV0gPSAwO1xuICAgIGVxbnNbMys2KjJdID0gMDtcbiAgICBlcW5zWzQrNiowXSA9IDA7XG4gICAgZXFuc1s0KzYqMV0gPSAxO1xuICAgIGVxbnNbNCs2KjJdID0gMDtcbiAgICBlcW5zWzUrNiowXSA9IDA7XG4gICAgZXFuc1s1KzYqMV0gPSAwO1xuICAgIGVxbnNbNSs2KjJdID0gMTtcblxuICAgIC8vIENvbXB1dGUgcmlnaHQgdXBwZXIgdHJpYW5ndWxhciB2ZXJzaW9uIG9mIHRoZSBtYXRyaXggLSBHYXVzcyBlbGltaW5hdGlvblxuICAgIHZhciBuID0gMywgayA9IG4sIG5wO1xuICAgIHZhciBrcCA9IG5jOyAvLyBudW0gcm93c1xuICAgIHZhciBwO1xuICAgIGRvIHtcbiAgICAgICAgaSA9IGsgLSBuO1xuICAgICAgICBpZiAoZXFuc1tpK25jKmldID09PSAwKSB7XG4gICAgICAgICAgICAvLyB0aGUgcGl2b3QgaXMgbnVsbCwgc3dhcCBsaW5lc1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZXFuc1tpK25jKmpdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5wID0ga3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHsgLy8gZG8gbGluZSggaSApID0gbGluZSggaSApICsgbGluZSggayApXG4gICAgICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVxbnNbcCtuYyppXSArPSBlcW5zW3ArbmMqal07XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVxbnNbaStuYyppXSAhPT0gMCkge1xuICAgICAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcbiAgICAgICAgICAgICAgICBucCA9IGtwO1xuICAgICAgICAgICAgICAgIGRvIHsgLy8gZG8gbGluZSggayApID0gbGluZSggayApIC0gbXVsdGlwbGllciAqIGxpbmUoIGkgKVxuICAgICAgICAgICAgICAgICAgICBwID0ga3AgLSBucDtcbiAgICAgICAgICAgICAgICAgICAgZXFuc1twK25jKmpdID0gcCA8PSBpID8gMCA6IGVxbnNbcCtuYypqXSAtIGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xuICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB3aGlsZSAoLS1uKTtcblxuICAgIC8vIGVsaW1pbmF0ZSB0aGUgdXBwZXIgbGVmdCB0cmlhbmdsZSBvZiB0aGUgbWF0cml4XG4gICAgaSA9IDI7XG4gICAgZG8ge1xuICAgICAgICBqID0gaS0xO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICB2YXIgbXVsdGlwbGllciA9IGVxbnNbaStuYypqXSAvIGVxbnNbaStuYyppXTtcbiAgICAgICAgICAgIG5wID0gbmM7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcCA9IG5jIC0gbnA7XG4gICAgICAgICAgICAgICAgZXFuc1twK25jKmpdID0gIGVxbnNbcCtuYypqXSAtIGVxbnNbcCtuYyppXSAqIG11bHRpcGxpZXIgO1xuICAgICAgICAgICAgfSB3aGlsZSAoLS1ucCk7XG4gICAgICAgIH0gd2hpbGUgKGotLSk7XG4gICAgfSB3aGlsZSAoLS1pKTtcblxuICAgIC8vIG9wZXJhdGlvbnMgb24gdGhlIGRpYWdvbmFsXG4gICAgaSA9IDI7XG4gICAgZG8ge1xuICAgICAgICB2YXIgbXVsdGlwbGllciA9IDEgLyBlcW5zW2krbmMqaV07XG4gICAgICAgIG5wID0gbmM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHAgPSBuYyAtIG5wO1xuICAgICAgICAgICAgZXFuc1twK25jKmldID0gZXFuc1twK25jKmldICogbXVsdGlwbGllciA7XG4gICAgICAgIH0gd2hpbGUgKC0tbnApO1xuICAgIH0gd2hpbGUgKGktLSk7XG5cbiAgICBpID0gMjtcbiAgICBkbyB7XG4gICAgICAgIGogPSAyO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBwID0gZXFuc1tucitqK25jKmldO1xuICAgICAgICAgICAgaWYoIGlzTmFOKCBwICkgfHwgcCA9PT1JbmZpbml0eSApe1xuICAgICAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHJldmVyc2UhIEE9W1wiK3RoaXMudG9TdHJpbmcoKStcIl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldC5lKCBpICwgaiAsIHAgKTtcbiAgICAgICAgfSB3aGlsZSAoai0tKTtcbiAgICB9IHdoaWxlIChpLS0pO1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXRyaXggZnJvbSBhIHF1YXRlcmlvblxuICogQG1ldGhvZCBzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAqL1xuTWF0My5wcm90b3R5cGUuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiA9IGZ1bmN0aW9uKCBxICkge1xuICAgIHZhciB4ID0gcS54LCB5ID0gcS55LCB6ID0gcS56LCB3ID0gcS53LFxuICAgICAgICB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6LFxuICAgICAgICB4eCA9IHggKiB4MiwgeHkgPSB4ICogeTIsIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MiwgeXogPSB5ICogejIsIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyLFxuICAgICAgICBlID0gdGhpcy5lbGVtZW50cztcblxuICAgIGVbMyowICsgMF0gPSAxIC0gKCB5eSArIHp6ICk7XG4gICAgZVszKjAgKyAxXSA9IHh5IC0gd3o7XG4gICAgZVszKjAgKyAyXSA9IHh6ICsgd3k7XG5cbiAgICBlWzMqMSArIDBdID0geHkgKyB3ejtcbiAgICBlWzMqMSArIDFdID0gMSAtICggeHggKyB6eiApO1xuICAgIGVbMyoxICsgMl0gPSB5eiAtIHd4O1xuXG4gICAgZVszKjIgKyAwXSA9IHh6IC0gd3k7XG4gICAgZVszKjIgKyAxXSA9IHl6ICsgd3g7XG4gICAgZVszKjIgKyAyXSA9IDEgLSAoIHh4ICsgeXkgKTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIG1hdHJpeFxuICogQG1ldGhvZCB0cmFuc3Bvc2VcbiAqIEBwYXJhbSAge01hdDN9IHRhcmdldCBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0LlxuICogQHJldHVybiB7TWF0M30gVGhlIHRhcmdldCBNYXQzLCBvciBhIG5ldyBNYXQzIGlmIHRhcmdldCB3YXMgb21pdHRlZC5cbiAqL1xuTWF0My5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24oIHRhcmdldCApIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IE1hdDMoKTtcblxuICAgIHZhciBNdCA9IHRhcmdldC5lbGVtZW50cyxcbiAgICAgICAgTSA9IHRoaXMuZWxlbWVudHM7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PTM7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqIT09MzsgaisrKXtcbiAgICAgICAgICAgIE10WzMqaSArIGpdID0gTVszKmogKyBpXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG59LHtcIi4vVmVjM1wiOjMwfV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBRdWF0ZXJuaW9uO1xuXG52YXIgVmVjMyA9IF9kZXJlcV8oJy4vVmVjMycpO1xuXG4vKipcbiAqIEEgUXVhdGVybmlvbiBkZXNjcmliZXMgYSByb3RhdGlvbiBpbiAzRCBzcGFjZS4gVGhlIFF1YXRlcm5pb24gaXMgbWF0aGVtYXRpY2FsbHkgZGVmaW5lZCBhcyBRID0geCppICsgeSpqICsgeiprICsgdywgd2hlcmUgKGksaixrKSBhcmUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvcnMuICh4LHkseikgY2FuIGJlIHNlZW4gYXMgYSB2ZWN0b3IgcmVsYXRlZCB0byB0aGUgYXhpcyBvZiByb3RhdGlvbiwgd2hpbGUgdGhlIHJlYWwgbXVsdGlwbGllciwgdywgaXMgcmVsYXRlZCB0byB0aGUgYW1vdW50IG9mIHJvdGF0aW9uLlxuICogQGNsYXNzIFF1YXRlcm5pb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBqLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogTXVsdGlwbGllciBvZiB0aGUgaW1hZ2luYXJ5IGJhc2lzIHZlY3RvciBrLlxuICogQHBhcmFtIHtOdW1iZXJ9IHcgTXVsdGlwbGllciBvZiB0aGUgcmVhbCBwYXJ0LlxuICogQHNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1YXRlcm5pb25cbiAqL1xuZnVuY3Rpb24gUXVhdGVybmlvbih4LHkseix3KXtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0geFxuICAgICAqL1xuICAgIHRoaXMueCA9IHghPT11bmRlZmluZWQgPyB4IDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSB5XG4gICAgICovXG4gICAgdGhpcy55ID0geSE9PXVuZGVmaW5lZCA/IHkgOiAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IHpcbiAgICAgKi9cbiAgICB0aGlzLnogPSB6IT09dW5kZWZpbmVkID8geiA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbXVsdGlwbGllciBvZiB0aGUgcmVhbCBxdWF0ZXJuaW9uIGJhc2lzIHZlY3Rvci5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gd1xuICAgICAqL1xuICAgIHRoaXMudyA9IHchPT11bmRlZmluZWQgPyB3IDogMTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBxdWF0ZXJuaW9uLlxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHBhcmFtIHtOdW1iZXJ9IHpcbiAqIEBwYXJhbSB7TnVtYmVyfSB3XG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKHgseSx6LHcpe1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHRoaXMudyA9IHc7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdG8gYSByZWFkYWJsZSBmb3JtYXRcbiAqIEBtZXRob2QgdG9TdHJpbmdcbiAqIEByZXR1cm4gc3RyaW5nXG4gKi9cblF1YXRlcm5pb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy54K1wiLFwiK3RoaXMueStcIixcIit0aGlzLnorXCIsXCIrdGhpcy53O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGFuIEFycmF5XG4gKiBAbWV0aG9kIHRvQXJyYXlcbiAqIEByZXR1cm4gQXJyYXlcbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIFt0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLnddO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHF1YXRlcm5pb24gY29tcG9uZW50cyBnaXZlbiBhbiBheGlzIGFuZCBhbiBhbmdsZS5cbiAqIEBtZXRob2Qgc2V0RnJvbUF4aXNBbmdsZVxuICogQHBhcmFtIHtWZWMzfSBheGlzXG4gKiBAcGFyYW0ge051bWJlcn0gYW5nbGUgaW4gcmFkaWFuc1xuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tQXhpc0FuZ2xlID0gZnVuY3Rpb24oYXhpcyxhbmdsZSl7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihhbmdsZSowLjUpO1xuICAgIHRoaXMueCA9IGF4aXMueCAqIHM7XG4gICAgdGhpcy55ID0gYXhpcy55ICogcztcbiAgICB0aGlzLnogPSBheGlzLnogKiBzO1xuICAgIHRoaXMudyA9IE1hdGguY29zKGFuZ2xlKjAuNSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoZSBxdWF0ZXJuaW9uIHRvIGF4aXMvYW5nbGUgcmVwcmVzZW50YXRpb24uXG4gKiBAbWV0aG9kIHRvQXhpc0FuZ2xlXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldEF4aXMgT3B0aW9uYWwuIEEgdmVjdG9yIG9iamVjdCB0byByZXVzZSBmb3Igc3RvcmluZyB0aGUgYXhpcy5cbiAqIEByZXR1cm4gQXJyYXkgQW4gYXJyYXksIGZpcnN0IGVsZW1udCBpcyB0aGUgYXhpcyBhbmQgdGhlIHNlY29uZCBpcyB0aGUgYW5nbGUgaW4gcmFkaWFucy5cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudG9BeGlzQW5nbGUgPSBmdW5jdGlvbih0YXJnZXRBeGlzKXtcbiAgICB0YXJnZXRBeGlzID0gdGFyZ2V0QXhpcyB8fCBuZXcgVmVjMygpO1xuICAgIHRoaXMubm9ybWFsaXplKCk7IC8vIGlmIHc+MSBhY29zIGFuZCBzcXJ0IHdpbGwgcHJvZHVjZSBlcnJvcnMsIHRoaXMgY2FudCBoYXBwZW4gaWYgcXVhdGVybmlvbiBpcyBub3JtYWxpc2VkXG4gICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguYWNvcyh0aGlzLncpO1xuICAgIHZhciBzID0gTWF0aC5zcXJ0KDEtdGhpcy53KnRoaXMudyk7IC8vIGFzc3VtaW5nIHF1YXRlcm5pb24gbm9ybWFsaXNlZCB0aGVuIHcgaXMgbGVzcyB0aGFuIDEsIHNvIHRlcm0gYWx3YXlzIHBvc2l0aXZlLlxuICAgIGlmIChzIDwgMC4wMDEpIHsgLy8gdGVzdCB0byBhdm9pZCBkaXZpZGUgYnkgemVybywgcyBpcyBhbHdheXMgcG9zaXRpdmUgZHVlIHRvIHNxcnRcbiAgICAgICAgLy8gaWYgcyBjbG9zZSB0byB6ZXJvIHRoZW4gZGlyZWN0aW9uIG9mIGF4aXMgbm90IGltcG9ydGFudFxuICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLng7IC8vIGlmIGl0IGlzIGltcG9ydGFudCB0aGF0IGF4aXMgaXMgbm9ybWFsaXNlZCB0aGVuIHJlcGxhY2Ugd2l0aCB4PTE7IHk9ej0wO1xuICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnk7XG4gICAgICAgIHRhcmdldEF4aXMueiA9IHRoaXMuejtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRBeGlzLnggPSB0aGlzLnggLyBzOyAvLyBub3JtYWxpc2UgYXhpc1xuICAgICAgICB0YXJnZXRBeGlzLnkgPSB0aGlzLnkgLyBzO1xuICAgICAgICB0YXJnZXRBeGlzLnogPSB0aGlzLnogLyBzO1xuICAgIH1cbiAgICByZXR1cm4gW3RhcmdldEF4aXMsYW5nbGVdO1xufTtcblxudmFyIHNmdl90MSA9IG5ldyBWZWMzKCksXG4gICAgc2Z2X3QyID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTZXQgdGhlIHF1YXRlcm5pb24gdmFsdWUgZ2l2ZW4gdHdvIHZlY3RvcnMuIFRoZSByZXN1bHRpbmcgcm90YXRpb24gd2lsbCBiZSB0aGUgbmVlZGVkIHJvdGF0aW9uIHRvIHJvdGF0ZSB1IHRvIHYuXG4gKiBAbWV0aG9kIHNldEZyb21WZWN0b3JzXG4gKiBAcGFyYW0ge1ZlYzN9IHVcbiAqIEBwYXJhbSB7VmVjM30gdlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tVmVjdG9ycyA9IGZ1bmN0aW9uKHUsdil7XG4gICAgaWYodS5pc0FudGlwYXJhbGxlbFRvKHYpKXtcbiAgICAgICAgdmFyIHQxID0gc2Z2X3QxO1xuICAgICAgICB2YXIgdDIgPSBzZnZfdDI7XG5cbiAgICAgICAgdS50YW5nZW50cyh0MSx0Mik7XG4gICAgICAgIHRoaXMuc2V0RnJvbUF4aXNBbmdsZSh0MSxNYXRoLlBJKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYSA9IHUuY3Jvc3Modik7XG4gICAgICAgIHRoaXMueCA9IGEueDtcbiAgICAgICAgdGhpcy55ID0gYS55O1xuICAgICAgICB0aGlzLnogPSBhLno7XG4gICAgICAgIHRoaXMudyA9IE1hdGguc3FydChNYXRoLnBvdyh1Lm5vcm0oKSwyKSAqIE1hdGgucG93KHYubm9ybSgpLDIpKSArIHUuZG90KHYpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUXVhdGVybmlvbiBtdWx0aXBsaWNhdGlvblxuICogQG1ldGhvZCBtdWx0XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHFcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gdGFyZ2V0IE9wdGlvbmFsLlxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xudmFyIFF1YXRlcm5pb25fbXVsdF92YSA9IG5ldyBWZWMzKCk7XG52YXIgUXVhdGVybmlvbl9tdWx0X3ZiID0gbmV3IFZlYzMoKTtcbnZhciBRdWF0ZXJuaW9uX211bHRfdmF4dmIgPSBuZXcgVmVjMygpO1xuUXVhdGVybmlvbi5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uKHEsdGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcbiAgICB2YXIgdyA9IHRoaXMudyxcbiAgICAgICAgdmEgPSBRdWF0ZXJuaW9uX211bHRfdmEsXG4gICAgICAgIHZiID0gUXVhdGVybmlvbl9tdWx0X3ZiLFxuICAgICAgICB2YXh2YiA9IFF1YXRlcm5pb25fbXVsdF92YXh2YjtcblxuICAgIHZhLnNldCh0aGlzLngsdGhpcy55LHRoaXMueik7XG4gICAgdmIuc2V0KHEueCxxLnkscS56KTtcbiAgICB0YXJnZXQudyA9IHcqcS53IC0gdmEuZG90KHZiKTtcbiAgICB2YS5jcm9zcyh2Yix2YXh2Yik7XG5cbiAgICB0YXJnZXQueCA9IHcgKiB2Yi54ICsgcS53KnZhLnggKyB2YXh2Yi54O1xuICAgIHRhcmdldC55ID0gdyAqIHZiLnkgKyBxLncqdmEueSArIHZheHZiLnk7XG4gICAgdGFyZ2V0LnogPSB3ICogdmIueiArIHEudyp2YS56ICsgdmF4dmIuejtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgaW52ZXJzZSBxdWF0ZXJuaW9uIHJvdGF0aW9uLlxuICogQG1ldGhvZCBpbnZlcnNlXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldFxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICB0aGlzLmNvbmp1Z2F0ZSh0YXJnZXQpO1xuICAgIHZhciBpbm9ybTIgPSAxLyh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xuICAgIHRhcmdldC54ICo9IGlub3JtMjtcbiAgICB0YXJnZXQueSAqPSBpbm9ybTI7XG4gICAgdGFyZ2V0LnogKj0gaW5vcm0yO1xuICAgIHRhcmdldC53ICo9IGlub3JtMjtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgcXVhdGVybmlvbiBjb25qdWdhdGVcbiAqIEBtZXRob2QgY29uanVnYXRlXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHRhcmdldFxuICogQHJldHVybiB7UXVhdGVybmlvbn1cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIHRhcmdldC54ID0gLXRoaXMueDtcbiAgICB0YXJnZXQueSA9IC10aGlzLnk7XG4gICAgdGFyZ2V0LnogPSAtdGhpcy56O1xuICAgIHRhcmdldC53ID0gdGhpcy53O1xuXG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgb2YgdGhlIHF1YXRlcm5pb24uXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZVxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBsID0gTWF0aC5zcXJ0KHRoaXMueCp0aGlzLngrdGhpcy55KnRoaXMueSt0aGlzLnoqdGhpcy56K3RoaXMudyp0aGlzLncpO1xuICAgIGlmICggbCA9PT0gMCApIHtcbiAgICAgICAgdGhpcy54ID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcbiAgICAgICAgdGhpcy56ID0gMDtcbiAgICAgICAgdGhpcy53ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsID0gMSAvIGw7XG4gICAgICAgIHRoaXMueCAqPSBsO1xuICAgICAgICB0aGlzLnkgKj0gbDtcbiAgICAgICAgdGhpcy56ICo9IGw7XG4gICAgICAgIHRoaXMudyAqPSBsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQXBwcm94aW1hdGlvbiBvZiBxdWF0ZXJuaW9uIG5vcm1hbGl6YXRpb24uIFdvcmtzIGJlc3Qgd2hlbiBxdWF0IGlzIGFscmVhZHkgYWxtb3N0LW5vcm1hbGl6ZWQuXG4gKiBAbWV0aG9kIG5vcm1hbGl6ZUZhc3RcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vZmFzdC1xdWF0ZXJuaW9uLW5vcm1hbGl6YXRpb25cbiAqIEBhdXRob3IgdW5waGFzZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS91bnBoYXNlZFxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5ub3JtYWxpemVGYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmID0gKDMuMC0odGhpcy54KnRoaXMueCt0aGlzLnkqdGhpcy55K3RoaXMueip0aGlzLnordGhpcy53KnRoaXMudykpLzIuMDtcbiAgICBpZiAoIGYgPT09IDAgKSB7XG4gICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG4gICAgICAgIHRoaXMueiA9IDA7XG4gICAgICAgIHRoaXMudyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54ICo9IGY7XG4gICAgICAgIHRoaXMueSAqPSBmO1xuICAgICAgICB0aGlzLnogKj0gZjtcbiAgICAgICAgdGhpcy53ICo9IGY7XG4gICAgfVxufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGUgcXVhdGVybmlvbiBieSBhIHZlY3RvclxuICogQG1ldGhvZCB2bXVsdFxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuUXVhdGVybmlvbi5wcm90b3R5cGUudm11bHQgPSBmdW5jdGlvbih2LHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgeCA9IHYueCxcbiAgICAgICAgeSA9IHYueSxcbiAgICAgICAgeiA9IHYuejtcblxuICAgIHZhciBxeCA9IHRoaXMueCxcbiAgICAgICAgcXkgPSB0aGlzLnksXG4gICAgICAgIHF6ID0gdGhpcy56LFxuICAgICAgICBxdyA9IHRoaXMudztcblxuICAgIC8vIHEqdlxuICAgIHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgaXkgPSAgcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XG5cbiAgICB0YXJnZXQueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgdGFyZ2V0LnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xuICAgIHRhcmdldC56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyBxdWF0ZXJuaW9uLlxuICogQG1ldGhvZCBjb3B5XG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHNvdXJjZVxuICogQHJldHVybiB7UXVhdGVybmlvbn0gdGhpc1xuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24oc291cmNlKXtcbiAgICB0aGlzLnggPSBzb3VyY2UueDtcbiAgICB0aGlzLnkgPSBzb3VyY2UueTtcbiAgICB0aGlzLnogPSBzb3VyY2UuejtcbiAgICB0aGlzLncgPSBzb3VyY2UudztcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcXVhdGVybmlvbiB0byBldWxlciBhbmdsZSByZXByZXNlbnRhdGlvbi4gT3JkZXI6IFlaWCwgYXMgdGhpcyBwYWdlIGRlc2NyaWJlczogaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvc3RhbmRhcmRzL2luZGV4Lmh0bVxuICogQG1ldGhvZCB0b0V1bGVyXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICogQHBhcmFtIHN0cmluZyBvcmRlciBUaHJlZS1jaGFyYWN0ZXIgc3RyaW5nIGUuZy4gXCJZWlhcIiwgd2hpY2ggYWxzbyBpcyBkZWZhdWx0LlxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS50b0V1bGVyID0gZnVuY3Rpb24odGFyZ2V0LG9yZGVyKXtcbiAgICBvcmRlciA9IG9yZGVyIHx8IFwiWVpYXCI7XG5cbiAgICB2YXIgaGVhZGluZywgYXR0aXR1ZGUsIGJhbms7XG4gICAgdmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XG5cbiAgICBzd2l0Y2gob3JkZXIpe1xuICAgIGNhc2UgXCJZWlhcIjpcbiAgICAgICAgdmFyIHRlc3QgPSB4KnkgKyB6Knc7XG4gICAgICAgIGlmICh0ZXN0ID4gMC40OTkpIHsgLy8gc2luZ3VsYXJpdHkgYXQgbm9ydGggcG9sZVxuICAgICAgICAgICAgaGVhZGluZyA9IDIgKiBNYXRoLmF0YW4yKHgsdyk7XG4gICAgICAgICAgICBhdHRpdHVkZSA9IE1hdGguUEkvMjtcbiAgICAgICAgICAgIGJhbmsgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0ZXN0IDwgLTAuNDk5KSB7IC8vIHNpbmd1bGFyaXR5IGF0IHNvdXRoIHBvbGVcbiAgICAgICAgICAgIGhlYWRpbmcgPSAtMiAqIE1hdGguYXRhbjIoeCx3KTtcbiAgICAgICAgICAgIGF0dGl0dWRlID0gLSBNYXRoLlBJLzI7XG4gICAgICAgICAgICBiYW5rID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZihpc05hTihoZWFkaW5nKSl7XG4gICAgICAgICAgICB2YXIgc3F4ID0geCp4O1xuICAgICAgICAgICAgdmFyIHNxeSA9IHkqeTtcbiAgICAgICAgICAgIHZhciBzcXogPSB6Kno7XG4gICAgICAgICAgICBoZWFkaW5nID0gTWF0aC5hdGFuMigyKnkqdyAtIDIqeCp6ICwgMSAtIDIqc3F5IC0gMipzcXopOyAvLyBIZWFkaW5nXG4gICAgICAgICAgICBhdHRpdHVkZSA9IE1hdGguYXNpbigyKnRlc3QpOyAvLyBhdHRpdHVkZVxuICAgICAgICAgICAgYmFuayA9IE1hdGguYXRhbjIoMip4KncgLSAyKnkqeiAsIDEgLSAyKnNxeCAtIDIqc3F6KTsgLy8gYmFua1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV1bGVyIG9yZGVyIFwiK29yZGVyK1wiIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcbiAgICB9XG5cbiAgICB0YXJnZXQueSA9IGhlYWRpbmc7XG4gICAgdGFyZ2V0LnogPSBhdHRpdHVkZTtcbiAgICB0YXJnZXQueCA9IGJhbms7XG59O1xuXG4vKipcbiAqIFNlZSBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvMjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvY29udGVudC9TcGluQ2FsYy5tXG4gKiBAbWV0aG9kIHNldEZyb21FdWxlclxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcGFyYW0ge051bWJlcn0gelxuICogQHBhcmFtIHtTdHJpbmd9IG9yZGVyIFRoZSBvcmRlciB0byBhcHBseSBhbmdsZXM6ICdYWVonIG9yICdZWFonIG9yIGFueSBvdGhlciBjb21iaW5hdGlvblxuICovXG5RdWF0ZXJuaW9uLnByb3RvdHlwZS5zZXRGcm9tRXVsZXIgPSBmdW5jdGlvbiAoIHgsIHksIHosIG9yZGVyICkge1xuICAgIG9yZGVyID0gb3JkZXIgfHwgXCJYWVpcIjtcblxuICAgIHZhciBjMSA9IE1hdGguY29zKCB4IC8gMiApO1xuICAgIHZhciBjMiA9IE1hdGguY29zKCB5IC8gMiApO1xuICAgIHZhciBjMyA9IE1hdGguY29zKCB6IC8gMiApO1xuICAgIHZhciBzMSA9IE1hdGguc2luKCB4IC8gMiApO1xuICAgIHZhciBzMiA9IE1hdGguc2luKCB5IC8gMiApO1xuICAgIHZhciBzMyA9IE1hdGguc2luKCB6IC8gMiApO1xuXG4gICAgaWYgKCBvcmRlciA9PT0gJ1hZWicgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XG4gICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcbiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xuXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcblxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XG5cbiAgICB9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XG5cbiAgICAgICAgdGhpcy54ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xuICAgICAgICB0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XG4gICAgICAgIHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcbiAgICAgICAgdGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xuXG4gICAgfSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xuXG4gICAgICAgIHRoaXMueCA9IHMxICogYzIgKiBjMyArIGMxICogczIgKiBzMztcbiAgICAgICAgdGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xuICAgICAgICB0aGlzLnogPSBjMSAqIGMyICogczMgLSBzMSAqIHMyICogYzM7XG4gICAgICAgIHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcblxuICAgIH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcblxuICAgICAgICB0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XG4gICAgICAgIHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcbiAgICAgICAgdGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xuICAgICAgICB0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcblxufTtcblxuUXVhdGVybmlvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBuZXcgUXVhdGVybmlvbih0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncpO1xufTtcbn0se1wiLi9WZWMzXCI6MzB9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4vVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuL1F1YXRlcm5pb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbi8qKlxuICogQGNsYXNzIFRyYW5zZm9ybVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0LyoqXG5cdCAqIEBwcm9wZXJ0eSB7VmVjM30gcG9zaXRpb25cblx0ICovXG5cdHRoaXMucG9zaXRpb24gPSBuZXcgVmVjMygpO1xuICAgIGlmKG9wdGlvbnMucG9zaXRpb24pe1xuICAgICAgICB0aGlzLnBvc2l0aW9uLmNvcHkob3B0aW9ucy5wb3NpdGlvbik7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAcHJvcGVydHkge1F1YXRlcm5pb259IHF1YXRlcm5pb25cblx0ICovXG5cdHRoaXMucXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgaWYob3B0aW9ucy5xdWF0ZXJuaW9uKXtcbiAgICAgICAgdGhpcy5xdWF0ZXJuaW9uLmNvcHkob3B0aW9ucy5xdWF0ZXJuaW9uKTtcbiAgICB9XG59XG5cbnZhciB0bXBRdWF0ID0gbmV3IFF1YXRlcm5pb24oKTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhRnJhbWVcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdGVybmlvblxuICogQHBhcmFtIHtWZWMzfSB3b3JsZFBvaW50XG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdFxuICovXG5UcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcXVhdGVybmlvbiwgd29ybGRQb2ludCwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgd29ybGRQb2ludC52c3ViKHBvc2l0aW9uLCByZXN1bHQpO1xuICAgIHF1YXRlcm5pb24uY29uanVnYXRlKHRtcFF1YXQpO1xuICAgIHRtcFF1YXQudm11bHQocmVzdWx0LCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBhIGdsb2JhbCBwb2ludCBpbiBsb2NhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhbFxuICogQHBhcmFtICB7VmVjM30gcG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM30gVGhlIFwicmVzdWx0XCIgdmVjdG9yIG9iamVjdFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnBvaW50VG9Mb2NhbCA9IGZ1bmN0aW9uKHdvcmxkUG9pbnQsIHJlc3VsdCl7XG4gICAgcmV0dXJuIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHdvcmxkUG9pbnQsIHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcG9pbnRUb1dvcmxkRnJhbWVcbiAqIEBwYXJhbSB7VmVjM30gcG9zaXRpb25cbiAqIEBwYXJhbSB7VmVjM30gcXVhdGVybmlvblxuICogQHBhcmFtIHtWZWMzfSBsb2NhbFBvaW50XG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdFxuICovXG5UcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcXVhdGVybmlvbiwgbG9jYWxQb2ludCwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgcXVhdGVybmlvbi52bXVsdChsb2NhbFBvaW50LCByZXN1bHQpO1xuICAgIHJlc3VsdC52YWRkKHBvc2l0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBhIGxvY2FsIHBvaW50IGluIGdsb2JhbCB0cmFuc2Zvcm0gY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHBvaW50VG9Xb3JsZFxuICogQHBhcmFtICB7VmVjM30gcG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM30gVGhlIFwicmVzdWx0XCIgdmVjdG9yIG9iamVjdFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnBvaW50VG9Xb3JsZCA9IGZ1bmN0aW9uKGxvY2FsUG9pbnQsIHJlc3VsdCl7XG4gICAgcmV0dXJuIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIGxvY2FsUG9pbnQsIHJlc3VsdCk7XG59O1xuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUudmVjdG9yVG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24obG9jYWxWZWN0b3IsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdChsb2NhbFZlY3RvciwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSA9IGZ1bmN0aW9uKHF1YXRlcm5pb24sIGxvY2FsVmVjdG9yLCByZXN1bHQpe1xuICAgIHF1YXRlcm5pb24udm11bHQobG9jYWxWZWN0b3IsIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblRyYW5zZm9ybS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbihwb3NpdGlvbiwgcXVhdGVybmlvbiwgd29ybGRWZWN0b3IsIHJlc3VsdCl7XG4gICAgdmFyIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgVmVjMygpO1xuICAgIHF1YXRlcm5pb24udyAqPSAtMTtcbiAgICBxdWF0ZXJuaW9uLnZtdWx0KHdvcmxkVmVjdG9yLCByZXN1bHQpO1xuICAgIHF1YXRlcm5pb24udyAqPSAtMTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuL1F1YXRlcm5pb25cIjoyOCxcIi4vVmVjM1wiOjMwfV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBWZWMzO1xuXG52YXIgTWF0MyA9IF9kZXJlcV8oJy4vTWF0MycpO1xuXG4vKipcbiAqIDMtZGltZW5zaW9uYWwgdmVjdG9yXG4gKiBAY2xhc3MgVmVjM1xuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciB2ID0gbmV3IFZlYzMoMSwgMiwgMyk7XG4gKiAgICAgY29uc29sZS5sb2coJ3g9JyArIHYueCk7IC8vIHg9MVxuICovXG5mdW5jdGlvbiBWZWMzKHgseSx6KXtcbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgeFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy54ID0geHx8MC4wO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHlcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMueSA9IHl8fDAuMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB6XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnogPSB6fHwwLjA7XG59XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtWZWMzfSBaRVJPXG4gKi9cblZlYzMuWkVSTyA9IG5ldyBWZWMzKDAsIDAsIDApO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB7VmVjM30gVU5JVF9YXG4gKi9cblZlYzMuVU5JVF9YID0gbmV3IFZlYzMoMSwgMCwgMCk7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IHtWZWMzfSBVTklUX1lcbiAqL1xuVmVjMy5VTklUX1kgPSBuZXcgVmVjMygwLCAxLCAwKTtcblxuLyoqXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkge1ZlYzN9IFVOSVRfWlxuICovXG5WZWMzLlVOSVRfWiA9IG5ldyBWZWMzKDAsIDAsIDEpO1xuXG4vKipcbiAqIFZlY3RvciBjcm9zcyBwcm9kdWN0XG4gKiBAbWV0aG9kIGNyb3NzXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLiBUYXJnZXQgdG8gc2F2ZSBpbi5cbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNyb3NzID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIHZhciB2eD12LngsIHZ5PXYueSwgdno9di56LCB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuXG4gICAgdGFyZ2V0LnggPSAoeSAqIHZ6KSAtICh6ICogdnkpO1xuICAgIHRhcmdldC55ID0gKHogKiB2eCkgLSAoeCAqIHZ6KTtcbiAgICB0YXJnZXQueiA9ICh4ICogdnkpIC0gKHkgKiB2eCk7XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHZlY3RvcnMnIDMgZWxlbWVudHNcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6XG4gKiBAcmV0dXJuIFZlYzNcbiAqL1xuVmVjMy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oeCx5LHope1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLnogPSB6O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXQgYWxsIGNvbXBvbmVudHMgb2YgdGhlIHZlY3RvciB0byB6ZXJvLlxuICogQG1ldGhvZCBzZXRaZXJvXG4gKi9cblZlYzMucHJvdG90eXBlLnNldFplcm8gPSBmdW5jdGlvbigpe1xuICAgIHRoaXMueCA9IHRoaXMueSA9IHRoaXMueiA9IDA7XG59O1xuXG4vKipcbiAqIFZlY3RvciBhZGRpdGlvblxuICogQG1ldGhvZCB2YWRkXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsLlxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjMy5wcm90b3R5cGUudmFkZCA9IGZ1bmN0aW9uKHYsdGFyZ2V0KXtcbiAgICBpZih0YXJnZXQpe1xuICAgICAgICB0YXJnZXQueCA9IHYueCArIHRoaXMueDtcbiAgICAgICAgdGFyZ2V0LnkgPSB2LnkgKyB0aGlzLnk7XG4gICAgICAgIHRhcmdldC56ID0gdi56ICsgdGhpcy56O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKyB2LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55ICsgdi55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiArIHYueik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBWZWN0b3Igc3VidHJhY3Rpb25cbiAqIEBtZXRob2QgdnN1YlxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBPcHRpb25hbC4gVGFyZ2V0IHRvIHNhdmUgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS52c3ViID0gZnVuY3Rpb24odix0YXJnZXQpe1xuICAgIGlmKHRhcmdldCl7XG4gICAgICAgIHRhcmdldC54ID0gdGhpcy54IC0gdi54O1xuICAgICAgICB0YXJnZXQueSA9IHRoaXMueSAtIHYueTtcbiAgICAgICAgdGFyZ2V0LnogPSB0aGlzLnogLSB2Lno7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueC12LngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy55LXYueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnotdi56KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY3Jvc3MgcHJvZHVjdCBtYXRyaXggYV9jcm9zcyBmcm9tIGEgdmVjdG9yLCBzdWNoIHRoYXQgYSB4IGIgPSBhX2Nyb3NzICogYiA9IGNcbiAqIEBtZXRob2QgY3Jvc3NtYXRcbiAqIEBzZWUgaHR0cDovL3d3dzguY3MudW11LnNlL2t1cnNlci9UREJEMjQvVlQwNi9sZWN0dXJlcy9MZWN0dXJlNi5wZGZcbiAqIEByZXR1cm4ge01hdDN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNyb3NzbWF0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IE1hdDMoWyAgICAgMCwgIC10aGlzLnosICAgdGhpcy55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueiwgICAgICAgIDAsICAtdGhpcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgLXRoaXMueSwgICB0aGlzLngsICAgICAgICAwXSk7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSB0aGUgdmVjdG9yLiBOb3RlIHRoYXQgdGhpcyBjaGFuZ2VzIHRoZSB2YWx1ZXMgaW4gdGhlIHZlY3Rvci5cbiAqIEBtZXRob2Qgbm9ybWFsaXplXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgdGhlIG5vcm0gb2YgdGhlIHZlY3RvclxuICovXG5WZWMzLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBuID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG4gICAgaWYobj4wLjApe1xuICAgICAgICB2YXIgaW52TiA9IDEvbjtcbiAgICAgICAgdGhpcy54ICo9IGludk47XG4gICAgICAgIHRoaXMueSAqPSBpbnZOO1xuICAgICAgICB0aGlzLnogKj0gaW52TjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYWtlIHNvbWV0aGluZyB1cFxuICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICB0aGlzLnkgPSAwO1xuICAgICAgICB0aGlzLnogPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn07XG5cbi8qKlxuICogR2V0IHRoZSB2ZXJzaW9uIG9mIHRoaXMgdmVjdG9yIHRoYXQgaXMgb2YgbGVuZ3RoIDEuXG4gKiBAbWV0aG9kIHVuaXRcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluXG4gKiBAcmV0dXJuIHtWZWMzfSBSZXR1cm5zIHRoZSB1bml0IHZlY3RvclxuICovXG5WZWMzLnByb3RvdHlwZS51bml0ID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICB2YXIgeD10aGlzLngsIHk9dGhpcy55LCB6PXRoaXMuejtcbiAgICB2YXIgbmludiA9IE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xuICAgIGlmKG5pbnY+MC4wKXtcbiAgICAgICAgbmludiA9IDEuMC9uaW52O1xuICAgICAgICB0YXJnZXQueCA9IHggKiBuaW52O1xuICAgICAgICB0YXJnZXQueSA9IHkgKiBuaW52O1xuICAgICAgICB0YXJnZXQueiA9IHogKiBuaW52O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC54ID0gMTtcbiAgICAgICAgdGFyZ2V0LnkgPSAwO1xuICAgICAgICB0YXJnZXQueiA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2Qgbm9ybVxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGRlcHJlY2F0ZWQgVXNlIC5sZW5ndGgoKSBpbnN0ZWFkXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm0gPSBmdW5jdGlvbigpe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvclxuICogQG1ldGhvZCBsZW5ndGhcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMy5wcm90b3R5cGUubGVuZ3RoID0gVmVjMy5wcm90b3R5cGUubm9ybTtcblxuLyoqXG4gKiBHZXQgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2Qgbm9ybTJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBkZXByZWNhdGVkIFVzZSAubGVuZ3RoU3F1YXJlZCgpIGluc3RlYWQuXG4gKi9cblZlYzMucHJvdG90eXBlLm5vcm0yID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5kb3QodGhpcyk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhlIHZlY3Rvci5cbiAqIEBtZXRob2QgbGVuZ3RoU3F1YXJlZFxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5WZWMzLnByb3RvdHlwZS5sZW5ndGhTcXVhcmVkID0gVmVjMy5wcm90b3R5cGUubm9ybTI7XG5cbi8qKlxuICogR2V0IGRpc3RhbmNlIGZyb20gdGhpcyBwb2ludCB0byBhbm90aGVyIHBvaW50XG4gKiBAbWV0aG9kIGRpc3RhbmNlVG9cbiAqIEBwYXJhbSAge1ZlYzN9IHBcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVmVjMy5wcm90b3R5cGUuZGlzdGFuY2VUbyA9IGZ1bmN0aW9uKHApe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBweD1wLngsIHB5PXAueSwgcHo9cC56O1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHB4LXgpKihweC14KStcbiAgICAgICAgICAgICAgICAgICAgIChweS15KSoocHkteSkrXG4gICAgICAgICAgICAgICAgICAgICAocHoteikqKHB6LXopKTtcbn07XG5cbi8qKlxuICogR2V0IHNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGlzIHBvaW50IHRvIGFub3RoZXIgcG9pbnRcbiAqIEBtZXRob2QgZGlzdGFuY2VTcXVhcmVkXG4gKiBAcGFyYW0gIHtWZWMzfSBwXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmRpc3RhbmNlU3F1YXJlZCA9IGZ1bmN0aW9uKHApe1xuICAgIHZhciB4PXRoaXMueCwgeT10aGlzLnksIHo9dGhpcy56O1xuICAgIHZhciBweD1wLngsIHB5PXAueSwgcHo9cC56O1xuICAgIHJldHVybiAocHgteCkqKHB4LXgpICsgKHB5LXkpKihweS15KSArIChwei16KSoocHoteik7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IGFsbCB0aGUgY29tcG9uZW50cyBvZiB0aGUgdmVjdG9yIHdpdGggYSBzY2FsYXIuXG4gKiBAZGVwcmVjYXRlZCBVc2UgLnNjYWxlIGluc3RlYWRcbiAqIEBtZXRob2QgbXVsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxhclxuICogQHBhcmFtIHtWZWMzfSB0YXJnZXQgVGhlIHZlY3RvciB0byBzYXZlIHRoZSByZXN1bHQgaW4uXG4gKiBAcmV0dXJuIHtWZWMzfVxuICogQGRlcHJlY2F0ZWQgVXNlIC5zY2FsZSgpIGluc3RlYWRcbiAqL1xuVmVjMy5wcm90b3R5cGUubXVsdCA9IGZ1bmN0aW9uKHNjYWxhcix0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciB4ID0gdGhpcy54LFxuICAgICAgICB5ID0gdGhpcy55LFxuICAgICAgICB6ID0gdGhpcy56O1xuICAgIHRhcmdldC54ID0gc2NhbGFyICogeDtcbiAgICB0YXJnZXQueSA9IHNjYWxhciAqIHk7XG4gICAgdGFyZ2V0LnogPSBzY2FsYXIgKiB6O1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoZSB2ZWN0b3Igd2l0aCBhIHNjYWxhci5cbiAqIEBtZXRob2Qgc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsYXJcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS5zY2FsZSA9IFZlYzMucHJvdG90eXBlLm11bHQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlIGRvdCBwcm9kdWN0XG4gKiBAbWV0aG9kIGRvdFxuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblZlYzMucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKHYpe1xuICAgIHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2Lno7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgaXNaZXJvXG4gKiBAcmV0dXJuIGJvb2xcbiAqL1xuVmVjMy5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy54PT09MCAmJiB0aGlzLnk9PT0wICYmIHRoaXMuej09PTA7XG59O1xuXG4vKipcbiAqIE1ha2UgdGhlIHZlY3RvciBwb2ludCBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLlxuICogQG1ldGhvZCBuZWdhdGVcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0IE9wdGlvbmFsIHRhcmdldCB0byBzYXZlIGluXG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5WZWMzLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHRhcmdldC54ID0gLXRoaXMueDtcbiAgICB0YXJnZXQueSA9IC10aGlzLnk7XG4gICAgdGFyZ2V0LnogPSAtdGhpcy56O1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdHdvIGFydGlmaWNpYWwgdGFuZ2VudHMgdG8gdGhlIHZlY3RvclxuICogQG1ldGhvZCB0YW5nZW50c1xuICogQHBhcmFtIHtWZWMzfSB0MSBWZWN0b3Igb2JqZWN0IHRvIHNhdmUgdGhlIGZpcnN0IHRhbmdlbnQgaW5cbiAqIEBwYXJhbSB7VmVjM30gdDIgVmVjdG9yIG9iamVjdCB0byBzYXZlIHRoZSBzZWNvbmQgdGFuZ2VudCBpblxuICovXG52YXIgVmVjM190YW5nZW50c19uID0gbmV3IFZlYzMoKTtcbnZhciBWZWMzX3RhbmdlbnRzX3JhbmRWZWMgPSBuZXcgVmVjMygpO1xuVmVjMy5wcm90b3R5cGUudGFuZ2VudHMgPSBmdW5jdGlvbih0MSx0Mil7XG4gICAgdmFyIG5vcm0gPSB0aGlzLm5vcm0oKTtcbiAgICBpZihub3JtPjAuMCl7XG4gICAgICAgIHZhciBuID0gVmVjM190YW5nZW50c19uO1xuICAgICAgICB2YXIgaW5vcm0gPSAxL25vcm07XG4gICAgICAgIG4uc2V0KHRoaXMueCppbm9ybSx0aGlzLnkqaW5vcm0sdGhpcy56Kmlub3JtKTtcbiAgICAgICAgdmFyIHJhbmRWZWMgPSBWZWMzX3RhbmdlbnRzX3JhbmRWZWM7XG4gICAgICAgIGlmKE1hdGguYWJzKG4ueCkgPCAwLjkpe1xuICAgICAgICAgICAgcmFuZFZlYy5zZXQoMSwwLDApO1xuICAgICAgICAgICAgbi5jcm9zcyhyYW5kVmVjLHQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJhbmRWZWMuc2V0KDAsMSwwKTtcbiAgICAgICAgICAgIG4uY3Jvc3MocmFuZFZlYyx0MSk7XG4gICAgICAgIH1cbiAgICAgICAgbi5jcm9zcyh0MSx0Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIG5vcm1hbCBsZW5ndGggaXMgemVybywgbWFrZSBzb21ldGhpbmcgdXBcbiAgICAgICAgdDEuc2V0KDEsIDAsIDApO1xuICAgICAgICB0Mi5zZXQoMCwgMSwgMCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhIG1vcmUgcmVhZGFibGUgZm9ybWF0XG4gKiBAbWV0aG9kIHRvU3RyaW5nXG4gKiBAcmV0dXJuIHN0cmluZ1xuICovXG5WZWMzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMueCtcIixcIit0aGlzLnkrXCIsXCIrdGhpcy56O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyB0byBhbiBhcnJheVxuICogQG1ldGhvZCB0b0FycmF5XG4gKiBAcmV0dXJuIEFycmF5XG4gKi9cblZlYzMucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBbdGhpcy54LCB0aGlzLnksIHRoaXMuel07XG59O1xuXG4vKipcbiAqIENvcGllcyB2YWx1ZSBvZiBzb3VyY2UgdG8gdGhpcyB2ZWN0b3IuXG4gKiBAbWV0aG9kIGNvcHlcbiAqIEBwYXJhbSB7VmVjM30gc291cmNlXG4gKiBAcmV0dXJuIHtWZWMzfSB0aGlzXG4gKi9cblZlYzMucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIHRoaXMueCA9IHNvdXJjZS54O1xuICAgIHRoaXMueSA9IHNvdXJjZS55O1xuICAgIHRoaXMueiA9IHNvdXJjZS56O1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIERvIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjdG9yc1xuICogQG1ldGhvZCBsZXJwXG4gKiBAcGFyYW0ge1ZlYzN9IHZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gMCB3aWxsIG1ha2UgdGhpcyBmdW5jdGlvbiByZXR1cm4gdSwgYW5kIDEgd2lsbCBtYWtlIGl0IHJldHVybiB2LiBOdW1iZXJzIGluIGJldHdlZW4gd2lsbCBnZW5lcmF0ZSBhIHZlY3RvciBpbiBiZXR3ZWVuIHRoZW0uXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICovXG5WZWMzLnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24odix0LHRhcmdldCl7XG4gICAgdmFyIHg9dGhpcy54LCB5PXRoaXMueSwgej10aGlzLno7XG4gICAgdGFyZ2V0LnggPSB4ICsgKHYueC14KSp0O1xuICAgIHRhcmdldC55ID0geSArICh2LnkteSkqdDtcbiAgICB0YXJnZXQueiA9IHogKyAodi56LXopKnQ7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmVjdG9yIGVxdWFscyBpcyBhbG1vc3QgZXF1YWwgdG8gYW5vdGhlciBvbmUuXG4gKiBAbWV0aG9kIGFsbW9zdEVxdWFsc1xuICogQHBhcmFtIHtWZWMzfSB2XG4gKiBAcGFyYW0ge051bWJlcn0gcHJlY2lzaW9uXG4gKiBAcmV0dXJuIGJvb2xcbiAqL1xuVmVjMy5wcm90b3R5cGUuYWxtb3N0RXF1YWxzID0gZnVuY3Rpb24odixwcmVjaXNpb24pe1xuICAgIGlmKHByZWNpc2lvbj09PXVuZGVmaW5lZCl7XG4gICAgICAgIHByZWNpc2lvbiA9IDFlLTY7XG4gICAgfVxuICAgIGlmKCBNYXRoLmFicyh0aGlzLngtdi54KT5wcmVjaXNpb24gfHxcbiAgICAgICAgTWF0aC5hYnModGhpcy55LXYueSk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMuei12LnopPnByZWNpc2lvbil7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmVjdG9yIGlzIGFsbW9zdCB6ZXJvXG4gKiBAbWV0aG9kIGFsbW9zdFplcm9cbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmVjaXNpb25cbiAqL1xuVmVjMy5wcm90b3R5cGUuYWxtb3N0WmVybyA9IGZ1bmN0aW9uKHByZWNpc2lvbil7XG4gICAgaWYocHJlY2lzaW9uPT09dW5kZWZpbmVkKXtcbiAgICAgICAgcHJlY2lzaW9uID0gMWUtNjtcbiAgICB9XG4gICAgaWYoIE1hdGguYWJzKHRoaXMueCk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMueSk+cHJlY2lzaW9uIHx8XG4gICAgICAgIE1hdGguYWJzKHRoaXMueik+cHJlY2lzaW9uKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBhbnRpcF9uZWcgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2ZWN0b3IgaXMgYW50aS1wYXJhbGxlbCB0byBhbm90aGVyIHZlY3Rvci5cbiAqIEBtZXRob2QgaXNBbnRpcGFyYWxsZWxUb1xuICogQHBhcmFtICB7VmVjM30gIHZcbiAqIEBwYXJhbSAge051bWJlcn0gIHByZWNpc2lvbiBTZXQgdG8gemVybyBmb3IgZXhhY3QgY29tcGFyaXNvbnNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblZlYzMucHJvdG90eXBlLmlzQW50aXBhcmFsbGVsVG8gPSBmdW5jdGlvbih2LHByZWNpc2lvbil7XG4gICAgdGhpcy5uZWdhdGUoYW50aXBfbmVnKTtcbiAgICByZXR1cm4gYW50aXBfbmVnLmFsbW9zdEVxdWFscyh2LHByZWNpc2lvbik7XG59O1xuXG4vKipcbiAqIENsb25lIHRoZSB2ZWN0b3JcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblZlYzMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3IFZlYzModGhpcy54LCB0aGlzLnksIHRoaXMueik7XG59O1xufSx7XCIuL01hdDNcIjoyN31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQm9keTtcblxudmFyIEV2ZW50VGFyZ2V0ID0gX2RlcmVxXygnLi4vdXRpbHMvRXZlbnRUYXJnZXQnKTtcbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9TaGFwZScpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBNYXQzID0gX2RlcmVxXygnLi4vbWF0aC9NYXQzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKTtcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcbnZhciBCb3ggPSBfZGVyZXFfKCcuLi9zaGFwZXMvQm94Jyk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGJvZHkgdHlwZXMuXG4gKiBAY2xhc3MgQm9keVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5wb3NpdGlvbl1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMudmVsb2NpdHldXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmFuZ3VsYXJWZWxvY2l0eV1cbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gW29wdGlvbnMucXVhdGVybmlvbl1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXNzXVxuICogQHBhcmFtIHtNYXRlcmlhbH0gW29wdGlvbnMubWF0ZXJpYWxdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMudHlwZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5saW5lYXJEYW1waW5nPTAuMDFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYW5ndWxhckRhbXBpbmc9MC4wMV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dTbGVlcD10cnVlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNsZWVwU3BlZWRMaW1pdD0wLjFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2xlZXBUaW1lTGltaXQ9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9MV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZml4ZWRSb3RhdGlvbj1mYWxzZV1cbiAqIEBwYXJhbSB7Qm9keX0gW29wdGlvbnMuc2hhcGVdXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBib2R5ID0gbmV3IEJvZHkoe1xuICogICAgICAgICBtYXNzOiAxXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIHNoYXBlID0gbmV3IFNwaGVyZSgxKTtcbiAqICAgICBib2R5LmFkZFNoYXBlKHNoYXBlKTtcbiAqICAgICB3b3JsZC5hZGQoYm9keSk7XG4gKi9cbmZ1bmN0aW9uIEJvZHkob3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBFdmVudFRhcmdldC5hcHBseSh0aGlzKTtcblxuICAgIHRoaXMuaWQgPSBCb2R5LmlkQ291bnRlcisrO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSB3b3JsZCB0aGUgYm9keSBpcyBsaXZpbmcgaW5cbiAgICAgKiBAcHJvcGVydHkgd29ybGRcbiAgICAgKiBAdHlwZSB7V29ybGR9XG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgQkVGT1JFIHN0ZXBwaW5nIHRoZSBzeXN0ZW0uIFVzZSBpdCB0byBhcHBseSBmb3JjZXMsIGZvciBleGFtcGxlLiBJbnNpZGUgdGhlIGZ1bmN0aW9uLCBcInRoaXNcIiB3aWxsIHJlZmVyIHRvIHRoaXMgQm9keSBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHByZVN0ZXBcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFdvcmxkIGV2ZW50cyBpbnN0ZWFkXG4gICAgICovXG4gICAgdGhpcy5wcmVTdGVwID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCBBRlRFUiBzdGVwcGluZyB0aGUgc3lzdGVtLiBJbnNpZGUgdGhlIGZ1bmN0aW9uLCBcInRoaXNcIiB3aWxsIHJlZmVyIHRvIHRoaXMgQm9keSBvYmplY3QuXG4gICAgICogQHByb3BlcnR5IHBvc3RTdGVwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBXb3JsZCBldmVudHMgaW5zdGVhZFxuICAgICAqL1xuICAgIHRoaXMucG9zdFN0ZXAgPSBudWxsO1xuXG4gICAgdGhpcy52bGFtYmRhID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBjb2xsaXNpb25GaWx0ZXJHcm91cFxuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyR3JvdXAgPSB0eXBlb2Yob3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCkgPT09ICdudW1iZXInID8gb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gY29sbGlzaW9uRmlsdGVyTWFza1xuICAgICAqL1xuICAgIHRoaXMuY29sbGlzaW9uRmlsdGVyTWFzayA9IHR5cGVvZihvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2spID09PSAnbnVtYmVyJyA/IG9wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzayA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIHByb2R1Y2UgY29udGFjdCBmb3JjZXMgd2hlbiBpbiBjb250YWN0IHdpdGggb3RoZXIgYm9kaWVzLiBOb3RlIHRoYXQgY29udGFjdHMgd2lsbCBiZSBnZW5lcmF0ZWQsIGJ1dCB0aGV5IHdpbGwgYmUgZGlzYWJsZWQuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG5cdHRoaXMuY29sbGlzaW9uUmVzcG9uc2UgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHBvc2l0aW9uXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICBpZihvcHRpb25zLnBvc2l0aW9uKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbi5jb3B5KG9wdGlvbnMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gcHJldmlvdXNQb3NpdGlvblxuICAgICAqL1xuICAgIHRoaXMucHJldmlvdXNQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsIHBvc2l0aW9uIG9mIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IGluaXRQb3NpdGlvblxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMuaW5pdFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB2ZWxvY2l0eVxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy52ZWxvY2l0eSl7XG4gICAgICAgIHRoaXMudmVsb2NpdHkuY29weShvcHRpb25zLnZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5pdFZlbG9jaXR5XG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5pbml0VmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogTGluZWFyIGZvcmNlIG9uIHRoZSBib2R5XG4gICAgICogQHByb3BlcnR5IGZvcmNlXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5mb3JjZSA9IG5ldyBWZWMzKCk7XG5cbiAgICB2YXIgbWFzcyA9IHR5cGVvZihvcHRpb25zLm1hc3MpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubWFzcyA6IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgbWFzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqL1xuICAgIHRoaXMubWFzcyA9IG1hc3M7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW52TWFzc1xuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pbnZNYXNzID0gbWFzcyA+IDAgPyAxLjAgLyBtYXNzIDogMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBtYXRlcmlhbFxuICAgICAqIEB0eXBlIHtNYXRlcmlhbH1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFsID0gb3B0aW9ucy5tYXRlcmlhbCB8fCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGxpbmVhckRhbXBpbmdcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGluZWFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmxpbmVhckRhbXBpbmcpID09PSAnbnVtYmVyJyA/IG9wdGlvbnMubGluZWFyRGFtcGluZyA6IDAuMDE7XG5cbiAgICAvKipcbiAgICAgKiBPbmUgb2Y6IEJvZHkuRFlOQU1JQywgQm9keS5TVEFUSUMgYW5kIEJvZHkuS0lORU1BVElDLlxuICAgICAqIEBwcm9wZXJ0eSB0eXBlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSAobWFzcyA8PSAwLjAgPyBCb2R5LlNUQVRJQyA6IEJvZHkuRFlOQU1JQyk7XG4gICAgaWYodHlwZW9mKG9wdGlvbnMudHlwZSkgPT09IHR5cGVvZihCb2R5LlNUQVRJQykpe1xuICAgICAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJvZHkgd2lsbCBhdXRvbWF0aWNhbGx5IGZhbGwgdG8gc2xlZXAuXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCB0cnVlXG4gICAgICovXG4gICAgdGhpcy5hbGxvd1NsZWVwID0gdHlwZW9mKG9wdGlvbnMuYWxsb3dTbGVlcCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5hbGxvd1NsZWVwIDogdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc2xlZXAgc3RhdGUuXG4gICAgICogQHByb3BlcnR5IHNsZWVwU3RhdGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTdGF0ZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgc3BlZWQgKHRoZSBub3JtIG9mIHRoZSB2ZWxvY2l0eSkgaXMgc21hbGxlciB0aGFuIHRoaXMgdmFsdWUsIHRoZSBib2R5IGlzIGNvbnNpZGVyZWQgc2xlZXB5LlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFNwZWVkTGltaXRcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDAuMVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBTcGVlZExpbWl0ID0gdHlwZW9mKG9wdGlvbnMuc2xlZXBTcGVlZExpbWl0KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnNsZWVwU3BlZWRMaW1pdCA6IDAuMTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBib2R5IGhhcyBiZWVuIHNsZWVweSBmb3IgdGhpcyBzbGVlcFRpbWVMaW1pdCBzZWNvbmRzLCBpdCBpcyBjb25zaWRlcmVkIHNsZWVwaW5nLlxuICAgICAqIEBwcm9wZXJ0eSBzbGVlcFRpbWVMaW1pdFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIHRoaXMuc2xlZXBUaW1lTGltaXQgPSB0eXBlb2Yob3B0aW9ucy5zbGVlcFRpbWVMaW1pdCkgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5zbGVlcFRpbWVMaW1pdCA6IDE7XG5cbiAgICB0aGlzLnRpbWVMYXN0U2xlZXB5ID0gMDtcblxuICAgIHRoaXMuX3dha2VVcEFmdGVyTmFycm93cGhhc2UgPSBmYWxzZTtcblxuXG4gICAgLyoqXG4gICAgICogUm90YXRpb25hbCBmb3JjZSBvbiB0aGUgYm9keSwgYXJvdW5kIGNlbnRlciBvZiBtYXNzXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSB0b3JxdWVcbiAgICAgKi9cbiAgICB0aGlzLnRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBPcmllbnRhdGlvbiBvZiB0aGUgYm9keVxuICAgICAqIEBwcm9wZXJ0eSBxdWF0ZXJuaW9uXG4gICAgICogQHR5cGUge1F1YXRlcm5pb259XG4gICAgICovXG4gICAgdGhpcy5xdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIGlmKG9wdGlvbnMucXVhdGVybmlvbil7XG4gICAgICAgIHRoaXMucXVhdGVybmlvbi5jb3B5KG9wdGlvbnMucXVhdGVybmlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGluaXRRdWF0ZXJuaW9uXG4gICAgICogQHR5cGUge1F1YXRlcm5pb259XG4gICAgICovXG4gICAgdGhpcy5pbml0UXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgYW5ndWxhclZlbG9jaXR5XG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5hbmd1bGFyVmVsb2NpdHkpe1xuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5jb3B5KG9wdGlvbnMuYW5ndWxhclZlbG9jaXR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgaW5pdEFuZ3VsYXJWZWxvY2l0eVxuICAgICAqIEB0eXBlIHtWZWMzfVxuICAgICAqL1xuICAgIHRoaXMuaW5pdEFuZ3VsYXJWZWxvY2l0eSA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLmludGVycG9sYXRlZFBvc2l0aW9uID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmludGVycG9sYXRlZFF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlc1xuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlT2Zmc2V0c1xuICAgICAqIEB0eXBlIHthcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYXBlT2Zmc2V0cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHNoYXBlT3JpZW50YXRpb25zXG4gICAgICogQHR5cGUge2FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc2hhcGVPcmllbnRhdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBpbmVydGlhXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5pbmVydGlhID0gbmV3IFZlYzMoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYSA9IG5ldyBWZWMzKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01hdDN9IGludkluZXJ0aWFXb3JsZFxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkID0gbmV3IE1hdDMoKTtcblxuICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gaW52SW5lcnRpYVNvbHZlXG4gICAgICovXG4gICAgdGhpcy5pbnZJbmVydGlhU29sdmUgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtNYXQzfSBpbnZJbmVydGlhV29ybGRTb2x2ZVxuICAgICAqL1xuICAgIHRoaXMuaW52SW5lcnRpYVdvcmxkU29sdmUgPSBuZXcgTWF0MygpO1xuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgaWYgeW91IGRvbid0IHdhbnQgdGhlIGJvZHkgdG8gcm90YXRlLiBNYWtlIHN1cmUgdG8gcnVuIC51cGRhdGVNYXNzUHJvcGVydGllcygpIGFmdGVyIGNoYW5naW5nIHRoaXMuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBmaXhlZFJvdGF0aW9uXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICB0aGlzLmZpeGVkUm90YXRpb24gPSB0eXBlb2Yob3B0aW9ucy5maXhlZFJvdGF0aW9uKSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMuZml4ZWRSb3RhdGlvbiA6IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGFuZ3VsYXJEYW1waW5nXG4gICAgICovXG4gICAgdGhpcy5hbmd1bGFyRGFtcGluZyA9IHR5cGVvZihvcHRpb25zLmFuZ3VsYXJEYW1waW5nKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmFuZ3VsYXJEYW1waW5nIDogMC4wMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBhYWJiXG4gICAgICogQHR5cGUge0FBQkJ9XG4gICAgICovXG4gICAgdGhpcy5hYWJiID0gbmV3IEFBQkIoKTtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgQUFCQiBuZWVkcyB0byBiZSB1cGRhdGVkIGJlZm9yZSB1c2UuXG4gICAgICogQHByb3BlcnR5IGFhYmJOZWVkc1VwZGF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuYWFiYk5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgIHRoaXMud2xhbWJkYSA9IG5ldyBWZWMzKCk7XG5cbiAgICBpZihvcHRpb25zLnNoYXBlKXtcbiAgICAgICAgdGhpcy5hZGRTaGFwZShvcHRpb25zLnNoYXBlKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1hc3NQcm9wZXJ0aWVzKCk7XG59XG5Cb2R5LnByb3RvdHlwZSA9IG5ldyBFdmVudFRhcmdldCgpO1xuQm9keS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb2R5O1xuXG4vKipcbiAqIEEgZHluYW1pYyBib2R5IGlzIGZ1bGx5IHNpbXVsYXRlZC4gQ2FuIGJlIG1vdmVkIG1hbnVhbGx5IGJ5IHRoZSB1c2VyLCBidXQgbm9ybWFsbHkgdGhleSBtb3ZlIGFjY29yZGluZyB0byBmb3JjZXMuIEEgZHluYW1pYyBib2R5IGNhbiBjb2xsaWRlIHdpdGggYWxsIGJvZHkgdHlwZXMuIEEgZHluYW1pYyBib2R5IGFsd2F5cyBoYXMgZmluaXRlLCBub24temVybyBtYXNzLlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IERZTkFNSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJvZHkuRFlOQU1JQyA9IDE7XG5cbi8qKlxuICogQSBzdGF0aWMgYm9keSBkb2VzIG5vdCBtb3ZlIGR1cmluZyBzaW11bGF0aW9uIGFuZCBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBTdGF0aWMgYm9kaWVzIGNhbiBiZSBtb3ZlZCBtYW51YWxseSBieSBzZXR0aW5nIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9keS4gVGhlIHZlbG9jaXR5IG9mIGEgc3RhdGljIGJvZHkgaXMgYWx3YXlzIHplcm8uIFN0YXRpYyBib2RpZXMgZG8gbm90IGNvbGxpZGUgd2l0aCBvdGhlciBzdGF0aWMgb3Iga2luZW1hdGljIGJvZGllcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBTVEFUSUNcbiAqIEB0eXBlIHtOdW1iZXJ9XG4gKi9cbkJvZHkuU1RBVElDID0gMjtcblxuLyoqXG4gKiBBIGtpbmVtYXRpYyBib2R5IG1vdmVzIHVuZGVyIHNpbXVsYXRpb24gYWNjb3JkaW5nIHRvIGl0cyB2ZWxvY2l0eS4gVGhleSBkbyBub3QgcmVzcG9uZCB0byBmb3JjZXMuIFRoZXkgY2FuIGJlIG1vdmVkIG1hbnVhbGx5LCBidXQgbm9ybWFsbHkgYSBraW5lbWF0aWMgYm9keSBpcyBtb3ZlZCBieSBzZXR0aW5nIGl0cyB2ZWxvY2l0eS4gQSBraW5lbWF0aWMgYm9keSBiZWhhdmVzIGFzIGlmIGl0IGhhcyBpbmZpbml0ZSBtYXNzLiBLaW5lbWF0aWMgYm9kaWVzIGRvIG5vdCBjb2xsaWRlIHdpdGggb3RoZXIgc3RhdGljIG9yIGtpbmVtYXRpYyBib2RpZXMuXG4gKiBAc3RhdGljXG4gKiBAcHJvcGVydHkgS0lORU1BVElDXG4gKiBAdHlwZSB7TnVtYmVyfVxuICovXG5Cb2R5LktJTkVNQVRJQyA9IDQ7XG5cblxuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBBV0FLRVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5BV0FLRSA9IDA7XG5cbi8qKlxuICogQHN0YXRpY1xuICogQHByb3BlcnR5IFNMRUVQWVxuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5TTEVFUFkgPSAxO1xuXG4vKipcbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSBTTEVFUElOR1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuQm9keS5TTEVFUElORyA9IDI7XG5cbkJvZHkuaWRDb3VudGVyID0gMDtcblxuLyoqXG4gKiBXYWtlIHRoZSBib2R5IHVwLlxuICogQG1ldGhvZCB3YWtlVXBcbiAqL1xuQm9keS5wcm90b3R5cGUud2FrZVVwID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcyA9IHRoaXMuc2xlZXBTdGF0ZTtcbiAgICB0aGlzLnNsZWVwU3RhdGUgPSAwO1xuICAgIGlmKHMgPT09IEJvZHkuU0xFRVBJTkcpe1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoe3R5cGU6XCJ3YWtldXBcIn0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogRm9yY2UgYm9keSBzbGVlcFxuICogQG1ldGhvZCBzbGVlcFxuICovXG5Cb2R5LnByb3RvdHlwZS5zbGVlcCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUElORztcbiAgICB0aGlzLnZlbG9jaXR5LnNldCgwLDAsMCk7XG4gICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkuc2V0KDAsMCwwKTtcbn07XG5cbkJvZHkuc2xlZXB5RXZlbnQgPSB7XG4gICAgdHlwZTogXCJzbGVlcHlcIlxufTtcblxuQm9keS5zbGVlcEV2ZW50ID0ge1xuICAgIHR5cGU6IFwic2xlZXBcIlxufTtcblxuLyoqXG4gKiBDYWxsZWQgZXZlcnkgdGltZXN0ZXAgdG8gdXBkYXRlIGludGVybmFsIHNsZWVwIHRpbWVyIGFuZCBjaGFuZ2Ugc2xlZXAgc3RhdGUgaWYgbmVlZGVkLlxuICogQG1ldGhvZCBzbGVlcFRpY2tcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lIFRoZSB3b3JsZCB0aW1lIGluIHNlY29uZHNcbiAqL1xuQm9keS5wcm90b3R5cGUuc2xlZXBUaWNrID0gZnVuY3Rpb24odGltZSl7XG4gICAgaWYodGhpcy5hbGxvd1NsZWVwKXtcbiAgICAgICAgdmFyIHNsZWVwU3RhdGUgPSB0aGlzLnNsZWVwU3RhdGU7XG4gICAgICAgIHZhciBzcGVlZFNxdWFyZWQgPSB0aGlzLnZlbG9jaXR5Lm5vcm0yKCkgKyB0aGlzLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICB2YXIgc3BlZWRMaW1pdFNxdWFyZWQgPSBNYXRoLnBvdyh0aGlzLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgaWYoc2xlZXBTdGF0ZT09PUJvZHkuQVdBS0UgJiYgc3BlZWRTcXVhcmVkIDwgc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICAgICAgdGhpcy5zbGVlcFN0YXRlID0gQm9keS5TTEVFUFk7IC8vIFNsZWVweVxuICAgICAgICAgICAgdGhpcy50aW1lTGFzdFNsZWVweSA9IHRpbWU7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcHlFdmVudCk7XG4gICAgICAgIH0gZWxzZSBpZihzbGVlcFN0YXRlPT09Qm9keS5TTEVFUFkgJiYgc3BlZWRTcXVhcmVkID4gc3BlZWRMaW1pdFNxdWFyZWQpe1xuICAgICAgICAgICAgdGhpcy53YWtlVXAoKTsgLy8gV2FrZSB1cFxuICAgICAgICB9IGVsc2UgaWYoc2xlZXBTdGF0ZT09PUJvZHkuU0xFRVBZICYmICh0aW1lIC0gdGhpcy50aW1lTGFzdFNsZWVweSApID4gdGhpcy5zbGVlcFRpbWVMaW1pdCl7XG4gICAgICAgICAgICB0aGlzLnNsZWVwKCk7IC8vIFNsZWVwaW5nXG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoQm9keS5zbGVlcEV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogSWYgdGhlIGJvZHkgaXMgc2xlZXBpbmcsIGl0IHNob3VsZCBiZSBpbW1vdmFibGUgLyBoYXZlIGluZmluaXRlIG1hc3MgZHVyaW5nIHNvbHZlLiBXZSBzb2x2ZSBpdCBieSBoYXZpbmcgYSBzZXBhcmF0ZSBcInNvbHZlIG1hc3NcIi5cbiAqIEBtZXRob2QgdXBkYXRlU29sdmVNYXNzUHJvcGVydGllc1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLnNsZWVwU3RhdGUgPT09IEJvZHkuU0xFRVBJTkcgfHwgdGhpcy50eXBlID09PSBCb2R5LktJTkVNQVRJQyl7XG4gICAgICAgIHRoaXMuaW52TWFzc1NvbHZlID0gMDtcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuc2V0WmVybygpO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLnNldFplcm8oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmludk1hc3NTb2x2ZSA9IHRoaXMuaW52TWFzcztcbiAgICAgICAgdGhpcy5pbnZJbmVydGlhU29sdmUuY29weSh0aGlzLmludkluZXJ0aWEpO1xuICAgICAgICB0aGlzLmludkluZXJ0aWFXb3JsZFNvbHZlLmNvcHkodGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29udmVydCBhIHdvcmxkIHBvaW50IHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gKiBAbWV0aG9kIHBvaW50VG9Mb2NhbEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkJvZHkucHJvdG90eXBlLnBvaW50VG9Mb2NhbEZyYW1lID0gZnVuY3Rpb24od29ybGRQb2ludCxyZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB3b3JsZFBvaW50LnZzdWIodGhpcy5wb3NpdGlvbixyZXN1bHQpO1xuICAgIHRoaXMucXVhdGVybmlvbi5jb25qdWdhdGUoKS52bXVsdChyZXN1bHQscmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgd29ybGQgdmVjdG9yIHRvIGxvY2FsIGJvZHkgZnJhbWUuXG4gKiBAbWV0aG9kIHZlY3RvclRvTG9jYWxGcmFtZVxuICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludFxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb0xvY2FsRnJhbWUgPSBmdW5jdGlvbih3b3JsZFZlY3RvciwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLmNvbmp1Z2F0ZSgpLnZtdWx0KHdvcmxkVmVjdG9yLHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIGxvY2FsIGJvZHkgcG9pbnQgdG8gd29ybGQgZnJhbWUuXG4gKiBAbWV0aG9kIHBvaW50VG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFBvaW50XG4gKiBAcGFyYW0gIHtWZWMzfSByZXN1bHRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cbkJvZHkucHJvdG90eXBlLnBvaW50VG9Xb3JsZEZyYW1lID0gZnVuY3Rpb24obG9jYWxQb2ludCxyZXN1bHQpe1xuICAgIHZhciByZXN1bHQgPSByZXN1bHQgfHwgbmV3IFZlYzMoKTtcbiAgICB0aGlzLnF1YXRlcm5pb24udm11bHQobG9jYWxQb2ludCxyZXN1bHQpO1xuICAgIHJlc3VsdC52YWRkKHRoaXMucG9zaXRpb24scmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgbG9jYWwgYm9keSBwb2ludCB0byB3b3JsZCBmcmFtZS5cbiAqIEBtZXRob2QgdmVjdG9yVG9Xb3JsZEZyYW1lXG4gKiBAcGFyYW0gIHtWZWMzfSBsb2NhbFZlY3RvclxuICogQHBhcmFtICB7VmVjM30gcmVzdWx0XG4gKiBAcmV0dXJuIHtWZWMzfVxuICovXG5Cb2R5LnByb3RvdHlwZS52ZWN0b3JUb1dvcmxkRnJhbWUgPSBmdW5jdGlvbihsb2NhbFZlY3RvciwgcmVzdWx0KXtcbiAgICB2YXIgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5xdWF0ZXJuaW9uLnZtdWx0KGxvY2FsVmVjdG9yLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG1wVmVjID0gbmV3IFZlYzMoKTtcbnZhciB0bXBRdWF0ID0gbmV3IFF1YXRlcm5pb24oKTtcblxuLyoqXG4gKiBBZGQgYSBzaGFwZSB0byB0aGUgYm9keSB3aXRoIGEgbG9jYWwgb2Zmc2V0IGFuZCBvcmllbnRhdGlvbi5cbiAqIEBtZXRob2QgYWRkU2hhcGVcbiAqIEBwYXJhbSB7U2hhcGV9IHNoYXBlXG4gKiBAcGFyYW0ge1ZlYzN9IG9mZnNldFxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJuIHtCb2R5fSBUaGUgYm9keSBvYmplY3QsIGZvciBjaGFpbmFiaWxpdHkuXG4gKi9cbkJvZHkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24oc2hhcGUsIF9vZmZzZXQsIF9vcmllbnRhdGlvbil7XG4gICAgdmFyIG9mZnNldCA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcblxuICAgIGlmKF9vZmZzZXQpe1xuICAgICAgICBvZmZzZXQuY29weShfb2Zmc2V0KTtcbiAgICB9XG4gICAgaWYoX29yaWVudGF0aW9uKXtcbiAgICAgICAgb3JpZW50YXRpb24uY29weShfb3JpZW50YXRpb24pO1xuICAgIH1cblxuICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgIHRoaXMuc2hhcGVPZmZzZXRzLnB1c2gob2Zmc2V0KTtcbiAgICB0aGlzLnNoYXBlT3JpZW50YXRpb25zLnB1c2gob3JpZW50YXRpb24pO1xuICAgIHRoaXMudXBkYXRlTWFzc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nUmFkaXVzKCk7XG5cbiAgICB0aGlzLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBib3VuZGluZyByYWRpdXMgb2YgdGhlIGJvZHkuIFNob3VsZCBiZSBkb25lIGlmIGFueSBvZiB0aGUgc2hhcGVzIGFyZSBjaGFuZ2VkLlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1JhZGl1c1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1JhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgTiA9IHNoYXBlcy5sZW5ndGgsXG4gICAgICAgIHJhZGl1cyA9IDA7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcbiAgICAgICAgc2hhcGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IHNoYXBlT2Zmc2V0c1tpXS5ub3JtKCksXG4gICAgICAgICAgICByID0gc2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXM7XG4gICAgICAgIGlmKG9mZnNldCArIHIgPiByYWRpdXMpe1xuICAgICAgICAgICAgcmFkaXVzID0gb2Zmc2V0ICsgcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYm91bmRpbmdSYWRpdXMgPSByYWRpdXM7XG59O1xuXG52YXIgY29tcHV0ZUFBQkJfc2hhcGVBQUJCID0gbmV3IEFBQkIoKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSAuYWFiYlxuICogQG1ldGhvZCBjb21wdXRlQUFCQlxuICogQHRvZG8gcmVuYW1lIHRvIHVwZGF0ZUFBQkIoKVxuICovXG5Cb2R5LnByb3RvdHlwZS5jb21wdXRlQUFCQiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuc2hhcGVzLFxuICAgICAgICBzaGFwZU9mZnNldHMgPSB0aGlzLnNoYXBlT2Zmc2V0cyxcbiAgICAgICAgc2hhcGVPcmllbnRhdGlvbnMgPSB0aGlzLnNoYXBlT3JpZW50YXRpb25zLFxuICAgICAgICBOID0gc2hhcGVzLmxlbmd0aCxcbiAgICAgICAgb2Zmc2V0ID0gdG1wVmVjLFxuICAgICAgICBvcmllbnRhdGlvbiA9IHRtcFF1YXQsXG4gICAgICAgIGJvZHlRdWF0ID0gdGhpcy5xdWF0ZXJuaW9uLFxuICAgICAgICBhYWJiID0gdGhpcy5hYWJiLFxuICAgICAgICBzaGFwZUFBQkIgPSBjb21wdXRlQUFCQl9zaGFwZUFBQkI7XG5cbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcblxuICAgICAgICAvLyBHZXQgc2hhcGUgd29ybGQgcXVhdGVybmlvblxuICAgICAgICBzaGFwZU9yaWVudGF0aW9uc1tpXS5tdWx0KGJvZHlRdWF0LCBvcmllbnRhdGlvbik7XG5cbiAgICAgICAgLy8gR2V0IHNoYXBlIHdvcmxkIHBvc2l0aW9uXG4gICAgICAgIG9yaWVudGF0aW9uLnZtdWx0KHNoYXBlT2Zmc2V0c1tpXSwgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0LnZhZGQodGhpcy5wb3NpdGlvbiwgb2Zmc2V0KTtcblxuICAgICAgICAvLyB2ZWMyLnJvdGF0ZShvZmZzZXQsIHNoYXBlT2Zmc2V0c1tpXSwgYm9keUFuZ2xlKTtcbiAgICAgICAgLy8gdmVjMi5hZGQob2Zmc2V0LCBvZmZzZXQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgICAgIC8vIEdldCBzaGFwZSBBQUJCXG4gICAgICAgIHNoYXBlLmNhbGN1bGF0ZVdvcmxkQUFCQihvZmZzZXQsIG9yaWVudGF0aW9uLCBzaGFwZUFBQkIubG93ZXJCb3VuZCwgc2hhcGVBQUJCLnVwcGVyQm91bmQpO1xuXG4gICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgYWFiYi5jb3B5KHNoYXBlQUFCQik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhYWJiLmV4dGVuZChzaGFwZUFBQkIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hYWJiTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbnZhciB1aXdfbTEgPSBuZXcgTWF0MygpLFxuICAgIHVpd19tMiA9IG5ldyBNYXQzKCksXG4gICAgdWl3X20zID0gbmV3IE1hdDMoKTtcblxuLyoqXG4gKiBVcGRhdGUgLmluZXJ0aWFXb3JsZCBhbmQgLmludkluZXJ0aWFXb3JsZFxuICogQG1ldGhvZCB1cGRhdGVJbmVydGlhV29ybGRcbiAqL1xuQm9keS5wcm90b3R5cGUudXBkYXRlSW5lcnRpYVdvcmxkID0gZnVuY3Rpb24oZm9yY2Upe1xuICAgIHZhciBJID0gdGhpcy5pbnZJbmVydGlhO1xuICAgIGlmIChJLnggPT09IEkueSAmJiBJLnkgPT09IEkueiAmJiAhZm9yY2UpIHtcbiAgICAgICAgLy8gSWYgaW5lcnRpYSBNID0gcypJLCB3aGVyZSBJIGlzIGlkZW50aXR5IGFuZCBzIGEgc2NhbGFyLCB0aGVuXG4gICAgICAgIC8vICAgIFIqTSpSJyA9IFIqKHMqSSkqUicgPSBzKlIqSSpSJyA9IHMqUipSJyA9IHMqSSA9IE1cbiAgICAgICAgLy8gd2hlcmUgUiBpcyB0aGUgcm90YXRpb24gbWF0cml4LlxuICAgICAgICAvLyBJbiBvdGhlciB3b3Jkcywgd2UgZG9uJ3QgaGF2ZSB0byB0cmFuc2Zvcm0gdGhlIGluZXJ0aWEgaWYgYWxsXG4gICAgICAgIC8vIGluZXJ0aWEgZGlhZ29uYWwgZW50cmllcyBhcmUgZXF1YWwuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG0xID0gdWl3X20xLFxuICAgICAgICAgICAgbTIgPSB1aXdfbTIsXG4gICAgICAgICAgICBtMyA9IHVpd19tMztcbiAgICAgICAgbTEuc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbih0aGlzLnF1YXRlcm5pb24pO1xuICAgICAgICBtMS50cmFuc3Bvc2UobTIpO1xuICAgICAgICBtMS5zY2FsZShJLG0xKTtcbiAgICAgICAgbTEubW11bHQobTIsdGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgICAgICAvL20zLmdldFRyYWNlKHRoaXMuaW52SW5lcnRpYVdvcmxkKTtcbiAgICB9XG5cbiAgICAvKlxuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdCh0aGlzLmluZXJ0aWEsdGhpcy5pbmVydGlhV29ybGQpO1xuICAgIHRoaXMucXVhdGVybmlvbi52bXVsdCh0aGlzLmludkluZXJ0aWEsdGhpcy5pbnZJbmVydGlhV29ybGQpO1xuICAgICovXG59O1xuXG4vKipcbiAqIEFwcGx5IGZvcmNlIHRvIGEgd29ybGQgcG9pbnQuIFRoaXMgY291bGQgZm9yIGV4YW1wbGUgYmUgYSBwb2ludCBvbiB0aGUgQm9keSBzdXJmYWNlLiBBcHBseWluZyBmb3JjZSB0aGlzIHdheSB3aWxsIGFkZCB0byBCb2R5LmZvcmNlIGFuZCBCb2R5LnRvcnF1ZS5cbiAqIEBtZXRob2QgYXBwbHlGb3JjZVxuICogQHBhcmFtICB7VmVjM30gZm9yY2UgVGhlIGFtb3VudCBvZiBmb3JjZSB0byBhZGQuXG4gKiBAcGFyYW0gIHtWZWMzfSB3b3JsZFBvaW50IEEgd29ybGQgcG9pbnQgdG8gYXBwbHkgdGhlIGZvcmNlIG9uLlxuICovXG52YXIgQm9keV9hcHBseUZvcmNlX3IgPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlGb3JjZV9yb3RGb3JjZSA9IG5ldyBWZWMzKCk7XG5Cb2R5LnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oZm9yY2Usd29ybGRQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBwb2ludCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXJcbiAgICB2YXIgciA9IEJvZHlfYXBwbHlGb3JjZV9yO1xuICAgIHdvcmxkUG9pbnQudnN1Yih0aGlzLnBvc2l0aW9uLHIpO1xuXG4gICAgLy8gQ29tcHV0ZSBwcm9kdWNlZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgdmFyIHJvdEZvcmNlID0gQm9keV9hcHBseUZvcmNlX3JvdEZvcmNlO1xuICAgIHIuY3Jvc3MoZm9yY2Uscm90Rm9yY2UpO1xuXG4gICAgLy8gQWRkIGxpbmVhciBmb3JjZVxuICAgIHRoaXMuZm9yY2UudmFkZChmb3JjZSx0aGlzLmZvcmNlKTtcblxuICAgIC8vIEFkZCByb3RhdGlvbmFsIGZvcmNlXG4gICAgdGhpcy50b3JxdWUudmFkZChyb3RGb3JjZSx0aGlzLnRvcnF1ZSk7XG59O1xuXG4vKipcbiAqIEFwcGx5IGZvcmNlIHRvIGEgbG9jYWwgcG9pbnQgaW4gdGhlIGJvZHkuXG4gKiBAbWV0aG9kIGFwcGx5TG9jYWxGb3JjZVxuICogQHBhcmFtICB7VmVjM30gZm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhcHBseSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBib2R5IGZyYW1lLlxuICogQHBhcmFtICB7VmVjM30gbG9jYWxQb2ludCBBIGxvY2FsIHBvaW50IGluIHRoZSBib2R5IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xudmFyIEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkRm9yY2UgPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlMb2NhbEZvcmNlX3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlMb2NhbEZvcmNlID0gZnVuY3Rpb24obG9jYWxGb3JjZSwgbG9jYWxQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdvcmxkRm9yY2UgPSBCb2R5X2FwcGx5TG9jYWxGb3JjZV93b3JsZEZvcmNlO1xuICAgIHZhciB3b3JsZFBvaW50ID0gQm9keV9hcHBseUxvY2FsRm9yY2Vfd29ybGRQb2ludDtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlXG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxGb3JjZSwgd29ybGRGb3JjZSk7XG4gICAgdGhpcy5wb2ludFRvV29ybGRGcmFtZShsb2NhbFBvaW50LCB3b3JsZFBvaW50KTtcblxuICAgIHRoaXMuYXBwbHlGb3JjZSh3b3JsZEZvcmNlLCB3b3JsZFBvaW50KTtcbn07XG5cbi8qKlxuICogQXBwbHkgaW1wdWxzZSB0byBhIHdvcmxkIHBvaW50LiBUaGlzIGNvdWxkIGZvciBleGFtcGxlIGJlIGEgcG9pbnQgb24gdGhlIEJvZHkgc3VyZmFjZS4gQW4gaW1wdWxzZSBpcyBhIGZvcmNlIGFkZGVkIHRvIGEgYm9keSBkdXJpbmcgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSAoaW1wdWxzZSA9IGZvcmNlICogdGltZSkuIEltcHVsc2VzIHdpbGwgYmUgYWRkZWQgdG8gQm9keS52ZWxvY2l0eSBhbmQgQm9keS5hbmd1bGFyVmVsb2NpdHkuXG4gKiBAbWV0aG9kIGFwcGx5SW1wdWxzZVxuICogQHBhcmFtICB7VmVjM30gaW1wdWxzZSBUaGUgYW1vdW50IG9mIGltcHVsc2UgdG8gYWRkLlxuICogQHBhcmFtICB7VmVjM30gd29ybGRQb2ludCBBIHdvcmxkIHBvaW50IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xudmFyIEJvZHlfYXBwbHlJbXB1bHNlX3IgPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlJbXB1bHNlX3ZlbG8gPSBuZXcgVmVjMygpO1xudmFyIEJvZHlfYXBwbHlJbXB1bHNlX3JvdFZlbG8gPSBuZXcgVmVjMygpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlJbXB1bHNlID0gZnVuY3Rpb24oaW1wdWxzZSwgd29ybGRQb2ludCl7XG4gICAgaWYodGhpcy50eXBlICE9PSBCb2R5LkRZTkFNSUMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBwb2ludCBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgYm9keSBjZW50ZXJcbiAgICB2YXIgciA9IEJvZHlfYXBwbHlJbXB1bHNlX3I7XG4gICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24scik7XG5cbiAgICAvLyBDb21wdXRlIHByb2R1Y2VkIGNlbnRyYWwgaW1wdWxzZSB2ZWxvY2l0eVxuICAgIHZhciB2ZWxvID0gQm9keV9hcHBseUltcHVsc2VfdmVsbztcbiAgICB2ZWxvLmNvcHkoaW1wdWxzZSk7XG4gICAgdmVsby5tdWx0KHRoaXMuaW52TWFzcyx2ZWxvKTtcblxuICAgIC8vIEFkZCBsaW5lYXIgaW1wdWxzZVxuICAgIHRoaXMudmVsb2NpdHkudmFkZCh2ZWxvLCB0aGlzLnZlbG9jaXR5KTtcblxuICAgIC8vIENvbXB1dGUgcHJvZHVjZWQgcm90YXRpb25hbCBpbXB1bHNlIHZlbG9jaXR5XG4gICAgdmFyIHJvdFZlbG8gPSBCb2R5X2FwcGx5SW1wdWxzZV9yb3RWZWxvO1xuICAgIHIuY3Jvc3MoaW1wdWxzZSxyb3RWZWxvKTtcblxuICAgIC8qXG4gICAgcm90VmVsby54ICo9IHRoaXMuaW52SW5lcnRpYS54O1xuICAgIHJvdFZlbG8ueSAqPSB0aGlzLmludkluZXJ0aWEueTtcbiAgICByb3RWZWxvLnogKj0gdGhpcy5pbnZJbmVydGlhLno7XG4gICAgKi9cbiAgICB0aGlzLmludkluZXJ0aWFXb3JsZC52bXVsdChyb3RWZWxvLHJvdFZlbG8pO1xuXG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgSW1wdWxzZVxuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LnZhZGQocm90VmVsbywgdGhpcy5hbmd1bGFyVmVsb2NpdHkpO1xufTtcblxuLyoqXG4gKiBBcHBseSBsb2NhbGx5LWRlZmluZWQgaW1wdWxzZSB0byBhIGxvY2FsIHBvaW50IGluIHRoZSBib2R5LlxuICogQG1ldGhvZCBhcHBseUxvY2FsSW1wdWxzZVxuICogQHBhcmFtICB7VmVjM30gZm9yY2UgVGhlIGZvcmNlIHZlY3RvciB0byBhcHBseSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSBib2R5IGZyYW1lLlxuICogQHBhcmFtICB7VmVjM30gbG9jYWxQb2ludCBBIGxvY2FsIHBvaW50IGluIHRoZSBib2R5IHRvIGFwcGx5IHRoZSBmb3JjZSBvbi5cbiAqL1xudmFyIEJvZHlfYXBwbHlMb2NhbEltcHVsc2Vfd29ybGRJbXB1bHNlID0gbmV3IFZlYzMoKTtcbnZhciBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xuQm9keS5wcm90b3R5cGUuYXBwbHlMb2NhbEltcHVsc2UgPSBmdW5jdGlvbihsb2NhbEltcHVsc2UsIGxvY2FsUG9pbnQpe1xuICAgIGlmKHRoaXMudHlwZSAhPT0gQm9keS5EWU5BTUlDKXtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3b3JsZEltcHVsc2UgPSBCb2R5X2FwcGx5TG9jYWxJbXB1bHNlX3dvcmxkSW1wdWxzZTtcbiAgICB2YXIgd29ybGRQb2ludCA9IEJvZHlfYXBwbHlMb2NhbEltcHVsc2Vfd29ybGRQb2ludDtcblxuICAgIC8vIFRyYW5zZm9ybSB0aGUgZm9yY2UgdmVjdG9yIHRvIHdvcmxkIHNwYWNlXG4gICAgdGhpcy52ZWN0b3JUb1dvcmxkRnJhbWUobG9jYWxJbXB1bHNlLCB3b3JsZEltcHVsc2UpO1xuICAgIHRoaXMucG9pbnRUb1dvcmxkRnJhbWUobG9jYWxQb2ludCwgd29ybGRQb2ludCk7XG5cbiAgICB0aGlzLmFwcGx5SW1wdWxzZSh3b3JsZEltcHVsc2UsIHdvcmxkUG9pbnQpO1xufTtcblxudmFyIEJvZHlfdXBkYXRlTWFzc1Byb3BlcnRpZXNfaGFsZkV4dGVudHMgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgeW91IGNoYW5nZSB0aGUgYm9keSBzaGFwZSBvciBtYXNzLlxuICogQG1ldGhvZCB1cGRhdGVNYXNzUHJvcGVydGllc1xuICovXG5Cb2R5LnByb3RvdHlwZS51cGRhdGVNYXNzUHJvcGVydGllcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhhbGZFeHRlbnRzID0gQm9keV91cGRhdGVNYXNzUHJvcGVydGllc19oYWxmRXh0ZW50cztcblxuICAgIHRoaXMuaW52TWFzcyA9IHRoaXMubWFzcyA+IDAgPyAxLjAgLyB0aGlzLm1hc3MgOiAwO1xuICAgIHZhciBJID0gdGhpcy5pbmVydGlhO1xuICAgIHZhciBmaXhlZCA9IHRoaXMuZml4ZWRSb3RhdGlvbjtcblxuICAgIC8vIEFwcHJveGltYXRlIHdpdGggQUFCQiBib3hcbiAgICB0aGlzLmNvbXB1dGVBQUJCKCk7XG4gICAgaGFsZkV4dGVudHMuc2V0KFxuICAgICAgICAodGhpcy5hYWJiLnVwcGVyQm91bmQueC10aGlzLmFhYmIubG93ZXJCb3VuZC54KSAvIDIsXG4gICAgICAgICh0aGlzLmFhYmIudXBwZXJCb3VuZC55LXRoaXMuYWFiYi5sb3dlckJvdW5kLnkpIC8gMixcbiAgICAgICAgKHRoaXMuYWFiYi51cHBlckJvdW5kLnotdGhpcy5hYWJiLmxvd2VyQm91bmQueikgLyAyXG4gICAgKTtcbiAgICBCb3guY2FsY3VsYXRlSW5lcnRpYShoYWxmRXh0ZW50cywgdGhpcy5tYXNzLCBJKTtcblxuICAgIHRoaXMuaW52SW5lcnRpYS5zZXQoXG4gICAgICAgIEkueCA+IDAgJiYgIWZpeGVkID8gMS4wIC8gSS54IDogMCxcbiAgICAgICAgSS55ID4gMCAmJiAhZml4ZWQgPyAxLjAgLyBJLnkgOiAwLFxuICAgICAgICBJLnogPiAwICYmICFmaXhlZCA/IDEuMCAvIEkueiA6IDBcbiAgICApO1xuICAgIHRoaXMudXBkYXRlSW5lcnRpYVdvcmxkKHRydWUpO1xufTtcblxuLyoqXG4gKiBHZXQgd29ybGQgdmVsb2NpdHkgb2YgYSBwb2ludCBpbiB0aGUgYm9keS5cbiAqIEBtZXRob2QgZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHdvcmxkUG9pbnRcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICogQHJldHVybiB7VmVjM30gVGhlIHJlc3VsdCB2ZWN0b3IuXG4gKi9cbkJvZHkucHJvdG90eXBlLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50ID0gZnVuY3Rpb24od29ybGRQb2ludCwgcmVzdWx0KXtcbiAgICB2YXIgciA9IG5ldyBWZWMzKCk7XG4gICAgd29ybGRQb2ludC52c3ViKHRoaXMucG9zaXRpb24sIHIpO1xuICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHIsIHJlc3VsdCk7XG4gICAgdGhpcy52ZWxvY2l0eS52YWRkKHJlc3VsdCwgcmVzdWx0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRlcmlhbC9NYXRlcmlhbFwiOjI1LFwiLi4vbWF0aC9NYXQzXCI6MjcsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vc2hhcGVzL0JveFwiOjM3LFwiLi4vc2hhcGVzL1NoYXBlXCI6NDMsXCIuLi91dGlscy9FdmVudFRhcmdldFwiOjQ5fV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuL0JvZHknKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIFJheSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBXaGVlbEluZm8gPSBfZGVyZXFfKCcuLi9vYmplY3RzL1doZWVsSW5mbycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJheWNhc3RWZWhpY2xlO1xuXG4vKipcbiAqIFZlaGljbGUgaGVscGVyIGNsYXNzIHRoYXQgY2FzdHMgcmF5cyBmcm9tIHRoZSB3aGVlbCBwb3NpdGlvbnMgdG93YXJkcyB0aGUgZ3JvdW5kIGFuZCBhcHBsaWVzIGZvcmNlcy5cbiAqIEBjbGFzcyBSYXljYXN0VmVoaWNsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge0JvZHl9IFtvcHRpb25zLmNoYXNzaXNCb2R5XSBUaGUgY2FyIGNoYXNzaXMgYm9keS5cbiAqIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMuaW5kZXhSaWdodEF4aXNdIEF4aXMgdG8gdXNlIGZvciByaWdodC4geD0wLCB5PTEsIHo9MlxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleExlZnRBeGlzXVxuICogQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5pbmRleFVwQXhpc11cbiAqL1xuZnVuY3Rpb24gUmF5Y2FzdFZlaGljbGUob3B0aW9ucyl7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhcnJheSBvZiBXaGVlbEluZm8gb2JqZWN0cy5cbiAgICAgKiBAcHJvcGVydHkge2FycmF5fSB3aGVlbEluZm9zXG4gICAgICovXG4gICAgdGhpcy53aGVlbEluZm9zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIHNldCB0byB0cnVlIGlmIHRoZSBjYXIgaXMgc2xpZGluZy5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IHNsaWRpbmdcbiAgICAgKi9cbiAgICB0aGlzLnNsaWRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7V29ybGR9IHdvcmxkXG4gICAgICovXG4gICAgdGhpcy53b3JsZCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBJbmRleCBvZiB0aGUgcmlnaHQgYXhpcywgMD14LCAxPXksIDI9elxuICAgICAqIEBwcm9wZXJ0eSB7aW50ZWdlcn0gaW5kZXhSaWdodEF4aXNcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgdGhpcy5pbmRleFJpZ2h0QXhpcyA9IHR5cGVvZihvcHRpb25zLmluZGV4UmlnaHRBeGlzKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmluZGV4UmlnaHRBeGlzIDogMTtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSBmb3J3YXJkIGF4aXMsIDA9eCwgMT15LCAyPXpcbiAgICAgKiBAcHJvcGVydHkge2ludGVnZXJ9IGluZGV4Rm9yd2FyZEF4aXNcbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5pbmRleEZvcndhcmRBeGlzID0gdHlwZW9mKG9wdGlvbnMuaW5kZXhGb3J3YXJkQXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5pbmRleEZvcndhcmRBeGlzIDogMDtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIHRoZSB1cCBheGlzLCAwPXgsIDE9eSwgMj16XG4gICAgICogQHByb3BlcnR5IHtpbnRlZ2VyfSBpbmRleFVwQXhpc1xuICAgICAqIEBkZWZhdWx0IDJcbiAgICAgKi9cbiAgICB0aGlzLmluZGV4VXBBeGlzID0gdHlwZW9mKG9wdGlvbnMuaW5kZXhVcEF4aXMpICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuaW5kZXhVcEF4aXMgOiAyO1xufVxuXG52YXIgdG1wVmVjMSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMiA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjMyA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNCA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNSA9IG5ldyBWZWMzKCk7XG52YXIgdG1wVmVjNiA9IG5ldyBWZWMzKCk7XG52YXIgdG1wUmF5ID0gbmV3IFJheSgpO1xuXG4vKipcbiAqIEFkZCBhIHdoZWVsLiBGb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9wdGlvbnMsIHNlZSBXaGVlbEluZm8uXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdmFyIGluZm8gPSBuZXcgV2hlZWxJbmZvKG9wdGlvbnMpO1xuICAgIHZhciBpbmRleCA9IHRoaXMud2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdGhpcy53aGVlbEluZm9zLnB1c2goaW5mbyk7XG5cbiAgICByZXR1cm4gaW5kZXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgc3RlZXJpbmcgdmFsdWUgb2YgYSB3aGVlbC5cbiAqIEBtZXRob2Qgc2V0U3RlZXJpbmdWYWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnNldFN0ZWVyaW5nVmFsdWUgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xuICAgIHdoZWVsLnN0ZWVyaW5nID0gdmFsdWU7XG59O1xuXG52YXIgdG9ycXVlID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTZXQgdGhlIHdoZWVsIGZvcmNlIHRvIGFwcGx5IG9uIG9uZSBvZiB0aGUgd2hlZWxzIGVhY2ggdGltZSBzdGVwXG4gKiBAbWV0aG9kIGFwcGx5RW5naW5lRm9yY2VcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFwcGx5RW5naW5lRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmVuZ2luZUZvcmNlID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYnJha2luZyBmb3JjZSBvZiBhIHdoZWVsXG4gKiBAbWV0aG9kIHNldEJyYWtlXG4gKiBAcGFyYW0ge251bWJlcn0gYnJha2VcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICovXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuc2V0QnJha2UgPSBmdW5jdGlvbihicmFrZSwgd2hlZWxJbmRleCl7XG4gICAgdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdLmJyYWtlID0gYnJha2U7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIHRvIHRoZSB3b3JsZC5cbiAqIEBtZXRob2QgYWRkVG9Xb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmFkZFRvV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5hZGQodGhpcy5jaGFzc2lzQm9keSk7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMucHJlU3RlcENhbGxiYWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhhdC51cGRhdGVWZWhpY2xlKHdvcmxkLmR0KTtcbiAgICB9O1xuICAgIHdvcmxkLmFkZEV2ZW50TGlzdGVuZXIoJ3ByZVN0ZXAnLCB0aGlzLnByZVN0ZXBDYWxsYmFjayk7XG4gICAgdGhpcy53b3JsZCA9IHdvcmxkO1xufTtcblxuLyoqXG4gKiBHZXQgb25lIG9mIHRoZSB3aGVlbCBheGxlcywgd29ybGQtb3JpZW50ZWQuXG4gKiBAcHJpdmF0ZVxuICogQG1ldGhvZCBnZXRWZWhpY2xlQXhpc1dvcmxkXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBheGlzSW5kZXhcbiAqIEBwYXJhbSAge1ZlYzN9IHJlc3VsdFxuICovXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUuZ2V0VmVoaWNsZUF4aXNXb3JsZCA9IGZ1bmN0aW9uKGF4aXNJbmRleCwgcmVzdWx0KXtcbiAgICByZXN1bHQuc2V0KFxuICAgICAgICBheGlzSW5kZXggPT09IDAgPyAxIDogMCxcbiAgICAgICAgYXhpc0luZGV4ID09PSAxID8gMSA6IDAsXG4gICAgICAgIGF4aXNJbmRleCA9PT0gMiA/IDEgOiAwXG4gICAgKTtcbiAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShyZXN1bHQsIHJlc3VsdCk7XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlVmVoaWNsZSA9IGZ1bmN0aW9uKHRpbWVTdGVwKXtcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdmFyIGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdGhpcy51cGRhdGVXaGVlbFRyYW5zZm9ybShpKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRWZWhpY2xlU3BlZWRLbUhvdXIgPSAzLjYgKiBjaGFzc2lzQm9keS52ZWxvY2l0eS5ub3JtKCk7XG5cbiAgICB2YXIgZm9yd2FyZFdvcmxkID0gbmV3IFZlYzMoKTtcbiAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmb3J3YXJkV29ybGQpO1xuXG4gICAgaWYgKGZvcndhcmRXb3JsZC5kb3QoY2hhc3Npc0JvZHkudmVsb2NpdHkpIDwgMCl7XG4gICAgICAgIHRoaXMuY3VycmVudFZlaGljbGVTcGVlZEttSG91ciAqPSAtMTtcbiAgICB9XG5cbiAgICAvLyBzaW11bGF0ZSBzdXNwZW5zaW9uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1XaGVlbHM7IGkrKykge1xuICAgICAgICB0aGlzLmNhc3RSYXkod2hlZWxJbmZvc1tpXSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVTdXNwZW5zaW9uKHRpbWVTdGVwKTtcblxuICAgIHZhciBpbXB1bHNlID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgcmVscG9zID0gbmV3IFZlYzMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIC8vYXBwbHkgc3VzcGVuc2lvbiBmb3JjZVxuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuICAgICAgICB2YXIgc3VzcGVuc2lvbkZvcmNlID0gd2hlZWwuc3VzcGVuc2lvbkZvcmNlO1xuICAgICAgICBpZiAoc3VzcGVuc2lvbkZvcmNlID4gd2hlZWwubWF4U3VzcGVuc2lvbkZvcmNlKSB7XG4gICAgICAgICAgICBzdXNwZW5zaW9uRm9yY2UgPSB3aGVlbC5tYXhTdXNwZW5zaW9uRm9yY2U7XG4gICAgICAgIH1cbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShzdXNwZW5zaW9uRm9yY2UgKiB0aW1lU3RlcCwgaW1wdWxzZSk7XG5cbiAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQvKnJlbHBvcyovKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUZyaWN0aW9uKHRpbWVTdGVwKTtcblxuICAgIHZhciBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgZndkICA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIHZlbCA9IG5ldyBWZWMzKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgIC8vdmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgIC8vd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgdmVsKTtcblxuICAgICAgICAvLyBIYWNrIHRvIGdldCB0aGUgcm90YXRpb24gaW4gdGhlIGNvcnJlY3QgZGlyZWN0aW9uXG4gICAgICAgIHZhciBtID0gMTtcbiAgICAgICAgc3dpdGNoKHRoaXMuaW5kZXhVcEF4aXMpe1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBtID0gLTE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbC5pc0luQ29udGFjdCkge1xuXG4gICAgICAgICAgICB0aGlzLmdldFZlaGljbGVBeGlzV29ybGQodGhpcy5pbmRleEZvcndhcmRBeGlzLCBmd2QpO1xuICAgICAgICAgICAgdmFyIHByb2ogPSBmd2QuZG90KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5zY2FsZShwcm9qLCBoaXROb3JtYWxXb3JsZFNjYWxlZFdpdGhQcm9qKTtcblxuICAgICAgICAgICAgZndkLnZzdWIoaGl0Tm9ybWFsV29ybGRTY2FsZWRXaXRoUHJvaiwgZndkKTtcblxuICAgICAgICAgICAgdmFyIHByb2oyID0gZndkLmRvdCh2ZWwpO1xuICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9IG0gKiBwcm9qMiAqIHRpbWVTdGVwIC8gd2hlZWwucmFkaXVzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoKHdoZWVsLnNsaWRpbmcgfHwgIXdoZWVsLmlzSW5Db250YWN0KSAmJiB3aGVlbC5lbmdpbmVGb3JjZSAhPT0gMCAmJiB3aGVlbC51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkKXtcbiAgICAgICAgICAgIC8vIEFwcGx5IGN1c3RvbSByb3RhdGlvbiB3aGVuIGFjY2VsZXJhdGluZyBhbmQgc2xpZGluZ1xuICAgICAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiA9ICh3aGVlbC5lbmdpbmVGb3JjZSA+IDAgPyAxIDogLTEpICogd2hlZWwuY3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZCAqIHRpbWVTdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG9jayB3aGVlbHNcbiAgICAgICAgaWYoTWF0aC5hYnMod2hlZWwuYnJha2UpID4gTWF0aC5hYnMod2hlZWwuZW5naW5lRm9yY2UpKXtcbiAgICAgICAgICAgIHdoZWVsLmRlbHRhUm90YXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwucm90YXRpb24gKz0gd2hlZWwuZGVsdGFSb3RhdGlvbjsgLy8gVXNlIHRoZSBvbGQgdmFsdWVcbiAgICAgICAgd2hlZWwuZGVsdGFSb3RhdGlvbiAqPSAwLjk5OyAvLyBkYW1waW5nIG9mIHJvdGF0aW9uIHdoZW4gbm90IGluIGNvbnRhY3RcbiAgICB9XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlU3VzcGVuc2lvbiA9IGZ1bmN0aW9uKGRlbHRhVGltZSkge1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgdmFyIGNoYXNzaXNNYXNzID0gY2hhc3Npc0JvZHkubWFzcztcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciB3X2l0ID0gMDsgd19pdCA8IG51bVdoZWVsczsgd19pdCsrKXtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1t3X2l0XTtcblxuICAgICAgICBpZiAod2hlZWwuaXNJbkNvbnRhY3Qpe1xuICAgICAgICAgICAgdmFyIGZvcmNlO1xuXG4gICAgICAgICAgICAvLyBTcHJpbmdcbiAgICAgICAgICAgIHZhciBzdXNwX2xlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfbGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgICAgIHZhciBsZW5ndGhfZGlmZiA9IChzdXNwX2xlbmd0aCAtIGN1cnJlbnRfbGVuZ3RoKTtcblxuICAgICAgICAgICAgZm9yY2UgPSB3aGVlbC5zdXNwZW5zaW9uU3RpZmZuZXNzICogbGVuZ3RoX2RpZmYgKiB3aGVlbC5jbGlwcGVkSW52Q29udGFjdERvdFN1c3BlbnNpb247XG5cbiAgICAgICAgICAgIC8vIERhbXBlclxuICAgICAgICAgICAgdmFyIHByb2plY3RlZF9yZWxfdmVsID0gd2hlZWwuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHk7XG4gICAgICAgICAgICB2YXIgc3VzcF9kYW1waW5nO1xuICAgICAgICAgICAgaWYgKHByb2plY3RlZF9yZWxfdmVsIDwgMCkge1xuICAgICAgICAgICAgICAgIHN1c3BfZGFtcGluZyA9IHdoZWVsLmRhbXBpbmdDb21wcmVzc2lvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VzcF9kYW1waW5nID0gd2hlZWwuZGFtcGluZ1JlbGF4YXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JjZSAtPSBzdXNwX2RhbXBpbmcgKiBwcm9qZWN0ZWRfcmVsX3ZlbDtcblxuICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gZm9yY2UgKiBjaGFzc2lzTWFzcztcbiAgICAgICAgICAgIGlmICh3aGVlbC5zdXNwZW5zaW9uRm9yY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkZvcmNlID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25Gb3JjZSA9IDA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgdmVoaWNsZSBpbmNsdWRpbmcgaXRzIGNvbnN0cmFpbnRzIGZyb20gdGhlIHdvcmxkLlxuICogQG1ldGhvZCByZW1vdmVGcm9tV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5yZW1vdmVGcm9tV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB3b3JsZC5yZW1vdmUodGhpcy5jaGFzc2lzQm9keSk7XG4gICAgd29ybGQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncHJlU3RlcCcsIHRoaXMucHJlU3RlcENhbGxiYWNrKTtcbiAgICB0aGlzLndvcmxkID0gbnVsbDtcbn07XG5cbnZhciBjYXN0UmF5X3JheXZlY3RvciA9IG5ldyBWZWMzKCk7XG52YXIgY2FzdFJheV90YXJnZXQgPSBuZXcgVmVjMygpO1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLmNhc3RSYXkgPSBmdW5jdGlvbih3aGVlbCkge1xuICAgIHZhciByYXl2ZWN0b3IgPSBjYXN0UmF5X3JheXZlY3RvcjtcbiAgICB2YXIgdGFyZ2V0ID0gY2FzdFJheV90YXJnZXQ7XG5cbiAgICB0aGlzLnVwZGF0ZVdoZWVsVHJhbnNmb3JtV29ybGQod2hlZWwpO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG5cbiAgICB2YXIgZGVwdGggPSAtMTtcblxuICAgIHZhciByYXlsZW4gPSB3aGVlbC5zdXNwZW5zaW9uUmVzdExlbmd0aCArIHdoZWVsLnJhZGl1cztcblxuICAgIHdoZWVsLmRpcmVjdGlvbldvcmxkLnNjYWxlKHJheWxlbiwgcmF5dmVjdG9yKTtcbiAgICB2YXIgc291cmNlID0gd2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkO1xuICAgIHNvdXJjZS52YWRkKHJheXZlY3RvciwgdGFyZ2V0KTtcbiAgICB2YXIgcmF5Y2FzdFJlc3VsdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQ7XG5cbiAgICB2YXIgcGFyYW0gPSAwO1xuXG4gICAgcmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgIC8vIFR1cm4gb2ZmIHJheSBjb2xsaXNpb24gd2l0aCB0aGUgY2hhc3NpcyB0ZW1wb3JhcmlseVxuICAgIHZhciBvbGRTdGF0ZSA9IGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIGNoYXNzaXNCb2R5LmNvbGxpc2lvblJlc3BvbnNlID0gZmFsc2U7XG5cbiAgICAvLyBDYXN0IHJheSBhZ2FpbnN0IHdvcmxkXG4gICAgdGhpcy53b3JsZC5yYXlUZXN0KHNvdXJjZSwgdGFyZ2V0LCByYXljYXN0UmVzdWx0KTtcbiAgICBjaGFzc2lzQm9keS5jb2xsaXNpb25SZXNwb25zZSA9IG9sZFN0YXRlO1xuXG4gICAgdmFyIG9iamVjdCA9IHJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgIHdoZWVsLnJheWNhc3RSZXN1bHQuZ3JvdW5kT2JqZWN0ID0gMDtcblxuICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgZGVwdGggPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdE5vcm1hbFdvcmxkICA9IHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQ7XG4gICAgICAgIHdoZWVsLmlzSW5Db250YWN0ID0gdHJ1ZTtcblxuICAgICAgICB2YXIgaGl0RGlzdGFuY2UgPSByYXljYXN0UmVzdWx0LmRpc3RhbmNlO1xuICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gaGl0RGlzdGFuY2UgLSB3aGVlbC5yYWRpdXM7XG5cbiAgICAgICAgLy8gY2xhbXAgb24gbWF4IHN1c3BlbnNpb24gdHJhdmVsXG4gICAgICAgIHZhciBtaW5TdXNwZW5zaW9uTGVuZ3RoID0gd2hlZWwuc3VzcGVuc2lvblJlc3RMZW5ndGggLSB3aGVlbC5tYXhTdXNwZW5zaW9uVHJhdmVsO1xuICAgICAgICB2YXIgbWF4U3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgd2hlZWwubWF4U3VzcGVuc2lvblRyYXZlbDtcbiAgICAgICAgaWYgKHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPCBtaW5TdXNwZW5zaW9uTGVuZ3RoKSB7XG4gICAgICAgICAgICB3aGVlbC5zdXNwZW5zaW9uTGVuZ3RoID0gbWluU3VzcGVuc2lvbkxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA+IG1heFN1c3BlbnNpb25MZW5ndGgpIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25MZW5ndGggPSBtYXhTdXNwZW5zaW9uTGVuZ3RoO1xuICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRlbm9taW5hdG9yID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3Qod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuXG4gICAgICAgIHZhciBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCA9IG5ldyBWZWMzKCk7XG4gICAgICAgIGNoYXNzaXNCb2R5LmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHdoZWVsLnJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZCwgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQpO1xuXG4gICAgICAgIHZhciBwcm9qVmVsID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XG5cbiAgICAgICAgaWYgKGRlbm9taW5hdG9yID49IC0wLjEpIHtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMDtcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEgLyAwLjE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW52ID0gLTEgLyBkZW5vbWluYXRvcjtcbiAgICAgICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IGludjtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgICAvL3B1dCB3aGVlbCBpbmZvIGFzIGluIHJlc3QgcG9zaXRpb25cbiAgICAgICAgd2hlZWwuc3VzcGVuc2lvbkxlbmd0aCA9IHdoZWVsLnN1c3BlbnNpb25SZXN0TGVuZ3RoICsgMCAqIHdoZWVsLm1heFN1c3BlbnNpb25UcmF2ZWw7XG4gICAgICAgIHdoZWVsLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gMC4wO1xuICAgICAgICB3aGVlbC5kaXJlY3Rpb25Xb3JsZC5zY2FsZSgtMSwgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZCk7XG4gICAgICAgIHdoZWVsLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVwdGg7XG59O1xuXG5SYXljYXN0VmVoaWNsZS5wcm90b3R5cGUudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCA9IGZ1bmN0aW9uKHdoZWVsKXtcbiAgICB3aGVlbC5pc0luQ29udGFjdCA9IGZhbHNlO1xuICAgIHZhciBjaGFzc2lzQm9keSA9IHRoaXMuY2hhc3Npc0JvZHk7XG4gICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUod2hlZWwuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsLCB3aGVlbC5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5kaXJlY3Rpb25Mb2NhbCwgd2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIGNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZSh3aGVlbC5heGxlTG9jYWwsIHdoZWVsLmF4bGVXb3JsZCk7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIG9uZSBvZiB0aGUgd2hlZWwgdHJhbnNmb3JtLlxuICogTm90ZSB3aGVuIHJlbmRlcmluZyB3aGVlbHM6IGR1cmluZyBlYWNoIHN0ZXAsIHdoZWVsIHRyYW5zZm9ybXMgYXJlIHVwZGF0ZWQgQkVGT1JFIHRoZSBjaGFzc2lzOyBpZS4gdGhlaXIgcG9zaXRpb24gYmVjb21lcyBpbnZhbGlkIGFmdGVyIHRoZSBzdGVwLiBUaHVzIHdoZW4geW91IHJlbmRlciB3aGVlbHMsIHlvdSBtdXN0IHVwZGF0ZSB3aGVlbCB0cmFuc2Zvcm1zIGJlZm9yZSByZW5kZXJpbmcgdGhlbS4gU2VlIHJheWNhc3RWZWhpY2xlIGRlbW8gZm9yIGFuIGV4YW1wbGUuXG4gKiBAbWV0aG9kIHVwZGF0ZVdoZWVsVHJhbnNmb3JtXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHdoZWVsSW5kZXggVGhlIHdoZWVsIGluZGV4IHRvIHVwZGF0ZS5cbiAqL1xuUmF5Y2FzdFZlaGljbGUucHJvdG90eXBlLnVwZGF0ZVdoZWVsVHJhbnNmb3JtID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIHVwID0gdG1wVmVjNDtcbiAgICB2YXIgcmlnaHQgPSB0bXBWZWM1O1xuICAgIHZhciBmd2QgPSB0bXBWZWM2O1xuXG4gICAgdmFyIHdoZWVsID0gdGhpcy53aGVlbEluZm9zW3doZWVsSW5kZXhdO1xuICAgIHRoaXMudXBkYXRlV2hlZWxUcmFuc2Zvcm1Xb3JsZCh3aGVlbCk7XG5cbiAgICB3aGVlbC5kaXJlY3Rpb25Mb2NhbC5zY2FsZSgtMSwgdXApO1xuICAgIHJpZ2h0LmNvcHkod2hlZWwuYXhsZUxvY2FsKTtcbiAgICB1cC5jcm9zcyhyaWdodCwgZndkKTtcbiAgICBmd2Qubm9ybWFsaXplKCk7XG4gICAgcmlnaHQubm9ybWFsaXplKCk7XG5cbiAgICAvLyBSb3RhdGUgYXJvdW5kIHN0ZWVyaW5nIG92ZXIgdGhlIHdoZWVsQXhsZVxuICAgIHZhciBzdGVlcmluZyA9IHdoZWVsLnN0ZWVyaW5nO1xuICAgIHZhciBzdGVlcmluZ09ybiA9IG5ldyBRdWF0ZXJuaW9uKCk7XG4gICAgc3RlZXJpbmdPcm4uc2V0RnJvbUF4aXNBbmdsZSh1cCwgc3RlZXJpbmcpO1xuXG4gICAgdmFyIHJvdGF0aW5nT3JuID0gbmV3IFF1YXRlcm5pb24oKTtcbiAgICByb3RhdGluZ09ybi5zZXRGcm9tQXhpc0FuZ2xlKHJpZ2h0LCB3aGVlbC5yb3RhdGlvbik7XG5cbiAgICAvLyBXb3JsZCByb3RhdGlvbiBvZiB0aGUgd2hlZWxcbiAgICB2YXIgcSA9IHdoZWVsLndvcmxkVHJhbnNmb3JtLnF1YXRlcm5pb247XG4gICAgdGhpcy5jaGFzc2lzQm9keS5xdWF0ZXJuaW9uLm11bHQoc3RlZXJpbmdPcm4sIHEpO1xuICAgIHEubXVsdChyb3RhdGluZ09ybiwgcSk7XG5cbiAgICBxLm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gd29ybGQgcG9zaXRpb24gb2YgdGhlIHdoZWVsXG4gICAgdmFyIHAgPSB3aGVlbC53b3JsZFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICBwLmNvcHkod2hlZWwuZGlyZWN0aW9uV29ybGQpO1xuICAgIHAuc2NhbGUod2hlZWwuc3VzcGVuc2lvbkxlbmd0aCwgcCk7XG4gICAgcC52YWRkKHdoZWVsLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZCwgcCk7XG59O1xuXG52YXIgZGlyZWN0aW9ucyA9IFtcbiAgICBuZXcgVmVjMygxLCAwLCAwKSxcbiAgICBuZXcgVmVjMygwLCAxLCAwKSxcbiAgICBuZXcgVmVjMygwLCAwLCAxKVxuXTtcblxuLyoqXG4gKiBHZXQgdGhlIHdvcmxkIHRyYW5zZm9ybSBvZiBvbmUgb2YgdGhlIHdoZWVsc1xuICogQG1ldGhvZCBnZXRXaGVlbFRyYW5zZm9ybVdvcmxkXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKiBAcmV0dXJuIHtUcmFuc2Zvcm19XG4gKi9cblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkID0gZnVuY3Rpb24od2hlZWxJbmRleCkge1xuICAgIHJldHVybiB0aGlzLndoZWVsSW5mb3Nbd2hlZWxJbmRleF0ud29ybGRUcmFuc2Zvcm07XG59O1xuXG5cbnZhciB1cGRhdGVGcmljdGlvbl9zdXJmTm9ybWFsV1Nfc2NhbGVkX3Byb2ogPSBuZXcgVmVjMygpO1xudmFyIHVwZGF0ZUZyaWN0aW9uX2F4bGUgPSBbXTtcbnZhciB1cGRhdGVGcmljdGlvbl9mb3J3YXJkV1MgPSBbXTtcbnZhciBzaWRlRnJpY3Rpb25TdGlmZm5lc3MyID0gMTtcblJheWNhc3RWZWhpY2xlLnByb3RvdHlwZS51cGRhdGVGcmljdGlvbiA9IGZ1bmN0aW9uKHRpbWVTdGVwKSB7XG4gICAgdmFyIHN1cmZOb3JtYWxXU19zY2FsZWRfcHJvaiA9IHVwZGF0ZUZyaWN0aW9uX3N1cmZOb3JtYWxXU19zY2FsZWRfcHJvajtcblxuICAgIC8vY2FsY3VsYXRlIHRoZSBpbXB1bHNlLCBzbyB0aGF0IHRoZSB3aGVlbHMgZG9uJ3QgbW92ZSBzaWRld2FyZHNcbiAgICB2YXIgd2hlZWxJbmZvcyA9IHRoaXMud2hlZWxJbmZvcztcbiAgICB2YXIgbnVtV2hlZWxzID0gd2hlZWxJbmZvcy5sZW5ndGg7XG4gICAgdmFyIGNoYXNzaXNCb2R5ID0gdGhpcy5jaGFzc2lzQm9keTtcbiAgICB2YXIgZm9yd2FyZFdTID0gdXBkYXRlRnJpY3Rpb25fZm9yd2FyZFdTO1xuICAgIHZhciBheGxlID0gdXBkYXRlRnJpY3Rpb25fYXhsZTtcblxuICAgIHZhciBudW1XaGVlbHNPbkdyb3VuZCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVdoZWVsczsgaSsrKSB7XG4gICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG5cbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCl7XG4gICAgICAgICAgICBudW1XaGVlbHNPbkdyb3VuZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hlZWwuc2lkZUltcHVsc2UgPSAwO1xuICAgICAgICB3aGVlbC5mb3J3YXJkSW1wdWxzZSA9IDA7XG4gICAgICAgIGlmKCFmb3J3YXJkV1NbaV0pe1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZighYXhsZVtpXSl7XG4gICAgICAgICAgICBheGxlW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspe1xuICAgICAgICB2YXIgd2hlZWwgPSB3aGVlbEluZm9zW2ldO1xuXG4gICAgICAgIHZhciBncm91bmRPYmplY3QgPSB3aGVlbC5yYXljYXN0UmVzdWx0LmJvZHk7XG5cbiAgICAgICAgaWYgKGdyb3VuZE9iamVjdCkge1xuICAgICAgICAgICAgdmFyIGF4bGVpID0gYXhsZVtpXTtcbiAgICAgICAgICAgIHZhciB3aGVlbFRyYW5zID0gdGhpcy5nZXRXaGVlbFRyYW5zZm9ybVdvcmxkKGkpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgYXhsZVxuICAgICAgICAgICAgd2hlZWxUcmFucy52ZWN0b3JUb1dvcmxkRnJhbWUoZGlyZWN0aW9uc1t0aGlzLmluZGV4UmlnaHRBeGlzXSwgYXhsZWkpO1xuXG4gICAgICAgICAgICB2YXIgc3VyZk5vcm1hbFdTID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZDtcbiAgICAgICAgICAgIHZhciBwcm9qID0gYXhsZWkuZG90KHN1cmZOb3JtYWxXUyk7XG4gICAgICAgICAgICBzdXJmTm9ybWFsV1Muc2NhbGUocHJvaiwgc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qKTtcbiAgICAgICAgICAgIGF4bGVpLnZzdWIoc3VyZk5vcm1hbFdTX3NjYWxlZF9wcm9qLCBheGxlaSk7XG4gICAgICAgICAgICBheGxlaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgc3VyZk5vcm1hbFdTLmNyb3NzKGF4bGVpLCBmb3J3YXJkV1NbaV0pO1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgICAgICB3aGVlbC5zaWRlSW1wdWxzZSA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoXG4gICAgICAgICAgICAgICAgY2hhc3Npc0JvZHksXG4gICAgICAgICAgICAgICAgd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLFxuICAgICAgICAgICAgICAgIGdyb3VuZE9iamVjdCxcbiAgICAgICAgICAgICAgICB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsXG4gICAgICAgICAgICAgICAgYXhsZWlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHNpZGVGcmljdGlvblN0aWZmbmVzczI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc2lkZUZhY3RvciA9IDE7XG4gICAgdmFyIGZ3ZEZhY3RvciA9IDAuNTtcblxuICAgIHRoaXMuc2xpZGluZyA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcbiAgICAgICAgdmFyIGdyb3VuZE9iamVjdCA9IHdoZWVsLnJheWNhc3RSZXN1bHQuYm9keTtcblxuICAgICAgICB2YXIgcm9sbGluZ0ZyaWN0aW9uID0gMDtcblxuICAgICAgICB3aGVlbC5zbGlwSW5mbyA9IDE7XG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZSA9IDA7XG4gICAgICAgICAgICB2YXIgbWF4SW1wdWxzZSA9IHdoZWVsLmJyYWtlID8gd2hlZWwuYnJha2UgOiBkZWZhdWx0Um9sbGluZ0ZyaWN0aW9uSW1wdWxzZTtcblxuICAgICAgICAgICAgLy8gYnRXaGVlbENvbnRhY3RQb2ludCBjb250YWN0UHQoY2hhc3Npc0JvZHksZ3JvdW5kT2JqZWN0LHdoZWVsSW5mcmF5Y2FzdEluZm8uaGl0UG9pbnRXb3JsZCxmb3J3YXJkV1Nbd2hlZWxdLG1heEltcHVsc2UpO1xuICAgICAgICAgICAgLy8gcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjb250YWN0UHQpO1xuICAgICAgICAgICAgcm9sbGluZ0ZyaWN0aW9uID0gY2FsY1JvbGxpbmdGcmljdGlvbihjaGFzc2lzQm9keSwgZ3JvdW5kT2JqZWN0LCB3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQsIGZvcndhcmRXU1tpXSwgbWF4SW1wdWxzZSk7XG5cbiAgICAgICAgICAgIHJvbGxpbmdGcmljdGlvbiArPSB3aGVlbC5lbmdpbmVGb3JjZSAqIHRpbWVTdGVwO1xuXG4gICAgICAgICAgICAvLyByb2xsaW5nRnJpY3Rpb24gPSAwO1xuICAgICAgICAgICAgdmFyIGZhY3RvciA9IG1heEltcHVsc2UgLyByb2xsaW5nRnJpY3Rpb247XG4gICAgICAgICAgICB3aGVlbC5zbGlwSW5mbyAqPSBmYWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvL3N3aXRjaCBiZXR3ZWVuIGFjdGl2ZSByb2xsaW5nICh0aHJvdHRsZSksIGJyYWtpbmcgYW5kIG5vbi1hY3RpdmUgcm9sbGluZyBmcmljdGlvbiAobnRocm90dGxlL2JyZWFrKVxuXG4gICAgICAgIHdoZWVsLmZvcndhcmRJbXB1bHNlID0gMDtcbiAgICAgICAgd2hlZWwuc2tpZEluZm8gPSAxO1xuXG4gICAgICAgIGlmIChncm91bmRPYmplY3QpIHtcbiAgICAgICAgICAgIHdoZWVsLnNraWRJbmZvID0gMTtcblxuICAgICAgICAgICAgdmFyIG1heGltcCA9IHdoZWVsLnN1c3BlbnNpb25Gb3JjZSAqIHRpbWVTdGVwICogd2hlZWwuZnJpY3Rpb25TbGlwO1xuICAgICAgICAgICAgdmFyIG1heGltcFNpZGUgPSBtYXhpbXA7XG5cbiAgICAgICAgICAgIHZhciBtYXhpbXBTcXVhcmVkID0gbWF4aW1wICogbWF4aW1wU2lkZTtcblxuICAgICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgPSByb2xsaW5nRnJpY3Rpb247Ly93aGVlbEluZm8uZW5naW5lRm9yY2UqIHRpbWVTdGVwO1xuXG4gICAgICAgICAgICB2YXIgeCA9IHdoZWVsLmZvcndhcmRJbXB1bHNlICogZndkRmFjdG9yO1xuICAgICAgICAgICAgdmFyIHkgPSB3aGVlbC5zaWRlSW1wdWxzZSAqIHNpZGVGYWN0b3I7XG5cbiAgICAgICAgICAgIHZhciBpbXB1bHNlU3F1YXJlZCA9IHggKiB4ICsgeSAqIHk7XG5cbiAgICAgICAgICAgIHdoZWVsLnNsaWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpbXB1bHNlU3F1YXJlZCA+IG1heGltcFNxdWFyZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNsaWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdoZWVsLnNsaWRpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGZhY3RvciA9IG1heGltcCAvIE1hdGguc3FydChpbXB1bHNlU3F1YXJlZCk7XG5cbiAgICAgICAgICAgICAgICB3aGVlbC5za2lkSW5mbyAqPSBmYWN0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5zbGlkaW5nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB3aGVlbCA9IHdoZWVsSW5mb3NbaV07XG4gICAgICAgICAgICBpZiAod2hlZWwuc2lkZUltcHVsc2UgIT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAod2hlZWwuc2tpZEluZm8gPCAxKXtcbiAgICAgICAgICAgICAgICAgICAgd2hlZWwuZm9yd2FyZEltcHVsc2UgKj0gd2hlZWwuc2tpZEluZm87XG4gICAgICAgICAgICAgICAgICAgIHdoZWVsLnNpZGVJbXB1bHNlICo9IHdoZWVsLnNraWRJbmZvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRoZSBpbXB1bHNlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtV2hlZWxzOyBpKyspIHtcbiAgICAgICAgdmFyIHdoZWVsID0gd2hlZWxJbmZvc1tpXTtcblxuICAgICAgICB2YXIgcmVsX3BvcyA9IG5ldyBWZWMzKCk7XG4gICAgICAgIC8vd2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkLnZzdWIoY2hhc3Npc0JvZHkucG9zaXRpb24sIHJlbF9wb3MpO1xuICAgICAgICAvLyBjYW5ub25zIGFwcGx5aW1wdWxzZSBpcyB1c2luZyB3b3JsZCBjb29yZCBmb3IgdGhlIHBvc2l0aW9uXG4gICAgICAgIHJlbF9wb3MuY29weSh3aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQpO1xuXG4gICAgICAgIGlmICh3aGVlbC5mb3J3YXJkSW1wdWxzZSAhPT0gMCkge1xuICAgICAgICAgICAgdmFyIGltcHVsc2UgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgZm9yd2FyZFdTW2ldLnNjYWxlKHdoZWVsLmZvcndhcmRJbXB1bHNlLCBpbXB1bHNlKTtcbiAgICAgICAgICAgIGNoYXNzaXNCb2R5LmFwcGx5SW1wdWxzZShpbXB1bHNlLCByZWxfcG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aGVlbC5zaWRlSW1wdWxzZSAhPT0gMCl7XG4gICAgICAgICAgICB2YXIgZ3JvdW5kT2JqZWN0ID0gd2hlZWwucmF5Y2FzdFJlc3VsdC5ib2R5O1xuXG4gICAgICAgICAgICB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgLy93aGVlbC5yYXljYXN0UmVzdWx0LmhpdFBvaW50V29ybGQudnN1Yihncm91bmRPYmplY3QucG9zaXRpb24sIHJlbF9wb3MyKTtcbiAgICAgICAgICAgIHJlbF9wb3MyLmNvcHkod2hlZWwucmF5Y2FzdFJlc3VsdC5oaXRQb2ludFdvcmxkKTtcbiAgICAgICAgICAgIHZhciBzaWRlSW1wID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgIGF4bGVbaV0uc2NhbGUod2hlZWwuc2lkZUltcHVsc2UsIHNpZGVJbXApO1xuXG4gICAgICAgICAgICAvLyBTY2FsZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gaW4gdGhlIHVwIGRpcmVjdGlvbiB3aXRoIHJvbGxJbmZsdWVuY2UuXG4gICAgICAgICAgICAvLyBJZiByb2xsSW5mbHVlbmNlIGlzIDEsIHRoZSBpbXB1bHNlIHdpbGwgYmUgYXBwbGllZCBvbiB0aGUgaGl0UG9pbnQgKGVhc3kgdG8gcm9sbCBvdmVyKSwgaWYgaXQgaXMgemVybyBpdCB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIHNhbWUgcGxhbmUgYXMgdGhlIGNlbnRlciBvZiBtYXNzIChub3QgZWFzeSB0byByb2xsIG92ZXIpLlxuICAgICAgICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb0xvY2FsRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XG4gICAgICAgICAgICByZWxfcG9zWyd4eXonW3RoaXMuaW5kZXhVcEF4aXNdXSAqPSB3aGVlbC5yb2xsSW5mbHVlbmNlO1xuICAgICAgICAgICAgY2hhc3Npc0JvZHkucG9pbnRUb1dvcmxkRnJhbWUocmVsX3BvcywgcmVsX3Bvcyk7XG4gICAgICAgICAgICBjaGFzc2lzQm9keS5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3Bvcyk7XG5cbiAgICAgICAgICAgIC8vYXBwbHkgZnJpY3Rpb24gaW1wdWxzZSBvbiB0aGUgZ3JvdW5kXG4gICAgICAgICAgICBzaWRlSW1wLnNjYWxlKC0xLCBzaWRlSW1wKTtcbiAgICAgICAgICAgIGdyb3VuZE9iamVjdC5hcHBseUltcHVsc2Uoc2lkZUltcCwgcmVsX3BvczIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMSA9IG5ldyBWZWMzKCk7XG52YXIgY2FsY1JvbGxpbmdGcmljdGlvbl92ZWwyID0gbmV3IFZlYzMoKTtcbnZhciBjYWxjUm9sbGluZ0ZyaWN0aW9uX3ZlbCA9IG5ldyBWZWMzKCk7XG5cbmZ1bmN0aW9uIGNhbGNSb2xsaW5nRnJpY3Rpb24oYm9keTAsIGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkLCBtYXhJbXB1bHNlKSB7XG4gICAgdmFyIGoxID0gMDtcbiAgICB2YXIgY29udGFjdFBvc1dvcmxkID0gZnJpY3Rpb25Qb3NXb3JsZDtcblxuICAgIC8vIHZhciByZWxfcG9zMSA9IG5ldyBWZWMzKCk7XG4gICAgLy8gdmFyIHJlbF9wb3MyID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgdmVsMSA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMTtcbiAgICB2YXIgdmVsMiA9IGNhbGNSb2xsaW5nRnJpY3Rpb25fdmVsMjtcbiAgICB2YXIgdmVsID0gY2FsY1JvbGxpbmdGcmljdGlvbl92ZWw7XG4gICAgLy8gY29udGFjdFBvc1dvcmxkLnZzdWIoYm9keTAucG9zaXRpb24sIHJlbF9wb3MxKTtcbiAgICAvLyBjb250YWN0UG9zV29ybGQudnN1Yihib2R5MS5wb3NpdGlvbiwgcmVsX3BvczIpO1xuXG4gICAgYm9keTAuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQoY29udGFjdFBvc1dvcmxkLCB2ZWwxKTtcbiAgICBib2R5MS5nZXRWZWxvY2l0eUF0V29ybGRQb2ludChjb250YWN0UG9zV29ybGQsIHZlbDIpO1xuICAgIHZlbDEudnN1Yih2ZWwyLCB2ZWwpO1xuXG4gICAgdmFyIHZyZWwgPSBmcmljdGlvbkRpcmVjdGlvbldvcmxkLmRvdCh2ZWwpO1xuXG4gICAgdmFyIGRlbm9tMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keTAsIGZyaWN0aW9uUG9zV29ybGQsIGZyaWN0aW9uRGlyZWN0aW9uV29ybGQpO1xuICAgIHZhciBkZW5vbTEgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yKGJvZHkxLCBmcmljdGlvblBvc1dvcmxkLCBmcmljdGlvbkRpcmVjdGlvbldvcmxkKTtcbiAgICB2YXIgcmVsYXhhdGlvbiA9IDE7XG4gICAgdmFyIGphY0RpYWdBQkludiA9IHJlbGF4YXRpb24gLyAoZGVub20wICsgZGVub20xKTtcblxuICAgIC8vIGNhbGN1bGF0ZSBqIHRoYXQgbW92ZXMgdXMgdG8gemVybyByZWxhdGl2ZSB2ZWxvY2l0eVxuICAgIGoxID0gLXZyZWwgKiBqYWNEaWFnQUJJbnY7XG5cbiAgICBpZiAobWF4SW1wdWxzZSA8IGoxKSB7XG4gICAgICAgIGoxID0gbWF4SW1wdWxzZTtcbiAgICB9XG4gICAgaWYgKGoxIDwgLW1heEltcHVsc2UpIHtcbiAgICAgICAgajEgPSAtbWF4SW1wdWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gajE7XG59XG5cbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwID0gbmV3IFZlYzMoKTtcbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX2MwID0gbmV3IFZlYzMoKTtcbnZhciBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3ZlYyA9IG5ldyBWZWMzKCk7XG52YXIgY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tID0gbmV3IFZlYzMoKTtcbmZ1bmN0aW9uIGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3IoYm9keSwgcG9zLCBub3JtYWwpIHtcbiAgICB2YXIgcjAgPSBjb21wdXRlSW1wdWxzZURlbm9taW5hdG9yX3IwO1xuICAgIHZhciBjMCA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfYzA7XG4gICAgdmFyIHZlYyA9IGNvbXB1dGVJbXB1bHNlRGVub21pbmF0b3JfdmVjO1xuICAgIHZhciBtID0gY29tcHV0ZUltcHVsc2VEZW5vbWluYXRvcl9tO1xuXG4gICAgcG9zLnZzdWIoYm9keS5wb3NpdGlvbiwgcjApO1xuICAgIHIwLmNyb3NzKG5vcm1hbCwgYzApO1xuICAgIGJvZHkuaW52SW5lcnRpYVdvcmxkLnZtdWx0KGMwLCBtKTtcbiAgICBtLmNyb3NzKHIwLCB2ZWMpO1xuXG4gICAgcmV0dXJuIGJvZHkuaW52TWFzcyArIG5vcm1hbC5kb3QodmVjKTtcbn1cblxuXG52YXIgcmVzb2x2ZVNpbmdsZUJpbGF0ZXJhbF92ZWwxID0gbmV3IFZlYzMoKTtcbnZhciByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDIgPSBuZXcgVmVjMygpO1xudmFyIHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsID0gbmV3IFZlYzMoKTtcblxuLy9iaWxhdGVyYWwgY29uc3RyYWludCBiZXR3ZWVuIHR3byBkeW5hbWljIG9iamVjdHNcbmZ1bmN0aW9uIHJlc29sdmVTaW5nbGVCaWxhdGVyYWwoYm9keTEsIHBvczEsIGJvZHkyLCBwb3MyLCBub3JtYWwsIGltcHVsc2Upe1xuICAgIHZhciBub3JtYWxMZW5TcXIgPSBub3JtYWwubm9ybTIoKTtcbiAgICBpZiAobm9ybWFsTGVuU3FyID4gMS4xKXtcbiAgICAgICAgcmV0dXJuIDA7IC8vIG5vIGltcHVsc2VcbiAgICB9XG4gICAgLy8gdmFyIHJlbF9wb3MxID0gbmV3IFZlYzMoKTtcbiAgICAvLyB2YXIgcmVsX3BvczIgPSBuZXcgVmVjMygpO1xuICAgIC8vIHBvczEudnN1Yihib2R5MS5wb3NpdGlvbiwgcmVsX3BvczEpO1xuICAgIC8vIHBvczIudnN1Yihib2R5Mi5wb3NpdGlvbiwgcmVsX3BvczIpO1xuXG4gICAgdmFyIHZlbDEgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDE7XG4gICAgdmFyIHZlbDIgPSByZXNvbHZlU2luZ2xlQmlsYXRlcmFsX3ZlbDI7XG4gICAgdmFyIHZlbCA9IHJlc29sdmVTaW5nbGVCaWxhdGVyYWxfdmVsO1xuICAgIGJvZHkxLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHBvczEsIHZlbDEpO1xuICAgIGJvZHkyLmdldFZlbG9jaXR5QXRXb3JsZFBvaW50KHBvczIsIHZlbDIpO1xuXG4gICAgdmVsMS52c3ViKHZlbDIsIHZlbCk7XG5cbiAgICB2YXIgcmVsX3ZlbCA9IG5vcm1hbC5kb3QodmVsKTtcblxuICAgIHZhciBjb250YWN0RGFtcGluZyA9IDAuMjtcbiAgICB2YXIgbWFzc1Rlcm0gPSAxIC8gKGJvZHkxLmludk1hc3MgKyBib2R5Mi5pbnZNYXNzKTtcbiAgICB2YXIgaW1wdWxzZSA9IC0gY29udGFjdERhbXBpbmcgKiByZWxfdmVsICogbWFzc1Rlcm07XG5cbiAgICByZXR1cm4gaW1wdWxzZTtcbn1cbn0se1wiLi4vY29sbGlzaW9uL1JheVwiOjksXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEwLFwiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4uL29iamVjdHMvV2hlZWxJbmZvXCI6MzYsXCIuL0JvZHlcIjozMX1dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi9Cb2R5Jyk7XG52YXIgU3BoZXJlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NwaGVyZScpO1xudmFyIEJveCA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Cb3gnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgSGluZ2VDb25zdHJhaW50ID0gX2RlcmVxXygnLi4vY29uc3RyYWludHMvSGluZ2VDb25zdHJhaW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmlnaWRWZWhpY2xlO1xuXG4vKipcbiAqIFNpbXBsZSB2ZWhpY2xlIGhlbHBlciBjbGFzcyB3aXRoIHNwaGVyaWNhbCByaWdpZCBib2R5IHdoZWVscy5cbiAqIEBjbGFzcyBSaWdpZFZlaGljbGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5jaGFzc2lzQm9keV1cbiAqL1xuZnVuY3Rpb24gUmlnaWRWZWhpY2xlKG9wdGlvbnMpe1xuICAgIHRoaXMud2hlZWxCb2RpZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBjb29yZGluYXRlU3lzdGVtXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5jb29yZGluYXRlU3lzdGVtID0gdHlwZW9mKG9wdGlvbnMuY29vcmRpbmF0ZVN5c3RlbSk9PT0ndW5kZWZpbmVkJyA/IG5ldyBWZWMzKDEsIDIsIDMpIDogb3B0aW9ucy5jb29yZGluYXRlU3lzdGVtLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge0JvZHl9IGNoYXNzaXNCb2R5XG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQm9keSA9IG9wdGlvbnMuY2hhc3Npc0JvZHk7XG5cbiAgICBpZighdGhpcy5jaGFzc2lzQm9keSl7XG4gICAgICAgIC8vIE5vIGNoYXNzaXMgYm9keSBnaXZlbi4gQ3JlYXRlIGl0IVxuICAgICAgICB2YXIgY2hhc3Npc1NoYXBlID0gbmV3IEJveChuZXcgVmVjMyg1LCAyLCAwLjUpKTtcbiAgICAgICAgdGhpcy5jaGFzc2lzQm9keSA9IG5ldyBCb2R5KDEsIGNoYXNzaXNTaGFwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIHRoaXMud2hlZWxBeGVzID0gW107XG4gICAgdGhpcy53aGVlbEZvcmNlcyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIHdoZWVsXG4gKiBAbWV0aG9kIGFkZFdoZWVsXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0Zyb250V2hlZWxdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLnBvc2l0aW9uXSBQb3NpdGlvbiBvZiB0aGUgd2hlZWwsIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keS5cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuZGlyZWN0aW9uXSBTbGlkZSBkaXJlY3Rpb24gb2YgdGhlIHdoZWVsIGFsb25nIHRoZSBzdXNwZW5zaW9uLlxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGlzXSBBeGlzIG9mIHJvdGF0aW9uIG9mIHRoZSB3aGVlbCwgbG9jYWxseSBkZWZpbmVkIGluIHRoZSBjaGFzc2lzLlxuICogQHBhcmFtIHtCb2R5fSBbb3B0aW9ucy5ib2R5XSBUaGUgd2hlZWwgYm9keS5cbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hZGRXaGVlbCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciB3aGVlbEJvZHkgPSBvcHRpb25zLmJvZHk7XG4gICAgaWYoIXdoZWVsQm9keSl7XG4gICAgICAgIHdoZWVsQm9keSA9ICBuZXcgQm9keSgxLCBuZXcgU3BoZXJlKDEuMikpO1xuICAgIH1cbiAgICB0aGlzLndoZWVsQm9kaWVzLnB1c2god2hlZWxCb2R5KTtcbiAgICB0aGlzLndoZWVsRm9yY2VzLnB1c2goMCk7XG5cbiAgICAvLyBQb3NpdGlvbiBjb25zdHJhaW4gd2hlZWxzXG4gICAgdmFyIHplcm8gPSBuZXcgVmVjMygpO1xuICAgIHZhciBwb3NpdGlvbiA9IHR5cGVvZihvcHRpb25zLnBvc2l0aW9uKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnBvc2l0aW9uLmNsb25lKCkgOiBuZXcgVmVjMygpO1xuXG4gICAgLy8gU2V0IHBvc2l0aW9uIGxvY2FsbHkgdG8gdGhlIGNoYXNzaXNcbiAgICB2YXIgd29ybGRQb3NpdGlvbiA9IG5ldyBWZWMzKCk7XG4gICAgdGhpcy5jaGFzc2lzQm9keS5wb2ludFRvV29ybGRGcmFtZShwb3NpdGlvbiwgd29ybGRQb3NpdGlvbik7XG4gICAgd2hlZWxCb2R5LnBvc2l0aW9uLnNldCh3b3JsZFBvc2l0aW9uLngsIHdvcmxkUG9zaXRpb24ueSwgd29ybGRQb3NpdGlvbi56KTtcblxuICAgIC8vIENvbnN0cmFpbiB3aGVlbFxuICAgIHZhciBheGlzID0gdHlwZW9mKG9wdGlvbnMuYXhpcykgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5heGlzLmNsb25lKCkgOiBuZXcgVmVjMygwLCAxLCAwKTtcbiAgICB0aGlzLndoZWVsQXhlcy5wdXNoKGF4aXMpO1xuXG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IG5ldyBIaW5nZUNvbnN0cmFpbnQodGhpcy5jaGFzc2lzQm9keSwgd2hlZWxCb2R5LCB7XG4gICAgICAgIHBpdm90QTogcG9zaXRpb24sXG4gICAgICAgIGF4aXNBOiBheGlzLFxuICAgICAgICBwaXZvdEI6IFZlYzMuWkVSTyxcbiAgICAgICAgYXhpc0I6IGF4aXMsXG4gICAgICAgIGNvbGxpZGVDb25uZWN0ZWQ6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGhpbmdlQ29uc3RyYWludCk7XG5cbiAgICByZXR1cm4gdGhpcy53aGVlbEJvZGllcy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHN0ZWVyaW5nIHZhbHVlIG9mIGEgd2hlZWwuXG4gKiBAbWV0aG9kIHNldFN0ZWVyaW5nVmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKiBAdG9kbyBjaGVjayBjb29yZGluYXRlU3lzdGVtXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0U3RlZXJpbmdWYWx1ZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICAvLyBTZXQgYW5nbGUgb2YgdGhlIGhpbmdlIGF4aXNcbiAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xuXG4gICAgdmFyIGMgPSBNYXRoLmNvcyh2YWx1ZSksXG4gICAgICAgIHMgPSBNYXRoLnNpbih2YWx1ZSksXG4gICAgICAgIHggPSBheGlzLngsXG4gICAgICAgIHkgPSBheGlzLnk7XG4gICAgdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XS5heGlzQS5zZXQoXG4gICAgICAgIGMqeCAtcyp5LFxuICAgICAgICBzKnggK2MqeSxcbiAgICAgICAgMFxuICAgICk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdGFyZ2V0IHJvdGF0aW9uYWwgc3BlZWQgb2YgdGhlIGhpbmdlIGNvbnN0cmFpbnQuXG4gKiBAbWV0aG9kIHNldE1vdG9yU3BlZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0TW90b3JTcGVlZCA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICB2YXIgaGluZ2VDb25zdHJhaW50ID0gdGhpcy5jb25zdHJhaW50c1t3aGVlbEluZGV4XTtcbiAgICBoaW5nZUNvbnN0cmFpbnQuZW5hYmxlTW90b3IoKTtcbiAgICBoaW5nZUNvbnN0cmFpbnQubW90b3JUYXJnZXRWZWxvY2l0eSA9IHZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIHRhcmdldCByb3RhdGlvbmFsIHNwZWVkIG9mIHRoZSBoaW5nZSBjb25zdHJhaW50LlxuICogQG1ldGhvZCBkaXNhYmxlTW90b3JcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuZGlzYWJsZU1vdG9yID0gZnVuY3Rpb24od2hlZWxJbmRleCl7XG4gICAgdmFyIGhpbmdlQ29uc3RyYWludCA9IHRoaXMuY29uc3RyYWludHNbd2hlZWxJbmRleF07XG4gICAgaGluZ2VDb25zdHJhaW50LmRpc2FibGVNb3RvcigpO1xufTtcblxudmFyIHRvcnF1ZSA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogU2V0IHRoZSB3aGVlbCBmb3JjZSB0byBhcHBseSBvbiBvbmUgb2YgdGhlIHdoZWVscyBlYWNoIHRpbWUgc3RlcFxuICogQG1ldGhvZCBzZXRXaGVlbEZvcmNlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHZhbHVlXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSB3aGVlbEluZGV4XG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuc2V0V2hlZWxGb3JjZSA9IGZ1bmN0aW9uKHZhbHVlLCB3aGVlbEluZGV4KXtcbiAgICB0aGlzLndoZWVsRm9yY2VzW3doZWVsSW5kZXhdID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEFwcGx5IGEgdG9ycXVlIG9uIG9uZSBvZiB0aGUgd2hlZWxzLlxuICogQG1ldGhvZCBhcHBseVdoZWVsRm9yY2VcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSAge2ludGVnZXJ9IHdoZWVsSW5kZXhcbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5hcHBseVdoZWVsRm9yY2UgPSBmdW5jdGlvbih2YWx1ZSwgd2hlZWxJbmRleCl7XG4gICAgdmFyIGF4aXMgPSB0aGlzLndoZWVsQXhlc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgd2hlZWxCb2R5ID0gdGhpcy53aGVlbEJvZGllc1t3aGVlbEluZGV4XTtcbiAgICB2YXIgYm9keVRvcnF1ZSA9IHdoZWVsQm9keS50b3JxdWU7XG5cbiAgICBheGlzLnNjYWxlKHZhbHVlLCB0b3JxdWUpO1xuICAgIHdoZWVsQm9keS52ZWN0b3JUb1dvcmxkRnJhbWUodG9ycXVlLCB0b3JxdWUpO1xuICAgIGJvZHlUb3JxdWUudmFkZCh0b3JxdWUsIGJvZHlUb3JxdWUpO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIHZlaGljbGUgaW5jbHVkaW5nIGl0cyBjb25zdHJhaW50cyB0byB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIGFkZFRvV29ybGRcbiAqIEBwYXJhbSB7V29ybGR9IHdvcmxkXG4gKi9cblJpZ2lkVmVoaWNsZS5wcm90b3R5cGUuYWRkVG9Xb3JsZCA9IGZ1bmN0aW9uKHdvcmxkKXtcbiAgICB2YXIgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgIHZhciBib2RpZXMgPSB0aGlzLndoZWVsQm9kaWVzLmNvbmNhdChbdGhpcy5jaGFzc2lzQm9keV0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2RpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29ybGQuYWRkKGJvZGllc1tpXSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25zdHJhaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB3b3JsZC5hZGRDb25zdHJhaW50KGNvbnN0cmFpbnRzW2ldKTtcbiAgICB9XG5cbiAgICB3b3JsZC5hZGRFdmVudExpc3RlbmVyKCdwcmVTdGVwJywgdGhpcy5fdXBkYXRlLmJpbmQodGhpcykpO1xufTtcblxuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgd2hlZWxGb3JjZXMgPSB0aGlzLndoZWVsRm9yY2VzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd2hlZWxGb3JjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5hcHBseVdoZWVsRm9yY2Uod2hlZWxGb3JjZXNbaV0sIGkpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSB2ZWhpY2xlIGluY2x1ZGluZyBpdHMgY29uc3RyYWludHMgZnJvbSB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIHJlbW92ZUZyb21Xb3JsZFxuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqL1xuUmlnaWRWZWhpY2xlLnByb3RvdHlwZS5yZW1vdmVGcm9tV29ybGQgPSBmdW5jdGlvbih3b3JsZCl7XG4gICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICB2YXIgYm9kaWVzID0gdGhpcy53aGVlbEJvZGllcy5jb25jYXQoW3RoaXMuY2hhc3Npc0JvZHldKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm9kaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdvcmxkLnJlbW92ZShib2RpZXNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uc3RyYWludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd29ybGQucmVtb3ZlQ29uc3RyYWludChjb25zdHJhaW50c1tpXSk7XG4gICAgfVxufTtcblxudmFyIHdvcmxkQXhpcyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiBhIHdoZWVsXG4gKiBAbWV0aG9kIGdldFdoZWVsU3BlZWRcbiAqIEBwYXJhbSB7aW50ZWdlcn0gd2hlZWxJbmRleFxuICovXG5SaWdpZFZlaGljbGUucHJvdG90eXBlLmdldFdoZWVsU3BlZWQgPSBmdW5jdGlvbih3aGVlbEluZGV4KXtcbiAgICB2YXIgYXhpcyA9IHRoaXMud2hlZWxBeGVzW3doZWVsSW5kZXhdO1xuICAgIHZhciB3aGVlbEJvZHkgPSB0aGlzLndoZWVsQm9kaWVzW3doZWVsSW5kZXhdO1xuICAgIHZhciB3ID0gd2hlZWxCb2R5LmFuZ3VsYXJWZWxvY2l0eTtcbiAgICB0aGlzLmNoYXNzaXNCb2R5LnZlY3RvclRvV29ybGRGcmFtZShheGlzLCB3b3JsZEF4aXMpO1xuICAgIHJldHVybiB3LmRvdCh3b3JsZEF4aXMpO1xufTtcblxufSx7XCIuLi9jb25zdHJhaW50cy9IaW5nZUNvbnN0cmFpbnRcIjoxNSxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vc2hhcGVzL0JveFwiOjM3LFwiLi4vc2hhcGVzL1NwaGVyZVwiOjQ0LFwiLi9Cb2R5XCI6MzF9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFNQSFN5c3RlbTtcblxudmFyIFNoYXBlID0gX2RlcmVxXygnLi4vc2hhcGVzL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBQYXJ0aWNsZSA9IF9kZXJlcV8oJy4uL3NoYXBlcy9QYXJ0aWNsZScpO1xudmFyIEJvZHkgPSBfZGVyZXFfKCcuLi9vYmplY3RzL0JvZHknKTtcbnZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG5cbi8qKlxuICogU21vb3RoZWQtcGFydGljbGUgaHlkcm9keW5hbWljcyBzeXN0ZW1cbiAqIEBjbGFzcyBTUEhTeXN0ZW1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTUEhTeXN0ZW0oKXtcbiAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xuXHRcbiAgICAvKipcbiAgICAgKiBEZW5zaXR5IG9mIHRoZSBzeXN0ZW0gKGtnL20zKS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVuc2l0eVxuICAgICAqL1xuICAgIHRoaXMuZGVuc2l0eSA9IDE7XG5cdFxuICAgIC8qKlxuICAgICAqIERpc3RhbmNlIGJlbG93IHdoaWNoIHR3byBwYXJ0aWNsZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmUgbmVpZ2hib3JzLlxuICAgICAqIEl0IHNob3VsZCBiZSBhZGp1c3RlZCBzbyB0aGVyZSBhcmUgYWJvdXQgMTUtMjAgbmVpZ2hib3IgcGFydGljbGVzIHdpdGhpbiB0aGlzIHJhZGl1cy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc21vb3RoaW5nUmFkaXVzXG4gICAgICovXG4gICAgdGhpcy5zbW9vdGhpbmdSYWRpdXMgPSAxO1xuICAgIHRoaXMuc3BlZWRPZlNvdW5kID0gMTtcblx0XG4gICAgLyoqXG4gICAgICogVmlzY29zaXR5IG9mIHRoZSBzeXN0ZW0uXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHZpc2Nvc2l0eVxuICAgICAqL1xuICAgIHRoaXMudmlzY29zaXR5ID0gMC4wMTtcbiAgICB0aGlzLmVwcyA9IDAuMDAwMDAxO1xuXG4gICAgLy8gU3R1ZmYgQ29tcHV0ZWQgcGVyIHBhcnRpY2xlXG4gICAgdGhpcy5wcmVzc3VyZXMgPSBbXTtcbiAgICB0aGlzLmRlbnNpdGllcyA9IFtdO1xuICAgIHRoaXMubmVpZ2hib3JzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgcGFydGljbGUgdG8gdGhlIHN5c3RlbS5cbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge0JvZHl9IHBhcnRpY2xlXG4gKi9cblNQSFN5c3RlbS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ocGFydGljbGUpe1xuICAgIHRoaXMucGFydGljbGVzLnB1c2gocGFydGljbGUpO1xuICAgIGlmKHRoaXMubmVpZ2hib3JzLmxlbmd0aCA8IHRoaXMucGFydGljbGVzLmxlbmd0aCl7XG4gICAgICAgIHRoaXMubmVpZ2hib3JzLnB1c2goW10pO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgcGFydGljbGUgZnJvbSB0aGUgc3lzdGVtLlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcbiAqL1xuU1BIU3lzdGVtLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihwYXJ0aWNsZSl7XG4gICAgdmFyIGlkeCA9IHRoaXMucGFydGljbGVzLmluZGV4T2YocGFydGljbGUpO1xuICAgIGlmKGlkeCAhPT0gLTEpe1xuICAgICAgICB0aGlzLnBhcnRpY2xlcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICBpZih0aGlzLm5laWdoYm9ycy5sZW5ndGggPiB0aGlzLnBhcnRpY2xlcy5sZW5ndGgpe1xuICAgICAgICAgICAgdGhpcy5uZWlnaGJvcnMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBuZWlnaGJvcnMgd2l0aGluIHNtb290aGluZyB2b2x1bWUsIHNhdmUgaW4gdGhlIGFycmF5IG5laWdoYm9yc1xuICogQG1ldGhvZCBnZXROZWlnaGJvcnNcbiAqIEBwYXJhbSB7Qm9keX0gcGFydGljbGVcbiAqIEBwYXJhbSB7QXJyYXl9IG5laWdoYm9yc1xuICovXG52YXIgU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0ID0gbmV3IFZlYzMoKTtcblNQSFN5c3RlbS5wcm90b3R5cGUuZ2V0TmVpZ2hib3JzID0gZnVuY3Rpb24ocGFydGljbGUsbmVpZ2hib3JzKXtcbiAgICB2YXIgTiA9IHRoaXMucGFydGljbGVzLmxlbmd0aCxcbiAgICAgICAgaWQgPSBwYXJ0aWNsZS5pZCxcbiAgICAgICAgUjIgPSB0aGlzLnNtb290aGluZ1JhZGl1cyAqIHRoaXMuc21vb3RoaW5nUmFkaXVzLFxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX2dldE5laWdoYm9yc19kaXN0O1xuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTtcbiAgICAgICAgcC5wb3NpdGlvbi52c3ViKHBhcnRpY2xlLnBvc2l0aW9uLGRpc3QpO1xuICAgICAgICBpZihpZCE9PXAuaWQgJiYgZGlzdC5ub3JtMigpIDwgUjIpe1xuICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vLyBUZW1wIHZlY3RvcnMgZm9yIGNhbGN1bGF0aW9uXG52YXIgU1BIU3lzdGVtX3VwZGF0ZV9kaXN0ID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2FfcHJlc3N1cmUgPSBuZXcgVmVjMygpLFxuICAgIFNQSFN5c3RlbV91cGRhdGVfYV92aXNjID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX2dyYWRXID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3JfdmVjID0gbmV3IFZlYzMoKSxcbiAgICBTUEhTeXN0ZW1fdXBkYXRlX3UgPSBuZXcgVmVjMygpOyAvLyBSZWxhdGl2ZSB2ZWxvY2l0eVxuU1BIU3lzdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBOID0gdGhpcy5wYXJ0aWNsZXMubGVuZ3RoLFxuICAgICAgICBkaXN0ID0gU1BIU3lzdGVtX3VwZGF0ZV9kaXN0LFxuICAgICAgICBjcyA9IHRoaXMuc3BlZWRPZlNvdW5kLFxuICAgICAgICBlcHMgPSB0aGlzLmVwcztcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIHAgPSB0aGlzLnBhcnRpY2xlc1tpXTsgLy8gQ3VycmVudCBwYXJ0aWNsZVxuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdGhpcy5uZWlnaGJvcnNbaV07XG5cbiAgICAgICAgLy8gR2V0IG5laWdoYm9yc1xuICAgICAgICBuZWlnaGJvcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5nZXROZWlnaGJvcnMocCxuZWlnaGJvcnMpO1xuICAgICAgICBuZWlnaGJvcnMucHVzaCh0aGlzLnBhcnRpY2xlc1tpXSk7IC8vIEFkZCBjdXJyZW50IHRvb1xuICAgICAgICB2YXIgbnVtTmVpZ2hib3JzID0gbmVpZ2hib3JzLmxlbmd0aDtcblxuICAgICAgICAvLyBBY2N1bXVsYXRlIGRlbnNpdHkgZm9yIHRoZSBwYXJ0aWNsZVxuICAgICAgICB2YXIgc3VtID0gMC4wO1xuICAgICAgICBmb3IodmFyIGo9MDsgaiE9PW51bU5laWdoYm9yczsgaisrKXtcblxuICAgICAgICAgICAgLy9wcmludGYoXCJDdXJyZW50IHBhcnRpY2xlIGhhcyBwb3NpdGlvbiAlZiAlZiAlZlxcblwiLG9iamVjdHNbaWRdLnBvcy54KCksb2JqZWN0c1tpZF0ucG9zLnkoKSxvYmplY3RzW2lkXS5wb3MueigpKTtcbiAgICAgICAgICAgIHAucG9zaXRpb24udnN1YihuZWlnaGJvcnNbal0ucG9zaXRpb24sIGRpc3QpO1xuICAgICAgICAgICAgdmFyIGxlbiA9IGRpc3Qubm9ybSgpO1xuXG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gdGhpcy53KGxlbik7XG4gICAgICAgICAgICBzdW0gKz0gbmVpZ2hib3JzW2pdLm1hc3MgKiB3ZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTYXZlXG4gICAgICAgIHRoaXMuZGVuc2l0aWVzW2ldID0gc3VtO1xuICAgICAgICB0aGlzLnByZXNzdXJlc1tpXSA9IGNzICogY3MgKiAodGhpcy5kZW5zaXRpZXNbaV0gLSB0aGlzLmRlbnNpdHkpO1xuICAgIH1cblxuICAgIC8vIEFkZCBmb3JjZXNcblxuICAgIC8vIFN1bSB0byB0aGVzZSBhY2NlbGVyYXRpb25zXG4gICAgdmFyIGFfcHJlc3N1cmU9IFNQSFN5c3RlbV91cGRhdGVfYV9wcmVzc3VyZTtcbiAgICB2YXIgYV92aXNjID0gICAgU1BIU3lzdGVtX3VwZGF0ZV9hX3Zpc2M7XG4gICAgdmFyIGdyYWRXID0gICAgIFNQSFN5c3RlbV91cGRhdGVfZ3JhZFc7XG4gICAgdmFyIHJfdmVjID0gICAgIFNQSFN5c3RlbV91cGRhdGVfcl92ZWM7XG4gICAgdmFyIHUgPSAgICAgICAgIFNQSFN5c3RlbV91cGRhdGVfdTtcblxuICAgIGZvcih2YXIgaT0wOyBpIT09TjsgaSsrKXtcblxuICAgICAgICB2YXIgcGFydGljbGUgPSB0aGlzLnBhcnRpY2xlc1tpXTtcblxuICAgICAgICBhX3ByZXNzdXJlLnNldCgwLDAsMCk7XG4gICAgICAgIGFfdmlzYy5zZXQoMCwwLDApO1xuXG4gICAgICAgIC8vIEluaXQgdmFyc1xuICAgICAgICB2YXIgUGlqO1xuICAgICAgICB2YXIgbmFibGE7XG4gICAgICAgIHZhciBWaWo7XG5cbiAgICAgICAgLy8gU3VtIHVwIGZvciBhbGwgb3RoZXIgbmVpZ2hib3JzXG4gICAgICAgIHZhciBuZWlnaGJvcnMgPSB0aGlzLm5laWdoYm9yc1tpXTtcbiAgICAgICAgdmFyIG51bU5laWdoYm9ycyA9IG5laWdoYm9ycy5sZW5ndGg7XG5cbiAgICAgICAgLy9wcmludGYoXCJOZWlnaGJvcnM6IFwiKTtcbiAgICAgICAgZm9yKHZhciBqPTA7IGohPT1udW1OZWlnaGJvcnM7IGorKyl7XG5cbiAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tqXTtcbiAgICAgICAgICAgIC8vcHJpbnRmKFwiJWQgXCIsbmopO1xuXG4gICAgICAgICAgICAvLyBHZXQgciBvbmNlIGZvciBhbGwuLlxuICAgICAgICAgICAgcGFydGljbGUucG9zaXRpb24udnN1YihuZWlnaGJvci5wb3NpdGlvbixyX3ZlYyk7XG4gICAgICAgICAgICB2YXIgciA9IHJfdmVjLm5vcm0oKTtcblxuICAgICAgICAgICAgLy8gUHJlc3N1cmUgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBQaWogPSAtbmVpZ2hib3IubWFzcyAqICh0aGlzLnByZXNzdXJlc1tpXSAvICh0aGlzLmRlbnNpdGllc1tpXSp0aGlzLmRlbnNpdGllc1tpXSArIGVwcykgKyB0aGlzLnByZXNzdXJlc1tqXSAvICh0aGlzLmRlbnNpdGllc1tqXSp0aGlzLmRlbnNpdGllc1tqXSArIGVwcykpO1xuICAgICAgICAgICAgdGhpcy5ncmFkdyhyX3ZlYywgZ3JhZFcpO1xuICAgICAgICAgICAgLy8gQWRkIHRvIHByZXNzdXJlIGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgZ3JhZFcubXVsdChQaWogLCBncmFkVyk7XG4gICAgICAgICAgICBhX3ByZXNzdXJlLnZhZGQoZ3JhZFcsIGFfcHJlc3N1cmUpO1xuXG4gICAgICAgICAgICAvLyBWaXNjb3NpdHkgY29udHJpYnV0aW9uXG4gICAgICAgICAgICBuZWlnaGJvci52ZWxvY2l0eS52c3ViKHBhcnRpY2xlLnZlbG9jaXR5LCB1KTtcbiAgICAgICAgICAgIHUubXVsdCggMS4wIC8gKDAuMDAwMSt0aGlzLmRlbnNpdGllc1tpXSAqIHRoaXMuZGVuc2l0aWVzW2pdKSAqIHRoaXMudmlzY29zaXR5ICogbmVpZ2hib3IubWFzcyAsIHUgKTtcbiAgICAgICAgICAgIG5hYmxhID0gdGhpcy5uYWJsYXcocik7XG4gICAgICAgICAgICB1Lm11bHQobmFibGEsdSk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdmlzY29zaXR5IGFjY2VsZXJhdGlvblxuICAgICAgICAgICAgYV92aXNjLnZhZGQoIHUsIGFfdmlzYyApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGZvcmNlXG4gICAgICAgIGFfdmlzYy5tdWx0KHBhcnRpY2xlLm1hc3MsIGFfdmlzYyk7XG4gICAgICAgIGFfcHJlc3N1cmUubXVsdChwYXJ0aWNsZS5tYXNzLCBhX3ByZXNzdXJlKTtcblxuICAgICAgICAvLyBBZGQgZm9yY2UgdG8gcGFydGljbGVzXG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV92aXNjLCBwYXJ0aWNsZS5mb3JjZSk7XG4gICAgICAgIHBhcnRpY2xlLmZvcmNlLnZhZGQoYV9wcmVzc3VyZSwgcGFydGljbGUuZm9yY2UpO1xuICAgIH1cbn07XG5cbi8vIENhbGN1bGF0ZSB0aGUgd2VpZ2h0IHVzaW5nIHRoZSBXKHIpIHdlaWdodGZ1bmN0aW9uXG5TUEhTeXN0ZW0ucHJvdG90eXBlLncgPSBmdW5jdGlvbihyKXtcbiAgICAvLyAzMTVcbiAgICB2YXIgaCA9IHRoaXMuc21vb3RoaW5nUmFkaXVzO1xuICAgIHJldHVybiAzMTUuMC8oNjQuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogTWF0aC5wb3coaCpoLXIqciwzKTtcbn07XG5cbi8vIGNhbGN1bGF0ZSBncmFkaWVudCBvZiB0aGUgd2VpZ2h0IGZ1bmN0aW9uXG5TUEhTeXN0ZW0ucHJvdG90eXBlLmdyYWR3ID0gZnVuY3Rpb24oclZlYyxyZXN1bHRWZWMpe1xuICAgIHZhciByID0gclZlYy5ub3JtKCksXG4gICAgICAgIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICByVmVjLm11bHQoOTQ1LjAvKDMyLjAqTWF0aC5QSSpNYXRoLnBvdyhoLDkpKSAqIE1hdGgucG93KChoKmgtcipyKSwyKSAsIHJlc3VsdFZlYyk7XG59O1xuXG4vLyBDYWxjdWxhdGUgbmFibGEoVylcblNQSFN5c3RlbS5wcm90b3R5cGUubmFibGF3ID0gZnVuY3Rpb24ocil7XG4gICAgdmFyIGggPSB0aGlzLnNtb290aGluZ1JhZGl1cztcbiAgICB2YXIgbmFibGEgPSA5NDUuMC8oMzIuMCpNYXRoLlBJKk1hdGgucG93KGgsOSkpICogKGgqaC1yKnIpKig3KnIqciAtIDMqaCpoKTtcbiAgICByZXR1cm4gbmFibGE7XG59O1xuXG59LHtcIi4uL21hdGVyaWFsL01hdGVyaWFsXCI6MjUsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vb2JqZWN0cy9Cb2R5XCI6MzEsXCIuLi9zaGFwZXMvUGFydGljbGVcIjo0MSxcIi4uL3NoYXBlcy9TaGFwZVwiOjQzfV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTcHJpbmc7XG5cbi8qKlxuICogQSBzcHJpbmcsIGNvbm5lY3RpbmcgdHdvIGJvZGllcy5cbiAqXG4gKiBAY2xhc3MgU3ByaW5nXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUFcbiAqIEBwYXJhbSB7Qm9keX0gYm9keUJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXN0TGVuZ3RoXSAgIEEgbnVtYmVyID4gMC4gRGVmYXVsdDogMVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN0aWZmbmVzc10gICAgQSBudW1iZXIgPj0gMC4gRGVmYXVsdDogMTAwXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ10gICAgICBBIG51bWJlciA+PSAwLiBEZWZhdWx0OiAxXG4gKiBAcGFyYW0ge1ZlYzN9ICBbb3B0aW9ucy53b3JsZEFuY2hvckFdIFdoZXJlIHRvIGhvb2sgdGhlIHNwcmluZyB0byBib2R5IEEsIGluIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMud29ybGRBbmNob3JCXVxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JBXSBXaGVyZSB0byBob29rIHRoZSBzcHJpbmcgdG8gYm9keSBBLCBpbiBsb2NhbCBib2R5IGNvb3JkaW5hdGVzLlxuICogQHBhcmFtIHtWZWMzfSAgW29wdGlvbnMubG9jYWxBbmNob3JCXVxuICovXG5mdW5jdGlvbiBTcHJpbmcoYm9keUEsYm9keUIsb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvKipcbiAgICAgKiBSZXN0IGxlbmd0aCBvZiB0aGUgc3ByaW5nLlxuICAgICAqIEBwcm9wZXJ0eSByZXN0TGVuZ3RoXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnJlc3RMZW5ndGggPSB0eXBlb2Yob3B0aW9ucy5yZXN0TGVuZ3RoKSA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMucmVzdExlbmd0aCA6IDE7XG5cbiAgICAvKipcbiAgICAgKiBTdGlmZm5lc3Mgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgc3RpZmZuZXNzXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnN0aWZmbmVzcyA9IG9wdGlvbnMuc3RpZmZuZXNzIHx8IDEwMDtcblxuICAgIC8qKlxuICAgICAqIERhbXBpbmcgb2YgdGhlIHNwcmluZy5cbiAgICAgKiBAcHJvcGVydHkgZGFtcGluZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nID0gb3B0aW9ucy5kYW1waW5nIHx8IDE7XG5cbiAgICAvKipcbiAgICAgKiBGaXJzdCBjb25uZWN0ZWQgYm9keS5cbiAgICAgKiBAcHJvcGVydHkgYm9keUFcbiAgICAgKiBAdHlwZSB7Qm9keX1cbiAgICAgKi9cbiAgICB0aGlzLmJvZHlBID0gYm9keUE7XG5cbiAgICAvKipcbiAgICAgKiBTZWNvbmQgY29ubmVjdGVkIGJvZHkuXG4gICAgICogQHByb3BlcnR5IGJvZHlCXG4gICAgICogQHR5cGUge0JvZHl9XG4gICAgICovXG4gICAgdGhpcy5ib2R5QiA9IGJvZHlCO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QSBpbiBsb2NhbCBib2R5QSBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JBXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckEgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQW5jaG9yIGZvciBib2R5QiBpbiBsb2NhbCBib2R5QiBjb29yZGluYXRlcy5cbiAgICAgKiBAcHJvcGVydHkgbG9jYWxBbmNob3JCXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5sb2NhbEFuY2hvckIgPSBuZXcgVmVjMygpO1xuXG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckEpe1xuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQS5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JBKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy5sb2NhbEFuY2hvckIpe1xuICAgICAgICB0aGlzLmxvY2FsQW5jaG9yQi5jb3B5KG9wdGlvbnMubG9jYWxBbmNob3JCKTtcbiAgICB9XG4gICAgaWYob3B0aW9ucy53b3JsZEFuY2hvckEpe1xuICAgICAgICB0aGlzLnNldFdvcmxkQW5jaG9yQShvcHRpb25zLndvcmxkQW5jaG9yQSk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMud29ybGRBbmNob3JCKXtcbiAgICAgICAgdGhpcy5zZXRXb3JsZEFuY2hvckIob3B0aW9ucy53b3JsZEFuY2hvckIpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBTZXQgdGhlIGFuY2hvciBwb2ludCBvbiBib2R5IEEsIHVzaW5nIHdvcmxkIGNvb3JkaW5hdGVzLlxuICogQG1ldGhvZCBzZXRXb3JsZEFuY2hvckFcbiAqIEBwYXJhbSB7VmVjM30gd29ybGRBbmNob3JBXG4gKi9cblNwcmluZy5wcm90b3R5cGUuc2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24od29ybGRBbmNob3JBKXtcbiAgICB0aGlzLmJvZHlBLnBvaW50VG9Mb2NhbEZyYW1lKHdvcmxkQW5jaG9yQSx0aGlzLmxvY2FsQW5jaG9yQSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgdXNpbmcgd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIHNldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtWZWMzfSB3b3JsZEFuY2hvckJcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5zZXRXb3JsZEFuY2hvckIgPSBmdW5jdGlvbih3b3JsZEFuY2hvckIpe1xuICAgIHRoaXMuYm9keUIucG9pbnRUb0xvY2FsRnJhbWUod29ybGRBbmNob3JCLHRoaXMubG9jYWxBbmNob3JCKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBhbmNob3IgcG9pbnQgb24gYm9keSBBLCBpbiB3b3JsZCBjb29yZGluYXRlcy5cbiAqIEBtZXRob2QgZ2V0V29ybGRBbmNob3JBXG4gKiBAcGFyYW0ge1ZlYzN9IHJlc3VsdCBUaGUgdmVjdG9yIHRvIHN0b3JlIHRoZSByZXN1bHQgaW4uXG4gKi9cblNwcmluZy5wcm90b3R5cGUuZ2V0V29ybGRBbmNob3JBID0gZnVuY3Rpb24ocmVzdWx0KXtcbiAgICB0aGlzLmJvZHlBLnBvaW50VG9Xb3JsZEZyYW1lKHRoaXMubG9jYWxBbmNob3JBLHJlc3VsdCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgYW5jaG9yIHBvaW50IG9uIGJvZHkgQiwgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKiBAbWV0aG9kIGdldFdvcmxkQW5jaG9yQlxuICogQHBhcmFtIHtWZWMzfSByZXN1bHQgVGhlIHZlY3RvciB0byBzdG9yZSB0aGUgcmVzdWx0IGluLlxuICovXG5TcHJpbmcucHJvdG90eXBlLmdldFdvcmxkQW5jaG9yQiA9IGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgdGhpcy5ib2R5Qi5wb2ludFRvV29ybGRGcmFtZSh0aGlzLmxvY2FsQW5jaG9yQixyZXN1bHQpO1xufTtcblxudmFyIGFwcGx5Rm9yY2VfciA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfcl91bml0ID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfdSA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfZiA9ICAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBID0gICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JCID0gICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmkgPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmogPSAgICAgICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmlfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfcmpfeF9mID0gICAgICAgICBuZXcgVmVjMygpLFxuICAgIGFwcGx5Rm9yY2VfdG1wID0gICAgICAgICAgICBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEFwcGx5IHRoZSBzcHJpbmcgZm9yY2UgdG8gdGhlIGNvbm5lY3RlZCBib2RpZXMuXG4gKiBAbWV0aG9kIGFwcGx5Rm9yY2VcbiAqL1xuU3ByaW5nLnByb3RvdHlwZS5hcHBseUZvcmNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgayA9IHRoaXMuc3RpZmZuZXNzLFxuICAgICAgICBkID0gdGhpcy5kYW1waW5nLFxuICAgICAgICBsID0gdGhpcy5yZXN0TGVuZ3RoLFxuICAgICAgICBib2R5QSA9IHRoaXMuYm9keUEsXG4gICAgICAgIGJvZHlCID0gdGhpcy5ib2R5QixcbiAgICAgICAgciA9IGFwcGx5Rm9yY2VfcixcbiAgICAgICAgcl91bml0ID0gYXBwbHlGb3JjZV9yX3VuaXQsXG4gICAgICAgIHUgPSBhcHBseUZvcmNlX3UsXG4gICAgICAgIGYgPSBhcHBseUZvcmNlX2YsXG4gICAgICAgIHRtcCA9IGFwcGx5Rm9yY2VfdG1wO1xuXG4gICAgdmFyIHdvcmxkQW5jaG9yQSA9IGFwcGx5Rm9yY2Vfd29ybGRBbmNob3JBLFxuICAgICAgICB3b3JsZEFuY2hvckIgPSBhcHBseUZvcmNlX3dvcmxkQW5jaG9yQixcbiAgICAgICAgcmkgPSBhcHBseUZvcmNlX3JpLFxuICAgICAgICByaiA9IGFwcGx5Rm9yY2VfcmosXG4gICAgICAgIHJpX3hfZiA9IGFwcGx5Rm9yY2VfcmlfeF9mLFxuICAgICAgICByal94X2YgPSBhcHBseUZvcmNlX3JqX3hfZjtcblxuICAgIC8vIEdldCB3b3JsZCBhbmNob3JzXG4gICAgdGhpcy5nZXRXb3JsZEFuY2hvckEod29ybGRBbmNob3JBKTtcbiAgICB0aGlzLmdldFdvcmxkQW5jaG9yQih3b3JsZEFuY2hvckIpO1xuXG4gICAgLy8gR2V0IG9mZnNldCBwb2ludHNcbiAgICB3b3JsZEFuY2hvckEudnN1Yihib2R5QS5wb3NpdGlvbixyaSk7XG4gICAgd29ybGRBbmNob3JCLnZzdWIoYm9keUIucG9zaXRpb24scmopO1xuXG4gICAgLy8gQ29tcHV0ZSBkaXN0YW5jZSB2ZWN0b3IgYmV0d2VlbiB3b3JsZCBhbmNob3IgcG9pbnRzXG4gICAgd29ybGRBbmNob3JCLnZzdWIod29ybGRBbmNob3JBLHIpO1xuICAgIHZhciBybGVuID0gci5ub3JtKCk7XG4gICAgcl91bml0LmNvcHkocik7XG4gICAgcl91bml0Lm5vcm1hbGl6ZSgpO1xuXG4gICAgLy8gQ29tcHV0ZSByZWxhdGl2ZSB2ZWxvY2l0eSBvZiB0aGUgYW5jaG9yIHBvaW50cywgdVxuICAgIGJvZHlCLnZlbG9jaXR5LnZzdWIoYm9keUEudmVsb2NpdHksdSk7XG4gICAgLy8gQWRkIHJvdGF0aW9uYWwgdmVsb2NpdHlcblxuICAgIGJvZHlCLmFuZ3VsYXJWZWxvY2l0eS5jcm9zcyhyaix0bXApO1xuICAgIHUudmFkZCh0bXAsdSk7XG4gICAgYm9keUEuYW5ndWxhclZlbG9jaXR5LmNyb3NzKHJpLHRtcCk7XG4gICAgdS52c3ViKHRtcCx1KTtcblxuICAgIC8vIEYgPSAtIGsgKiAoIHggLSBMICkgLSBEICogKCB1IClcbiAgICByX3VuaXQubXVsdCgtayoocmxlbi1sKSAtIGQqdS5kb3Qocl91bml0KSwgZik7XG5cbiAgICAvLyBBZGQgZm9yY2VzIHRvIGJvZGllc1xuICAgIGJvZHlBLmZvcmNlLnZzdWIoZixib2R5QS5mb3JjZSk7XG4gICAgYm9keUIuZm9yY2UudmFkZChmLGJvZHlCLmZvcmNlKTtcblxuICAgIC8vIEFuZ3VsYXIgZm9yY2VcbiAgICByaS5jcm9zcyhmLHJpX3hfZik7XG4gICAgcmouY3Jvc3MoZixyal94X2YpO1xuICAgIGJvZHlBLnRvcnF1ZS52c3ViKHJpX3hfZixib2R5QS50b3JxdWUpO1xuICAgIGJvZHlCLnRvcnF1ZS52YWRkKHJqX3hfZixib2R5Qi50b3JxdWUpO1xufTtcblxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMH1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi4vbWF0aC9UcmFuc2Zvcm0nKTtcbnZhciBSYXljYXN0UmVzdWx0ID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL1JheWNhc3RSZXN1bHQnKTtcbnZhciBVdGlscyA9IF9kZXJlcV8oJy4uL3V0aWxzL1V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gV2hlZWxJbmZvO1xuXG4vKipcbiAqIEBjbGFzcyBXaGVlbEluZm9cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGRdXG4gKiBAcGFyYW0ge1ZlYzN9IFtvcHRpb25zLmRpcmVjdGlvbkxvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5kaXJlY3Rpb25Xb3JsZF1cbiAqIEBwYXJhbSB7VmVjM30gW29wdGlvbnMuYXhsZUxvY2FsXVxuICogQHBhcmFtIHtWZWMzfSBbb3B0aW9ucy5heGxlV29ybGRdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblJlc3RMZW5ndGg9MV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoPTJdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucmFkaXVzPTFdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcz0xMDBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uPTEwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmRhbXBpbmdSZWxheGF0aW9uPTEwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmZyaWN0aW9uU2xpcD0xMDAwMF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdGVlcmluZz0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvdGF0aW9uPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZGVsdGFSb3RhdGlvbj0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnJvbGxJbmZsdWVuY2U9MC4wMV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhTdXNwZW5zaW9uRm9yY2VdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzRnJvbnRXaGVlbD10cnVlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbj0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5PTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3VzcGVuc2lvbkZvcmNlPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc2tpZEluZm89MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zdXNwZW5zaW9uTGVuZ3RoPTBdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbD0xXVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkPWZhbHNlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ9LTAuMV1cbiAqL1xuZnVuY3Rpb24gV2hlZWxJbmZvKG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBVdGlscy5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICBkaXJlY3Rpb25Mb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgZGlyZWN0aW9uV29ybGQ6IG5ldyBWZWMzKCksXG4gICAgICAgIGF4bGVMb2NhbDogbmV3IFZlYzMoKSxcbiAgICAgICAgYXhsZVdvcmxkOiBuZXcgVmVjMygpLFxuICAgICAgICBzdXNwZW5zaW9uUmVzdExlbmd0aDogMSxcbiAgICAgICAgc3VzcGVuc2lvbk1heExlbmd0aDogMixcbiAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICBzdXNwZW5zaW9uU3RpZmZuZXNzOiAxMDAsXG4gICAgICAgIGRhbXBpbmdDb21wcmVzc2lvbjogMTAsXG4gICAgICAgIGRhbXBpbmdSZWxheGF0aW9uOiAxMCxcbiAgICAgICAgZnJpY3Rpb25TbGlwOiAxMDAwMCxcbiAgICAgICAgc3RlZXJpbmc6IDAsXG4gICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICBkZWx0YVJvdGF0aW9uOiAwLFxuICAgICAgICByb2xsSW5mbHVlbmNlOiAwLjAxLFxuICAgICAgICBtYXhTdXNwZW5zaW9uRm9yY2U6IE51bWJlci5NQVhfVkFMVUUsXG4gICAgICAgIGlzRnJvbnRXaGVlbDogdHJ1ZSxcbiAgICAgICAgY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uOiAxLFxuICAgICAgICBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eTogMCxcbiAgICAgICAgc3VzcGVuc2lvbkZvcmNlOiAwLFxuICAgICAgICBza2lkSW5mbzogMCxcbiAgICAgICAgc3VzcGVuc2lvbkxlbmd0aDogMCxcbiAgICAgICAgbWF4U3VzcGVuc2lvblRyYXZlbDogMSxcbiAgICAgICAgdXNlQ3VzdG9tU2xpZGluZ1JvdGF0aW9uYWxTcGVlZDogZmFsc2UsXG4gICAgICAgIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQ6IC0wLjFcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIE1heCB0cmF2ZWwgZGlzdGFuY2Ugb2YgdGhlIHN1c3BlbnNpb24sIGluIG1ldGVycy5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWF4U3VzcGVuc2lvblRyYXZlbFxuICAgICAqL1xuICAgIHRoaXMubWF4U3VzcGVuc2lvblRyYXZlbCA9IG9wdGlvbnMubWF4U3VzcGVuc2lvblRyYXZlbDtcblxuICAgIC8qKlxuICAgICAqIFNwZWVkIHRvIGFwcGx5IHRvIHRoZSB3aGVlbCByb3RhdGlvbiB3aGVuIHRoZSB3aGVlbCBpcyBzbGlkaW5nLlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXG4gICAgICovXG4gICAgdGhpcy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy5jdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuXG4gICAgLyoqXG4gICAgICogSWYgdGhlIGN1c3RvbVNsaWRpbmdSb3RhdGlvbmFsU3BlZWQgc2hvdWxkIGJlIHVzZWQuXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSB1c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkXG4gICAgICovXG4gICAgdGhpcy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkID0gb3B0aW9ucy51c2VDdXN0b21TbGlkaW5nUm90YXRpb25hbFNwZWVkO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtCb29sZWFufSBzbGlkaW5nXG4gICAgICovXG4gICAgdGhpcy5zbGlkaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBDb25uZWN0aW9uIHBvaW50LCBkZWZpbmVkIGxvY2FsbHkgaW4gdGhlIGNoYXNzaXMgYm9keSBmcmFtZS5cbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGNoYXNzaXNDb25uZWN0aW9uUG9pbnRMb2NhbFxuICAgICAqL1xuICAgIHRoaXMuY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludExvY2FsID0gb3B0aW9ucy5jaGFzc2lzQ29ubmVjdGlvblBvaW50TG9jYWwuY2xvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gY2hhc3Npc0Nvbm5lY3Rpb25Qb2ludFdvcmxkXG4gICAgICovXG4gICAgdGhpcy5jaGFzc2lzQ29ubmVjdGlvblBvaW50V29ybGQgPSBvcHRpb25zLmNoYXNzaXNDb25uZWN0aW9uUG9pbnRXb3JsZC5jbG9uZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBkaXJlY3Rpb25Mb2NhbFxuICAgICAqL1xuICAgIHRoaXMuZGlyZWN0aW9uTG9jYWwgPSBvcHRpb25zLmRpcmVjdGlvbkxvY2FsLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge1ZlYzN9IGRpcmVjdGlvbldvcmxkXG4gICAgICovXG4gICAgdGhpcy5kaXJlY3Rpb25Xb3JsZCA9IG9wdGlvbnMuZGlyZWN0aW9uV29ybGQuY2xvbmUoKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gYXhsZUxvY2FsXG4gICAgICovXG4gICAgdGhpcy5heGxlTG9jYWwgPSBvcHRpb25zLmF4bGVMb2NhbC5jbG9uZSgpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtWZWMzfSBheGxlV29ybGRcbiAgICAgKi9cbiAgICB0aGlzLmF4bGVXb3JsZCA9IG9wdGlvbnMuYXhsZVdvcmxkLmNsb25lKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblJlc3RMZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLnN1c3BlbnNpb25SZXN0TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uUmVzdExlbmd0aDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uTWF4TGVuZ3RoXG4gICAgICovXG4gICAgdGhpcy5zdXNwZW5zaW9uTWF4TGVuZ3RoID0gb3B0aW9ucy5zdXNwZW5zaW9uTWF4TGVuZ3RoO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJhZGl1c1xuICAgICAqL1xuICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc3VzcGVuc2lvblN0aWZmbmVzc1xuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvblN0aWZmbmVzcyA9IG9wdGlvbnMuc3VzcGVuc2lvblN0aWZmbmVzcztcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYW1waW5nQ29tcHJlc3Npb25cbiAgICAgKi9cbiAgICB0aGlzLmRhbXBpbmdDb21wcmVzc2lvbiA9IG9wdGlvbnMuZGFtcGluZ0NvbXByZXNzaW9uO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhbXBpbmdSZWxheGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5kYW1waW5nUmVsYXhhdGlvbiA9IG9wdGlvbnMuZGFtcGluZ1JlbGF4YXRpb247XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZnJpY3Rpb25TbGlwXG4gICAgICovXG4gICAgdGhpcy5mcmljdGlvblNsaXAgPSBvcHRpb25zLmZyaWN0aW9uU2xpcDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdGVlcmluZ1xuICAgICAqL1xuICAgIHRoaXMuc3RlZXJpbmcgPSAwO1xuXG4gICAgLyoqXG4gICAgICogUm90YXRpb24gdmFsdWUsIGluIHJhZGlhbnMuXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdGF0aW9uXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZGVsdGFSb3RhdGlvblxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFSb3RhdGlvbiA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gcm9sbEluZmx1ZW5jZVxuICAgICAqL1xuICAgIHRoaXMucm9sbEluZmx1ZW5jZSA9IG9wdGlvbnMucm9sbEluZmx1ZW5jZTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtYXhTdXNwZW5zaW9uRm9yY2VcbiAgICAgKi9cbiAgICB0aGlzLm1heFN1c3BlbnNpb25Gb3JjZSA9IG9wdGlvbnMubWF4U3VzcGVuc2lvbkZvcmNlO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGVuZ2luZUZvcmNlXG4gICAgICovXG4gICAgdGhpcy5lbmdpbmVGb3JjZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYnJha2VcbiAgICAgKi9cbiAgICB0aGlzLmJyYWtlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpc0Zyb250V2hlZWxcbiAgICAgKi9cbiAgICB0aGlzLmlzRnJvbnRXaGVlbCA9IG9wdGlvbnMuaXNGcm9udFdoZWVsO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvblxuICAgICAqL1xuICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzdXNwZW5zaW9uUmVsYXRpdmVWZWxvY2l0eVxuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25Gb3JjZVxuICAgICAqL1xuICAgIHRoaXMuc3VzcGVuc2lvbkZvcmNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBza2lkSW5mb1xuICAgICAqL1xuICAgIHRoaXMuc2tpZEluZm8gPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHN1c3BlbnNpb25MZW5ndGhcbiAgICAgKi9cbiAgICB0aGlzLnN1c3BlbnNpb25MZW5ndGggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZGVJbXB1bHNlXG4gICAgICovXG4gICAgdGhpcy5zaWRlSW1wdWxzZSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZm9yd2FyZEltcHVsc2VcbiAgICAgKi9cbiAgICB0aGlzLmZvcndhcmRJbXB1bHNlID0gMDtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHQgZnJvbSByYXljYXN0aW5nXG4gICAgICogQHByb3BlcnR5IHtSYXljYXN0UmVzdWx0fSByYXljYXN0UmVzdWx0XG4gICAgICovXG4gICAgdGhpcy5yYXljYXN0UmVzdWx0ID0gbmV3IFJheWNhc3RSZXN1bHQoKTtcblxuICAgIC8qKlxuICAgICAqIFdoZWVsIHdvcmxkIHRyYW5zZm9ybVxuICAgICAqIEBwcm9wZXJ0eSB7VHJhbnNmb3JtfSB3b3JsZFRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRoaXMud29ybGRUcmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5Db250YWN0XG4gICAgICovXG4gICAgdGhpcy5pc0luQ29udGFjdCA9IGZhbHNlO1xufVxuXG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIHJlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgY2hhc3Npc192ZWxvY2l0eV9hdF9jb250YWN0UG9pbnQgPSBuZXcgVmVjMygpO1xuV2hlZWxJbmZvLnByb3RvdHlwZS51cGRhdGVXaGVlbCA9IGZ1bmN0aW9uKGNoYXNzaXMpe1xuICAgIHZhciByYXljYXN0UmVzdWx0ID0gdGhpcy5yYXljYXN0UmVzdWx0O1xuXG4gICAgaWYgKHRoaXMuaXNJbkNvbnRhY3Qpe1xuICAgICAgICB2YXIgcHJvamVjdD0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QocmF5Y2FzdFJlc3VsdC5kaXJlY3Rpb25Xb3JsZCk7XG4gICAgICAgIHJheWNhc3RSZXN1bHQuaGl0UG9pbnRXb3JsZC52c3ViKGNoYXNzaXMucG9zaXRpb24sIHJlbHBvcyk7XG4gICAgICAgIGNoYXNzaXMuZ2V0VmVsb2NpdHlBdFdvcmxkUG9pbnQocmVscG9zLCBjaGFzc2lzX3ZlbG9jaXR5X2F0X2NvbnRhY3RQb2ludCk7XG4gICAgICAgIHZhciBwcm9qVmVsID0gcmF5Y2FzdFJlc3VsdC5oaXROb3JtYWxXb3JsZC5kb3QoIGNoYXNzaXNfdmVsb2NpdHlfYXRfY29udGFjdFBvaW50ICk7XG4gICAgICAgIGlmIChwcm9qZWN0ID49IC0wLjEpIHtcbiAgICAgICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMCAvIDAuMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpbnYgPSAtMSAvIHByb2plY3Q7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbnNpb25SZWxhdGl2ZVZlbG9jaXR5ID0gcHJvalZlbCAqIGludjtcbiAgICAgICAgICAgIHRoaXMuY2xpcHBlZEludkNvbnRhY3REb3RTdXNwZW5zaW9uID0gaW52O1xuICAgICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOb3QgaW4gY29udGFjdCA6IHBvc2l0aW9uIHdoZWVsIGluIGEgbmljZSAocmVzdCBsZW5ndGgpIHBvc2l0aW9uXG4gICAgICAgIHJheWNhc3RSZXN1bHQuc3VzcGVuc2lvbkxlbmd0aCA9IHRoaXMuc3VzcGVuc2lvblJlc3RMZW5ndGg7XG4gICAgICAgIHRoaXMuc3VzcGVuc2lvblJlbGF0aXZlVmVsb2NpdHkgPSAwLjA7XG4gICAgICAgIHJheWNhc3RSZXN1bHQuZGlyZWN0aW9uV29ybGQuc2NhbGUoLTEsIHJheWNhc3RSZXN1bHQuaGl0Tm9ybWFsV29ybGQpO1xuICAgICAgICB0aGlzLmNsaXBwZWRJbnZDb250YWN0RG90U3VzcGVuc2lvbiA9IDEuMDtcbiAgICB9XG59O1xufSx7XCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEwLFwiLi4vbWF0aC9UcmFuc2Zvcm1cIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vdXRpbHMvVXRpbHNcIjo1M31dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gQm94O1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIENvbnZleFBvbHloZWRyb24gPSBfZGVyZXFfKCcuL0NvbnZleFBvbHloZWRyb24nKTtcblxuLyoqXG4gKiBBIDNkIGJveCBzaGFwZS5cbiAqIEBjbGFzcyBCb3hcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtWZWMzfSBoYWxmRXh0ZW50c1xuICogQGF1dGhvciBzY2h0ZXBwZVxuICogQGV4dGVuZHMgU2hhcGVcbiAqL1xuZnVuY3Rpb24gQm94KGhhbGZFeHRlbnRzKXtcbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQk9YO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGhhbGZFeHRlbnRzXG4gICAgICogQHR5cGUge1ZlYzN9XG4gICAgICovXG4gICAgdGhpcy5oYWxmRXh0ZW50cyA9IGhhbGZFeHRlbnRzO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSB0aGUgY29udGFjdCBnZW5lcmF0b3IgdG8gbWFrZSBjb250YWN0cyB3aXRoIG90aGVyIGNvbnZleCBwb2x5aGVkcmEgZm9yIGV4YW1wbGVcbiAgICAgKiBAcHJvcGVydHkgY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uXG4gICAgICogQHR5cGUge0NvbnZleFBvbHloZWRyb259XG4gICAgICovXG4gICAgdGhpcy5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24gPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG59XG5Cb3gucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5Cb3gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQm94O1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGxvY2FsIGNvbnZleCBwb2x5aGVkcm9uIHJlcHJlc2VudGF0aW9uIHVzZWQgZm9yIHNvbWUgY29sbGlzaW9ucy5cbiAqIEBtZXRob2QgdXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uXG4gKi9cbkJveC5wcm90b3R5cGUudXBkYXRlQ29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgc3ggPSB0aGlzLmhhbGZFeHRlbnRzLng7XG4gICAgdmFyIHN5ID0gdGhpcy5oYWxmRXh0ZW50cy55O1xuICAgIHZhciBzeiA9IHRoaXMuaGFsZkV4dGVudHMuejtcbiAgICB2YXIgViA9IFZlYzM7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXG4gICAgICAgIG5ldyBWKC1zeCwtc3ksLXN6KSxcbiAgICAgICAgbmV3IFYoIHN4LC1zeSwtc3opLFxuICAgICAgICBuZXcgViggc3gsIHN5LC1zeiksXG4gICAgICAgIG5ldyBWKC1zeCwgc3ksLXN6KSxcbiAgICAgICAgbmV3IFYoLXN4LC1zeSwgc3opLFxuICAgICAgICBuZXcgViggc3gsLXN5LCBzeiksXG4gICAgICAgIG5ldyBWKCBzeCwgc3ksIHN6KSxcbiAgICAgICAgbmV3IFYoLXN4LCBzeSwgc3opXG4gICAgXTtcblxuICAgIHZhciBpbmRpY2VzID0gW1xuICAgICAgICBbMywyLDEsMF0sIC8vIC16XG4gICAgICAgIFs0LDUsNiw3XSwgLy8gK3pcbiAgICAgICAgWzUsNCwwLDFdLCAvLyAteVxuICAgICAgICBbMiwzLDcsNl0sIC8vICt5XG4gICAgICAgIFswLDQsNywzXSwgLy8gLXhcbiAgICAgICAgWzEsMiw2LDVdLCAvLyAreFxuICAgIF07XG5cbiAgICB2YXIgYXhlcyA9IFtcbiAgICAgICAgbmV3IFYoMCwgMCwgMSksXG4gICAgICAgIG5ldyBWKDAsIDEsIDApLFxuICAgICAgICBuZXcgVigxLCAwLCAwKVxuICAgIF07XG5cbiAgICB2YXIgaCA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKHZlcnRpY2VzLCBpbmRpY2VzKTtcbiAgICB0aGlzLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbiA9IGg7XG4gICAgaC5tYXRlcmlhbCA9IHRoaXMubWF0ZXJpYWw7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgY2FsY3VsYXRlTG9jYWxJbmVydGlhXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IG1hc3NcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuQm94LnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgQm94LmNhbGN1bGF0ZUluZXJ0aWEodGhpcy5oYWxmRXh0ZW50cywgbWFzcywgdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuQm94LmNhbGN1bGF0ZUluZXJ0aWEgPSBmdW5jdGlvbihoYWxmRXh0ZW50cyxtYXNzLHRhcmdldCl7XG4gICAgdmFyIGUgPSBoYWxmRXh0ZW50cztcbiAgICB0YXJnZXQueCA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS55KjIqZS55ICsgMiplLnoqMiplLnogKTtcbiAgICB0YXJnZXQueSA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS54KjIqZS54ICsgMiplLnoqMiplLnogKTtcbiAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAgIDIqZS55KjIqZS55ICsgMiplLngqMiplLnggKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBib3ggNiBzaWRlIG5vcm1hbHNcbiAqIEBtZXRob2QgZ2V0U2lkZU5vcm1hbHNcbiAqIEBwYXJhbSB7YXJyYXl9ICAgICAgc2l4VGFyZ2V0VmVjdG9ycyBBbiBhcnJheSBvZiA2IHZlY3RvcnMsIHRvIHN0b3JlIHRoZSByZXN1bHRpbmcgc2lkZSBub3JtYWxzIGluLlxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0ICAgICAgICAgICAgIE9yaWVudGF0aW9uIHRvIGFwcGx5IHRvIHRoZSBub3JtYWwgdmVjdG9ycy4gSWYgbm90IHByb3ZpZGVkLCB0aGUgdmVjdG9ycyB3aWxsIGJlIGluIHJlc3BlY3QgdG8gdGhlIGxvY2FsIGZyYW1lLlxuICogQHJldHVybiB7YXJyYXl9XG4gKi9cbkJveC5wcm90b3R5cGUuZ2V0U2lkZU5vcm1hbHMgPSBmdW5jdGlvbihzaXhUYXJnZXRWZWN0b3JzLHF1YXQpe1xuICAgIHZhciBzaWRlcyA9IHNpeFRhcmdldFZlY3RvcnM7XG4gICAgdmFyIGV4ID0gdGhpcy5oYWxmRXh0ZW50cztcbiAgICBzaWRlc1swXS5zZXQoICBleC54LCAgICAgMCwgICAgIDApO1xuICAgIHNpZGVzWzFdLnNldCggICAgIDAsICBleC55LCAgICAgMCk7XG4gICAgc2lkZXNbMl0uc2V0KCAgICAgMCwgICAgIDAsICBleC56KTtcbiAgICBzaWRlc1szXS5zZXQoIC1leC54LCAgICAgMCwgICAgIDApO1xuICAgIHNpZGVzWzRdLnNldCggICAgIDAsIC1leC55LCAgICAgMCk7XG4gICAgc2lkZXNbNV0uc2V0KCAgICAgMCwgICAgIDAsIC1leC56KTtcblxuICAgIGlmKHF1YXQhPT11bmRlZmluZWQpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PXNpZGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHF1YXQudm11bHQoc2lkZXNbaV0sc2lkZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpZGVzO1xufTtcblxuQm94LnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA4LjAgKiB0aGlzLmhhbGZFeHRlbnRzLnggKiB0aGlzLmhhbGZFeHRlbnRzLnkgKiB0aGlzLmhhbGZFeHRlbnRzLno7XG59O1xuXG5Cb3gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gdGhpcy5oYWxmRXh0ZW50cy5ub3JtKCk7XG59O1xuXG52YXIgd29ybGRDb3JuZXJUZW1wUG9zID0gbmV3IFZlYzMoKTtcbnZhciB3b3JsZENvcm5lclRlbXBOZWcgPSBuZXcgVmVjMygpO1xuQm94LnByb3RvdHlwZS5mb3JFYWNoV29ybGRDb3JuZXIgPSBmdW5jdGlvbihwb3MscXVhdCxjYWxsYmFjayl7XG5cbiAgICB2YXIgZSA9IHRoaXMuaGFsZkV4dGVudHM7XG4gICAgdmFyIGNvcm5lcnMgPSBbWyAgZS54LCAgZS55LCAgZS56XSxcbiAgICAgICAgICAgICAgICAgICBbIC1lLngsICBlLnksICBlLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgLWUueCwgLWUueSwgIGUuel0sXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAtZS55LCAtZS56XSxcbiAgICAgICAgICAgICAgICAgICBbICBlLngsIC1lLnksIC1lLnpdLFxuICAgICAgICAgICAgICAgICAgIFsgIGUueCwgIGUueSwgLWUuel0sXG4gICAgICAgICAgICAgICAgICAgWyAtZS54LCAgZS55LCAtZS56XSxcbiAgICAgICAgICAgICAgICAgICBbICBlLngsIC1lLnksICBlLnpdXTtcbiAgICBmb3IodmFyIGk9MDsgaTxjb3JuZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnNldChjb3JuZXJzW2ldWzBdLGNvcm5lcnNbaV1bMV0sY29ybmVyc1tpXVsyXSk7XG4gICAgICAgIHF1YXQudm11bHQod29ybGRDb3JuZXJUZW1wUG9zLHdvcmxkQ29ybmVyVGVtcFBvcyk7XG4gICAgICAgIHBvcy52YWRkKHdvcmxkQ29ybmVyVGVtcFBvcyx3b3JsZENvcm5lclRlbXBQb3MpO1xuICAgICAgICBjYWxsYmFjayh3b3JsZENvcm5lclRlbXBQb3MueCxcbiAgICAgICAgICAgICAgICAgd29ybGRDb3JuZXJUZW1wUG9zLnksXG4gICAgICAgICAgICAgICAgIHdvcmxkQ29ybmVyVGVtcFBvcy56KTtcbiAgICB9XG59O1xuXG52YXIgd29ybGRDb3JuZXJzVGVtcCA9IFtcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKCksXG4gICAgbmV3IFZlYzMoKSxcbiAgICBuZXcgVmVjMygpLFxuICAgIG5ldyBWZWMzKClcbl07XG5Cb3gucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xuXG4gICAgdmFyIGUgPSB0aGlzLmhhbGZFeHRlbnRzO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbMF0uc2V0KGUueCwgZS55LCBlLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbMV0uc2V0KC1lLngsICBlLnksIGUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFsyXS5zZXQoLWUueCwgLWUueSwgZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzNdLnNldCgtZS54LCAtZS55LCAtZS56KTtcbiAgICB3b3JsZENvcm5lcnNUZW1wWzRdLnNldChlLngsIC1lLnksIC1lLnopO1xuICAgIHdvcmxkQ29ybmVyc1RlbXBbNV0uc2V0KGUueCwgIGUueSwgLWUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFs2XS5zZXQoLWUueCwgIGUueSwgLWUueik7XG4gICAgd29ybGRDb3JuZXJzVGVtcFs3XS5zZXQoZS54LCAtZS55LCAgZS56KTtcblxuICAgIHZhciB3YyA9IHdvcmxkQ29ybmVyc1RlbXBbMF07XG4gICAgcXVhdC52bXVsdCh3Yywgd2MpO1xuICAgIHBvcy52YWRkKHdjLCB3Yyk7XG4gICAgbWF4LmNvcHkod2MpO1xuICAgIG1pbi5jb3B5KHdjKTtcbiAgICBmb3IodmFyIGk9MTsgaTw4OyBpKyspe1xuICAgICAgICB2YXIgd2MgPSB3b3JsZENvcm5lcnNUZW1wW2ldO1xuICAgICAgICBxdWF0LnZtdWx0KHdjLCB3Yyk7XG4gICAgICAgIHBvcy52YWRkKHdjLCB3Yyk7XG4gICAgICAgIHZhciB4ID0gd2MueDtcbiAgICAgICAgdmFyIHkgPSB3Yy55O1xuICAgICAgICB2YXIgeiA9IHdjLno7XG4gICAgICAgIGlmKHggPiBtYXgueCl7XG4gICAgICAgICAgICBtYXgueCA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYoeSA+IG1heC55KXtcbiAgICAgICAgICAgIG1heC55ID0geTtcbiAgICAgICAgfVxuICAgICAgICBpZih6ID4gbWF4Lnope1xuICAgICAgICAgICAgbWF4LnogPSB6O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoeCA8IG1pbi54KXtcbiAgICAgICAgICAgIG1pbi54ID0geDtcbiAgICAgICAgfVxuICAgICAgICBpZih5IDwgbWluLnkpe1xuICAgICAgICAgICAgbWluLnkgPSB5O1xuICAgICAgICB9XG4gICAgICAgIGlmKHogPCBtaW4ueil7XG4gICAgICAgICAgICBtaW4ueiA9IHo7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXQgZWFjaCBheGlzIG1heFxuICAgIC8vIG1pbi5zZXQoSW5maW5pdHksSW5maW5pdHksSW5maW5pdHkpO1xuICAgIC8vIG1heC5zZXQoLUluZmluaXR5LC1JbmZpbml0eSwtSW5maW5pdHkpO1xuICAgIC8vIHRoaXMuZm9yRWFjaFdvcmxkQ29ybmVyKHBvcyxxdWF0LGZ1bmN0aW9uKHgseSx6KXtcbiAgICAvLyAgICAgaWYoeCA+IG1heC54KXtcbiAgICAvLyAgICAgICAgIG1heC54ID0geDtcbiAgICAvLyAgICAgfVxuICAgIC8vICAgICBpZih5ID4gbWF4Lnkpe1xuICAgIC8vICAgICAgICAgbWF4LnkgPSB5O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHogPiBtYXgueil7XG4gICAgLy8gICAgICAgICBtYXgueiA9IHo7XG4gICAgLy8gICAgIH1cblxuICAgIC8vICAgICBpZih4IDwgbWluLngpe1xuICAgIC8vICAgICAgICAgbWluLnggPSB4O1xuICAgIC8vICAgICB9XG4gICAgLy8gICAgIGlmKHkgPCBtaW4ueSl7XG4gICAgLy8gICAgICAgICBtaW4ueSA9IHk7XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgaWYoeiA8IG1pbi56KXtcbiAgICAvLyAgICAgICAgIG1pbi56ID0gejtcbiAgICAvLyAgICAgfVxuICAgIC8vIH0pO1xufTtcblxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vQ29udmV4UG9seWhlZHJvblwiOjM4LFwiLi9TaGFwZVwiOjQzfV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBDb252ZXhQb2x5aGVkcm9uO1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBUcmFuc2Zvcm0gPSBfZGVyZXFfKCcuLi9tYXRoL1RyYW5zZm9ybScpO1xuXG4vKipcbiAqIEEgc2V0IG9mIHBvbHlnb25zIGRlc2NyaWJpbmcgYSBjb252ZXggc2hhcGUuXG4gKiBAY2xhc3MgQ29udmV4UG9seWhlZHJvblxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTaGFwZVxuICogQGRlc2NyaXB0aW9uIFRoZSBzaGFwZSBNVVNUIGJlIGNvbnZleCBmb3IgdGhlIGNvZGUgdG8gd29yayBwcm9wZXJseS4gTm8gcG9seWdvbnMgbWF5IGJlIGNvcGxhbmFyIChjb250YWluZWRcbiAqIGluIHRoZSBzYW1lIDNEIHBsYW5lKSwgaW5zdGVhZCB0aGVzZSBzaG91bGQgYmUgbWVyZ2VkIGludG8gb25lIHBvbHlnb24uXG4gKlxuICogQHBhcmFtIHthcnJheX0gcG9pbnRzIEFuIGFycmF5IG9mIFZlYzMnc1xuICogQHBhcmFtIHthcnJheX0gZmFjZXMgQXJyYXkgb2YgaW50ZWdlciBhcnJheXMsIGRlc2NyaWJpbmcgd2hpY2ggdmVydGljZXMgdGhhdCBpcyBpbmNsdWRlZCBpbiBlYWNoIGZhY2UuXG4gKlxuICogQGF1dGhvciBxaWFvIC8gaHR0cHM6Ly9naXRodWIuY29tL3FpYW8gKG9yaWdpbmFsIGF1dGhvciwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9xaWFvL3RocmVlLmpzL2NvbW1pdC84NTAyNmYwYzc2OWU0MDAwMTQ4YTY3ZDQ1YTllOWI5YzUxMDg4MzZmKVxuICogQGF1dGhvciBzY2h0ZXBwZSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2h0ZXBwZVxuICogQHNlZSBodHRwOi8vd3d3LmFsdGRldmJsb2dhZGF5LmNvbS8yMDExLzA1LzEzL2NvbnRhY3QtZ2VuZXJhdGlvbi1iZXR3ZWVuLTNkLWNvbnZleC1tZXNoZXMvXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXQuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NyYy9CdWxsZXRDb2xsaXNpb24vTmFycm93UGhhc2VDb2xsaXNpb24vYnRQb2x5aGVkcmFsQ29udGFjdENsaXBwaW5nLmNwcFxuICpcbiAqIEB0b2RvIE1vdmUgdGhlIGNsaXBwaW5nIGZ1bmN0aW9ucyB0byBDb250YWN0R2VuZXJhdG9yP1xuICogQHRvZG8gQXV0b21hdGljYWxseSBtZXJnZSBjb3BsYW5hciBwb2x5Z29ucyBpbiBjb25zdHJ1Y3Rvci5cbiAqL1xuZnVuY3Rpb24gQ29udmV4UG9seWhlZHJvbihwb2ludHMsIGZhY2VzLCB1bmlxdWVBeGVzKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgdGhpcy50eXBlID0gU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTjtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IHBvaW50c3x8W107XG5cbiAgICB0aGlzLndvcmxkVmVydGljZXMgPSBbXTsgLy8gV29ybGQgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiAudmVydGljZXNcbiAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBpbnRlZ2VyIGFycmF5cywgaW5kaWNhdGluZyB3aGljaCB2ZXJ0aWNlcyBlYWNoIGZhY2UgY29uc2lzdHMgb2ZcbiAgICAgKiBAcHJvcGVydHkgZmFjZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mYWNlcyA9IGZhY2VzfHxbXTtcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgZmFjZU5vcm1hbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5mYWNlTm9ybWFscyA9IFtdO1xuICAgIHRoaXMuY29tcHV0ZU5vcm1hbHMoKTtcblxuICAgIHRoaXMud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLndvcmxkRmFjZU5vcm1hbHMgPSBbXTsgLy8gV29ybGQgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiAuZmFjZU5vcm1hbHNcblxuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIFZlYzNcbiAgICAgKiBAcHJvcGVydHkgdW5pcXVlRWRnZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy51bmlxdWVFZGdlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSWYgZ2l2ZW4sIHRoZXNlIGxvY2FsbHkgZGVmaW5lZCwgbm9ybWFsaXplZCBheGVzIGFyZSB0aGUgb25seSBvbmVzIGJlaW5nIGNoZWNrZWQgd2hlbiBkb2luZyBzZXBhcmF0aW5nIGF4aXMgY2hlY2suXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gdW5pcXVlQXhlc1xuICAgICAqL1xuICAgIHRoaXMudW5pcXVlQXhlcyA9IHVuaXF1ZUF4ZXMgPyB1bmlxdWVBeGVzLnNsaWNlKCkgOiBudWxsO1xuXG4gICAgdGhpcy5jb21wdXRlRWRnZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG59XG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb252ZXhQb2x5aGVkcm9uO1xuXG52YXIgY29tcHV0ZUVkZ2VzX3RtcEVkZ2UgPSBuZXcgVmVjMygpO1xuLyoqXG4gKiBDb21wdXRlcyB1bmlxdWVFZGdlc1xuICogQG1ldGhvZCBjb21wdXRlRWRnZXNcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZUVkZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZmFjZXMgPSB0aGlzLmZhY2VzO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIG52ID0gdmVydGljZXMubGVuZ3RoO1xuICAgIHZhciBlZGdlcyA9IHRoaXMudW5pcXVlRWRnZXM7XG5cbiAgICBlZGdlcy5sZW5ndGggPSAwO1xuXG4gICAgdmFyIGVkZ2UgPSBjb21wdXRlRWRnZXNfdG1wRWRnZTtcblxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBmYWNlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbaV07XG4gICAgICAgIHZhciBudW1WZXJ0aWNlcyA9IGZhY2UubGVuZ3RoO1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqICE9PSBudW1WZXJ0aWNlczsgaisrKXtcbiAgICAgICAgICAgIHZhciBrID0gKCBqKzEgKSAlIG51bVZlcnRpY2VzO1xuICAgICAgICAgICAgdmVydGljZXNbZmFjZVtqXV0udnN1Yih2ZXJ0aWNlc1tmYWNlW2tdXSwgZWRnZSk7XG4gICAgICAgICAgICBlZGdlLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IodmFyIHA9MDsgcCAhPT0gZWRnZXMubGVuZ3RoOyBwKyspe1xuICAgICAgICAgICAgICAgIGlmIChlZGdlc1twXS5hbG1vc3RFcXVhbHMoZWRnZSkgfHwgZWRnZXNbcF0uYWxtb3N0RXF1YWxzKGVkZ2UpKXtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZm91bmQpe1xuICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goZWRnZS5jbG9uZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbm9ybWFscyBvZiB0aGUgZmFjZXMuIFdpbGwgcmV1c2UgZXhpc3RpbmcgVmVjMyBvYmplY3RzIGluIHRoZSAuZmFjZU5vcm1hbHMgYXJyYXkgaWYgdGhleSBleGlzdC5cbiAqIEBtZXRob2QgY29tcHV0ZU5vcm1hbHNcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY29tcHV0ZU5vcm1hbHMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZmFjZU5vcm1hbHMubGVuZ3RoID0gdGhpcy5mYWNlcy5sZW5ndGg7XG5cbiAgICAvLyBHZW5lcmF0ZSBub3JtYWxzXG4gICAgZm9yKHZhciBpPTA7IGk8dGhpcy5mYWNlcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgLy8gQ2hlY2sgc28gYWxsIHZlcnRpY2VzIGV4aXN0cyBmb3IgdGhpcyBmYWNlXG4gICAgICAgIGZvcih2YXIgaj0wOyBqPHRoaXMuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgaWYoIXRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVtqXV0pe1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnRleCBcIit0aGlzLmZhY2VzW2ldW2pdK1wiIG5vdCBmb3VuZCFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbiA9IHRoaXMuZmFjZU5vcm1hbHNbaV0gfHwgbmV3IFZlYzMoKTtcbiAgICAgICAgdGhpcy5nZXRGYWNlTm9ybWFsKGksbik7XG4gICAgICAgIG4ubmVnYXRlKG4pO1xuICAgICAgICB0aGlzLmZhY2VOb3JtYWxzW2ldID0gbjtcbiAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMudmVydGljZXNbdGhpcy5mYWNlc1tpXVswXV07XG4gICAgICAgIGlmKG4uZG90KHZlcnRleCkgPCAwKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCIuZmFjZU5vcm1hbHNbXCIgKyBpICsgXCJdID0gVmVjMyhcIituLnRvU3RyaW5nKCkrXCIpIGxvb2tzIGxpa2UgaXQgcG9pbnRzIGludG8gdGhlIHNoYXBlPyBUaGUgdmVydGljZXMgZm9sbG93LiBNYWtlIHN1cmUgdGhleSBhcmUgb3JkZXJlZCBDQ1cgYXJvdW5kIHRoZSBub3JtYWwsIHVzaW5nIHRoZSByaWdodCBoYW5kIHJ1bGUuXCIpO1xuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGo8dGhpcy5mYWNlc1tpXS5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiLnZlcnRpY2VzW1wiK3RoaXMuZmFjZXNbaV1bal0rXCJdID0gVmVjMyhcIit0aGlzLnZlcnRpY2VzW3RoaXMuZmFjZXNbaV1bal1dLnRvU3RyaW5nKCkrXCIpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgZmFjZSBub3JtYWwgZ2l2ZW4gMyB2ZXJ0aWNlc1xuICogQHN0YXRpY1xuICogQG1ldGhvZCBnZXRGYWNlTm9ybWFsXG4gKiBAcGFyYW0ge1ZlYzN9IHZhXG4gKiBAcGFyYW0ge1ZlYzN9IHZiXG4gKiBAcGFyYW0ge1ZlYzN9IHZjXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldFxuICovXG52YXIgY2IgPSBuZXcgVmVjMygpO1xudmFyIGFiID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24uY29tcHV0ZU5vcm1hbCA9IGZ1bmN0aW9uICggdmEsIHZiLCB2YywgdGFyZ2V0ICkge1xuICAgIHZiLnZzdWIodmEsYWIpO1xuICAgIHZjLnZzdWIodmIsY2IpO1xuICAgIGNiLmNyb3NzKGFiLHRhcmdldCk7XG4gICAgaWYgKCAhdGFyZ2V0LmlzWmVybygpICkge1xuICAgICAgICB0YXJnZXQubm9ybWFsaXplKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBub3JtYWwgb2YgYSBmYWNlIGZyb20gaXRzIHZlcnRpY2VzXG4gKiBAbWV0aG9kIGdldEZhY2VOb3JtYWxcbiAqIEBwYXJhbSAge051bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldEZhY2VOb3JtYWwgPSBmdW5jdGlvbihpLHRhcmdldCl7XG4gICAgdmFyIGYgPSB0aGlzLmZhY2VzW2ldO1xuICAgIHZhciB2YSA9IHRoaXMudmVydGljZXNbZlswXV07XG4gICAgdmFyIHZiID0gdGhpcy52ZXJ0aWNlc1tmWzFdXTtcbiAgICB2YXIgdmMgPSB0aGlzLnZlcnRpY2VzW2ZbMl1dO1xuICAgIHJldHVybiBDb252ZXhQb2x5aGVkcm9uLmNvbXB1dGVOb3JtYWwodmEsdmIsdmMsdGFyZ2V0KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBjbGlwQWdhaW5zdEh1bGxcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxuICogQHBhcmFtIHtWZWMzfSBwb3NCXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRCXG4gKiBAcGFyYW0ge1ZlYzN9IHNlcGFyYXRpbmdOb3JtYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IENsYW1wIGRpc3RhbmNlXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGlzdFxuICogQHBhcmFtIHthcnJheX0gcmVzdWx0IFRoZSBhbiBhcnJheSBvZiBjb250YWN0IHBvaW50IG9iamVjdHMsIHNlZSBjbGlwRmFjZUFnYWluc3RIdWxsXG4gKiBAc2VlIGh0dHA6Ly9idWxsZXQuZ29vZ2xlY29kZS5jb20vc3ZuL3RydW5rL3NyYy9CdWxsZXRDb2xsaXNpb24vTmFycm93UGhhc2VDb2xsaXNpb24vYnRQb2x5aGVkcmFsQ29udGFjdENsaXBwaW5nLmNwcFxuICovXG52YXIgY2FoX1dvcmxkTm9ybWFsID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBBZ2FpbnN0SHVsbCA9IGZ1bmN0aW9uKHBvc0EscXVhdEEsaHVsbEIscG9zQixxdWF0QixzZXBhcmF0aW5nTm9ybWFsLG1pbkRpc3QsbWF4RGlzdCxyZXN1bHQpe1xuICAgIHZhciBXb3JsZE5vcm1hbCA9IGNhaF9Xb3JsZE5vcm1hbDtcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xuICAgIHZhciBjdXJNYXhEaXN0ID0gbWF4RGlzdDtcbiAgICB2YXIgY2xvc2VzdEZhY2VCID0gLTE7XG4gICAgdmFyIGRtYXggPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBmb3IodmFyIGZhY2U9MDsgZmFjZSA8IGh1bGxCLmZhY2VzLmxlbmd0aDsgZmFjZSsrKXtcbiAgICAgICAgV29ybGROb3JtYWwuY29weShodWxsQi5mYWNlTm9ybWFsc1tmYWNlXSk7XG4gICAgICAgIHF1YXRCLnZtdWx0KFdvcmxkTm9ybWFsLFdvcmxkTm9ybWFsKTtcbiAgICAgICAgLy9wb3NCLnZhZGQoV29ybGROb3JtYWwsV29ybGROb3JtYWwpO1xuICAgICAgICB2YXIgZCA9IFdvcmxkTm9ybWFsLmRvdChzZXBhcmF0aW5nTm9ybWFsKTtcbiAgICAgICAgaWYgKGQgPiBkbWF4KXtcbiAgICAgICAgICAgIGRtYXggPSBkO1xuICAgICAgICAgICAgY2xvc2VzdEZhY2VCID0gZmFjZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgd29ybGRWZXJ0c0IxID0gW107XG4gICAgdmFyIHBvbHlCID0gaHVsbEIuZmFjZXNbY2xvc2VzdEZhY2VCXTtcbiAgICB2YXIgbnVtVmVydGljZXMgPSBwb2x5Qi5sZW5ndGg7XG4gICAgZm9yKHZhciBlMD0wOyBlMDxudW1WZXJ0aWNlczsgZTArKyl7XG4gICAgICAgIHZhciBiID0gaHVsbEIudmVydGljZXNbcG9seUJbZTBdXTtcbiAgICAgICAgdmFyIHdvcmxkYiA9IG5ldyBWZWMzKCk7XG4gICAgICAgIHdvcmxkYi5jb3B5KGIpO1xuICAgICAgICBxdWF0Qi52bXVsdCh3b3JsZGIsd29ybGRiKTtcbiAgICAgICAgcG9zQi52YWRkKHdvcmxkYix3b3JsZGIpO1xuICAgICAgICB3b3JsZFZlcnRzQjEucHVzaCh3b3JsZGIpO1xuICAgIH1cblxuICAgIGlmIChjbG9zZXN0RmFjZUI+PTApe1xuICAgICAgICB0aGlzLmNsaXBGYWNlQWdhaW5zdEh1bGwoc2VwYXJhdGluZ05vcm1hbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc0EsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWF0QSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmxkVmVydHNCMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhEaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0KTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZpbmQgdGhlIHNlcGFyYXRpbmcgYXhpcyBiZXR3ZWVuIHRoaXMgaHVsbCBhbmQgYW5vdGhlclxuICogQG1ldGhvZCBmaW5kU2VwYXJhdGluZ0F4aXNcbiAqIEBwYXJhbSB7Q29udmV4UG9seWhlZHJvbn0gaHVsbEJcbiAqIEBwYXJhbSB7VmVjM30gcG9zQVxuICogQHBhcmFtIHtRdWF0ZXJuaW9ufSBxdWF0QVxuICogQHBhcmFtIHtWZWMzfSBwb3NCXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRCXG4gKiBAcGFyYW0ge1ZlYzN9IHRhcmdldCBUaGUgdGFyZ2V0IHZlY3RvciB0byBzYXZlIHRoZSBheGlzIGluXG4gKiBAcmV0dXJuIHtib29sfSBSZXR1cm5zIGZhbHNlIGlmIGEgc2VwYXJhdGlvbiBpcyBmb3VuZCwgZWxzZSB0cnVlXG4gKi9cbnZhciBmc2FfZmFjZUFOb3JtYWxXUzMgPSBuZXcgVmVjMygpLFxuICAgIGZzYV9Xb3JsZG5vcm1hbDEgPSBuZXcgVmVjMygpLFxuICAgIGZzYV9kZWx0YUMgPSBuZXcgVmVjMygpLFxuICAgIGZzYV93b3JsZEVkZ2UwID0gbmV3IFZlYzMoKSxcbiAgICBmc2Ffd29ybGRFZGdlMSA9IG5ldyBWZWMzKCksXG4gICAgZnNhX0Nyb3NzID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmZpbmRTZXBhcmF0aW5nQXhpcyA9IGZ1bmN0aW9uKGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qix0YXJnZXQsIGZhY2VMaXN0QSwgZmFjZUxpc3RCKXtcbiAgICB2YXIgZmFjZUFOb3JtYWxXUzMgPSBmc2FfZmFjZUFOb3JtYWxXUzMsXG4gICAgICAgIFdvcmxkbm9ybWFsMSA9IGZzYV9Xb3JsZG5vcm1hbDEsXG4gICAgICAgIGRlbHRhQyA9IGZzYV9kZWx0YUMsXG4gICAgICAgIHdvcmxkRWRnZTAgPSBmc2Ffd29ybGRFZGdlMCxcbiAgICAgICAgd29ybGRFZGdlMSA9IGZzYV93b3JsZEVkZ2UxLFxuICAgICAgICBDcm9zcyA9IGZzYV9Dcm9zcztcblxuICAgIHZhciBkbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB2YXIgaHVsbEEgPSB0aGlzO1xuICAgIHZhciBjdXJQbGFuZVRlc3RzPTA7XG5cbiAgICBpZighaHVsbEEudW5pcXVlQXhlcyl7XG5cbiAgICAgICAgdmFyIG51bUZhY2VzQSA9IGZhY2VMaXN0QSA/IGZhY2VMaXN0QS5sZW5ndGggOiBodWxsQS5mYWNlcy5sZW5ndGg7XG5cbiAgICAgICAgLy8gVGVzdCBmYWNlIG5vcm1hbHMgZnJvbSBodWxsQVxuICAgICAgICBmb3IodmFyIGk9MDsgaTxudW1GYWNlc0E7IGkrKyl7XG4gICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEEgPyBmYWNlTGlzdEFbaV0gOiBpO1xuXG4gICAgICAgICAgICAvLyBHZXQgd29ybGQgZmFjZSBub3JtYWxcbiAgICAgICAgICAgIGZhY2VBTm9ybWFsV1MzLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmldKTtcbiAgICAgICAgICAgIHF1YXRBLnZtdWx0KGZhY2VBTm9ybWFsV1MzLGZhY2VBTm9ybWFsV1MzKTtcblxuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhmYWNlQU5vcm1hbFdTMywgaHVsbEIsIHBvc0EsIHF1YXRBLCBwb3NCLCBxdWF0Qik7XG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDxkbWluKXtcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShmYWNlQU5vcm1hbFdTMyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gVGVzdCB1bmlxdWUgYXhlc1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBodWxsQS51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKXtcblxuICAgICAgICAgICAgLy8gR2V0IHdvcmxkIGF4aXNcbiAgICAgICAgICAgIHF1YXRBLnZtdWx0KGh1bGxBLnVuaXF1ZUF4ZXNbaV0sZmFjZUFOb3JtYWxXUzMpO1xuXG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKGZhY2VBTm9ybWFsV1MzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcbiAgICAgICAgICAgIGlmKGQ9PT1mYWxzZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KGZhY2VBTm9ybWFsV1MzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKCFodWxsQi51bmlxdWVBeGVzKXtcblxuICAgICAgICAvLyBUZXN0IGZhY2Ugbm9ybWFscyBmcm9tIGh1bGxCXG4gICAgICAgIHZhciBudW1GYWNlc0IgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEIubGVuZ3RoIDogaHVsbEIuZmFjZXMubGVuZ3RoO1xuICAgICAgICBmb3IodmFyIGk9MDtpPG51bUZhY2VzQjtpKyspe1xuXG4gICAgICAgICAgICB2YXIgZmkgPSBmYWNlTGlzdEIgPyBmYWNlTGlzdEJbaV0gOiBpO1xuXG4gICAgICAgICAgICBXb3JsZG5vcm1hbDEuY29weShodWxsQi5mYWNlTm9ybWFsc1tmaV0pO1xuICAgICAgICAgICAgcXVhdEIudm11bHQoV29ybGRub3JtYWwxLFdvcmxkbm9ybWFsMSk7XG4gICAgICAgICAgICBjdXJQbGFuZVRlc3RzKys7XG4gICAgICAgICAgICB2YXIgZCA9IGh1bGxBLnRlc3RTZXBBeGlzKFdvcmxkbm9ybWFsMSwgaHVsbEIscG9zQSxxdWF0QSxwb3NCLHF1YXRCKTtcbiAgICAgICAgICAgIGlmKGQ9PT1mYWxzZSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihkPGRtaW4pe1xuICAgICAgICAgICAgICAgIGRtaW4gPSBkO1xuICAgICAgICAgICAgICAgIHRhcmdldC5jb3B5KFdvcmxkbm9ybWFsMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIFRlc3QgdW5pcXVlIGF4ZXMgaW4gQlxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpICE9PSBodWxsQi51bmlxdWVBeGVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHF1YXRCLnZtdWx0KGh1bGxCLnVuaXF1ZUF4ZXNbaV0sV29ybGRub3JtYWwxKTtcblxuICAgICAgICAgICAgY3VyUGxhbmVUZXN0cysrO1xuICAgICAgICAgICAgdmFyIGQgPSBodWxsQS50ZXN0U2VwQXhpcyhXb3JsZG5vcm1hbDEsIGh1bGxCLHBvc0EscXVhdEEscG9zQixxdWF0Qik7XG4gICAgICAgICAgICBpZihkPT09ZmFsc2Upe1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoZDxkbWluKXtcbiAgICAgICAgICAgICAgICBkbWluID0gZDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuY29weShXb3JsZG5vcm1hbDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGVzdCBlZGdlc1xuICAgIGZvcih2YXIgZTA9MDsgZTAgIT09IGh1bGxBLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTArKyl7XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkIGVkZ2VcbiAgICAgICAgcXVhdEEudm11bHQoaHVsbEEudW5pcXVlRWRnZXNbZTBdLHdvcmxkRWRnZTApO1xuXG4gICAgICAgIGZvcih2YXIgZTE9MDsgZTEgIT09IGh1bGxCLnVuaXF1ZUVkZ2VzLmxlbmd0aDsgZTErKyl7XG5cbiAgICAgICAgICAgIC8vIEdldCB3b3JsZCBlZGdlIDJcbiAgICAgICAgICAgIHF1YXRCLnZtdWx0KGh1bGxCLnVuaXF1ZUVkZ2VzW2UxXSwgd29ybGRFZGdlMSk7XG4gICAgICAgICAgICB3b3JsZEVkZ2UwLmNyb3NzKHdvcmxkRWRnZTEsQ3Jvc3MpO1xuXG4gICAgICAgICAgICBpZighQ3Jvc3MuYWxtb3N0WmVybygpKXtcbiAgICAgICAgICAgICAgICBDcm9zcy5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IGh1bGxBLnRlc3RTZXBBeGlzKENyb3NzLCBodWxsQiwgcG9zQSwgcXVhdEEsIHBvc0IsIHF1YXRCKTtcbiAgICAgICAgICAgICAgICBpZihkaXN0ID09PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IGRtaW4pe1xuICAgICAgICAgICAgICAgICAgICBkbWluID0gZGlzdDtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmNvcHkoQ3Jvc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHBvc0IudnN1Yihwb3NBLGRlbHRhQyk7XG4gICAgaWYoKGRlbHRhQy5kb3QodGFyZ2V0KSk+MC4wKXtcbiAgICAgICAgdGFyZ2V0Lm5lZ2F0ZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufTtcblxudmFyIG1heG1pbkE9W10sIG1heG1pbkI9W107XG5cbi8qKlxuICogVGVzdCBzZXBhcmF0aW5nIGF4aXMgYWdhaW5zdCB0d28gaHVsbHMuIEJvdGggaHVsbHMgYXJlIHByb2plY3RlZCBvbnRvIHRoZSBheGlzIGFuZCB0aGUgb3ZlcmxhcCBzaXplIGlzIHJldHVybmVkIGlmIHRoZXJlIGlzIG9uZS5cbiAqIEBtZXRob2QgdGVzdFNlcEF4aXNcbiAqIEBwYXJhbSB7VmVjM30gYXhpc1xuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsQlxuICogQHBhcmFtIHtWZWMzfSBwb3NBXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXG4gKiBAcGFyYW0ge1ZlYzN9IHBvc0JcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gcXVhdEJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG92ZXJsYXAgZGVwdGgsIG9yIEZBTFNFIGlmIG5vIHBlbmV0cmF0aW9uLlxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS50ZXN0U2VwQXhpcyA9IGZ1bmN0aW9uKGF4aXMsIGh1bGxCLCBwb3NBLCBxdWF0QSwgcG9zQiwgcXVhdEIpe1xuICAgIHZhciBodWxsQT10aGlzO1xuICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQSwgYXhpcywgcG9zQSwgcXVhdEEsIG1heG1pbkEpO1xuICAgIENvbnZleFBvbHloZWRyb24ucHJvamVjdChodWxsQiwgYXhpcywgcG9zQiwgcXVhdEIsIG1heG1pbkIpO1xuICAgIHZhciBtYXhBID0gbWF4bWluQVswXTtcbiAgICB2YXIgbWluQSA9IG1heG1pbkFbMV07XG4gICAgdmFyIG1heEIgPSBtYXhtaW5CWzBdO1xuICAgIHZhciBtaW5CID0gbWF4bWluQlsxXTtcbiAgICBpZihtYXhBPG1pbkIgfHwgbWF4QjxtaW5BKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBTZXBhcmF0ZWRcbiAgICB9XG4gICAgdmFyIGQwID0gbWF4QSAtIG1pbkI7XG4gICAgdmFyIGQxID0gbWF4QiAtIG1pbkE7XG4gICAgdmFyIGRlcHRoID0gZDA8ZDEgPyBkMDpkMTtcbiAgICByZXR1cm4gZGVwdGg7XG59O1xuXG52YXIgY2xpX2FhYmJtaW4gPSBuZXcgVmVjMygpLFxuICAgIGNsaV9hYWJibWF4ID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIC8vIEFwcHJveGltYXRlIHdpdGggYm94IGluZXJ0aWFcbiAgICAvLyBFeGFjdCBpbmVydGlhIGNhbGN1bGF0aW9uIGlzIG92ZXJraWxsLCBidXQgc2VlIGh0dHA6Ly9nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9Qb2x5aGVkcmFsTWFzc1Byb3BlcnRpZXMucGRmIGZvciB0aGUgY29ycmVjdCB3YXkgdG8gZG8gaXRcbiAgICB0aGlzLmNvbXB1dGVMb2NhbEFBQkIoY2xpX2FhYmJtaW4sY2xpX2FhYmJtYXgpO1xuICAgIHZhciB4ID0gY2xpX2FhYmJtYXgueCAtIGNsaV9hYWJibWluLngsXG4gICAgICAgIHkgPSBjbGlfYWFiYm1heC55IC0gY2xpX2FhYmJtaW4ueSxcbiAgICAgICAgeiA9IGNsaV9hYWJibWF4LnogLSBjbGlfYWFiYm1pbi56O1xuICAgIHRhcmdldC54ID0gMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeSoyKnkgKyAyKnoqMip6ICk7XG4gICAgdGFyZ2V0LnkgPSAxLjAgLyAxMi4wICogbWFzcyAqICggMip4KjIqeCArIDIqeioyKnogKTtcbiAgICB0YXJnZXQueiA9IDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKnkqMip5ICsgMip4KjIqeCApO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIGdldFBsYW5lQ29uc3RhbnRPZkZhY2VcbiAqIEBwYXJhbSAge051bWJlcn0gZmFjZV9pIEluZGV4IG9mIHRoZSBmYWNlXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmdldFBsYW5lQ29uc3RhbnRPZkZhY2UgPSBmdW5jdGlvbihmYWNlX2kpe1xuICAgIHZhciBmID0gdGhpcy5mYWNlc1tmYWNlX2ldO1xuICAgIHZhciBuID0gdGhpcy5mYWNlTm9ybWFsc1tmYWNlX2ldO1xuICAgIHZhciB2ID0gdGhpcy52ZXJ0aWNlc1tmWzBdXTtcbiAgICB2YXIgYyA9IC1uLmRvdCh2KTtcbiAgICByZXR1cm4gYztcbn07XG5cbi8qKlxuICogQ2xpcCBhIGZhY2UgYWdhaW5zdCBhIGh1bGwuXG4gKiBAbWV0aG9kIGNsaXBGYWNlQWdhaW5zdEh1bGxcbiAqIEBwYXJhbSB7VmVjM30gc2VwYXJhdGluZ05vcm1hbFxuICogQHBhcmFtIHtWZWMzfSBwb3NBXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRBXG4gKiBAcGFyYW0ge0FycmF5fSB3b3JsZFZlcnRzQjEgQW4gYXJyYXkgb2YgVmVjMyB3aXRoIHZlcnRpY2VzIGluIHRoZSB3b3JsZCBmcmFtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBtaW5EaXN0IERpc3RhbmNlIGNsYW1waW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4RGlzdFxuICogQHBhcmFtIEFycmF5IHJlc3VsdCBBcnJheSB0byBzdG9yZSByZXN1bHRpbmcgY29udGFjdCBwb2ludHMgaW4uIFdpbGwgYmUgb2JqZWN0cyB3aXRoIHByb3BlcnRpZXM6IHBvaW50LCBkZXB0aCwgbm9ybWFsLiBUaGVzZSBhcmUgcmVwcmVzZW50ZWQgaW4gd29ybGQgY29vcmRpbmF0ZXMuXG4gKi9cbnZhciBjZmFoX2ZhY2VBTm9ybWFsV1MgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfZWRnZTAgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfV29ybGRFZGdlMCA9IG5ldyBWZWMzKCksXG4gICAgY2ZhaF93b3JsZFBsYW5lQW5vcm1hbDEgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfcGxhbmVOb3JtYWxXUzEgPSBuZXcgVmVjMygpLFxuICAgIGNmYWhfd29ybGRBMSA9IG5ldyBWZWMzKCksXG4gICAgY2ZhaF9sb2NhbFBsYW5lTm9ybWFsID0gbmV3IFZlYzMoKSxcbiAgICBjZmFoX3BsYW5lTm9ybWFsV1MgPSBuZXcgVmVjMygpO1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuY2xpcEZhY2VBZ2FpbnN0SHVsbCA9IGZ1bmN0aW9uKHNlcGFyYXRpbmdOb3JtYWwsIHBvc0EsIHF1YXRBLCB3b3JsZFZlcnRzQjEsIG1pbkRpc3QsIG1heERpc3QscmVzdWx0KXtcbiAgICB2YXIgZmFjZUFOb3JtYWxXUyA9IGNmYWhfZmFjZUFOb3JtYWxXUyxcbiAgICAgICAgZWRnZTAgPSBjZmFoX2VkZ2UwLFxuICAgICAgICBXb3JsZEVkZ2UwID0gY2ZhaF9Xb3JsZEVkZ2UwLFxuICAgICAgICB3b3JsZFBsYW5lQW5vcm1hbDEgPSBjZmFoX3dvcmxkUGxhbmVBbm9ybWFsMSxcbiAgICAgICAgcGxhbmVOb3JtYWxXUzEgPSBjZmFoX3BsYW5lTm9ybWFsV1MxLFxuICAgICAgICB3b3JsZEExID0gY2ZhaF93b3JsZEExLFxuICAgICAgICBsb2NhbFBsYW5lTm9ybWFsID0gY2ZhaF9sb2NhbFBsYW5lTm9ybWFsLFxuICAgICAgICBwbGFuZU5vcm1hbFdTID0gY2ZhaF9wbGFuZU5vcm1hbFdTO1xuXG4gICAgdmFyIGh1bGxBID0gdGhpcztcbiAgICB2YXIgd29ybGRWZXJ0c0IyID0gW107XG4gICAgdmFyIHBWdHhJbiA9IHdvcmxkVmVydHNCMTtcbiAgICB2YXIgcFZ0eE91dCA9IHdvcmxkVmVydHNCMjtcbiAgICAvLyBGaW5kIHRoZSBmYWNlIHdpdGggbm9ybWFsIGNsb3Nlc3QgdG8gdGhlIHNlcGFyYXRpbmcgYXhpc1xuICAgIHZhciBjbG9zZXN0RmFjZUEgPSAtMTtcbiAgICB2YXIgZG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgZm9yKHZhciBmYWNlPTA7IGZhY2U8aHVsbEEuZmFjZXMubGVuZ3RoOyBmYWNlKyspe1xuICAgICAgICBmYWNlQU5vcm1hbFdTLmNvcHkoaHVsbEEuZmFjZU5vcm1hbHNbZmFjZV0pO1xuICAgICAgICBxdWF0QS52bXVsdChmYWNlQU5vcm1hbFdTLGZhY2VBTm9ybWFsV1MpO1xuICAgICAgICAvL3Bvc0EudmFkZChmYWNlQU5vcm1hbFdTLGZhY2VBTm9ybWFsV1MpO1xuICAgICAgICB2YXIgZCA9IGZhY2VBTm9ybWFsV1MuZG90KHNlcGFyYXRpbmdOb3JtYWwpO1xuICAgICAgICBpZiAoZCA8IGRtaW4pe1xuICAgICAgICAgICAgZG1pbiA9IGQ7XG4gICAgICAgICAgICBjbG9zZXN0RmFjZUEgPSBmYWNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjbG9zZXN0RmFjZUEgPCAwKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coXCItLS0gZGlkIG5vdCBmaW5kIGFueSBjbG9zZXN0IGZhY2UuLi4gLS0tXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vY29uc29sZS5sb2coXCJjbG9zZXN0IEE6IFwiLGNsb3Nlc3RGYWNlQSk7XG4gICAgLy8gR2V0IHRoZSBmYWNlIGFuZCBjb25zdHJ1Y3QgY29ubmVjdGVkIGZhY2VzXG4gICAgdmFyIHBvbHlBID0gaHVsbEEuZmFjZXNbY2xvc2VzdEZhY2VBXTtcbiAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcyA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPGh1bGxBLmZhY2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGo8aHVsbEEuZmFjZXNbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgaWYocG9seUEuaW5kZXhPZihodWxsQS5mYWNlc1tpXVtqXSkhPT0tMSAvKiBTaGFyaW5nIGEgdmVydGV4Ki8gJiYgaSE9PWNsb3Nlc3RGYWNlQSAvKiBOb3QgdGhlIG9uZSB3ZSBhcmUgbG9va2luZyBmb3IgY29ubmVjdGlvbnMgZnJvbSAqLyAmJiBwb2x5QS5jb25uZWN0ZWRGYWNlcy5pbmRleE9mKGkpPT09LTEgLyogTm90IGFscmVhZHkgYWRkZWQgKi8gKXtcbiAgICAgICAgICAgICAgICBwb2x5QS5jb25uZWN0ZWRGYWNlcy5wdXNoKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENsaXAgdGhlIHBvbHlnb24gdG8gdGhlIGJhY2sgb2YgdGhlIHBsYW5lcyBvZiBhbGwgZmFjZXMgb2YgaHVsbCBBLCB0aGF0IGFyZSBhZGphY2VudCB0byB0aGUgd2l0bmVzcyBmYWNlXG4gICAgdmFyIG51bUNvbnRhY3RzID0gcFZ0eEluLmxlbmd0aDtcbiAgICB2YXIgbnVtVmVydGljZXNBID0gcG9seUEubGVuZ3RoO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IodmFyIGUwPTA7IGUwPG51bVZlcnRpY2VzQTsgZTArKyl7XG4gICAgICAgIHZhciBhID0gaHVsbEEudmVydGljZXNbcG9seUFbZTBdXTtcbiAgICAgICAgdmFyIGIgPSBodWxsQS52ZXJ0aWNlc1twb2x5QVsoZTArMSklbnVtVmVydGljZXNBXV07XG4gICAgICAgIGEudnN1YihiLGVkZ2UwKTtcbiAgICAgICAgV29ybGRFZGdlMC5jb3B5KGVkZ2UwKTtcbiAgICAgICAgcXVhdEEudm11bHQoV29ybGRFZGdlMCxXb3JsZEVkZ2UwKTtcbiAgICAgICAgcG9zQS52YWRkKFdvcmxkRWRnZTAsV29ybGRFZGdlMCk7XG4gICAgICAgIHdvcmxkUGxhbmVBbm9ybWFsMS5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7Ly90cmFuc0EuZ2V0QmFzaXMoKSogYnRWZWN0b3IzKHBvbHlBLm1fcGxhbmVbMF0scG9seUEubV9wbGFuZVsxXSxwb2x5QS5tX3BsYW5lWzJdKTtcbiAgICAgICAgcXVhdEEudm11bHQod29ybGRQbGFuZUFub3JtYWwxLHdvcmxkUGxhbmVBbm9ybWFsMSk7XG4gICAgICAgIHBvc0EudmFkZCh3b3JsZFBsYW5lQW5vcm1hbDEsd29ybGRQbGFuZUFub3JtYWwxKTtcbiAgICAgICAgV29ybGRFZGdlMC5jcm9zcyh3b3JsZFBsYW5lQW5vcm1hbDEscGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICBwbGFuZU5vcm1hbFdTMS5uZWdhdGUocGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICB3b3JsZEExLmNvcHkoYSk7XG4gICAgICAgIHF1YXRBLnZtdWx0KHdvcmxkQTEsd29ybGRBMSk7XG4gICAgICAgIHBvc0EudmFkZCh3b3JsZEExLHdvcmxkQTEpO1xuICAgICAgICB2YXIgcGxhbmVFcVdTMSA9IC13b3JsZEExLmRvdChwbGFuZU5vcm1hbFdTMSk7XG4gICAgICAgIHZhciBwbGFuZUVxV1M7XG4gICAgICAgIGlmKHRydWUpe1xuICAgICAgICAgICAgdmFyIG90aGVyRmFjZSA9IHBvbHlBLmNvbm5lY3RlZEZhY2VzW2UwXTtcbiAgICAgICAgICAgIGxvY2FsUGxhbmVOb3JtYWwuY29weSh0aGlzLmZhY2VOb3JtYWxzW290aGVyRmFjZV0pO1xuICAgICAgICAgICAgdmFyIGxvY2FsUGxhbmVFcSA9IHRoaXMuZ2V0UGxhbmVDb25zdGFudE9mRmFjZShvdGhlckZhY2UpO1xuXG4gICAgICAgICAgICBwbGFuZU5vcm1hbFdTLmNvcHkobG9jYWxQbGFuZU5vcm1hbCk7XG4gICAgICAgICAgICBxdWF0QS52bXVsdChwbGFuZU5vcm1hbFdTLHBsYW5lTm9ybWFsV1MpO1xuICAgICAgICAgICAgLy9wb3NBLnZhZGQocGxhbmVOb3JtYWxXUyxwbGFuZU5vcm1hbFdTKTtcbiAgICAgICAgICAgIHZhciBwbGFuZUVxV1MgPSBsb2NhbFBsYW5lRXEgLSBwbGFuZU5vcm1hbFdTLmRvdChwb3NBKTtcbiAgICAgICAgfSBlbHNlICB7XG4gICAgICAgICAgICBwbGFuZU5vcm1hbFdTLmNvcHkocGxhbmVOb3JtYWxXUzEpO1xuICAgICAgICAgICAgcGxhbmVFcVdTID0gcGxhbmVFcVdTMTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENsaXAgZmFjZSBhZ2FpbnN0IG91ciBjb25zdHJ1Y3RlZCBwbGFuZVxuICAgICAgICB0aGlzLmNsaXBGYWNlQWdhaW5zdFBsYW5lKHBWdHhJbiwgcFZ0eE91dCwgcGxhbmVOb3JtYWxXUywgcGxhbmVFcVdTKTtcblxuICAgICAgICAvLyBUaHJvdyBhd2F5IGFsbCBjbGlwcGVkIHBvaW50cywgYnV0IHNhdmUgdGhlIHJlYW1pbmluZyB1bnRpbCBuZXh0IGNsaXBcbiAgICAgICAgd2hpbGUocFZ0eEluLmxlbmd0aCl7XG4gICAgICAgICAgICBwVnR4SW4uc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZShwVnR4T3V0Lmxlbmd0aCl7XG4gICAgICAgICAgICBwVnR4SW4ucHVzaChwVnR4T3V0LnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy9jb25zb2xlLmxvZyhcIlJlc3VsdGluZyBwb2ludHMgYWZ0ZXIgY2xpcDpcIixwVnR4SW4pO1xuXG4gICAgLy8gb25seSBrZWVwIGNvbnRhY3QgcG9pbnRzIHRoYXQgYXJlIGJlaGluZCB0aGUgd2l0bmVzcyBmYWNlXG4gICAgbG9jYWxQbGFuZU5vcm1hbC5jb3B5KHRoaXMuZmFjZU5vcm1hbHNbY2xvc2VzdEZhY2VBXSk7XG5cbiAgICB2YXIgbG9jYWxQbGFuZUVxID0gdGhpcy5nZXRQbGFuZUNvbnN0YW50T2ZGYWNlKGNsb3Nlc3RGYWNlQSk7XG4gICAgcGxhbmVOb3JtYWxXUy5jb3B5KGxvY2FsUGxhbmVOb3JtYWwpO1xuICAgIHF1YXRBLnZtdWx0KHBsYW5lTm9ybWFsV1MscGxhbmVOb3JtYWxXUyk7XG5cbiAgICB2YXIgcGxhbmVFcVdTID0gbG9jYWxQbGFuZUVxIC0gcGxhbmVOb3JtYWxXUy5kb3QocG9zQSk7XG4gICAgZm9yICh2YXIgaT0wOyBpPHBWdHhJbi5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBkZXB0aCA9IHBsYW5lTm9ybWFsV1MuZG90KHBWdHhJbltpXSkgKyBwbGFuZUVxV1M7IC8vPz8/XG4gICAgICAgIC8qY29uc29sZS5sb2coXCJkZXB0aCBjYWxjIGZyb20gbm9ybWFsPVwiLHBsYW5lTm9ybWFsV1MudG9TdHJpbmcoKSxcIiBhbmQgY29uc3RhbnQgXCIrcGxhbmVFcVdTK1wiIGFuZCB2ZXJ0ZXggXCIscFZ0eEluW2ldLnRvU3RyaW5nKCksXCIgZ2l2ZXMgXCIrZGVwdGgpOyovXG4gICAgICAgIGlmIChkZXB0aCA8PW1pbkRpc3Qpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJjbGFtcGVkOiBkZXB0aD1cIitkZXB0aCtcIiB0byBtaW5EaXN0PVwiKyhtaW5EaXN0K1wiXCIpKTtcbiAgICAgICAgICAgIGRlcHRoID0gbWluRGlzdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXB0aCA8PW1heERpc3Qpe1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gcFZ0eEluW2ldO1xuICAgICAgICAgICAgaWYoZGVwdGg8PTApe1xuICAgICAgICAgICAgICAgIC8qY29uc29sZS5sb2coXCJHb3QgY29udGFjdCBwb2ludCBcIixwb2ludC50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCIsIGRlcHRoPVwiLGRlcHRoLFxuICAgICAgICAgICAgICAgICAgXCJjb250YWN0IG5vcm1hbD1cIixzZXBhcmF0aW5nTm9ybWFsLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICBcInBsYW5lXCIscGxhbmVOb3JtYWxXUy50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgXCJwbGFuZUNvbnN0YW50XCIscGxhbmVFcVdTKTsqL1xuICAgICAgICAgICAgICAgIHZhciBwID0ge1xuICAgICAgICAgICAgICAgICAgICBwb2ludDpwb2ludCxcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsOnBsYW5lTm9ybWFsV1MsXG4gICAgICAgICAgICAgICAgICAgIGRlcHRoOiBkZXB0aCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGlwIGEgZmFjZSBpbiBhIGh1bGwgYWdhaW5zdCB0aGUgYmFjayBvZiBhIHBsYW5lLlxuICogQG1ldGhvZCBjbGlwRmFjZUFnYWluc3RQbGFuZVxuICogQHBhcmFtIHtBcnJheX0gaW5WZXJ0aWNlc1xuICogQHBhcmFtIHtBcnJheX0gb3V0VmVydGljZXNcbiAqIEBwYXJhbSB7VmVjM30gcGxhbmVOb3JtYWxcbiAqIEBwYXJhbSB7TnVtYmVyfSBwbGFuZUNvbnN0YW50IFRoZSBjb25zdGFudCBpbiB0aGUgbWF0aGVtYXRpY2FsIHBsYW5lIGVxdWF0aW9uXG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNsaXBGYWNlQWdhaW5zdFBsYW5lID0gZnVuY3Rpb24oaW5WZXJ0aWNlcyxvdXRWZXJ0aWNlcywgcGxhbmVOb3JtYWwsIHBsYW5lQ29uc3RhbnQpe1xuICAgIHZhciBuX2RvdF9maXJzdCwgbl9kb3RfbGFzdDtcbiAgICB2YXIgbnVtVmVydHMgPSBpblZlcnRpY2VzLmxlbmd0aDtcblxuICAgIGlmKG51bVZlcnRzIDwgMil7XG4gICAgICAgIHJldHVybiBvdXRWZXJ0aWNlcztcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RWZXJ0ZXggPSBpblZlcnRpY2VzW2luVmVydGljZXMubGVuZ3RoLTFdLFxuICAgICAgICBsYXN0VmVydGV4ID0gICBpblZlcnRpY2VzWzBdO1xuXG4gICAgbl9kb3RfZmlyc3QgPSBwbGFuZU5vcm1hbC5kb3QoZmlyc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcblxuICAgIGZvcih2YXIgdmkgPSAwOyB2aSA8IG51bVZlcnRzOyB2aSsrKXtcbiAgICAgICAgbGFzdFZlcnRleCA9IGluVmVydGljZXNbdmldO1xuICAgICAgICBuX2RvdF9sYXN0ID0gcGxhbmVOb3JtYWwuZG90KGxhc3RWZXJ0ZXgpICsgcGxhbmVDb25zdGFudDtcbiAgICAgICAgaWYobl9kb3RfZmlyc3QgPCAwKXtcbiAgICAgICAgICAgIGlmKG5fZG90X2xhc3QgPCAwKXtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA8IDAsIGVuZCA8IDAsIHNvIG91dHB1dCBsYXN0VmVydGV4XG4gICAgICAgICAgICAgICAgdmFyIG5ld3YgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIG5ld3YuY29weShsYXN0VmVydGV4KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA8IDAsIGVuZCA+PSAwLCBzbyBvdXRwdXQgaW50ZXJzZWN0aW9uXG4gICAgICAgICAgICAgICAgdmFyIG5ld3YgPSBuZXcgVmVjMygpO1xuICAgICAgICAgICAgICAgIGZpcnN0VmVydGV4LmxlcnAobGFzdFZlcnRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5fZG90X2ZpcnN0IC8gKG5fZG90X2ZpcnN0IC0gbl9kb3RfbGFzdCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXd2KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKG5ld3YpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYobl9kb3RfbGFzdDwwKXtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCA+PSAwLCBlbmQgPCAwIHNvIG91dHB1dCBpbnRlcnNlY3Rpb24gYW5kIGVuZFxuICAgICAgICAgICAgICAgIHZhciBuZXd2ID0gbmV3IFZlYzMoKTtcbiAgICAgICAgICAgICAgICBmaXJzdFZlcnRleC5sZXJwKGxhc3RWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuX2RvdF9maXJzdCAvIChuX2RvdF9maXJzdCAtIG5fZG90X2xhc3QpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3dik7XG4gICAgICAgICAgICAgICAgb3V0VmVydGljZXMucHVzaChuZXd2KTtcbiAgICAgICAgICAgICAgICBvdXRWZXJ0aWNlcy5wdXNoKGxhc3RWZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpcnN0VmVydGV4ID0gbGFzdFZlcnRleDtcbiAgICAgICAgbl9kb3RfZmlyc3QgPSBuX2RvdF9sYXN0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0VmVydGljZXM7XG59O1xuXG4vLyBVcGRhdGVzIC53b3JsZFZlcnRpY2VzIGFuZCBzZXRzIC53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgdG8gZmFsc2UuXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jb21wdXRlV29ybGRWZXJ0aWNlcyA9IGZ1bmN0aW9uKHBvc2l0aW9uLHF1YXQpe1xuICAgIHZhciBOID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XG4gICAgd2hpbGUodGhpcy53b3JsZFZlcnRpY2VzLmxlbmd0aCA8IE4pe1xuICAgICAgICB0aGlzLndvcmxkVmVydGljZXMucHVzaCggbmV3IFZlYzMoKSApO1xuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIHdvcmxkVmVydHMgPSB0aGlzLndvcmxkVmVydGljZXM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBxdWF0LnZtdWx0KCB2ZXJ0c1tpXSAsIHdvcmxkVmVydHNbaV0gKTtcbiAgICAgICAgcG9zaXRpb24udmFkZCggd29ybGRWZXJ0c1tpXSAsIHdvcmxkVmVydHNbaV0gKTtcbiAgICB9XG5cbiAgICB0aGlzLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSA9IGZhbHNlO1xufTtcblxudmFyIGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0ID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVMb2NhbEFBQkIgPSBmdW5jdGlvbihhYWJibWluLGFhYmJtYXgpe1xuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgd29ybGRWZXJ0ID0gY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQ7XG5cbiAgICBhYWJibWluLnNldChOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICBhYWJibWF4LnNldCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFKTtcblxuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydGljZXNbaV07XG4gICAgICAgIGlmICAgICAodi54IDwgYWFiYm1pbi54KXtcbiAgICAgICAgICAgIGFhYmJtaW4ueCA9IHYueDtcbiAgICAgICAgfSBlbHNlIGlmKHYueCA+IGFhYmJtYXgueCl7XG4gICAgICAgICAgICBhYWJibWF4LnggPSB2Lng7XG4gICAgICAgIH1cbiAgICAgICAgaWYgICAgICh2LnkgPCBhYWJibWluLnkpe1xuICAgICAgICAgICAgYWFiYm1pbi55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gYWFiYm1heC55KXtcbiAgICAgICAgICAgIGFhYmJtYXgueSA9IHYueTtcbiAgICAgICAgfVxuICAgICAgICBpZiAgICAgKHYueiA8IGFhYmJtaW4ueil7XG4gICAgICAgICAgICBhYWJibWluLnogPSB2Lno7XG4gICAgICAgIH0gZWxzZSBpZih2LnogPiBhYWJibWF4Lnope1xuICAgICAgICAgICAgYWFiYm1heC56ID0gdi56O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIC53b3JsZFZlcnRpY2VzIGFuZCBzZXRzIC53b3JsZFZlcnRpY2VzTmVlZHNVcGRhdGUgdG8gZmFsc2UuXG4gKiBAbWV0aG9kIGNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxdWF0XG4gKi9cbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzID0gZnVuY3Rpb24ocXVhdCl7XG4gICAgdmFyIE4gPSB0aGlzLmZhY2VOb3JtYWxzLmxlbmd0aDtcbiAgICB3aGlsZSh0aGlzLndvcmxkRmFjZU5vcm1hbHMubGVuZ3RoIDwgTil7XG4gICAgICAgIHRoaXMud29ybGRGYWNlTm9ybWFscy5wdXNoKCBuZXcgVmVjMygpICk7XG4gICAgfVxuXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLmZhY2VOb3JtYWxzLFxuICAgICAgICB3b3JsZE5vcm1hbHMgPSB0aGlzLndvcmxkRmFjZU5vcm1hbHM7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICBxdWF0LnZtdWx0KCBub3JtYWxzW2ldICwgd29ybGROb3JtYWxzW2ldICk7XG4gICAgfVxuXG4gICAgdGhpcy53b3JsZEZhY2VOb3JtYWxzTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1c1xuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gQXNzdW1lIHBvaW50cyBhcmUgZGlzdHJpYnV0ZWQgd2l0aCBsb2NhbCAoMCwwLDApIGFzIGNlbnRlclxuICAgIHZhciBtYXgyID0gMDtcbiAgICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRzLmxlbmd0aDsgaSE9PU47IGkrKykge1xuICAgICAgICB2YXIgbm9ybTIgPSB2ZXJ0c1tpXS5ub3JtMigpO1xuICAgICAgICBpZihub3JtMiA+IG1heDIpe1xuICAgICAgICAgICAgbWF4MiA9IG5vcm0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQobWF4Mik7XG59O1xuXG52YXIgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZVdvcmxkQUFCQlxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgcG9zXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259ICBxdWF0XG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBtaW5cbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1heFxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MscXVhdCxtaW4sbWF4KXtcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLCB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIG1pbngsbWlueSxtaW56LG1heHgsbWF4eSxtYXh6O1xuICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgIHRlbXBXb3JsZFZlcnRleC5jb3B5KHZlcnRzW2ldKTtcbiAgICAgICAgcXVhdC52bXVsdCh0ZW1wV29ybGRWZXJ0ZXgsdGVtcFdvcmxkVmVydGV4KTtcbiAgICAgICAgcG9zLnZhZGQodGVtcFdvcmxkVmVydGV4LHRlbXBXb3JsZFZlcnRleCk7XG4gICAgICAgIHZhciB2ID0gdGVtcFdvcmxkVmVydGV4O1xuICAgICAgICBpZiAgICAgKHYueCA8IG1pbnggfHwgbWlueD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW54ID0gdi54O1xuICAgICAgICB9IGVsc2UgaWYodi54ID4gbWF4eCB8fCBtYXh4PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHggPSB2Lng7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAgICAgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gbWF4eSB8fCBtYXh5PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHkgPSB2Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAgICAgKHYueiA8IG1pbnogfHwgbWluej09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW56ID0gdi56O1xuICAgICAgICB9IGVsc2UgaWYodi56ID4gbWF4eiB8fCBtYXh6PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHogPSB2Lno7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluLnNldChtaW54LG1pbnksbWlueik7XG4gICAgbWF4LnNldChtYXh4LG1heHksbWF4eik7XG59O1xuXG4vKipcbiAqIEdldCBhcHByb3hpbWF0ZSBjb252ZXggdm9sdW1lXG4gKiBAbWV0aG9kIHZvbHVtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDtcbn07XG5cbi8qKlxuICogR2V0IGFuIGF2ZXJhZ2Ugb2YgYWxsIHRoZSB2ZXJ0aWNlcyBwb3NpdGlvbnNcbiAqIEBtZXRob2QgZ2V0QXZlcmFnZVBvaW50TG9jYWxcbiAqIEBwYXJhbSAge1ZlYzN9IHRhcmdldFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuQ29udmV4UG9seWhlZHJvbi5wcm90b3R5cGUuZ2V0QXZlcmFnZVBvaW50TG9jYWwgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICB0YXJnZXQudmFkZCh2ZXJ0c1tpXSx0YXJnZXQpO1xuICAgIH1cbiAgICB0YXJnZXQubXVsdCgxL24sdGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYWxsIGxvY2FsIHBvaW50cy4gV2lsbCBjaGFuZ2UgdGhlIC52ZXJ0aWNlc1xuICogQG1ldGhvZCB0cmFuc2Zvcm1BbGxQb2ludHNcbiAqIEBwYXJhbSAge1ZlYzN9IG9mZnNldFxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICovXG5Db252ZXhQb2x5aGVkcm9uLnByb3RvdHlwZS50cmFuc2Zvcm1BbGxQb2ludHMgPSBmdW5jdGlvbihvZmZzZXQscXVhdCl7XG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgdmVydHMgPSB0aGlzLnZlcnRpY2VzO1xuXG4gICAgLy8gQXBwbHkgcm90YXRpb25cbiAgICBpZihxdWF0KXtcbiAgICAgICAgLy8gUm90YXRlIHZlcnRpY2VzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPG47IGkrKyl7XG4gICAgICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJvdGF0ZSBmYWNlIG5vcm1hbHNcbiAgICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5mYWNlTm9ybWFscy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMuZmFjZU5vcm1hbHNbaV07XG4gICAgICAgICAgICBxdWF0LnZtdWx0KHYsdik7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgLy8gUm90YXRlIGVkZ2VzXG4gICAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMudW5pcXVlRWRnZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSB0aGlzLnVuaXF1ZUVkZ2VzW2ldO1xuICAgICAgICAgICAgcXVhdC52bXVsdCh2LHYpO1xuICAgICAgICB9Ki9cbiAgICB9XG5cbiAgICAvLyBBcHBseSBvZmZzZXRcbiAgICBpZihvZmZzZXQpe1xuICAgICAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICAgICAgdmFyIHYgPSB2ZXJ0c1tpXTtcbiAgICAgICAgICAgIHYudmFkZChvZmZzZXQsdik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHAgaXMgaW5zaWRlIHRoZSBwb2x5aGVkcmEuIE11c3QgYmUgaW4gbG9jYWwgY29vcmRzLiBUaGUgcG9pbnQgbGllcyBvdXRzaWRlIG9mIHRoZSBjb252ZXggaHVsbCBvZiB0aGUgb3RoZXIgcG9pbnRzIGlmIGFuZCBvbmx5IGlmIHRoZSBkaXJlY3Rpb24gb2YgYWxsIHRoZSB2ZWN0b3JzIGZyb20gaXQgdG8gdGhvc2Ugb3RoZXIgcG9pbnRzIGFyZSBvbiBsZXNzIHRoYW4gb25lIGhhbGYgb2YgYSBzcGhlcmUgYXJvdW5kIGl0LlxuICogQG1ldGhvZCBwb2ludElzSW5zaWRlXG4gKiBAcGFyYW0gIHtWZWMzfSBwICAgICAgQSBwb2ludCBnaXZlbiBpbiBsb2NhbCBjb29yZGluYXRlc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIENvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZSA9IG5ldyBWZWMzKCk7XG52YXIgQ29udmV4UG9seWhlZHJvbl92VG9QID0gbmV3IFZlYzMoKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uX3ZUb1BvaW50SW5zaWRlID0gbmV3IFZlYzMoKTtcbkNvbnZleFBvbHloZWRyb24ucHJvdG90eXBlLnBvaW50SXNJbnNpZGUgPSBmdW5jdGlvbihwKXtcbiAgICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxuICAgICAgICB2ZXJ0cyA9IHRoaXMudmVydGljZXMsXG4gICAgICAgIGZhY2VzID0gdGhpcy5mYWNlcyxcbiAgICAgICAgbm9ybWFscyA9IHRoaXMuZmFjZU5vcm1hbHM7XG4gICAgdmFyIHBvc2l0aXZlUmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgTiA9IHRoaXMuZmFjZXMubGVuZ3RoO1xuICAgIHZhciBwb2ludEluc2lkZSA9IENvbnZleFBvbHloZWRyb25fcG9pbnRJc0luc2lkZTtcbiAgICB0aGlzLmdldEF2ZXJhZ2VQb2ludExvY2FsKHBvaW50SW5zaWRlKTtcbiAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspe1xuICAgICAgICB2YXIgbnVtVmVydGljZXMgPSB0aGlzLmZhY2VzW2ldLmxlbmd0aDtcbiAgICAgICAgdmFyIG4gPSBub3JtYWxzW2ldO1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ZhY2VzW2ldWzBdXTsgLy8gV2Ugb25seSBuZWVkIG9uZSBwb2ludCBpbiB0aGUgZmFjZVxuXG4gICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpc1xuICAgICAgICB2YXIgdlRvUCA9IENvbnZleFBvbHloZWRyb25fdlRvUDtcbiAgICAgICAgcC52c3ViKHYsdlRvUCk7XG4gICAgICAgIHZhciByMSA9IG4uZG90KHZUb1ApO1xuXG4gICAgICAgIHZhciB2VG9Qb2ludEluc2lkZSA9IENvbnZleFBvbHloZWRyb25fdlRvUG9pbnRJbnNpZGU7XG4gICAgICAgIHBvaW50SW5zaWRlLnZzdWIodix2VG9Qb2ludEluc2lkZSk7XG4gICAgICAgIHZhciByMiA9IG4uZG90KHZUb1BvaW50SW5zaWRlKTtcblxuICAgICAgICBpZigocjE8MCAmJiByMj4wKSB8fCAocjE+MCAmJiByMjwwKSl7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEVuY291bnRlcmVkIHNvbWUgb3RoZXIgc2lnbi4gRXhpdC5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlIGdvdCBoZXJlLCBhbGwgZG90IHByb2R1Y3RzIHdlcmUgb2YgdGhlIHNhbWUgc2lnbi5cbiAgICByZXR1cm4gcG9zaXRpdmVSZXN1bHQgPyAxIDogLTE7XG59O1xuXG4vKipcbiAqIEdldCBtYXggYW5kIG1pbiBkb3QgcHJvZHVjdCBvZiBhIGNvbnZleCBodWxsIGF0IHBvc2l0aW9uIChwb3MscXVhdCkgcHJvamVjdGVkIG9udG8gYW4gYXhpcy4gUmVzdWx0cyBhcmUgc2F2ZWQgaW4gdGhlIGFycmF5IG1heG1pbi5cbiAqIEBzdGF0aWNcbiAqIEBtZXRob2QgcHJvamVjdFxuICogQHBhcmFtIHtDb252ZXhQb2x5aGVkcm9ufSBodWxsXG4gKiBAcGFyYW0ge1ZlYzN9IGF4aXNcbiAqIEBwYXJhbSB7VmVjM30gcG9zXG4gKiBAcGFyYW0ge1F1YXRlcm5pb259IHF1YXRcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCByZXN1bHRbMF0gYW5kIHJlc3VsdFsxXSB3aWxsIGJlIHNldCB0byBtYXhpbXVtIGFuZCBtaW5pbXVtLCByZXNwZWN0aXZlbHkuXG4gKi9cbnZhciBwcm9qZWN0X3dvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcbnZhciBwcm9qZWN0X2xvY2FsQXhpcyA9IG5ldyBWZWMzKCk7XG52YXIgcHJvamVjdF9sb2NhbE9yaWdpbiA9IG5ldyBWZWMzKCk7XG5Db252ZXhQb2x5aGVkcm9uLnByb2plY3QgPSBmdW5jdGlvbihodWxsLCBheGlzLCBwb3MsIHF1YXQsIHJlc3VsdCl7XG4gICAgdmFyIG4gPSBodWxsLnZlcnRpY2VzLmxlbmd0aCxcbiAgICAgICAgd29ybGRWZXJ0ZXggPSBwcm9qZWN0X3dvcmxkVmVydGV4LFxuICAgICAgICBsb2NhbEF4aXMgPSBwcm9qZWN0X2xvY2FsQXhpcyxcbiAgICAgICAgbWF4ID0gMCxcbiAgICAgICAgbWluID0gMCxcbiAgICAgICAgbG9jYWxPcmlnaW4gPSBwcm9qZWN0X2xvY2FsT3JpZ2luLFxuICAgICAgICB2cyA9IGh1bGwudmVydGljZXM7XG5cbiAgICBsb2NhbE9yaWdpbi5zZXRaZXJvKCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gdGhlIGF4aXMgdG8gbG9jYWxcbiAgICBUcmFuc2Zvcm0udmVjdG9yVG9Mb2NhbEZyYW1lKHBvcywgcXVhdCwgYXhpcywgbG9jYWxBeGlzKTtcbiAgICBUcmFuc2Zvcm0ucG9pbnRUb0xvY2FsRnJhbWUocG9zLCBxdWF0LCBsb2NhbE9yaWdpbiwgbG9jYWxPcmlnaW4pO1xuICAgIHZhciBhZGQgPSBsb2NhbE9yaWdpbi5kb3QobG9jYWxBeGlzKTtcblxuICAgIG1pbiA9IG1heCA9IHZzWzBdLmRvdChsb2NhbEF4aXMpO1xuXG4gICAgZm9yKHZhciBpID0gMTsgaSA8IG47IGkrKyl7XG4gICAgICAgIHZhciB2YWwgPSB2c1tpXS5kb3QobG9jYWxBeGlzKTtcblxuICAgICAgICBpZih2YWwgPiBtYXgpe1xuICAgICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodmFsIDwgbWluKXtcbiAgICAgICAgICAgIG1pbiA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG1pbiAtPSBhZGQ7XG4gICAgbWF4IC09IGFkZDtcblxuICAgIGlmKG1pbiA+IG1heCl7XG4gICAgICAgIC8vIEluY29uc2lzdGVudCAtIHN3YXBcbiAgICAgICAgdmFyIHRlbXAgPSBtaW47XG4gICAgICAgIG1pbiA9IG1heDtcbiAgICAgICAgbWF4ID0gdGVtcDtcbiAgICB9XG4gICAgLy8gT3V0cHV0XG4gICAgcmVzdWx0WzBdID0gbWF4O1xuICAgIHJlc3VsdFsxXSA9IG1pbjtcbn07XG5cbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1RyYW5zZm9ybVwiOjI5LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL1NoYXBlXCI6NDN9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEN5bGluZGVyO1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIFF1YXRlcm5pb24gPSBfZGVyZXFfKCcuLi9tYXRoL1F1YXRlcm5pb24nKTtcbnZhciBDb252ZXhQb2x5aGVkcm9uID0gX2RlcmVxXygnLi9Db252ZXhQb2x5aGVkcm9uJyk7XG5cbi8qKlxuICogQGNsYXNzIEN5bGluZGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIENvbnZleFBvbHloZWRyb25cbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNUb3BcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXNCb3R0b21cbiAqIEBwYXJhbSB7TnVtYmVyfSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1TZWdtZW50cyBUaGUgbnVtYmVyIG9mIHNlZ21lbnRzIHRvIGJ1aWxkIHRoZSBjeWxpbmRlciBvdXQgb2ZcbiAqL1xuZnVuY3Rpb24gQ3lsaW5kZXIoIHJhZGl1c1RvcCwgcmFkaXVzQm90dG9tLCBoZWlnaHQgLCBudW1TZWdtZW50cyApIHtcbiAgICB2YXIgTiA9IG51bVNlZ21lbnRzLFxuICAgICAgICB2ZXJ0cyA9IFtdLFxuICAgICAgICBheGVzID0gW10sXG4gICAgICAgIGZhY2VzID0gW10sXG4gICAgICAgIGJvdHRvbWZhY2UgPSBbXSxcbiAgICAgICAgdG9wZmFjZSA9IFtdLFxuICAgICAgICBjb3MgPSBNYXRoLmNvcyxcbiAgICAgICAgc2luID0gTWF0aC5zaW47XG5cbiAgICAvLyBGaXJzdCBib3R0b20gcG9pbnRcbiAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c0JvdHRvbSpjb3MoMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzQm90dG9tKnNpbigwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtaGVpZ2h0KjAuNSkpO1xuICAgIGJvdHRvbWZhY2UucHVzaCgwKTtcblxuICAgIC8vIEZpcnN0IHRvcCBwb2ludFxuICAgIHZlcnRzLnB1c2gobmV3IFZlYzMocmFkaXVzVG9wKmNvcygwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNUb3Aqc2luKDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCowLjUpKTtcbiAgICB0b3BmYWNlLnB1c2goMSk7XG5cbiAgICBmb3IodmFyIGk9MDsgaTxOOyBpKyspe1xuICAgICAgICB2YXIgdGhldGEgPSAyKk1hdGguUEkvTiAqIChpKzEpO1xuICAgICAgICB2YXIgdGhldGFOID0gMipNYXRoLlBJL04gKiAoaSswLjUpO1xuICAgICAgICBpZihpPE4tMSl7XG4gICAgICAgICAgICAvLyBCb3R0b21cbiAgICAgICAgICAgIHZlcnRzLnB1c2gobmV3IFZlYzMocmFkaXVzQm90dG9tKmNvcyh0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXNCb3R0b20qc2luKHRoZXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC1oZWlnaHQqMC41KSk7XG4gICAgICAgICAgICBib3R0b21mYWNlLnB1c2goMippKzIpO1xuICAgICAgICAgICAgLy8gVG9wXG4gICAgICAgICAgICB2ZXJ0cy5wdXNoKG5ldyBWZWMzKHJhZGl1c1RvcCpjb3ModGhldGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzVG9wKnNpbih0aGV0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQqMC41KSk7XG4gICAgICAgICAgICB0b3BmYWNlLnB1c2goMippKzMpO1xuXG4gICAgICAgICAgICAvLyBGYWNlXG4gICAgICAgICAgICBmYWNlcy5wdXNoKFsyKmkrMiwgMippKzMsIDIqaSsxLDIqaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmFjZXMucHVzaChbMCwxLCAyKmkrMSwgMippXSk7IC8vIENvbm5lY3RcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF4aXM6IHdlIGNhbiBjdXQgb2ZmIGhhbGYgb2YgdGhlbSBpZiB3ZSBoYXZlIGV2ZW4gbnVtYmVyIG9mIHNlZ21lbnRzXG4gICAgICAgIGlmKE4gJSAyID09PSAxIHx8IGkgPCBOIC8gMil7XG4gICAgICAgICAgICBheGVzLnB1c2gobmV3IFZlYzMoY29zKHRoZXRhTiksIHNpbih0aGV0YU4pLCAwKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmFjZXMucHVzaCh0b3BmYWNlKTtcbiAgICBheGVzLnB1c2gobmV3IFZlYzMoMCwwLDEpKTtcblxuICAgIC8vIFJlb3JkZXIgYm90dG9tIGZhY2VcbiAgICB2YXIgdGVtcCA9IFtdO1xuICAgIGZvcih2YXIgaT0wOyBpPGJvdHRvbWZhY2UubGVuZ3RoOyBpKyspe1xuICAgICAgICB0ZW1wLnB1c2goYm90dG9tZmFjZVtib3R0b21mYWNlLmxlbmd0aCAtIGkgLSAxXSk7XG4gICAgfVxuICAgIGZhY2VzLnB1c2godGVtcCk7XG5cbiAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OO1xuICAgIENvbnZleFBvbHloZWRyb24uY2FsbCggdGhpcywgdmVydHMsIGZhY2VzLCBheGVzICk7XG59XG5cbkN5bGluZGVyLnByb3RvdHlwZSA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XG5cbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vQ29udmV4UG9seWhlZHJvblwiOjM4LFwiLi9TaGFwZVwiOjQzfV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xudmFyIENvbnZleFBvbHloZWRyb24gPSBfZGVyZXFfKCcuL0NvbnZleFBvbHloZWRyb24nKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgVXRpbHMgPSBfZGVyZXFfKCcuLi91dGlscy9VdGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlaWdodGZpZWxkO1xuXG4vKipcbiAqIEhlaWdodGZpZWxkIHNoYXBlIGNsYXNzLiBIZWlnaHQgZGF0YSBpcyBnaXZlbiBhcyBhbiBhcnJheS4gVGhlc2UgZGF0YSBwb2ludHMgYXJlIHNwcmVhZCBvdXQgZXZlbmx5IHdpdGggYSBnaXZlbiBkaXN0YW5jZS5cbiAqIEBjbGFzcyBIZWlnaHRmaWVsZFxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBBbiBhcnJheSBvZiBZIHZhbHVlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBjb25zdHJ1Y3QgdGhlIHRlcnJhaW4uXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1pblZhbHVlXSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBkYXRhIHBvaW50cyBpbiB0aGUgZGF0YSBhcnJheS4gV2lsbCBiZSBjb21wdXRlZCBhdXRvbWF0aWNhbGx5IGlmIG5vdCBnaXZlbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhWYWx1ZV0gTWF4aW11bSB2YWx1ZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5lbGVtZW50U2l6ZT0wLjFdIFdvcmxkIHNwYWNpbmcgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBkaXJlY3Rpb24uXG4gKiBAdG9kbyBTaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIGFsb25nIGFsbCBheGVzLCBub3QganVzdCB5XG4gKlxuICogQGV4YW1wbGVcbiAqICAgICAvLyBHZW5lcmF0ZSBzb21lIGhlaWdodCBkYXRhICh5LXZhbHVlcykuXG4gKiAgICAgdmFyIGRhdGEgPSBbXTtcbiAqICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTAwMDsgaSsrKXtcbiAqICAgICAgICAgdmFyIHkgPSAwLjUgKiBNYXRoLmNvcygwLjIgKiBpKTtcbiAqICAgICAgICAgZGF0YS5wdXNoKHkpO1xuICogICAgIH1cbiAqXG4gKiAgICAgLy8gQ3JlYXRlIHRoZSBoZWlnaHRmaWVsZCBzaGFwZVxuICogICAgIHZhciBoZWlnaHRmaWVsZFNoYXBlID0gbmV3IEhlaWdodGZpZWxkKGRhdGEsIHtcbiAqICAgICAgICAgZWxlbWVudFNpemU6IDEgLy8gRGlzdGFuY2UgYmV0d2VlbiB0aGUgZGF0YSBwb2ludHMgaW4gWCBhbmQgWSBkaXJlY3Rpb25zXG4gKiAgICAgfSk7XG4gKiAgICAgdmFyIGhlaWdodGZpZWxkQm9keSA9IG5ldyBCb2R5KCk7XG4gKiAgICAgaGVpZ2h0ZmllbGRCb2R5LmFkZFNoYXBlKGhlaWdodGZpZWxkU2hhcGUpO1xuICogICAgIHdvcmxkLmFkZEJvZHkoaGVpZ2h0ZmllbGRCb2R5KTtcbiAqL1xuZnVuY3Rpb24gSGVpZ2h0ZmllbGQoZGF0YSwgb3B0aW9ucyl7XG4gICAgb3B0aW9ucyA9IFV0aWxzLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgbWF4VmFsdWUgOiBudWxsLFxuICAgICAgICBtaW5WYWx1ZSA6IG51bGwsXG4gICAgICAgIGVsZW1lbnRTaXplIDogMVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgbnVtYmVycywgb3IgaGVpZ2h0IHZhbHVlcywgdGhhdCBhcmUgc3ByZWFkIG91dCBhbG9uZyB0aGUgeCBheGlzLlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGRhdGFcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuXG4gICAgLyoqXG4gICAgICogTWF4IHZhbHVlIG9mIHRoZSBkYXRhXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heFZhbHVlXG4gICAgICovXG4gICAgdGhpcy5tYXhWYWx1ZSA9IG9wdGlvbnMubWF4VmFsdWU7XG5cbiAgICAvKipcbiAgICAgKiBNYXggdmFsdWUgb2YgdGhlIGRhdGFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gbWluVmFsdWVcbiAgICAgKi9cbiAgICB0aGlzLm1pblZhbHVlID0gb3B0aW9ucy5taW5WYWx1ZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3aWR0aCBvZiBlYWNoIGVsZW1lbnRcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gZWxlbWVudFNpemVcbiAgICAgKiBAdG9kbyBlbGVtZW50U2l6ZVggYW5kIFlcbiAgICAgKi9cbiAgICB0aGlzLmVsZW1lbnRTaXplID0gb3B0aW9ucy5lbGVtZW50U2l6ZTtcblxuICAgIGlmKG9wdGlvbnMubWluVmFsdWUgPT09IG51bGwpe1xuICAgICAgICB0aGlzLnVwZGF0ZU1pblZhbHVlKCk7XG4gICAgfVxuICAgIGlmKG9wdGlvbnMubWF4VmFsdWUgPT09IG51bGwpe1xuICAgICAgICB0aGlzLnVwZGF0ZU1heFZhbHVlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5jYWNoZUVuYWJsZWQgPSB0cnVlO1xuXG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMucGlsbGFyQ29udmV4ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgICB0aGlzLnBpbGxhck9mZnNldCA9IG5ldyBWZWMzKCk7XG5cbiAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRDtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG5cbiAgICAvLyBcImlfal9pc1VwcGVyXCIgPT4geyBjb252ZXg6IC4uLiwgb2Zmc2V0OiAuLi4gfVxuICAgIC8vIGZvciBleGFtcGxlOlxuICAgIC8vIF9jYWNoZWRQaWxsYXJzW1wiMF8yXzFcIl1cbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XG59XG5IZWlnaHRmaWVsZC5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblxuLyoqXG4gKiBDYWxsIHdoZW5ldmVyIHlvdSBjaGFuZ2UgdGhlIGRhdGEgYXJyYXkuXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9jYWNoZWRQaWxsYXJzID0ge307XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLm1pblZhbHVlIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZU1pblZhbHVlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS51cGRhdGVNaW5WYWx1ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIG1pblZhbHVlID0gZGF0YVswXVswXTtcbiAgICBmb3IodmFyIGk9MDsgaSAhPT0gZGF0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvcih2YXIgaj0wOyBqICE9PSBkYXRhW2ldLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIHZhciB2ID0gZGF0YVtpXVtqXTtcbiAgICAgICAgICAgIGlmKHYgPCBtaW5WYWx1ZSl7XG4gICAgICAgICAgICAgICAgbWluVmFsdWUgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMubWluVmFsdWUgPSBtaW5WYWx1ZTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSAubWF4VmFsdWUgcHJvcGVydHlcbiAqIEBtZXRob2QgdXBkYXRlTWF4VmFsdWVcbiAqL1xuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnVwZGF0ZU1heFZhbHVlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgbWF4VmFsdWUgPSBkYXRhWzBdWzBdO1xuICAgIGZvcih2YXIgaT0wOyBpICE9PSBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqPTA7IGogIT09IGRhdGFbaV0ubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIHYgPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgaWYodiA+IG1heFZhbHVlKXtcbiAgICAgICAgICAgICAgICBtYXhWYWx1ZSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5tYXhWYWx1ZSA9IG1heFZhbHVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGhlaWdodCB2YWx1ZSBhdCBhbiBpbmRleC4gRG9uJ3QgZm9yZ2V0IHRvIHVwZGF0ZSBtYXhWYWx1ZSBhbmQgbWluVmFsdWUgYWZ0ZXIgeW91J3JlIGRvbmUuXG4gKiBAbWV0aG9kIHNldEhlaWdodFZhbHVlQXRJbmRleFxuICogQHBhcmFtIHtpbnRlZ2VyfSB4aVxuICogQHBhcmFtIHtpbnRlZ2VyfSB5aVxuICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5zZXRIZWlnaHRWYWx1ZUF0SW5kZXggPSBmdW5jdGlvbih4aSwgeWksIHZhbHVlKXtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBkYXRhW3hpXVt5aV0gPSB2YWx1ZTtcblxuICAgIC8vIEludmFsaWRhdGUgY2FjaGVcbiAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpLCBmYWxzZSk7XG4gICAgaWYoeGkgPiAwKXtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpIC0gMSwgeWksIHRydWUpO1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZih5aSA+IDApe1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGksIHlpIC0gMSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWkgLSAxLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmKHlpID4gMCAmJiB4aSA+IDApe1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGVkQ29udmV4VHJpYW5nbGVQaWxsYXIoeGkgLSAxLCB5aSAtIDEsIHRydWUpO1xuICAgIH1cbn07XG5cbi8qKlxuICogR2V0IG1heC9taW4gaW4gYSByZWN0YW5nbGUgaW4gdGhlIG1hdHJpeCBkYXRhXG4gKiBAbWV0aG9kIGdldFJlY3RNaW5NYXhcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlNaW5YXG4gKiBAcGFyYW0gIHtpbnRlZ2VyfSBpTWluWVxuICogQHBhcmFtICB7aW50ZWdlcn0gaU1heFhcbiAqIEBwYXJhbSAge2ludGVnZXJ9IGlNYXhZXG4gKiBAcGFyYW0gIHthcnJheX0gW3Jlc3VsdF0gQW4gYXJyYXkgdG8gc3RvcmUgdGhlIHJlc3VsdHMgaW4uXG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIHJlc3VsdCBhcnJheSwgaWYgaXQgd2FzIHBhc3NlZCBpbi4gTWluaW11bSB3aWxsIGJlIGF0IHBvc2l0aW9uIDAgYW5kIG1heCBhdCAxLlxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0UmVjdE1pbk1heCA9IGZ1bmN0aW9uIChpTWluWCwgaU1pblksIGlNYXhYLCBpTWF4WSwgcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0IHx8IFtdO1xuXG4gICAgLy8gR2V0IG1heCBhbmQgbWluIG9mIHRoZSBkYXRhXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIG1heCA9IHRoaXMubWluVmFsdWU7IC8vIFNldCBmaXJzdCB2YWx1ZVxuICAgIGZvcih2YXIgaSA9IGlNaW5YOyBpIDw9IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8PSBpTWF4WTsgaisrKXtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkYXRhW2ldW2pdO1xuICAgICAgICAgICAgaWYoaGVpZ2h0ID4gbWF4KXtcbiAgICAgICAgICAgICAgICBtYXggPSBoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXN1bHRbMF0gPSB0aGlzLm1pblZhbHVlO1xuICAgIHJlc3VsdFsxXSA9IG1heDtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBpbmRleCBvZiBhIGxvY2FsIHBvc2l0aW9uIG9uIHRoZSBoZWlnaHRmaWVsZC4gVGhlIGluZGV4ZXMgaW5kaWNhdGUgdGhlIHJlY3RhbmdsZXMsIHNvIGlmIHlvdXIgdGVycmFpbiBpcyBtYWRlIG9mIE4geCBOIGhlaWdodCBkYXRhIHBvaW50cywgeW91IHdpbGwgaGF2ZSByZWN0YW5nbGUgaW5kZXhlcyByYW5naW5nIGZyb20gMCB0byBOLTEuXG4gKiBAbWV0aG9kIGdldEluZGV4T2ZQb3NpdGlvblxuICogQHBhcmFtICB7bnVtYmVyfSB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHQgVHdvLWVsZW1lbnQgYXJyYXlcbiAqIEBwYXJhbSAge2Jvb2xlYW59IGNsYW1wIElmIHRoZSBwb3NpdGlvbiBzaG91bGQgYmUgY2xhbXBlZCB0byB0aGUgaGVpZ2h0ZmllbGQgZWRnZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRJbmRleE9mUG9zaXRpb24gPSBmdW5jdGlvbiAoeCwgeSwgcmVzdWx0LCBjbGFtcCkge1xuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZGF0YSBwb2ludHMgdG8gdGVzdCBhZ2FpbnN0XG4gICAgdmFyIHcgPSB0aGlzLmVsZW1lbnRTaXplO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciB4aSA9IE1hdGguZmxvb3IoeCAvIHcpO1xuICAgIHZhciB5aSA9IE1hdGguZmxvb3IoeSAvIHcpO1xuXG4gICAgcmVzdWx0WzBdID0geGk7XG4gICAgcmVzdWx0WzFdID0geWk7XG5cbiAgICBpZihjbGFtcCl7XG4gICAgICAgIC8vIENsYW1wIGluZGV4IHRvIGVkZ2VzXG4gICAgICAgIGlmKHhpIDwgMCl7IHhpID0gMDsgfVxuICAgICAgICBpZih5aSA8IDApeyB5aSA9IDA7IH1cbiAgICAgICAgaWYoeGkgPj0gZGF0YS5sZW5ndGggLSAxKXsgeGkgPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICAgICAgaWYoeWkgPj0gZGF0YVswXS5sZW5ndGggLSAxKXsgeWkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cbiAgICB9XG5cbiAgICAvLyBCYWlsIG91dCBpZiB3ZSBhcmUgb3V0IG9mIHRoZSB0ZXJyYWluXG4gICAgaWYoeGkgPCAwIHx8IHlpIDwgMCB8fCB4aSA+PSBkYXRhLmxlbmd0aC0xIHx8IHlpID49IGRhdGFbMF0ubGVuZ3RoLTEpe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0SGVpZ2h0QXQgPSBmdW5jdGlvbih4LCB5LCBlZGdlQ2xhbXApe1xuICAgIHZhciBpZHggPSBbXTtcbiAgICB0aGlzLmdldEluZGV4T2ZQb3NpdGlvbih4LCB5LCBpZHgsIGVkZ2VDbGFtcCk7XG5cbiAgICAvLyBUT0RPOiBnZXQgdXBwZXIgb3IgbG93ZXIgdHJpYW5nbGUsIHRoZW4gdXNlIGJhcnljZW50cmljIGludGVycG9sYXRpb24gdG8gZ2V0IHRoZSBoZWlnaHQgaW4gdGhlIHRyaWFuZ2xlLlxuICAgIHZhciBtaW5tYXggPSBbXTtcbiAgICB0aGlzLmdldFJlY3RNaW5NYXgoaWR4WzBdLCBpZHhbMV0gKyAxLCBpZHhbMF0sIGlkeFsxXSArIDEsIG1pbm1heCk7XG5cbiAgICByZXR1cm4gKG1pbm1heFswXSArIG1pbm1heFsxXSkgLyAyOyAvLyBhdmVyYWdlXG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q2FjaGVDb252ZXhUcmlhbmdsZVBpbGxhcktleSA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgcmV0dXJuIHhpICsgJ18nICsgeWkgKyAnXycgKyAoZ2V0VXBwZXJUcmlhbmdsZSA/IDEgOiAwKTtcbn07XG5cbkhlaWdodGZpZWxkLnByb3RvdHlwZS5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyID0gZnVuY3Rpb24oeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlLCBjb252ZXgsIG9mZnNldCl7XG4gICAgdGhpcy5fY2FjaGVkUGlsbGFyc1t0aGlzLmdldENhY2hlQ29udmV4VHJpYW5nbGVQaWxsYXJLZXkoeGksIHlpLCBnZXRVcHBlclRyaWFuZ2xlKV0gPSB7XG4gICAgICAgIGNvbnZleDogY29udmV4LFxuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgIH07XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY2xlYXJDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhciA9IGZ1bmN0aW9uKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSl7XG4gICAgZGVsZXRlIHRoaXMuX2NhY2hlZFBpbGxhcnNbdGhpcy5nZXRDYWNoZUNvbnZleFRyaWFuZ2xlUGlsbGFyS2V5KHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSldO1xufTtcblxuLyoqXG4gKiBHZXQgYSB0cmlhbmdsZSBpbiB0aGUgdGVycmFpbiBpbiB0aGUgZm9ybSBvZiBhIHRyaWFuZ3VsYXIgY29udmV4IHNoYXBlLlxuICogQG1ldGhvZCBnZXRDb252ZXhUcmlhbmdsZVBpbGxhclxuICogQHBhcmFtICB7aW50ZWdlcn0gaVxuICogQHBhcmFtICB7aW50ZWdlcn0galxuICogQHBhcmFtICB7Ym9vbGVhbn0gZ2V0VXBwZXJUcmlhbmdsZVxuICovXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIgPSBmdW5jdGlvbih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpe1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnBpbGxhckNvbnZleDtcbiAgICB2YXIgb2Zmc2V0UmVzdWx0ID0gdGhpcy5waWxsYXJPZmZzZXQ7XG5cbiAgICBpZih0aGlzLmNhY2hlRW5hYmxlZCl7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5nZXRDYWNoZWRDb252ZXhUcmlhbmdsZVBpbGxhcih4aSwgeWksIGdldFVwcGVyVHJpYW5nbGUpO1xuICAgICAgICBpZihkYXRhKXtcbiAgICAgICAgICAgIHRoaXMucGlsbGFyQ29udmV4ID0gZGF0YS5jb252ZXg7XG4gICAgICAgICAgICB0aGlzLnBpbGxhck9mZnNldCA9IGRhdGEub2Zmc2V0O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0ID0gbmV3IENvbnZleFBvbHloZWRyb24oKTtcbiAgICAgICAgb2Zmc2V0UmVzdWx0ID0gbmV3IFZlYzMoKTtcblxuICAgICAgICB0aGlzLnBpbGxhckNvbnZleCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5waWxsYXJPZmZzZXQgPSBvZmZzZXRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGVsZW1lbnRTaXplID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB2YXIgZmFjZXMgPSByZXN1bHQuZmFjZXM7XG5cbiAgICAvLyBSZXVzZSB2ZXJ0cyBpZiBwb3NzaWJsZVxuICAgIHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGggPSA2O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIGlmKCFyZXN1bHQudmVydGljZXNbaV0pe1xuICAgICAgICAgICAgcmVzdWx0LnZlcnRpY2VzW2ldID0gbmV3IFZlYzMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldXNlIGZhY2VzIGlmIHBvc3NpYmxlXG4gICAgZmFjZXMubGVuZ3RoID0gNTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgICBpZighZmFjZXNbaV0pe1xuICAgICAgICAgICAgZmFjZXNbaV0gPSBbXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB2ZXJ0cyA9IHJlc3VsdC52ZXJ0aWNlcztcblxuICAgIHZhciBoID0gKE1hdGgubWluKFxuICAgICAgICBkYXRhW3hpXVt5aV0sXG4gICAgICAgIGRhdGFbeGkrMV1beWldLFxuICAgICAgICBkYXRhW3hpXVt5aSsxXSxcbiAgICAgICAgZGF0YVt4aSsxXVt5aSsxXVxuICAgICkgLSB0aGlzLm1pblZhbHVlICkgLyAyICsgdGhpcy5taW5WYWx1ZTtcblxuICAgIGlmICghZ2V0VXBwZXJUcmlhbmdsZSkge1xuXG4gICAgICAgIC8vIENlbnRlciBvZiB0aGUgdHJpYW5nbGUgcGlsbGFyIC0gYWxsIHBvbHlnb25zIGFyZSBnaXZlbiByZWxhdGl2ZSB0byB0aGlzIG9uZVxuICAgICAgICBvZmZzZXRSZXN1bHQuc2V0KFxuICAgICAgICAgICAgKHhpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSwgLy8gc29ydCBvZiBjZW50ZXIgb2YgYSB0cmlhbmdsZVxuICAgICAgICAgICAgKHlpICsgMC4yNSkgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGggLy8gdmVydGljYWwgY2VudGVyXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gVG9wIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZlcnRzWzBdLnNldChcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aV1beWldIC0gaFxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1sxXS5zZXQoXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXSAtIGhcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbMl0uc2V0KFxuICAgICAgICAgICAgLTAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIGRhdGFbeGldW3lpICsgMV0gLSBoXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYm90dG9tIHRyaWFuZ2xlIHZlcnRzXG4gICAgICAgIHZlcnRzWzNdLnNldChcbiAgICAgICAgICAgIC0wLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLWgtMVxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1s0XS5zZXQoXG4gICAgICAgICAgICAwLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLWgtMVxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1s1XS5zZXQoXG4gICAgICAgICAgICAtMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC43NSAgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC1oLTFcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB0b3AgdHJpYW5nbGVcbiAgICAgICAgZmFjZXNbMF1bMF0gPSAwO1xuICAgICAgICBmYWNlc1swXVsxXSA9IDE7XG4gICAgICAgIGZhY2VzWzBdWzJdID0gMjtcblxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGVcbiAgICAgICAgZmFjZXNbMV1bMF0gPSA1O1xuICAgICAgICBmYWNlc1sxXVsxXSA9IDQ7XG4gICAgICAgIGZhY2VzWzFdWzJdID0gMztcblxuICAgICAgICAvLyAteCBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1syXVswXSA9IDA7XG4gICAgICAgIGZhY2VzWzJdWzFdID0gMjtcbiAgICAgICAgZmFjZXNbMl1bMl0gPSA1O1xuICAgICAgICBmYWNlc1syXVszXSA9IDM7XG5cbiAgICAgICAgLy8gLXkgZmFjaW5nIHF1YWRcbiAgICAgICAgZmFjZXNbM11bMF0gPSAxO1xuICAgICAgICBmYWNlc1szXVsxXSA9IDA7XG4gICAgICAgIGZhY2VzWzNdWzJdID0gMztcbiAgICAgICAgZmFjZXNbM11bM10gPSA0O1xuXG4gICAgICAgIC8vICt4eSBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1s0XVswXSA9IDQ7XG4gICAgICAgIGZhY2VzWzRdWzFdID0gNTtcbiAgICAgICAgZmFjZXNbNF1bMl0gPSAyO1xuICAgICAgICBmYWNlc1s0XVszXSA9IDE7XG5cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ2VudGVyIG9mIHRoZSB0cmlhbmdsZSBwaWxsYXIgLSBhbGwgcG9seWdvbnMgYXJlIGdpdmVuIHJlbGF0aXZlIHRvIHRoaXMgb25lXG4gICAgICAgIG9mZnNldFJlc3VsdC5zZXQoXG4gICAgICAgICAgICAoeGkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLCAvLyBzb3J0IG9mIGNlbnRlciBvZiBhIHRyaWFuZ2xlXG4gICAgICAgICAgICAoeWkgKyAwLjc1KSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgaCAvLyB2ZXJ0aWNhbCBjZW50ZXJcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBUb3AgdHJpYW5nbGUgdmVydHNcbiAgICAgICAgdmVydHNbMF0uc2V0KFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpICsgMV0gLSBoXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRzWzFdLnNldChcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICBkYXRhW3hpXVt5aSArIDFdIC0gaFxuICAgICAgICApO1xuICAgICAgICB2ZXJ0c1syXS5zZXQoXG4gICAgICAgICAgICAwLjI1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtMC43NSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgZGF0YVt4aSArIDFdW3lpXSAtIGhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBib3R0b20gdHJpYW5nbGUgdmVydHNcbiAgICAgICAgdmVydHNbM10uc2V0KFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgMC4yNSAqIGVsZW1lbnRTaXplLFxuICAgICAgICAgICAgLSBoLTFcbiAgICAgICAgKTtcbiAgICAgICAgdmVydHNbNF0uc2V0KFxuICAgICAgICAgICAgLTAuNzUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC0gaC0xXG4gICAgICAgICk7XG4gICAgICAgIHZlcnRzWzVdLnNldChcbiAgICAgICAgICAgIDAuMjUgKiBlbGVtZW50U2l6ZSxcbiAgICAgICAgICAgIC0wLjc1ICogZWxlbWVudFNpemUsXG4gICAgICAgICAgICAtIGgtMVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFRvcCB0cmlhbmdsZVxuICAgICAgICBmYWNlc1swXVswXSA9IDA7XG4gICAgICAgIGZhY2VzWzBdWzFdID0gMTtcbiAgICAgICAgZmFjZXNbMF1bMl0gPSAyO1xuXG4gICAgICAgIC8vIGJvdHRvbSB0cmlhbmdsZVxuICAgICAgICBmYWNlc1sxXVswXSA9IDU7XG4gICAgICAgIGZhY2VzWzFdWzFdID0gNDtcbiAgICAgICAgZmFjZXNbMV1bMl0gPSAzO1xuXG4gICAgICAgIC8vICt4IGZhY2luZyBxdWFkXG4gICAgICAgIGZhY2VzWzJdWzBdID0gMjtcbiAgICAgICAgZmFjZXNbMl1bMV0gPSA1O1xuICAgICAgICBmYWNlc1syXVsyXSA9IDM7XG4gICAgICAgIGZhY2VzWzJdWzNdID0gMDtcblxuICAgICAgICAvLyAreSBmYWNpbmcgcXVhZFxuICAgICAgICBmYWNlc1szXVswXSA9IDM7XG4gICAgICAgIGZhY2VzWzNdWzFdID0gNDtcbiAgICAgICAgZmFjZXNbM11bMl0gPSAxO1xuICAgICAgICBmYWNlc1szXVszXSA9IDA7XG5cbiAgICAgICAgLy8gLXh5IGZhY2luZyBxdWFkXG4gICAgICAgIGZhY2VzWzRdWzBdID0gMTtcbiAgICAgICAgZmFjZXNbNF1bMV0gPSA0O1xuICAgICAgICBmYWNlc1s0XVsyXSA9IDU7XG4gICAgICAgIGZhY2VzWzRdWzNdID0gMjtcbiAgICB9XG5cbiAgICByZXN1bHQuY29tcHV0ZU5vcm1hbHMoKTtcbiAgICByZXN1bHQuY29tcHV0ZUVkZ2VzKCk7XG4gICAgcmVzdWx0LnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG5cbiAgICB0aGlzLnNldENhY2hlZENvbnZleFRyaWFuZ2xlUGlsbGFyKHhpLCB5aSwgZ2V0VXBwZXJUcmlhbmdsZSwgcmVzdWx0LCBvZmZzZXRSZXN1bHQpO1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsIHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuSGVpZ2h0ZmllbGQucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7IC8vIFRoZSB0ZXJyYWluIGlzIGluZmluaXRlXG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLCBxdWF0LCBtaW4sIG1heCl7XG4gICAgLy8gVE9ETzogZG8gaXQgcHJvcGVybHlcbiAgICBtaW4uc2V0KC1OdW1iZXIuTUFYX1ZBTFVFLCAtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUpO1xuICAgIG1heC5zZXQoTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRSk7XG59O1xuXG5IZWlnaHRmaWVsZC5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIC8vIFVzZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBtaW4vbWF4IHZhbHVlc1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICBzID0gdGhpcy5lbGVtZW50U2l6ZTtcbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gbmV3IFZlYzMoZGF0YS5sZW5ndGggKiBzLCBkYXRhWzBdLmxlbmd0aCAqIHMsIE1hdGgubWF4KE1hdGguYWJzKHRoaXMubWF4VmFsdWUpLCBNYXRoLmFicyh0aGlzLm1pblZhbHVlKSkpLm5vcm0oKTtcbn07XG5cbn0se1wiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi91dGlscy9VdGlsc1wiOjUzLFwiLi9Db252ZXhQb2x5aGVkcm9uXCI6MzgsXCIuL1NoYXBlXCI6NDN9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFBhcnRpY2xlO1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuL1NoYXBlJyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xuXG4vKipcbiAqIFBhcnRpY2xlIHNoYXBlLlxuICogQGNsYXNzIFBhcnRpY2xlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGVcbiAqIEBleHRlbmRzIFNoYXBlXG4gKi9cbmZ1bmN0aW9uIFBhcnRpY2xlKCl7XG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLlBBUlRJQ0xFO1xufVxuUGFydGljbGUucHJvdG90eXBlID0gbmV3IFNoYXBlKCk7XG5QYXJ0aWNsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJ0aWNsZTtcblxuLyoqXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHBhcmFtICB7TnVtYmVyfSBtYXNzXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqIEByZXR1cm4ge1ZlYzN9XG4gKi9cblBhcnRpY2xlLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgdGFyZ2V0LnNldCgwLCAwLCAwKTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcblxuUGFydGljbGUucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIDA7XG59O1xuXG5QYXJ0aWNsZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSAwO1xufTtcblxuUGFydGljbGUucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xuICAgIC8vIEdldCBlYWNoIGF4aXMgbWF4XG4gICAgbWluLmNvcHkocG9zKTtcbiAgICBtYXguY29weShwb3MpO1xufTtcblxufSx7XCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vU2hhcGVcIjo0M31dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUGxhbmU7XG5cbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG5cbi8qKlxuICogQSBwbGFuZSwgZmFjaW5nIGluIHRoZSBaIGRpcmVjdGlvbi4gVGhlIHBsYW5lIGhhcyBpdHMgc3VyZmFjZSBhdCB6PTAgYW5kIGV2ZXJ5dGhpbmcgYmVsb3cgej0wIGlzIGFzc3VtZWQgdG8gYmUgc29saWQgcGxhbmUuIFRvIG1ha2UgdGhlIHBsYW5lIGZhY2UgaW4gc29tZSBvdGhlciBkaXJlY3Rpb24gdGhhbiB6LCB5b3UgbXVzdCBwdXQgaXQgaW5zaWRlIGEgUmlnaWRCb2R5IGFuZCByb3RhdGUgdGhhdCBib2R5LiBTZWUgdGhlIGRlbW9zLlxuICogQGNsYXNzIFBsYW5lXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKi9cbmZ1bmN0aW9uIFBsYW5lKCl7XG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnR5cGUgPSBTaGFwZS50eXBlcy5QTEFORTtcblxuICAgIC8vIFdvcmxkIG9yaWVudGVkIG5vcm1hbFxuICAgIHRoaXMud29ybGROb3JtYWwgPSBuZXcgVmVjMygpO1xuICAgIHRoaXMud29ybGROb3JtYWxOZWVkc1VwZGF0ZSA9IHRydWU7XG5cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gTnVtYmVyLk1BWF9WQUxVRTtcbn1cblBsYW5lLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuUGxhbmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGxhbmU7XG5cblBsYW5lLnByb3RvdHlwZS5jb21wdXRlV29ybGROb3JtYWwgPSBmdW5jdGlvbihxdWF0KXtcbiAgICB2YXIgbiA9IHRoaXMud29ybGROb3JtYWw7XG4gICAgbi5zZXQoMCwwLDEpO1xuICAgIHF1YXQudm11bHQobixuKTtcbiAgICB0aGlzLndvcmxkTm9ybWFsTmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cblBsYW5lLnByb3RvdHlwZS5jYWxjdWxhdGVMb2NhbEluZXJ0aWEgPSBmdW5jdGlvbihtYXNzLHRhcmdldCl7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IG5ldyBWZWMzKCk7XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG5cblBsYW5lLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFOyAvLyBUaGUgcGxhbmUgaXMgaW5maW5pdGUuLi5cbn07XG5cbnZhciB0ZW1wTm9ybWFsID0gbmV3IFZlYzMoKTtcblBsYW5lLnByb3RvdHlwZS5jYWxjdWxhdGVXb3JsZEFBQkIgPSBmdW5jdGlvbihwb3MsIHF1YXQsIG1pbiwgbWF4KXtcbiAgICAvLyBUaGUgcGxhbmUgQUFCQiBpcyBpbmZpbml0ZSwgZXhjZXB0IGlmIHRoZSBub3JtYWwgaXMgcG9pbnRpbmcgYWxvbmcgYW55IGF4aXNcbiAgICB0ZW1wTm9ybWFsLnNldCgwLDAsMSk7IC8vIERlZmF1bHQgcGxhbmUgbm9ybWFsIGlzIHpcbiAgICBxdWF0LnZtdWx0KHRlbXBOb3JtYWwsdGVtcE5vcm1hbCk7XG4gICAgdmFyIG1heFZhbCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgbWluLnNldCgtbWF4VmFsLCAtbWF4VmFsLCAtbWF4VmFsKTtcbiAgICBtYXguc2V0KG1heFZhbCwgbWF4VmFsLCBtYXhWYWwpO1xuXG4gICAgaWYodGVtcE5vcm1hbC54ID09PSAxKXsgbWF4LnggPSBwb3MueDsgfVxuICAgIGlmKHRlbXBOb3JtYWwueSA9PT0gMSl7IG1heC55ID0gcG9zLnk7IH1cbiAgICBpZih0ZW1wTm9ybWFsLnogPT09IDEpeyBtYXgueiA9IHBvcy56OyB9XG5cbiAgICBpZih0ZW1wTm9ybWFsLnggPT09IC0xKXsgbWluLnggPSBwb3MueDsgfVxuICAgIGlmKHRlbXBOb3JtYWwueSA9PT0gLTEpeyBtaW4ueSA9IHBvcy55OyB9XG4gICAgaWYodGVtcE5vcm1hbC56ID09PSAtMSl7IG1pbi56ID0gcG9zLno7IH1cbn07XG5cblBsYW5lLnByb3RvdHlwZS51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyA9IE51bWJlci5NQVhfVkFMVUU7XG59O1xufSx7XCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4vU2hhcGVcIjo0M31dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvTWF0ZXJpYWwnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBzaGFwZXNcbiAqIEBjbGFzcyBTaGFwZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYXV0aG9yIHNjaHRlcHBlXG4gKiBAdG9kbyBTaG91bGQgaGF2ZSBhIG1lY2hhbmlzbSBmb3IgY2FjaGluZyBib3VuZGluZyBzcGhlcmUgcmFkaXVzIGluc3RlYWQgb2YgY2FsY3VsYXRpbmcgaXQgZWFjaCB0aW1lXG4gKi9cbmZ1bmN0aW9uIFNoYXBlKCl7XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmeWVyIG9mIHRoZSBTaGFwZS5cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gU2hhcGUuaWRDb3VudGVyKys7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGlzIHNoYXBlLiBNdXN0IGJlIHNldCB0byBhbiBpbnQgPiAwIGJ5IHN1YmNsYXNzZXMuXG4gICAgICogQHByb3BlcnR5IHR5cGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBzZWUgU2hhcGUudHlwZXNcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSAwO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxvY2FsIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMgb2YgdGhpcyBzaGFwZS5cbiAgICAgKiBAcHJvcGVydHkge051bWJlcn0gYm91bmRpbmdTcGhlcmVSYWRpdXNcbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nU3BoZXJlUmFkaXVzID0gMDtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gcHJvZHVjZSBjb250YWN0IGZvcmNlcyB3aGVuIGluIGNvbnRhY3Qgd2l0aCBvdGhlciBib2RpZXMuIE5vdGUgdGhhdCBjb250YWN0cyB3aWxsIGJlIGdlbmVyYXRlZCwgYnV0IHRoZXkgd2lsbCBiZSBkaXNhYmxlZC5cbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbGxpc2lvblJlc3BvbnNlXG4gICAgICovXG4gICAgdGhpcy5jb2xsaXNpb25SZXNwb25zZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge01hdGVyaWFsfSBtYXRlcmlhbFxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xufVxuU2hhcGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGU7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGJvdW5kaW5nIHNwaGVyZSByYWRpdXMuIFRoZSByZXN1bHQgaXMgc3RvcmVkIGluIHRoZSBwcm9wZXJ0eSAuYm91bmRpbmdTcGhlcmVSYWRpdXNcbiAqIEBtZXRob2QgdXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuU2hhcGUucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBcImNvbXB1dGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpIG5vdCBpbXBsZW1lbnRlZCBmb3Igc2hhcGUgdHlwZSBcIit0aGlzLnR5cGU7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdm9sdW1lIG9mIHRoaXMgc2hhcGVcbiAqIEBtZXRob2Qgdm9sdW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cblNoYXBlLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHRocm93IFwidm9sdW1lKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiK3RoaXMudHlwZTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW5lcnRpYSBpbiB0aGUgbG9jYWwgZnJhbWUgZm9yIHRoaXMgc2hhcGUuXG4gKiBAbWV0aG9kIGNhbGN1bGF0ZUxvY2FsSW5lcnRpYVxuICogQHJldHVybiB7VmVjM31cbiAqIEBzZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxuICovXG5TaGFwZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIHRocm93IFwiY2FsY3VsYXRlTG9jYWxJbmVydGlhKCkgbm90IGltcGxlbWVudGVkIGZvciBzaGFwZSB0eXBlIFwiK3RoaXMudHlwZTtcbn07XG5cblNoYXBlLmlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogVGhlIGF2YWlsYWJsZSBzaGFwZSB0eXBlcy5cbiAqIEBzdGF0aWNcbiAqIEBwcm9wZXJ0eSB0eXBlc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuU2hhcGUudHlwZXMgPSB7XG4gICAgU1BIRVJFOjEsXG4gICAgUExBTkU6MixcbiAgICBCT1g6NCxcbiAgICBDT01QT1VORDo4LFxuICAgIENPTlZFWFBPTFlIRURST046MTYsXG4gICAgSEVJR0hURklFTEQ6MzIsXG4gICAgUEFSVElDTEU6NjQsXG4gICAgQ1lMSU5ERVI6MTI4LFxuICAgIFRSSU1FU0g6MjU2XG59O1xuXG5cbn0se1wiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyNSxcIi4uL21hdGgvUXVhdGVybmlvblwiOjI4LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL1NoYXBlXCI6NDN9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFNwaGVyZTtcblxudmFyIFNoYXBlID0gX2RlcmVxXygnLi9TaGFwZScpO1xudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcblxuLyoqXG4gKiBTcGhlcmljYWwgc2hhcGVcbiAqIEBjbGFzcyBTcGhlcmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgU2hhcGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWRpdXMgVGhlIHJhZGl1cyBvZiB0aGUgc3BoZXJlLCBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cDovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gU3BoZXJlKHJhZGl1cyl7XG4gICAgU2hhcGUuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSByYWRpdXNcbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyE9PXVuZGVmaW5lZCA/IE51bWJlcihyYWRpdXMpIDogMS4wO1xuICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLlNQSEVSRTtcblxuICAgIGlmKHRoaXMucmFkaXVzIDwgMCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNwaGVyZSByYWRpdXMgY2Fubm90IGJlIG5lZ2F0aXZlLicpO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMoKTtcbn1cblNwaGVyZS5wcm90b3R5cGUgPSBuZXcgU2hhcGUoKTtcblNwaGVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmU7XG5cblNwaGVyZS5wcm90b3R5cGUuY2FsY3VsYXRlTG9jYWxJbmVydGlhID0gZnVuY3Rpb24obWFzcyx0YXJnZXQpe1xuICAgIHRhcmdldCA9IHRhcmdldCB8fCBuZXcgVmVjMygpO1xuICAgIHZhciBJID0gMi4wKm1hc3MqdGhpcy5yYWRpdXMqdGhpcy5yYWRpdXMvNS4wO1xuICAgIHRhcmdldC54ID0gSTtcbiAgICB0YXJnZXQueSA9IEk7XG4gICAgdGFyZ2V0LnogPSBJO1xuICAgIHJldHVybiB0YXJnZXQ7XG59O1xuXG5TcGhlcmUucHJvdG90eXBlLnZvbHVtZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIDQuMCAqIE1hdGguUEkgKiB0aGlzLnJhZGl1cyAvIDMuMDtcbn07XG5cblNwaGVyZS5wcm90b3R5cGUudXBkYXRlQm91bmRpbmdTcGhlcmVSYWRpdXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSB0aGlzLnJhZGl1cztcbn07XG5cblNwaGVyZS5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRBQUJCID0gZnVuY3Rpb24ocG9zLHF1YXQsbWluLG1heCl7XG4gICAgdmFyIHIgPSB0aGlzLnJhZGl1cztcbiAgICB2YXIgYXhlcyA9IFsneCcsJ3knLCd6J107XG4gICAgZm9yKHZhciBpPTA7IGk8YXhlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIHZhciBheCA9IGF4ZXNbaV07XG4gICAgICAgIG1pbltheF0gPSBwb3NbYXhdIC0gcjtcbiAgICAgICAgbWF4W2F4XSA9IHBvc1theF0gKyByO1xuICAgIH1cbn07XG5cbn0se1wiLi4vbWF0aC9WZWMzXCI6MzAsXCIuL1NoYXBlXCI6NDN9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFRyaW1lc2g7XG5cbnZhciBTaGFwZSA9IF9kZXJlcV8oJy4vU2hhcGUnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4uL21hdGgvVHJhbnNmb3JtJyk7XG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG52YXIgT2N0cmVlID0gX2RlcmVxXygnLi4vdXRpbHMvT2N0cmVlJyk7XG5cbi8qKlxuICogQGNsYXNzIFRyaW1lc2hcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHthcnJheX0gdmVydGljZXNcbiAqIEBwYXJhbSB7YXJyYXl9IGluZGljZXNcbiAqIEBleHRlbmRzIFNoYXBlXG4gKiBAZXhhbXBsZVxuICogICAgIC8vIEhvdyB0byBtYWtlIGEgbWVzaCB3aXRoIGEgc2luZ2xlIHRyaWFuZ2xlXG4gKiAgICAgdmFyIHZlcnRpY2VzID0gW1xuICogICAgICAgICAwLCAwLCAwLCAvLyB2ZXJ0ZXggMFxuICogICAgICAgICAxLCAwLCAwLCAvLyB2ZXJ0ZXggMVxuICogICAgICAgICAwLCAxLCAwICAvLyB2ZXJ0ZXggMlxuICogICAgIF07XG4gKiAgICAgdmFyIGluZGljZXMgPSBbXG4gKiAgICAgICAgIDAsIDEsIDIgIC8vIHRyaWFuZ2xlIDBcbiAqICAgICBdO1xuICogICAgIHZhciB0cmltZXNoU2hhcGUgPSBuZXcgVHJpbWVzaCh2ZXJ0aWNlcywgaW5kaWNlcyk7XG4gKi9cbmZ1bmN0aW9uIFRyaW1lc2godmVydGljZXMsIGluZGljZXMpIHtcbiAgICBTaGFwZS5jYWxsKHRoaXMpO1xuICAgIHRoaXMudHlwZSA9IFNoYXBlLnR5cGVzLlRSSU1FU0g7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgdmVydGljZXNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXMpO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgaW50ZWdlcnMsIGluZGljYXRpbmcgd2hpY2ggdmVydGljZXMgZWFjaCB0cmlhbmdsZSBjb25zaXN0cyBvZi4gVGhlIGxlbmd0aCBvZiB0aGlzIGFycmF5IGlzIHRodXMgMyB0aW1lcyB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy5cbiAgICAgKiBAcHJvcGVydHkgaW5kaWNlc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmluZGljZXMgPSBuZXcgSW50MTZBcnJheShpbmRpY2VzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBub3JtYWxzIGRhdGEuXG4gICAgICogQHByb3BlcnR5IG5vcm1hbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5ub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheShpbmRpY2VzLmxlbmd0aCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbG9jYWwgQUFCQiBvZiB0aGUgbWVzaC5cbiAgICAgKiBAcHJvcGVydHkgYWFiYlxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmFhYmIgPSBuZXcgQUFCQigpO1xuXG4gICAgLyoqXG4gICAgICogUmVmZXJlbmNlcyB0byB2ZXJ0ZXggcGFpcnMsIG1ha2luZyB1cCBhbGwgdW5pcXVlIGVkZ2VzIGluIHRoZSB0cmltZXNoLlxuICAgICAqIEBwcm9wZXJ0eSB7YXJyYXl9IGVkZ2VzXG4gICAgICovXG4gICAgdGhpcy5lZGdlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBMb2NhbCBzY2FsaW5nIG9mIHRoZSBtZXNoLiBVc2UgLnNldFNjYWxlKCkgdG8gc2V0IGl0LlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM30gc2NhbGVcbiAgICAgKi9cbiAgICB0aGlzLnNjYWxlID0gbmV3IFZlYzMoMSwgMSwgMSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXhlZCB0cmlhbmdsZXMuIFVzZSAudXBkYXRlVHJlZSgpIHRvIHVwZGF0ZSBpdC5cbiAgICAgKiBAcHJvcGVydHkge09jdHJlZX0gdHJlZVxuICAgICAqL1xuICAgIHRoaXMudHJlZSA9IG5ldyBPY3RyZWUoKTtcblxuICAgIHRoaXMudXBkYXRlRWRnZXMoKTtcbiAgICB0aGlzLnVwZGF0ZU5vcm1hbHMoKTtcbiAgICB0aGlzLnVwZGF0ZUFBQkIoKTtcbiAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzKCk7XG4gICAgdGhpcy51cGRhdGVUcmVlKCk7XG59XG5UcmltZXNoLnByb3RvdHlwZSA9IG5ldyBTaGFwZSgpO1xuVHJpbWVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmltZXNoO1xuXG52YXIgY29tcHV0ZU5vcm1hbHNfbiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCB1cGRhdGVUcmVlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZVRyZWUgPSBmdW5jdGlvbigpe1xuICAgIHZhciB0cmVlID0gdGhpcy50cmVlO1xuXG4gICAgdHJlZS5yZXNldCgpO1xuICAgIHRyZWUuYWFiYi5jb3B5KHRoaXMuYWFiYik7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTsgLy8gVGhlIGxvY2FsIG1lc2ggQUFCQiBpcyBzY2FsZWQsIGJ1dCB0aGUgb2N0cmVlIEFBQkIgc2hvdWxkIGJlIHVuc2NhbGVkXG4gICAgdHJlZS5hYWJiLmxvd2VyQm91bmQueCAqPSAxIC8gc2NhbGUueDtcbiAgICB0cmVlLmFhYmIubG93ZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xuICAgIHRyZWUuYWFiYi5sb3dlckJvdW5kLnogKj0gMSAvIHNjYWxlLno7XG4gICAgdHJlZS5hYWJiLnVwcGVyQm91bmQueCAqPSAxIC8gc2NhbGUueDtcbiAgICB0cmVlLmFhYmIudXBwZXJCb3VuZC55ICo9IDEgLyBzY2FsZS55O1xuICAgIHRyZWUuYWFiYi51cHBlckJvdW5kLnogKj0gMSAvIHNjYWxlLno7XG5cbiAgICAvLyBJbnNlcnQgYWxsIHRyaWFuZ2xlc1xuICAgIHZhciB0cmlhbmdsZUFBQkIgPSBuZXcgQUFCQigpO1xuICAgIHZhciBhID0gbmV3IFZlYzMoKTtcbiAgICB2YXIgYiA9IG5ldyBWZWMzKCk7XG4gICAgdmFyIGMgPSBuZXcgVmVjMygpO1xuICAgIHZhciBwb2ludHMgPSBbYSwgYiwgY107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG4gICAgICAgIC8vdGhpcy5nZXRUcmlhbmdsZVZlcnRpY2VzKGksIGEsIGIsIGMpO1xuXG4gICAgICAgIC8vIEdldCB1bnNjYWxlZCB0cmlhbmdsZSB2ZXJ0c1xuICAgICAgICB2YXIgaTMgPSBpICogMztcbiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XG4gICAgICAgIHRoaXMuX2dldFVuc2NhbGVkVmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDFdLCBiKTtcbiAgICAgICAgdGhpcy5fZ2V0VW5zY2FsZWRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMl0sIGMpO1xuXG4gICAgICAgIHRyaWFuZ2xlQUFCQi5zZXRGcm9tUG9pbnRzKHBvaW50cyk7XG4gICAgICAgIHRyZWUuaW5zZXJ0KHRyaWFuZ2xlQUFCQiwgaSk7XG4gICAgfVxuICAgIHRyZWUucmVtb3ZlRW1wdHlOb2RlcygpO1xufTtcblxudmFyIHVuc2NhbGVkQUFCQiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogR2V0IHRyaWFuZ2xlcyBpbiBhIGxvY2FsIEFBQkIgZnJvbSB0aGUgdHJpbWVzaC5cbiAqIEBtZXRob2QgZ2V0VHJpYW5nbGVzSW5BQUJCXG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0IEFuIGFycmF5IG9mIGludGVnZXJzLCByZWZlcmVuY2luZyB0aGUgcXVlcmllZCB0cmlhbmdsZXMuXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFRyaWFuZ2xlc0luQUFCQiA9IGZ1bmN0aW9uKGFhYmIsIHJlc3VsdCl7XG4gICAgdW5zY2FsZWRBQUJCLmNvcHkoYWFiYik7XG5cbiAgICAvLyBTY2FsZSBpdCB0byBsb2NhbFxuICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgdmFyIGlzeCA9IHNjYWxlLng7XG4gICAgdmFyIGlzeSA9IHNjYWxlLnk7XG4gICAgdmFyIGlzeiA9IHNjYWxlLno7XG4gICAgdmFyIGwgPSB1bnNjYWxlZEFBQkIubG93ZXJCb3VuZDtcbiAgICB2YXIgdSA9IHVuc2NhbGVkQUFCQi51cHBlckJvdW5kO1xuICAgIGwueCAvPSBpc3g7XG4gICAgbC55IC89IGlzeTtcbiAgICBsLnogLz0gaXN6O1xuICAgIHUueCAvPSBpc3g7XG4gICAgdS55IC89IGlzeTtcbiAgICB1LnogLz0gaXN6O1xuXG4gICAgcmV0dXJuIHRoaXMudHJlZS5hYWJiUXVlcnkodW5zY2FsZWRBQUJCLCByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNldFNjYWxlXG4gKiBAcGFyYW0ge1ZlYzN9IHNjYWxlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24oc2NhbGUpe1xuICAgIHZhciB3YXNVbmlmb3JtID0gdGhpcy5zY2FsZS54ID09PSB0aGlzLnNjYWxlLnkgPT09IHRoaXMuc2NhbGUuejtcbiAgICB2YXIgaXNVbmlmb3JtID0gc2NhbGUueCA9PT0gc2NhbGUueSA9PT0gc2NhbGUuejtcblxuICAgIGlmKCEod2FzVW5pZm9ybSAmJiBpc1VuaWZvcm0pKXtcbiAgICAgICAgLy8gTm9uLXVuaWZvcm0gc2NhbGluZy4gTmVlZCB0byB1cGRhdGUgbm9ybWFscy5cbiAgICAgICAgdGhpcy51cGRhdGVOb3JtYWxzKCk7XG4gICAgfVxuICAgIHRoaXMuc2NhbGUuY29weShzY2FsZSk7XG4gICAgdGhpcy51cGRhdGVBQUJCKCk7XG4gICAgdGhpcy51cGRhdGVCb3VuZGluZ1NwaGVyZVJhZGl1cygpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBub3JtYWxzIG9mIHRoZSBmYWNlcy4gV2lsbCBzYXZlIGluIHRoZSAubm9ybWFscyBhcnJheS5cbiAqIEBtZXRob2QgdXBkYXRlTm9ybWFsc1xuICovXG5UcmltZXNoLnByb3RvdHlwZS51cGRhdGVOb3JtYWxzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgbiA9IGNvbXB1dGVOb3JtYWxzX247XG5cbiAgICAvLyBHZW5lcmF0ZSBub3JtYWxzXG4gICAgdmFyIG5vcm1hbHMgPSB0aGlzLm5vcm1hbHM7XG4gICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKXtcbiAgICAgICAgdmFyIGkzID0gaSAqIDM7XG5cbiAgICAgICAgdmFyIGEgPSB0aGlzLmluZGljZXNbaTNdLFxuICAgICAgICAgICAgYiA9IHRoaXMuaW5kaWNlc1tpMyArIDFdLFxuICAgICAgICAgICAgYyA9IHRoaXMuaW5kaWNlc1tpMyArIDJdO1xuXG4gICAgICAgIHRoaXMuZ2V0VmVydGV4KGEsIHZhKTtcbiAgICAgICAgdGhpcy5nZXRWZXJ0ZXgoYiwgdmIpO1xuICAgICAgICB0aGlzLmdldFZlcnRleChjLCB2Yyk7XG5cbiAgICAgICAgVHJpbWVzaC5jb21wdXRlTm9ybWFsKHZiLCB2YSwgdmMsIG4pO1xuXG4gICAgICAgIG5vcm1hbHNbaTNdID0gbi54O1xuICAgICAgICBub3JtYWxzW2kzICsgMV0gPSBuLnk7XG4gICAgICAgIG5vcm1hbHNbaTMgKyAyXSA9IG4uejtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSB0aGUgLmVkZ2VzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUVkZ2VzXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUVkZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgZWRnZXMgPSB7fTtcbiAgICB2YXIgYWRkID0gZnVuY3Rpb24oaW5kZXhBLCBpbmRleEIpe1xuICAgICAgICB2YXIga2V5ID0gYSA8IGIgPyBhICsgJ18nICsgYiA6IGIgKyAnXycgKyBhO1xuICAgICAgICBlZGdlc1trZXldID0gdHJ1ZTtcbiAgICB9O1xuICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy5pbmRpY2VzLmxlbmd0aCAvIDM7IGkrKyl7XG4gICAgICAgIHZhciBpMyA9IGkgKiAzO1xuICAgICAgICB2YXIgYSA9IHRoaXMuaW5kaWNlc1tpM10sXG4gICAgICAgICAgICBiID0gdGhpcy5pbmRpY2VzW2kzICsgMV0sXG4gICAgICAgICAgICBjID0gdGhpcy5pbmRpY2VzW2kzICsgMl07XG4gICAgICAgIGFkZChhLGIpO1xuICAgICAgICBhZGQoYixjKTtcbiAgICAgICAgYWRkKGMsYSk7XG4gICAgfVxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWRnZXMpO1xuICAgIHRoaXMuZWRnZXMgPSBuZXcgSW50MTZBcnJheShrZXlzLmxlbmd0aCAqIDIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5kaWNlcyA9IGtleXNbaV0uc3BsaXQoJ18nKTtcbiAgICAgICAgdGhpcy5lZGdlc1syICogaV0gPSBwYXJzZUludChpbmRpY2VzWzBdLCAxMCk7XG4gICAgICAgIHRoaXMuZWRnZXNbMiAqIGkgKyAxXSA9IHBhcnNlSW50KGluZGljZXNbMV0sIDEwKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhbiBlZGdlIHZlcnRleFxuICogQG1ldGhvZCBnZXRFZGdlVmVydGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGVkZ2VJbmRleFxuICogQHBhcmFtICB7bnVtYmVyfSBmaXJzdE9yU2Vjb25kIDAgb3IgMSwgZGVwZW5kaW5nIG9uIHdoaWNoIG9uZSBvZiB0aGUgdmVydGljZXMgeW91IG5lZWQuXG4gKiBAcGFyYW0gIHtWZWMzfSB2ZXJ0ZXhTdG9yZSBXaGVyZSB0byBzdG9yZSB0aGUgcmVzdWx0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZXJ0ZXggPSBmdW5jdGlvbihlZGdlSW5kZXgsIGZpcnN0T3JTZWNvbmQsIHZlcnRleFN0b3JlKXtcbiAgICB2YXIgdmVydGV4SW5kZXggPSB0aGlzLmVkZ2VzW2VkZ2VJbmRleCAqIDIgKyAoZmlyc3RPclNlY29uZCA/IDEgOiAwKV07XG4gICAgdGhpcy5nZXRWZXJ0ZXgodmVydGV4SW5kZXgsIHZlcnRleFN0b3JlKTtcbn07XG5cbnZhciBnZXRFZGdlVmVjdG9yX3ZhID0gbmV3IFZlYzMoKTtcbnZhciBnZXRFZGdlVmVjdG9yX3ZiID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBHZXQgYSB2ZWN0b3IgYWxvbmcgYW4gZWRnZS5cbiAqIEBtZXRob2QgZ2V0RWRnZVZlY3RvclxuICogQHBhcmFtICB7bnVtYmVyfSBlZGdlSW5kZXhcbiAqIEBwYXJhbSAge1ZlYzN9IHZlY3RvclN0b3JlXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldEVkZ2VWZWN0b3IgPSBmdW5jdGlvbihlZGdlSW5kZXgsIHZlY3RvclN0b3JlKXtcbiAgICB2YXIgdmEgPSBnZXRFZGdlVmVjdG9yX3ZhO1xuICAgIHZhciB2YiA9IGdldEVkZ2VWZWN0b3JfdmI7XG4gICAgdGhpcy5nZXRFZGdlVmVydGV4KGVkZ2VJbmRleCwgMCwgdmEpO1xuICAgIHRoaXMuZ2V0RWRnZVZlcnRleChlZGdlSW5kZXgsIDEsIHZiKTtcbiAgICB2Yi52c3ViKHZhLCB2ZWN0b3JTdG9yZSk7XG59O1xuXG4vKipcbiAqIEdldCBmYWNlIG5vcm1hbCBnaXZlbiAzIHZlcnRpY2VzXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNvbXB1dGVOb3JtYWxcbiAqIEBwYXJhbSB7VmVjM30gdmFcbiAqIEBwYXJhbSB7VmVjM30gdmJcbiAqIEBwYXJhbSB7VmVjM30gdmNcbiAqIEBwYXJhbSB7VmVjM30gdGFyZ2V0XG4gKi9cbnZhciBjYiA9IG5ldyBWZWMzKCk7XG52YXIgYWIgPSBuZXcgVmVjMygpO1xuVHJpbWVzaC5jb21wdXRlTm9ybWFsID0gZnVuY3Rpb24gKCB2YSwgdmIsIHZjLCB0YXJnZXQgKSB7XG4gICAgdmIudnN1Yih2YSxhYik7XG4gICAgdmMudnN1Yih2YixjYik7XG4gICAgY2IuY3Jvc3MoYWIsdGFyZ2V0KTtcbiAgICBpZiAoICF0YXJnZXQuaXNaZXJvKCkgKSB7XG4gICAgICAgIHRhcmdldC5ub3JtYWxpemUoKTtcbiAgICB9XG59O1xuXG52YXIgdmEgPSBuZXcgVmVjMygpO1xudmFyIHZiID0gbmV3IFZlYzMoKTtcbnZhciB2YyA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogR2V0IHZlcnRleCBpLlxuICogQG1ldGhvZCBnZXRWZXJ0ZXhcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gb3V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFZlcnRleCA9IGZ1bmN0aW9uKGksIG91dCl7XG4gICAgdmFyIHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgICB0aGlzLl9nZXRVbnNjYWxlZFZlcnRleChpLCBvdXQpO1xuICAgIG91dC54ICo9IHNjYWxlLng7XG4gICAgb3V0LnkgKj0gc2NhbGUueTtcbiAgICBvdXQueiAqPSBzY2FsZS56O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdldCByYXcgdmVydGV4IGlcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kIF9nZXRVbnNjYWxlZFZlcnRleFxuICogQHBhcmFtICB7bnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtWZWMzfSBvdXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcIm91dFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuX2dldFVuc2NhbGVkVmVydGV4ID0gZnVuY3Rpb24oaSwgb3V0KXtcbiAgICB2YXIgaTMgPSBpICogMztcbiAgICB2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xuICAgIHJldHVybiBvdXQuc2V0KFxuICAgICAgICB2ZXJ0aWNlc1tpM10sXG4gICAgICAgIHZlcnRpY2VzW2kzICsgMV0sXG4gICAgICAgIHZlcnRpY2VzW2kzICsgMl1cbiAgICApO1xufTtcblxuLyoqXG4gKiBHZXQgYSB2ZXJ0ZXggZnJvbSB0aGUgdHJpbWVzaCx0cmFuc2Zvcm1lZCBieSB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHF1YXRlcm5pb24uXG4gKiBAbWV0aG9kIGdldFdvcmxkVmVydGV4XG4gKiBAcGFyYW0gIHtudW1iZXJ9IGlcbiAqIEBwYXJhbSAge1ZlYzN9IHBvc1xuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcXVhdFxuICogQHBhcmFtICB7VmVjM30gb3V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJvdXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmdldFdvcmxkVmVydGV4ID0gZnVuY3Rpb24oaSwgcG9zLCBxdWF0LCBvdXQpe1xuICAgIHRoaXMuZ2V0VmVydGV4KGksIG91dCk7XG4gICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHBvcywgcXVhdCwgb3V0LCBvdXQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdGhyZWUgdmVydGljZXMgZm9yIHRyaWFuZ2xlIGkuXG4gKiBAbWV0aG9kIGdldFRyaWFuZ2xlVmVydGljZXNcbiAqIEBwYXJhbSAge251bWJlcn0gaVxuICogQHBhcmFtICB7VmVjM30gYVxuICogQHBhcmFtICB7VmVjM30gYlxuICogQHBhcmFtICB7VmVjM30gY1xuICovXG5UcmltZXNoLnByb3RvdHlwZS5nZXRUcmlhbmdsZVZlcnRpY2VzID0gZnVuY3Rpb24oaSwgYSwgYiwgYyl7XG4gICAgdmFyIGkzID0gaSAqIDM7XG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzXSwgYSk7XG4gICAgdGhpcy5nZXRWZXJ0ZXgodGhpcy5pbmRpY2VzW2kzICsgMV0sIGIpO1xuICAgIHRoaXMuZ2V0VmVydGV4KHRoaXMuaW5kaWNlc1tpMyArIDJdLCBjKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgbm9ybWFsIG9mIHRyaWFuZ2xlIGkuXG4gKiBAbWV0aG9kIGdldE5vcm1hbFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtWZWMzfSB0YXJnZXRcbiAqIEByZXR1cm4ge1ZlYzN9IFRoZSBcInRhcmdldFwiIHZlY3RvciBvYmplY3RcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuZ2V0Tm9ybWFsID0gZnVuY3Rpb24oaSwgdGFyZ2V0KXtcbiAgICB2YXIgaTMgPSBpICogMztcbiAgICByZXR1cm4gdGFyZ2V0LnNldChcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzXSxcbiAgICAgICAgdGhpcy5ub3JtYWxzW2kzICsgMV0sXG4gICAgICAgIHRoaXMubm9ybWFsc1tpMyArIDJdXG4gICAgKTtcbn07XG5cbnZhciBjbGlfYWFiYiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogQG1ldGhvZCBjYWxjdWxhdGVMb2NhbEluZXJ0aWFcbiAqIEBwYXJhbSAge051bWJlcn0gbWFzc1xuICogQHBhcmFtICB7VmVjM30gdGFyZ2V0XG4gKiBAcmV0dXJuIHtWZWMzfSBUaGUgXCJ0YXJnZXRcIiB2ZWN0b3Igb2JqZWN0XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYSA9IGZ1bmN0aW9uKG1hc3MsdGFyZ2V0KXtcbiAgICAvLyBBcHByb3hpbWF0ZSB3aXRoIGJveCBpbmVydGlhXG4gICAgLy8gRXhhY3QgaW5lcnRpYSBjYWxjdWxhdGlvbiBpcyBvdmVya2lsbCwgYnV0IHNlZSBodHRwOi8vZ2VvbWV0cmljdG9vbHMuY29tL0RvY3VtZW50YXRpb24vUG9seWhlZHJhbE1hc3NQcm9wZXJ0aWVzLnBkZiBmb3IgdGhlIGNvcnJlY3Qgd2F5IHRvIGRvIGl0XG4gICAgdGhpcy5jb21wdXRlTG9jYWxBQUJCKGNsaV9hYWJiKTtcbiAgICB2YXIgeCA9IGNsaV9hYWJiLnVwcGVyQm91bmQueCAtIGNsaV9hYWJiLmxvd2VyQm91bmQueCxcbiAgICAgICAgeSA9IGNsaV9hYWJiLnVwcGVyQm91bmQueSAtIGNsaV9hYWJiLmxvd2VyQm91bmQueSxcbiAgICAgICAgeiA9IGNsaV9hYWJiLnVwcGVyQm91bmQueiAtIGNsaV9hYWJiLmxvd2VyQm91bmQuejtcbiAgICByZXR1cm4gdGFyZ2V0LnNldChcbiAgICAgICAgMS4wIC8gMTIuMCAqIG1hc3MgKiAoIDIqeSoyKnkgKyAyKnoqMip6ICksXG4gICAgICAgIDEuMCAvIDEyLjAgKiBtYXNzICogKCAyKngqMip4ICsgMip6KjIqeiApLFxuICAgICAgICAxLjAgLyAxMi4wICogbWFzcyAqICggMip5KjIqeSArIDIqeCoyKnggKVxuICAgICk7XG59O1xuXG52YXIgY29tcHV0ZUxvY2FsQUFCQl93b3JsZFZlcnQgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGxvY2FsIEFBQkIgZm9yIHRoZSB0cmltZXNoXG4gKiBAbWV0aG9kIGNvbXB1dGVMb2NhbEFBQkJcbiAqIEBwYXJhbSAge0FBQkJ9IGFhYmJcbiAqL1xuVHJpbWVzaC5wcm90b3R5cGUuY29tcHV0ZUxvY2FsQUFCQiA9IGZ1bmN0aW9uKGFhYmIpe1xuICAgIHZhciBsID0gYWFiYi5sb3dlckJvdW5kLFxuICAgICAgICB1ID0gYWFiYi51cHBlckJvdW5kLFxuICAgICAgICBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGgsXG4gICAgICAgIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcyxcbiAgICAgICAgdiA9IGNvbXB1dGVMb2NhbEFBQkJfd29ybGRWZXJ0O1xuXG4gICAgdGhpcy5nZXRWZXJ0ZXgoMCwgdik7XG4gICAgbC5jb3B5KHYpO1xuICAgIHUuY29weSh2KTtcblxuICAgIGZvcih2YXIgaT0wOyBpICE9PSBuOyBpKyspe1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcblxuICAgICAgICBpZih2LnggPCBsLngpe1xuICAgICAgICAgICAgbC54ID0gdi54O1xuICAgICAgICB9IGVsc2UgaWYodi54ID4gdS54KXtcbiAgICAgICAgICAgIHUueCA9IHYueDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHYueSA8IGwueSl7XG4gICAgICAgICAgICBsLnkgPSB2Lnk7XG4gICAgICAgIH0gZWxzZSBpZih2LnkgPiB1Lnkpe1xuICAgICAgICAgICAgdS55ID0gdi55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodi56IDwgbC56KXtcbiAgICAgICAgICAgIGwueiA9IHYuejtcbiAgICAgICAgfSBlbHNlIGlmKHYueiA+IHUueil7XG4gICAgICAgICAgICB1LnogPSB2Lno7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogVXBkYXRlIHRoZSAuYWFiYiBwcm9wZXJ0eVxuICogQG1ldGhvZCB1cGRhdGVBQUJCXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUFBQkIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuY29tcHV0ZUxvY2FsQUFCQih0aGlzLmFhYmIpO1xufTtcblxuLyoqXG4gKiBXaWxsIHVwZGF0ZSB0aGUgLmJvdW5kaW5nU3BoZXJlUmFkaXVzIHByb3BlcnR5XG4gKiBAbWV0aG9kIHVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzXG4gKi9cblRyaW1lc2gucHJvdG90eXBlLnVwZGF0ZUJvdW5kaW5nU3BoZXJlUmFkaXVzID0gZnVuY3Rpb24oKXtcbiAgICAvLyBBc3N1bWUgcG9pbnRzIGFyZSBkaXN0cmlidXRlZCB3aXRoIGxvY2FsICgwLDAsMCkgYXMgY2VudGVyXG4gICAgdmFyIG1heDIgPSAwO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XG4gICAgdmFyIHYgPSBuZXcgVmVjMygpO1xuICAgIGZvcih2YXIgaT0wLCBOPXZlcnRpY2VzLmxlbmd0aCAvIDM7IGkgIT09IE47IGkrKykge1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcbiAgICAgICAgdmFyIG5vcm0yID0gdi5ub3JtMigpO1xuICAgICAgICBpZihub3JtMiA+IG1heDIpe1xuICAgICAgICAgICAgbWF4MiA9IG5vcm0yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmVSYWRpdXMgPSBNYXRoLnNxcnQobWF4Mik7XG59O1xuXG52YXIgdGVtcFdvcmxkVmVydGV4ID0gbmV3IFZlYzMoKTtcbnZhciBjYWxjdWxhdGVXb3JsZEFBQkJfZnJhbWUgPSBuZXcgVHJhbnNmb3JtKCk7XG52YXIgY2FsY3VsYXRlV29ybGRBQUJCX2FhYmIgPSBuZXcgQUFCQigpO1xuXG4vKipcbiAqIEBtZXRob2QgY2FsY3VsYXRlV29ybGRBQUJCXG4gKiBAcGFyYW0ge1ZlYzN9ICAgICAgICBwb3NcbiAqIEBwYXJhbSB7UXVhdGVybmlvbn0gIHF1YXRcbiAqIEBwYXJhbSB7VmVjM30gICAgICAgIG1pblxuICogQHBhcmFtIHtWZWMzfSAgICAgICAgbWF4XG4gKi9cblRyaW1lc2gucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkQUFCQiA9IGZ1bmN0aW9uKHBvcyxxdWF0LG1pbixtYXgpe1xuICAgIC8qXG4gICAgdmFyIG4gPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAvIDMsXG4gICAgICAgIHZlcnRzID0gdGhpcy52ZXJ0aWNlcztcbiAgICB2YXIgbWlueCxtaW55LG1pbnosbWF4eCxtYXh5LG1heHo7XG5cbiAgICB2YXIgdiA9IHRlbXBXb3JsZFZlcnRleDtcbiAgICBmb3IodmFyIGk9MDsgaTxuOyBpKyspe1xuICAgICAgICB0aGlzLmdldFZlcnRleChpLCB2KTtcbiAgICAgICAgcXVhdC52bXVsdCh2LCB2KTtcbiAgICAgICAgcG9zLnZhZGQodiwgdik7XG4gICAgICAgIGlmICh2LnggPCBtaW54IHx8IG1pbng9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWlueCA9IHYueDtcbiAgICAgICAgfSBlbHNlIGlmKHYueCA+IG1heHggfHwgbWF4eD09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtYXh4ID0gdi54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYueSA8IG1pbnkgfHwgbWlueT09PXVuZGVmaW5lZCl7XG4gICAgICAgICAgICBtaW55ID0gdi55O1xuICAgICAgICB9IGVsc2UgaWYodi55ID4gbWF4eSB8fCBtYXh5PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1heHkgPSB2Lnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodi56IDwgbWlueiB8fCBtaW56PT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgIG1pbnogPSB2Lno7XG4gICAgICAgIH0gZWxzZSBpZih2LnogPiBtYXh6IHx8IG1heHo9PT11bmRlZmluZWQpe1xuICAgICAgICAgICAgbWF4eiA9IHYuejtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4uc2V0KG1pbngsbWlueSxtaW56KTtcbiAgICBtYXguc2V0KG1heHgsbWF4eSxtYXh6KTtcbiAgICAqL1xuXG4gICAgLy8gRmFzdGVyIGFwcHJveGltYXRpb24gdXNpbmcgbG9jYWwgQUFCQlxuICAgIHZhciBmcmFtZSA9IGNhbGN1bGF0ZVdvcmxkQUFCQl9mcmFtZTtcbiAgICB2YXIgcmVzdWx0ID0gY2FsY3VsYXRlV29ybGRBQUJCX2FhYmI7XG4gICAgZnJhbWUucG9zaXRpb24gPSBwb3M7XG4gICAgZnJhbWUucXVhdGVybmlvbiA9IHF1YXQ7XG4gICAgdGhpcy5hYWJiLnRvV29ybGRGcmFtZShmcmFtZSwgcmVzdWx0KTtcbiAgICBtaW4uY29weShyZXN1bHQubG93ZXJCb3VuZCk7XG4gICAgbWF4LmNvcHkocmVzdWx0LnVwcGVyQm91bmQpO1xufTtcblxuLyoqXG4gKiBHZXQgYXBwcm94aW1hdGUgdm9sdW1lXG4gKiBAbWV0aG9kIHZvbHVtZVxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5UcmltZXNoLnByb3RvdHlwZS52b2x1bWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiA0LjAgKiBNYXRoLlBJICogdGhpcy5ib3VuZGluZ1NwaGVyZVJhZGl1cyAvIDMuMDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgVHJpbWVzaCBpbnN0YW5jZSwgc2hhcGVkIGFzIGEgdG9ydXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGNyZWF0ZVRvcnVzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtyYWRpdXM9MV1cbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YmU9MC41XVxuICogQHBhcmFtICB7bnVtYmVyfSBbcmFkaWFsU2VnbWVudHM9OF1cbiAqIEBwYXJhbSAge251bWJlcn0gW3R1YnVsYXJTZWdtZW50cz02XVxuICogQHBhcmFtICB7bnVtYmVyfSBbYXJjPTYuMjgzMTg1MzA3MTc5NTg2XVxuICogQHJldHVybiB7VHJpbWVzaH0gQSB0b3J1c1xuICovXG5UcmltZXNoLmNyZWF0ZVRvcnVzID0gZnVuY3Rpb24gKHJhZGl1cywgdHViZSwgcmFkaWFsU2VnbWVudHMsIHR1YnVsYXJTZWdtZW50cywgYXJjKSB7XG4gICAgcmFkaXVzID0gcmFkaXVzIHx8IDE7XG4gICAgdHViZSA9IHR1YmUgfHwgMC41O1xuICAgIHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcbiAgICB0dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgNjtcbiAgICBhcmMgPSBhcmMgfHwgTWF0aC5QSSAqIDI7XG5cbiAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yICggdmFyIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuICAgICAgICAgICAgdmFyIHUgPSBpIC8gdHVidWxhclNlZ21lbnRzICogYXJjO1xuICAgICAgICAgICAgdmFyIHYgPSBqIC8gcmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcblxuICAgICAgICAgICAgdmFyIHggPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xuICAgICAgICAgICAgdmFyIHkgPSAoIHJhZGl1cyArIHR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xuICAgICAgICAgICAgdmFyIHogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcblxuICAgICAgICAgICAgdmVydGljZXMucHVzaCggeCwgeSwgeiApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yICggdmFyIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDE7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xuICAgICAgICAgICAgdmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcbiAgICAgICAgICAgIHZhciBiID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpIC0gMTtcbiAgICAgICAgICAgIHZhciBjID0gKCB0dWJ1bGFyU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xuICAgICAgICAgICAgdmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xuXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goYSwgYiwgZCk7XG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goYiwgYywgZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFRyaW1lc2godmVydGljZXMsIGluZGljZXMpO1xufTtcblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4uL21hdGgvVHJhbnNmb3JtXCI6MjksXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4uL3V0aWxzL09jdHJlZVwiOjUwLFwiLi9TaGFwZVwiOjQzfV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBHU1NvbHZlcjtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgU29sdmVyID0gX2RlcmVxXygnLi9Tb2x2ZXInKTtcblxuLyoqXG4gKiBDb25zdHJhaW50IGVxdWF0aW9uIEdhdXNzLVNlaWRlbCBzb2x2ZXIuXG4gKiBAY2xhc3MgR1NTb2x2ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHRvZG8gVGhlIHNwb29rIHBhcmFtZXRlcnMgc2hvdWxkIGJlIHNwZWNpZmllZCBmb3IgZWFjaCBjb25zdHJhaW50LCBub3QgZ2xvYmFsbHkuXG4gKiBAYXV0aG9yIHNjaHRlcHBlIC8gaHR0cHM6Ly9naXRodWIuY29tL3NjaHRlcHBlXG4gKiBAc2VlIGh0dHBzOi8vd3d3OC5jcy51bXUuc2Uva3Vyc2VyLzVEVjA1OC9WVDA5L2xlY3R1cmVzL3Nwb29rbm90ZXMucGRmXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqL1xuZnVuY3Rpb24gR1NTb2x2ZXIoKXtcbiAgICBTb2x2ZXIuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2Ygc29sdmVyIGl0ZXJhdGlvbnMgZGV0ZXJtaW5lcyBxdWFsaXR5IG9mIHRoZSBjb25zdHJhaW50cyBpbiB0aGUgd29ybGQuIFRoZSBtb3JlIGl0ZXJhdGlvbnMsIHRoZSBtb3JlIGNvcnJlY3Qgc2ltdWxhdGlvbi4gTW9yZSBpdGVyYXRpb25zIG5lZWQgbW9yZSBjb21wdXRhdGlvbnMgdGhvdWdoLiBJZiB5b3UgaGF2ZSBhIGxhcmdlIGdyYXZpdHkgZm9yY2UgaW4geW91ciB3b3JsZCwgeW91IHdpbGwgbmVlZCBtb3JlIGl0ZXJhdGlvbnMuXG4gICAgICogQHByb3BlcnR5IGl0ZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEB0b2RvIHdyaXRlIG1vcmUgYWJvdXQgc29sdmVyIGFuZCBpdGVyYXRpb25zIGluIHRoZSB3aWtpXG4gICAgICovXG4gICAgdGhpcy5pdGVyYXRpb25zID0gMTA7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHRvbGVyYW5jZSBpcyByZWFjaGVkLCB0aGUgc3lzdGVtIGlzIGFzc3VtZWQgdG8gYmUgY29udmVyZ2VkLlxuICAgICAqIEBwcm9wZXJ0eSB0b2xlcmFuY2VcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9sZXJhbmNlID0gMWUtNztcbn1cbkdTU29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcblxudmFyIEdTU29sdmVyX3NvbHZlX2xhbWJkYSA9IFtdOyAvLyBKdXN0IHRlbXBvcmFyeSBudW1iZXIgaG9sZGVycyB0aGF0IHdlIHdhbnQgdG8gcmV1c2UgZWFjaCBzb2x2ZS5cbnZhciBHU1NvbHZlcl9zb2x2ZV9pbnZDcyA9IFtdO1xudmFyIEdTU29sdmVyX3NvbHZlX0JzID0gW107XG5HU1NvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgdmFyIGl0ZXIgPSAwLFxuICAgICAgICBtYXhJdGVyID0gdGhpcy5pdGVyYXRpb25zLFxuICAgICAgICB0b2xTcXVhcmVkID0gdGhpcy50b2xlcmFuY2UqdGhpcy50b2xlcmFuY2UsXG4gICAgICAgIGVxdWF0aW9ucyA9IHRoaXMuZXF1YXRpb25zLFxuICAgICAgICBOZXEgPSBlcXVhdGlvbnMubGVuZ3RoLFxuICAgICAgICBib2RpZXMgPSB3b3JsZC5ib2RpZXMsXG4gICAgICAgIE5ib2RpZXMgPSBib2RpZXMubGVuZ3RoLFxuICAgICAgICBoID0gZHQsXG4gICAgICAgIHEsIEIsIGludkMsIGRlbHRhbGFtYmRhLCBkZWx0YWxhbWJkYVRvdCwgR1dsYW1iZGEsIGxhbWJkYWo7XG5cbiAgICAvLyBVcGRhdGUgc29sdmUgbWFzc1xuICAgIGlmKE5lcSAhPT0gMCl7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgICAgIGJvZGllc1tpXS51cGRhdGVTb2x2ZU1hc3NQcm9wZXJ0aWVzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUaGluZ3MgdGhhdCBkb2VzIG5vdCBjaGFuZ2UgZHVyaW5nIGl0ZXJhdGlvbiBjYW4gYmUgY29tcHV0ZWQgb25jZVxuICAgIHZhciBpbnZDcyA9IEdTU29sdmVyX3NvbHZlX2ludkNzLFxuICAgICAgICBCcyA9IEdTU29sdmVyX3NvbHZlX0JzLFxuICAgICAgICBsYW1iZGEgPSBHU1NvbHZlcl9zb2x2ZV9sYW1iZGE7XG4gICAgaW52Q3MubGVuZ3RoID0gTmVxO1xuICAgIEJzLmxlbmd0aCA9IE5lcTtcbiAgICBsYW1iZGEubGVuZ3RoID0gTmVxO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmVxOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tpXTtcbiAgICAgICAgbGFtYmRhW2ldID0gMC4wO1xuICAgICAgICBCc1tpXSA9IGMuY29tcHV0ZUIoaCk7XG4gICAgICAgIGludkNzW2ldID0gMS4wIC8gYy5jb21wdXRlQygpO1xuICAgIH1cblxuICAgIGlmKE5lcSAhPT0gMCl7XG5cbiAgICAgICAgLy8gUmVzZXQgdmxhbWJkYVxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5ib2RpZXM7IGkrKyl7XG4gICAgICAgICAgICB2YXIgYj1ib2RpZXNbaV0sXG4gICAgICAgICAgICAgICAgdmxhbWJkYT1iLnZsYW1iZGEsXG4gICAgICAgICAgICAgICAgd2xhbWJkYT1iLndsYW1iZGE7XG4gICAgICAgICAgICB2bGFtYmRhLnNldCgwLDAsMCk7XG4gICAgICAgICAgICBpZih3bGFtYmRhKXtcbiAgICAgICAgICAgICAgICB3bGFtYmRhLnNldCgwLDAsMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZXF1YXRpb25zXG4gICAgICAgIGZvcihpdGVyPTA7IGl0ZXIhPT1tYXhJdGVyOyBpdGVyKyspe1xuXG4gICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSB0b3RhbCBlcnJvciBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgICBkZWx0YWxhbWJkYVRvdCA9IDAuMDtcblxuICAgICAgICAgICAgZm9yKHZhciBqPTA7IGohPT1OZXE7IGorKyl7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IGVxdWF0aW9uc1tqXTtcblxuICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgQiA9IEJzW2pdO1xuICAgICAgICAgICAgICAgIGludkMgPSBpbnZDc1tqXTtcbiAgICAgICAgICAgICAgICBsYW1iZGFqID0gbGFtYmRhW2pdO1xuICAgICAgICAgICAgICAgIEdXbGFtYmRhID0gYy5jb21wdXRlR1dsYW1iZGEoKTtcbiAgICAgICAgICAgICAgICBkZWx0YWxhbWJkYSA9IGludkMgKiAoIEIgLSBHV2xhbWJkYSAtIGMuZXBzICogbGFtYmRhaiApO1xuXG4gICAgICAgICAgICAgICAgLy8gQ2xhbXAgaWYgd2UgYXJlIG5vdCB3aXRoaW4gdGhlIG1pbi9tYXggaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICBpZihsYW1iZGFqICsgZGVsdGFsYW1iZGEgPCBjLm1pbkZvcmNlKXtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFsYW1iZGEgPSBjLm1pbkZvcmNlIC0gbGFtYmRhajtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYobGFtYmRhaiArIGRlbHRhbGFtYmRhID4gYy5tYXhGb3JjZSl7XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhID0gYy5tYXhGb3JjZSAtIGxhbWJkYWo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhbWJkYVtqXSArPSBkZWx0YWxhbWJkYTtcblxuICAgICAgICAgICAgICAgIGRlbHRhbGFtYmRhVG90ICs9IGRlbHRhbGFtYmRhID4gMC4wID8gZGVsdGFsYW1iZGEgOiAtZGVsdGFsYW1iZGE7IC8vIGFicyhkZWx0YWxhbWJkYSlcblxuICAgICAgICAgICAgICAgIGMuYWRkVG9XbGFtYmRhKGRlbHRhbGFtYmRhKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHRvdGFsIGVycm9yIGlzIHNtYWxsIGVub3VnaCAtIHN0b3AgaXRlcmF0ZVxuICAgICAgICAgICAgaWYoZGVsdGFsYW1iZGFUb3QqZGVsdGFsYW1iZGFUb3QgPCB0b2xTcXVhcmVkKXtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZCByZXN1bHQgdG8gdmVsb2NpdHlcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1OYm9kaWVzOyBpKyspe1xuICAgICAgICAgICAgdmFyIGI9Ym9kaWVzW2ldLFxuICAgICAgICAgICAgICAgIHY9Yi52ZWxvY2l0eSxcbiAgICAgICAgICAgICAgICB3PWIuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgdi52YWRkKGIudmxhbWJkYSwgdik7XG4gICAgICAgICAgICBpZih3KXtcbiAgICAgICAgICAgICAgICB3LnZhZGQoYi53bGFtYmRhLCB3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpdGVyO1xufTtcblxufSx7XCIuLi9tYXRoL1F1YXRlcm5pb25cIjoyOCxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Tb2x2ZXJcIjo0N31dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gU29sdmVyO1xuXG4vKipcbiAqIENvbnN0cmFpbnQgZXF1YXRpb24gc29sdmVyIGJhc2UgY2xhc3MuXG4gKiBAY2xhc3MgU29sdmVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBhdXRob3Igc2NodGVwcGUgLyBodHRwczovL2dpdGh1Yi5jb20vc2NodGVwcGVcbiAqL1xuZnVuY3Rpb24gU29sdmVyKCl7XG4gICAgLyoqXG4gICAgICogQWxsIGVxdWF0aW9ucyB0byBiZSBzb2x2ZWRcbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBlcXVhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLmVxdWF0aW9ucyA9IFtdO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc2VzIVxuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbihkdCx3b3JsZCl7XG4gICAgLy8gU2hvdWxkIHJldHVybiB0aGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgZG9uZSFcbiAgICByZXR1cm4gMDtcbn07XG5cbi8qKlxuICogQWRkIGFuIGVxdWF0aW9uXG4gKiBAbWV0aG9kIGFkZEVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLmFkZEVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIGlmIChlcS5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuZXF1YXRpb25zLnB1c2goZXEpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGVxdWF0aW9uXG4gKiBAbWV0aG9kIHJlbW92ZUVxdWF0aW9uXG4gKiBAcGFyYW0ge0VxdWF0aW9ufSBlcVxuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUVxdWF0aW9uID0gZnVuY3Rpb24oZXEpe1xuICAgIHZhciBlcXMgPSB0aGlzLmVxdWF0aW9ucztcbiAgICB2YXIgaSA9IGVxcy5pbmRleE9mKGVxKTtcbiAgICBpZihpICE9PSAtMSl7XG4gICAgICAgIGVxcy5zcGxpY2UoaSwxKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhbGwgZXF1YXRpb25zXG4gKiBAbWV0aG9kIHJlbW92ZUFsbEVxdWF0aW9uc1xuICovXG5Tb2x2ZXIucHJvdG90eXBlLnJlbW92ZUFsbEVxdWF0aW9ucyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5lcXVhdGlvbnMubGVuZ3RoID0gMDtcbn07XG5cblxufSx7fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBTcGxpdFNvbHZlcjtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBRdWF0ZXJuaW9uID0gX2RlcmVxXygnLi4vbWF0aC9RdWF0ZXJuaW9uJyk7XG52YXIgU29sdmVyID0gX2RlcmVxXygnLi9Tb2x2ZXInKTtcbnZhciBCb2R5ID0gX2RlcmVxXygnLi4vb2JqZWN0cy9Cb2R5Jyk7XG5cbi8qKlxuICogU3BsaXRzIHRoZSBlcXVhdGlvbnMgaW50byBpc2xhbmRzIGFuZCBzb2x2ZXMgdGhlbSBpbmRlcGVuZGVudGx5LiBDYW4gaW1wcm92ZSBwZXJmb3JtYW5jZS5cbiAqIEBjbGFzcyBTcGxpdFNvbHZlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBTb2x2ZXJcbiAqIEBwYXJhbSB7U29sdmVyfSBzdWJzb2x2ZXJcbiAqL1xuZnVuY3Rpb24gU3BsaXRTb2x2ZXIoc3Vic29sdmVyKXtcbiAgICBTb2x2ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLml0ZXJhdGlvbnMgPSAxMDtcbiAgICB0aGlzLnRvbGVyYW5jZSA9IDFlLTc7XG4gICAgdGhpcy5zdWJzb2x2ZXIgPSBzdWJzb2x2ZXI7XG4gICAgdGhpcy5ub2RlcyA9IFtdO1xuICAgIHRoaXMubm9kZVBvb2wgPSBbXTtcblxuICAgIC8vIENyZWF0ZSBuZWVkZWQgbm9kZXMsIHJldXNlIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUodGhpcy5ub2RlUG9vbC5sZW5ndGggPCAxMjgpe1xuICAgICAgICB0aGlzLm5vZGVQb29sLnB1c2godGhpcy5jcmVhdGVOb2RlKCkpO1xuICAgIH1cbn1cblNwbGl0U29sdmVyLnByb3RvdHlwZSA9IG5ldyBTb2x2ZXIoKTtcblxuLy8gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHN1YnN5c3RlbXNcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9ub2RlcyA9IFtdOyAvLyBBbGwgYWxsb2NhdGVkIG5vZGUgb2JqZWN0c1xudmFyIFNwbGl0U29sdmVyX3NvbHZlX25vZGVQb29sID0gW107IC8vIEFsbCBhbGxvY2F0ZWQgbm9kZSBvYmplY3RzXG52YXIgU3BsaXRTb2x2ZXJfc29sdmVfZXFzID0gW107ICAgLy8gVGVtcCBhcnJheVxudmFyIFNwbGl0U29sdmVyX3NvbHZlX2JkcyA9IFtdOyAgIC8vIFRlbXAgYXJyYXlcbnZhciBTcGxpdFNvbHZlcl9zb2x2ZV9kdW1teVdvcmxkID0ge2JvZGllczpbXX07IC8vIFRlbXAgb2JqZWN0XG5cbnZhciBTVEFUSUMgPSBCb2R5LlNUQVRJQztcbmZ1bmN0aW9uIGdldFVudmlzaXRlZE5vZGUobm9kZXMpe1xuICAgIHZhciBObm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1Obm9kZXM7IGkrKyl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmKCFub2RlLnZpc2l0ZWQgJiYgIShub2RlLmJvZHkudHlwZSAmIFNUQVRJQykpe1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgcXVldWUgPSBbXTtcbmZ1bmN0aW9uIGJmcyhyb290LHZpc2l0RnVuYyxiZHMsZXFzKXtcbiAgICBxdWV1ZS5wdXNoKHJvb3QpO1xuICAgIHJvb3QudmlzaXRlZCA9IHRydWU7XG4gICAgdmlzaXRGdW5jKHJvb3QsYmRzLGVxcyk7XG4gICAgd2hpbGUocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gcXVldWUucG9wKCk7XG4gICAgICAgIC8vIExvb3Agb3ZlciB1bnZpc2l0ZWQgY2hpbGQgbm9kZXNcbiAgICAgICAgdmFyIGNoaWxkO1xuICAgICAgICB3aGlsZSgoY2hpbGQgPSBnZXRVbnZpc2l0ZWROb2RlKG5vZGUuY2hpbGRyZW4pKSkge1xuICAgICAgICAgICAgY2hpbGQudmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgICB2aXNpdEZ1bmMoY2hpbGQsYmRzLGVxcyk7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gdmlzaXRGdW5jKG5vZGUsYmRzLGVxcyl7XG4gICAgYmRzLnB1c2gobm9kZS5ib2R5KTtcbiAgICB2YXIgTmVxcyA9IG5vZGUuZXFzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XG4gICAgICAgIHZhciBlcSA9IG5vZGUuZXFzW2ldO1xuICAgICAgICBpZihlcXMuaW5kZXhPZihlcSkgPT09IC0xKXtcbiAgICAgICAgICAgIGVxcy5wdXNoKGVxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuU3BsaXRTb2x2ZXIucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB7IGJvZHk6bnVsbCwgY2hpbGRyZW46W10sIGVxczpbXSwgdmlzaXRlZDpmYWxzZSB9O1xufTtcblxuLyoqXG4gKiBTb2x2ZSB0aGUgc3Vic3lzdGVtc1xuICogQG1ldGhvZCBzb2x2ZVxuICogQHBhcmFtICB7TnVtYmVyfSBkdFxuICogQHBhcmFtICB7V29ybGR9IHdvcmxkXG4gKi9cblNwbGl0U29sdmVyLnByb3RvdHlwZS5zb2x2ZSA9IGZ1bmN0aW9uKGR0LHdvcmxkKXtcbiAgICB2YXIgbm9kZXM9U3BsaXRTb2x2ZXJfc29sdmVfbm9kZXMsXG4gICAgICAgIG5vZGVQb29sPXRoaXMubm9kZVBvb2wsXG4gICAgICAgIGJvZGllcz13b3JsZC5ib2RpZXMsXG4gICAgICAgIGVxdWF0aW9ucz10aGlzLmVxdWF0aW9ucyxcbiAgICAgICAgTmVxPWVxdWF0aW9ucy5sZW5ndGgsXG4gICAgICAgIE5ib2RpZXM9Ym9kaWVzLmxlbmd0aCxcbiAgICAgICAgc3Vic29sdmVyPXRoaXMuc3Vic29sdmVyO1xuXG4gICAgLy8gQ3JlYXRlIG5lZWRlZCBub2RlcywgcmV1c2UgaWYgcG9zc2libGVcbiAgICB3aGlsZShub2RlUG9vbC5sZW5ndGggPCBOYm9kaWVzKXtcbiAgICAgICAgbm9kZVBvb2wucHVzaCh0aGlzLmNyZWF0ZU5vZGUoKSk7XG4gICAgfVxuICAgIG5vZGVzLmxlbmd0aCA9IE5ib2RpZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOYm9kaWVzOyBpKyspIHtcbiAgICAgICAgbm9kZXNbaV0gPSBub2RlUG9vbFtpXTtcbiAgICB9XG5cbiAgICAvLyBSZXNldCBub2RlIHZhbHVlc1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmJvZGllczsgaSsrKXtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgbm9kZS5ib2R5ID0gYm9kaWVzW2ldO1xuICAgICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgIG5vZGUuZXFzLmxlbmd0aCA9IDA7XG4gICAgICAgIG5vZGUudmlzaXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBmb3IodmFyIGs9MDsgayE9PU5lcTsgaysrKXtcbiAgICAgICAgdmFyIGVxPWVxdWF0aW9uc1trXSxcbiAgICAgICAgICAgIGk9Ym9kaWVzLmluZGV4T2YoZXEuYmkpLFxuICAgICAgICAgICAgaj1ib2RpZXMuaW5kZXhPZihlcS5iaiksXG4gICAgICAgICAgICBuaT1ub2Rlc1tpXSxcbiAgICAgICAgICAgIG5qPW5vZGVzW2pdO1xuICAgICAgICBuaS5jaGlsZHJlbi5wdXNoKG5qKTtcbiAgICAgICAgbmkuZXFzLnB1c2goZXEpO1xuICAgICAgICBuai5jaGlsZHJlbi5wdXNoKG5pKTtcbiAgICAgICAgbmouZXFzLnB1c2goZXEpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCwgbj0wLCBlcXM9U3BsaXRTb2x2ZXJfc29sdmVfZXFzO1xuXG4gICAgc3Vic29sdmVyLnRvbGVyYW5jZSA9IHRoaXMudG9sZXJhbmNlO1xuICAgIHN1YnNvbHZlci5pdGVyYXRpb25zID0gdGhpcy5pdGVyYXRpb25zO1xuXG4gICAgdmFyIGR1bW15V29ybGQgPSBTcGxpdFNvbHZlcl9zb2x2ZV9kdW1teVdvcmxkO1xuICAgIHdoaWxlKChjaGlsZCA9IGdldFVudmlzaXRlZE5vZGUobm9kZXMpKSl7XG4gICAgICAgIGVxcy5sZW5ndGggPSAwO1xuICAgICAgICBkdW1teVdvcmxkLmJvZGllcy5sZW5ndGggPSAwO1xuICAgICAgICBiZnMoY2hpbGQsIHZpc2l0RnVuYywgZHVtbXlXb3JsZC5ib2RpZXMsIGVxcyk7XG5cbiAgICAgICAgdmFyIE5lcXMgPSBlcXMubGVuZ3RoO1xuXG4gICAgICAgIGVxcyA9IGVxcy5zb3J0KHNvcnRCeUlkKTtcblxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PU5lcXM7IGkrKyl7XG4gICAgICAgICAgICBzdWJzb2x2ZXIuYWRkRXF1YXRpb24oZXFzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyID0gc3Vic29sdmVyLnNvbHZlKGR0LGR1bW15V29ybGQpO1xuICAgICAgICBzdWJzb2x2ZXIucmVtb3ZlQWxsRXF1YXRpb25zKCk7XG4gICAgICAgIG4rKztcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn07XG5cbmZ1bmN0aW9uIHNvcnRCeUlkKGEsIGIpe1xuICAgIHJldHVybiBiLmlkIC0gYS5pZDtcbn1cbn0se1wiLi4vbWF0aC9RdWF0ZXJuaW9uXCI6MjgsXCIuLi9tYXRoL1ZlYzNcIjozMCxcIi4uL29iamVjdHMvQm9keVwiOjMxLFwiLi9Tb2x2ZXJcIjo0N31dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3Igb2JqZWN0cyB0aGF0IGRpc3BhdGNoZXMgZXZlbnRzLlxuICogQGNsYXNzIEV2ZW50VGFyZ2V0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50VGFyZ2V0O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IEV2ZW50VGFyZ2V0LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCBhZGRFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHRoaXMuX2xpc3RlbmVycyA9IHt9OyB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzWyB0eXBlIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1sgdHlwZSBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBldmVudCBsaXN0ZW5lciBpcyBhZGRlZFxuICAgICAqIEBtZXRob2QgaGFzRXZlbnRMaXN0ZW5lclxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBsaXN0ZW5lclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcbiAgICAgICAgaWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgaWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSAhPT0gdW5kZWZpbmVkICYmIGxpc3RlbmVyc1sgdHlwZSBdLmluZGV4T2YoIGxpc3RlbmVyICkgIT09IC0gMSApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyXG4gICAgICogQG1ldGhvZCByZW1vdmVFdmVudExpc3RlbmVyXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSB0eXBlXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAgICogQHJldHVybiB7RXZlbnRUYXJnZXR9IFRoZSBzZWxmIG9iamVjdCwgZm9yIGNoYWluYWJpbGl0eS5cbiAgICAgKi9cbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoIHR5cGUsIGxpc3RlbmVyICkge1xuICAgICAgICBpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICl7IHJldHVybiB0aGlzOyB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGlmICggbGlzdGVuZXJzW3R5cGVdID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKTtcbiAgICAgICAgaWYgKCBpbmRleCAhPT0gLSAxICkge1xuICAgICAgICAgICAgbGlzdGVuZXJzWyB0eXBlIF0uc3BsaWNlKCBpbmRleCwgMSApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbWl0IGFuIGV2ZW50LlxuICAgICAqIEBtZXRob2QgZGlzcGF0Y2hFdmVudFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gZXZlbnRcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGV2ZW50LnR5cGVcbiAgICAgKiBAcmV0dXJuIHtFdmVudFRhcmdldH0gVGhlIHNlbGYgb2JqZWN0LCBmb3IgY2hhaW5hYmlsaXR5LlxuICAgICAqL1xuICAgIGRpc3BhdGNoRXZlbnQ6IGZ1bmN0aW9uICggZXZlbnQgKSB7XG4gICAgICAgIGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKXsgcmV0dXJuIHRoaXM7IH1cbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcbiAgICAgICAgaWYgKCBsaXN0ZW5lckFycmF5ICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsID0gbGlzdGVuZXJBcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyQXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn07XG5cbn0se31dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBBQUJCID0gX2RlcmVxXygnLi4vY29sbGlzaW9uL0FBQkInKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2N0cmVlO1xuXG4vKipcbiAqIEBjbGFzcyBPY3RyZWVOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge09jdHJlZX0gW29wdGlvbnMucm9vdF1cbiAqIEBwYXJhbSB7QUFCQn0gW29wdGlvbnMuYWFiYl1cbiAqL1xuZnVuY3Rpb24gT2N0cmVlTm9kZShvcHRpb25zKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByb290IG5vZGVcbiAgICAgKiBAcHJvcGVydHkge09jdHJlZU5vZGV9IHJvb3RcbiAgICAgKi9cbiAgICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEJvdW5kYXJ5IG9mIHRoaXMgbm9kZVxuICAgICAqIEBwcm9wZXJ0eSB7QUFCQn0gYWFiYlxuICAgICAqL1xuICAgIHRoaXMuYWFiYiA9IG9wdGlvbnMuYWFiYiA/IG9wdGlvbnMuYWFiYi5jbG9uZSgpIDogbmV3IEFBQkIoKTtcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5lZCBkYXRhIGF0IHRoZSBjdXJyZW50IG5vZGUgbGV2ZWwuXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gZGF0YVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gdG8gdGhpcyBub2RlXG4gICAgICogQHByb3BlcnR5IHtBcnJheX0gY2hpbGRyZW5cbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG59XG5cbi8qKlxuICogQGNsYXNzIE9jdHJlZVxuICogQHBhcmFtIHtBQUJCfSBhYWJiIFRoZSB0b3RhbCBBQUJCIG9mIHRoZSB0cmVlXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4RGVwdGg9OF1cbiAqIEBleHRlbmRzIE9jdHJlZU5vZGVcbiAqL1xuZnVuY3Rpb24gT2N0cmVlKGFhYmIsIG9wdGlvbnMpe1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnMucm9vdCA9IG51bGw7XG4gICAgb3B0aW9ucy5hYWJiID0gYWFiYjtcbiAgICBPY3RyZWVOb2RlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAvKipcbiAgICAgKiBNYXhpbXVtIHN1YmRpdmlzaW9uIGRlcHRoXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IG1heERlcHRoXG4gICAgICovXG4gICAgdGhpcy5tYXhEZXB0aCA9IHR5cGVvZihvcHRpb25zLm1heERlcHRoKSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLm1heERlcHRoIDogODtcbn1cbk9jdHJlZS5wcm90b3R5cGUgPSBuZXcgT2N0cmVlTm9kZSgpO1xuXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKGFhYmIsIG9wdGlvbnMpe1xuICAgIHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIEluc2VydCBkYXRhIGludG8gdGhpcyBub2RlXG4gKiBAbWV0aG9kIGluc2VydFxuICogQHBhcmFtICB7QUFCQn0gYWFiYlxuICogQHBhcmFtICB7b2JqZWN0fSBlbGVtZW50RGF0YVxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBzdWNjZXNzZnVsLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24oYWFiYiwgZWxlbWVudERhdGEsIGxldmVsKXtcbiAgICB2YXIgbm9kZURhdGEgPSB0aGlzLmRhdGE7XG4gICAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuXG4gICAgLy8gSWdub3JlIG9iamVjdHMgdGhhdCBkbyBub3QgYmVsb25nIGluIHRoaXMgbm9kZVxuICAgIGlmICghdGhpcy5hYWJiLmNvbnRhaW5zKGFhYmIpKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBvYmplY3QgY2Fubm90IGJlIGFkZGVkXG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcblxuICAgIGlmKGxldmVsIDwgKHRoaXMubWF4RGVwdGggfHwgdGhpcy5yb290Lm1heERlcHRoKSl7XG4gICAgICAgIC8vIFN1YmRpdmlkZSBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4geWV0XG4gICAgICAgIHZhciBzdWJkaXZpZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKXtcbiAgICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKCk7XG4gICAgICAgICAgICBzdWJkaXZpZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCB0byB3aGljaGV2ZXIgbm9kZSB3aWxsIGFjY2VwdCBpdFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSAhPT0gODsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uaW5zZXJ0KGFhYmIsIGVsZW1lbnREYXRhLCBsZXZlbCArIDEpKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHN1YmRpdmlkZWQpe1xuICAgICAgICAgICAgLy8gTm8gY2hpbGRyZW4gYWNjZXB0ZWQhIE1pZ2h0IGFzIHdlbGwganVzdCByZW1vdmUgZW0gc2luY2UgdGhleSBjb250YWluIG5vbmVcbiAgICAgICAgICAgIGNoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUb28gZGVlcCwgb3IgY2hpbGRyZW4gZGlkbnQgd2FudCBpdC4gYWRkIGl0IGluIGN1cnJlbnQgbm9kZVxuICAgIG5vZGVEYXRhLnB1c2goZWxlbWVudERhdGEpO1xuXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaGFsZkRpYWdvbmFsID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBDcmVhdGUgOCBlcXVhbGx5IHNpemVkIGNoaWxkcmVuIG5vZGVzIGFuZCBwdXQgdGhlbSBpbiB0aGUgLmNoaWxkcmVuIGFycmF5LlxuICogQG1ldGhvZCBzdWJkaXZpZGVcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUuc3ViZGl2aWRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFhYmIgPSB0aGlzLmFhYmI7XG4gICAgdmFyIGwgPSBhYWJiLmxvd2VyQm91bmQ7XG4gICAgdmFyIHUgPSBhYWJiLnVwcGVyQm91bmQ7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG4gICAgY2hpbGRyZW4ucHVzaChcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMCwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMCwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMSwwKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMSwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMSwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMCwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDEsMCwxKSB9KSB9KSxcbiAgICAgICAgbmV3IE9jdHJlZU5vZGUoeyBhYWJiOiBuZXcgQUFCQih7IGxvd2VyQm91bmQ6IG5ldyBWZWMzKDAsMSwwKSB9KSB9KVxuICAgICk7XG5cbiAgICB1LnZzdWIobCwgaGFsZkRpYWdvbmFsKTtcbiAgICBoYWxmRGlhZ29uYWwuc2NhbGUoMC41LCBoYWxmRGlhZ29uYWwpO1xuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3QgfHwgdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA4OyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgLy8gU2V0IGN1cnJlbnQgbm9kZSBhcyByb290XG4gICAgICAgIGNoaWxkLnJvb3QgPSByb290O1xuXG4gICAgICAgIC8vIENvbXB1dGUgYm91bmRzXG4gICAgICAgIHZhciBsb3dlckJvdW5kID0gY2hpbGQuYWFiYi5sb3dlckJvdW5kO1xuICAgICAgICBsb3dlckJvdW5kLnggKj0gaGFsZkRpYWdvbmFsLng7XG4gICAgICAgIGxvd2VyQm91bmQueSAqPSBoYWxmRGlhZ29uYWwueTtcbiAgICAgICAgbG93ZXJCb3VuZC56ICo9IGhhbGZEaWFnb25hbC56O1xuXG4gICAgICAgIGxvd2VyQm91bmQudmFkZChsLCBsb3dlckJvdW5kKTtcblxuICAgICAgICAvLyBVcHBlciBib3VuZCBpcyBhbHdheXMgbG93ZXIgYm91bmQgKyBoYWxmRGlhZ29uYWxcbiAgICAgICAgbG93ZXJCb3VuZC52YWRkKGhhbGZEaWFnb25hbCwgY2hpbGQuYWFiYi51cHBlckJvdW5kKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEdldCBhbGwgZGF0YSwgcG90ZW50aWFsbHkgd2l0aGluIGFuIEFBQkJcbiAqIEBtZXRob2QgYWFiYlF1ZXJ5XG4gKiBAcGFyYW0gIHtBQUJCfSBhYWJiXG4gKiBAcGFyYW0gIHthcnJheX0gcmVzdWx0XG4gKiBAcmV0dXJuIHthcnJheX0gVGhlIFwicmVzdWx0XCIgb2JqZWN0XG4gKi9cbk9jdHJlZU5vZGUucHJvdG90eXBlLmFhYmJRdWVyeSA9IGZ1bmN0aW9uKGFhYmIsIHJlc3VsdCkge1xuXG4gICAgdmFyIG5vZGVEYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgLy8gYWJvcnQgaWYgdGhlIHJhbmdlIGRvZXMgbm90IGludGVyc2VjdCB0aGlzIG5vZGVcbiAgICAvLyBpZiAoIXRoaXMuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgLy8gICAgIHJldHVybiByZXN1bHQ7XG4gICAgLy8gfVxuXG4gICAgLy8gQWRkIG9iamVjdHMgYXQgdGhpcyBsZXZlbFxuICAgIC8vIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZURhdGEpO1xuXG4gICAgLy8gQWRkIGNoaWxkIGRhdGFcbiAgICAvLyBAdG9kbyB1bndyYXAgcmVjdXJzaW9uIGludG8gYSBxdWV1ZSAvIGxvb3AsIHRoYXQncyBmYXN0ZXIgaW4gSlNcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuXG5cbiAgICAvLyBmb3IgKHZhciBpID0gMCwgTiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpICE9PSBOOyBpKyspIHtcbiAgICAvLyAgICAgY2hpbGRyZW5baV0uYWFiYlF1ZXJ5KGFhYmIsIHJlc3VsdCk7XG4gICAgLy8gfVxuXG4gICAgdmFyIHF1ZXVlID0gW3RoaXNdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgaWYgKG5vZGUuYWFiYi5vdmVybGFwcyhhYWJiKSl7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkocXVldWUsIG5vZGUuY2hpbGRyZW4pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgdG1wQUFCQiA9IG5ldyBBQUJCKCk7XG5cbi8qKlxuICogR2V0IGFsbCBkYXRhLCBwb3RlbnRpYWxseSBpbnRlcnNlY3RlZCBieSBhIHJheS5cbiAqIEBtZXRob2QgcmF5UXVlcnlcbiAqIEBwYXJhbSAge1JheX0gcmF5XG4gKiBAcGFyYW0gIHtUcmFuc2Zvcm19IHRyZWVUcmFuc2Zvcm1cbiAqIEBwYXJhbSAge2FycmF5fSByZXN1bHRcbiAqIEByZXR1cm4ge2FycmF5fSBUaGUgXCJyZXN1bHRcIiBvYmplY3RcbiAqL1xuT2N0cmVlTm9kZS5wcm90b3R5cGUucmF5UXVlcnkgPSBmdW5jdGlvbihyYXksIHRyZWVUcmFuc2Zvcm0sIHJlc3VsdCkge1xuXG4gICAgLy8gVXNlIGFhYmIgcXVlcnkgZm9yIG5vdy5cbiAgICAvLyBAdG9kbyBpbXBsZW1lbnQgcmVhbCByYXkgcXVlcnkgd2hpY2ggbmVlZHMgbGVzcyBsb29rdXBzXG4gICAgcmF5LmdldEFBQkIodG1wQUFCQik7XG4gICAgdG1wQUFCQi50b0xvY2FsRnJhbWUodHJlZVRyYW5zZm9ybSwgdG1wQUFCQik7XG4gICAgdGhpcy5hYWJiUXVlcnkodG1wQUFCQiwgcmVzdWx0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgcmVtb3ZlRW1wdHlOb2Rlc1xuICovXG5PY3RyZWVOb2RlLnByb3RvdHlwZS5yZW1vdmVFbXB0eU5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHF1ZXVlID0gW3RoaXNdO1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmKCFub2RlLmNoaWxkcmVuW2ldLmRhdGEubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShxdWV1ZSwgbm9kZS5jaGlsZHJlbik7XG4gICAgfVxufTtcblxufSx7XCIuLi9jb2xsaXNpb24vQUFCQlwiOjMsXCIuLi9tYXRoL1ZlYzNcIjozMH1dLDUxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gUG9vbDtcblxuLyoqXG4gKiBGb3IgcG9vbGluZyBvYmplY3RzIHRoYXQgY2FuIGJlIHJldXNlZC5cbiAqIEBjbGFzcyBQb29sXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUG9vbCgpe1xuICAgIC8qKlxuICAgICAqIFRoZSBwb29sZWQgb2JqZWN0c1xuICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IG9iamVjdHNcbiAgICAgKi9cbiAgICB0aGlzLm9iamVjdHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yIG9mIHRoZSBvYmplY3RzXG4gICAgICogQHByb3BlcnR5IHttaXhlZH0gdHlwZVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IE9iamVjdDtcbn1cblxuLyoqXG4gKiBSZWxlYXNlIGFuIG9iamVjdCBhZnRlciB1c2VcbiAqIEBtZXRob2QgcmVsZWFzZVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICovXG5Qb29sLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgTmFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvcih2YXIgaT0wOyBpIT09TmFyZ3M7IGkrKyl7XG4gICAgICAgIHRoaXMub2JqZWN0cy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0XG4gKiBAbWV0aG9kIGdldFxuICogQHJldHVybiB7bWl4ZWR9XG4gKi9cblBvb2wucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5vYmplY3RzLmxlbmd0aD09PTApe1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3RPYmplY3QoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3RzLnBvcCgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ29uc3RydWN0IGFuIG9iamVjdC4gU2hvdWxkIGJlIGltcGxtZW50ZWQgaW4gZWFjaCBzdWJjbGFzcy5cbiAqIEBtZXRob2QgY29uc3RydWN0T2JqZWN0XG4gKiBAcmV0dXJuIHttaXhlZH1cbiAqL1xuUG9vbC5wcm90b3R5cGUuY29uc3RydWN0T2JqZWN0ID0gZnVuY3Rpb24oKXtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb25zdHJ1Y3RPYmplY3QoKSBub3QgaW1wbGVtZW50ZWQgaW4gdGhpcyBQb29sIHN1YmNsYXNzIHlldCFcIik7XG59O1xuXG59LHt9XSw1MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IFR1cGxlRGljdGlvbmFyeTtcblxuLyoqXG4gKiBAY2xhc3MgVHVwbGVEaWN0aW9uYXJ5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gVHVwbGVEaWN0aW9uYXJ5KCkge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgc3RvcmFnZVxuICAgICAqIEBwcm9wZXJ0eSBkYXRhXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSB7IGtleXM6W10gfTtcbn1cblxuLyoqXG4gKiBAbWV0aG9kIGdldFxuICogQHBhcmFtICB7TnVtYmVyfSBpXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuVHVwbGVEaWN0aW9uYXJ5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihpLCBqKSB7XG4gICAgaWYgKGkgPiBqKSB7XG4gICAgICAgIC8vIHN3YXBcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGFbaSsnLScral07XG59O1xuXG4vKipcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGlcbiAqIEBwYXJhbSAge051bWJlcn0galxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gKi9cblR1cGxlRGljdGlvbmFyeS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oaSwgaiwgdmFsdWUpIHtcbiAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgdmFyIHRlbXAgPSBqO1xuICAgICAgICBqID0gaTtcbiAgICAgICAgaSA9IHRlbXA7XG4gICAgfVxuICAgIHZhciBrZXkgPSBpKyctJytqO1xuXG4gICAgLy8gQ2hlY2sgaWYga2V5IGFscmVhZHkgZXhpc3RzXG4gICAgaWYoIXRoaXMuZ2V0KGksaikpe1xuICAgICAgICB0aGlzLmRhdGEua2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCByZXNldFxuICovXG5UdXBsZURpY3Rpb25hcnkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIGtleXMgPSBkYXRhLmtleXM7XG4gICAgd2hpbGUoa2V5cy5sZW5ndGggPiAwKXtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGRlbGV0ZSBkYXRhW2tleV07XG4gICAgfVxufTtcblxufSx7fV0sNTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZnVuY3Rpb24gVXRpbHMoKXt9XG5cbm1vZHVsZS5leHBvcnRzID0gVXRpbHM7XG5cbi8qKlxuICogRXh0ZW5kIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBAc3RhdGljXG4gKiBAbWV0aG9kIGRlZmF1bHRzXG4gKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgb2JqZWN0LiBNYXkgYmUgZmFsc3k6IGluIHRoaXMgY2FzZSwgYSBuZXcgb2JqZWN0IGlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICogQHBhcmFtICB7b2JqZWN0fSBkZWZhdWx0cyBBbiBvYmplY3QgY29udGFpbmluZyBkZWZhdWx0IHZhbHVlcy5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIG1vZGlmaWVkIG9wdGlvbnMgb2JqZWN0LlxuICovXG5VdGlscy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGRlZmF1bHRzKXtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGZvcih2YXIga2V5IGluIGRlZmF1bHRzKXtcbiAgICAgICAgaWYoIShrZXkgaW4gb3B0aW9ucykpe1xuICAgICAgICAgICAgb3B0aW9uc1trZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBWZWMzUG9vbDtcblxudmFyIFZlYzMgPSBfZGVyZXFfKCcuLi9tYXRoL1ZlYzMnKTtcbnZhciBQb29sID0gX2RlcmVxXygnLi9Qb29sJyk7XG5cbi8qKlxuICogQGNsYXNzIFZlYzNQb29sXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIFBvb2xcbiAqL1xuZnVuY3Rpb24gVmVjM1Bvb2woKXtcbiAgICBQb29sLmNhbGwodGhpcyk7XG4gICAgdGhpcy50eXBlID0gVmVjMztcbn1cblZlYzNQb29sLnByb3RvdHlwZSA9IG5ldyBQb29sKCk7XG5cbi8qKlxuICogQ29uc3RydWN0IGEgdmVjdG9yXG4gKiBAbWV0aG9kIGNvbnN0cnVjdE9iamVjdFxuICogQHJldHVybiB7VmVjM31cbiAqL1xuVmVjM1Bvb2wucHJvdG90eXBlLmNvbnN0cnVjdE9iamVjdCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG5ldyBWZWMzKCk7XG59O1xuXG59LHtcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi9Qb29sXCI6NTF9XSw1NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IE5hcnJvd3BoYXNlO1xuXG52YXIgQUFCQiA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9BQUJCJyk7XG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBSYXkgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Jyk7XG52YXIgVmVjMyA9IF9kZXJlcV8oJy4uL21hdGgvVmVjMycpO1xudmFyIFRyYW5zZm9ybSA9IF9kZXJlcV8oJy4uL21hdGgvVHJhbnNmb3JtJyk7XG52YXIgQ29udmV4UG9seWhlZHJvbiA9IF9kZXJlcV8oJy4uL3NoYXBlcy9Db252ZXhQb2x5aGVkcm9uJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIFNvbHZlciA9IF9kZXJlcV8oJy4uL3NvbHZlci9Tb2x2ZXInKTtcbnZhciBWZWMzUG9vbCA9IF9kZXJlcV8oJy4uL3V0aWxzL1ZlYzNQb29sJyk7XG52YXIgQ29udGFjdEVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvbicpO1xudmFyIEZyaWN0aW9uRXF1YXRpb24gPSBfZGVyZXFfKCcuLi9lcXVhdGlvbnMvRnJpY3Rpb25FcXVhdGlvbicpO1xuXG4vKipcbiAqIEhlbHBlciBjbGFzcyBmb3IgdGhlIFdvcmxkLiBHZW5lcmF0ZXMgQ29udGFjdEVxdWF0aW9ucy5cbiAqIEBjbGFzcyBOYXJyb3dwaGFzZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAdG9kbyBTcGhlcmUtQ29udmV4UG9seWhlZHJvbiBjb250YWN0c1xuICogQHRvZG8gQ29udGFjdCByZWR1Y3Rpb25cbiAqIEB0b2RvICBzaG91bGQgbW92ZSBtZXRob2RzIHRvIHByb3RvdHlwZVxuICovXG5mdW5jdGlvbiBOYXJyb3dwaGFzZSh3b3JsZCl7XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBzdG9yYWdlIG9mIHBvb2xlZCBjb250YWN0IHBvaW50cy5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5fSBjb250YWN0UG9pbnRQb29sXG4gICAgICovXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gW107XG5cbiAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25Qb29sID0gW107XG5cbiAgICB0aGlzLnJlc3VsdCA9IFtdO1xuICAgIHRoaXMuZnJpY3Rpb25SZXN1bHQgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFBvb2xlZCB2ZWN0b3JzLlxuICAgICAqIEBwcm9wZXJ0eSB7VmVjM1Bvb2x9IHYzcG9vbFxuICAgICAqL1xuICAgIHRoaXMudjNwb29sID0gbmV3IFZlYzNQb29sKCk7XG5cbiAgICB0aGlzLndvcmxkID0gd29ybGQ7XG4gICAgdGhpcy5jdXJyZW50Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uID0gZmFsc2U7XG59XG5cbi8qKlxuICogTWFrZSBhIGNvbnRhY3Qgb2JqZWN0LCBieSB1c2luZyB0aGUgaW50ZXJuYWwgcG9vbCBvciBjcmVhdGluZyBhIG5ldyBvbmUuXG4gKiBAbWV0aG9kIGNyZWF0ZUNvbnRhY3RFcXVhdGlvblxuICogQHJldHVybiB7Q29udGFjdEVxdWF0aW9ufVxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlQ29udGFjdEVxdWF0aW9uID0gZnVuY3Rpb24oYmksIGJqLCBzaSwgc2osIHJzaSwgcnNqKXtcbiAgICB2YXIgYztcbiAgICBpZih0aGlzLmNvbnRhY3RQb2ludFBvb2wubGVuZ3RoKXtcbiAgICAgICAgYyA9IHRoaXMuY29udGFjdFBvaW50UG9vbC5wb3AoKTtcbiAgICAgICAgYy5iaSA9IGJpO1xuICAgICAgICBjLmJqID0gYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYyA9IG5ldyBDb250YWN0RXF1YXRpb24oYmksIGJqKTtcbiAgICB9XG5cbiAgICBjLmVuYWJsZWQgPSBiaS5jb2xsaXNpb25SZXNwb25zZSAmJiBiai5jb2xsaXNpb25SZXNwb25zZSAmJiBzaS5jb2xsaXNpb25SZXNwb25zZSAmJiBzai5jb2xsaXNpb25SZXNwb25zZTtcblxuICAgIHZhciBjbSA9IHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbDtcblxuICAgIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcblxuICAgIGMuc2V0U3Bvb2tQYXJhbXMoXG4gICAgICAgIGNtLmNvbnRhY3RFcXVhdGlvblN0aWZmbmVzcyxcbiAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgICAgICAgdGhpcy53b3JsZC5kdFxuICAgICk7XG5cbiAgICB2YXIgbWF0QSA9IHNpLm1hdGVyaWFsIHx8IGJpLm1hdGVyaWFsO1xuICAgIHZhciBtYXRCID0gc2oubWF0ZXJpYWwgfHwgYmoubWF0ZXJpYWw7XG4gICAgaWYobWF0QSAmJiBtYXRCICYmIG1hdEEucmVzdGl0dXRpb24gPj0gMCAmJiBtYXRCLnJlc3RpdHV0aW9uID49IDApe1xuICAgICAgICBjLnJlc3RpdHV0aW9uID0gbWF0QS5yZXN0aXR1dGlvbiAqIG1hdEIucmVzdGl0dXRpb247XG4gICAgfVxuXG4gICAgYy5zaSA9IHJzaSB8fCBzaTtcbiAgICBjLnNqID0gcnNqIHx8IHNqO1xuXG4gICAgcmV0dXJuIGM7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdCA9IGZ1bmN0aW9uKGNvbnRhY3RFcXVhdGlvbiwgb3V0QXJyYXkpe1xuICAgIHZhciBib2R5QSA9IGNvbnRhY3RFcXVhdGlvbi5iaTtcbiAgICB2YXIgYm9keUIgPSBjb250YWN0RXF1YXRpb24uYmo7XG4gICAgdmFyIHNoYXBlQSA9IGNvbnRhY3RFcXVhdGlvbi5zaTtcbiAgICB2YXIgc2hhcGVCID0gY29udGFjdEVxdWF0aW9uLnNqO1xuXG4gICAgdmFyIHdvcmxkID0gdGhpcy53b3JsZDtcbiAgICB2YXIgY20gPSB0aGlzLmN1cnJlbnRDb250YWN0TWF0ZXJpYWw7XG5cbiAgICAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtXG4gICAgdmFyIGZyaWN0aW9uID0gY20uZnJpY3Rpb247XG4gICAgdmFyIG1hdEEgPSBzaGFwZUEubWF0ZXJpYWwgfHwgYm9keUEubWF0ZXJpYWw7XG4gICAgdmFyIG1hdEIgPSBzaGFwZUIubWF0ZXJpYWwgfHwgYm9keUIubWF0ZXJpYWw7XG4gICAgaWYobWF0QSAmJiBtYXRCICYmIG1hdEEuZnJpY3Rpb24gPj0gMCAmJiBtYXRCLmZyaWN0aW9uID49IDApe1xuICAgICAgICBmcmljdGlvbiA9IG1hdEEuZnJpY3Rpb24gKiBtYXRCLmZyaWN0aW9uO1xuICAgIH1cblxuICAgIGlmKGZyaWN0aW9uID4gMCl7XG5cbiAgICAgICAgLy8gQ3JlYXRlIDIgdGFuZ2VudCBlcXVhdGlvbnNcbiAgICAgICAgdmFyIG11ZyA9IGZyaWN0aW9uICogd29ybGQuZ3Jhdml0eS5sZW5ndGgoKTtcbiAgICAgICAgdmFyIHJlZHVjZWRNYXNzID0gKGJvZHlBLmludk1hc3MgKyBib2R5Qi5pbnZNYXNzKTtcbiAgICAgICAgaWYocmVkdWNlZE1hc3MgPiAwKXtcbiAgICAgICAgICAgIHJlZHVjZWRNYXNzID0gMS9yZWR1Y2VkTWFzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9vbCA9IHRoaXMuZnJpY3Rpb25FcXVhdGlvblBvb2w7XG4gICAgICAgIHZhciBjMSA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCLG11ZypyZWR1Y2VkTWFzcyk7XG4gICAgICAgIHZhciBjMiA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJvZHlBLGJvZHlCLG11ZypyZWR1Y2VkTWFzcyk7XG5cbiAgICAgICAgYzEuYmkgPSBjMi5iaSA9IGJvZHlBO1xuICAgICAgICBjMS5iaiA9IGMyLmJqID0gYm9keUI7XG4gICAgICAgIGMxLm1pbkZvcmNlID0gYzIubWluRm9yY2UgPSAtbXVnKnJlZHVjZWRNYXNzO1xuICAgICAgICBjMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzO1xuXG4gICAgICAgIC8vIENvcHkgb3ZlciB0aGUgcmVsYXRpdmUgdmVjdG9yc1xuICAgICAgICBjMS5yaS5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaSk7XG4gICAgICAgIGMxLnJqLmNvcHkoY29udGFjdEVxdWF0aW9uLnJqKTtcbiAgICAgICAgYzIucmkuY29weShjb250YWN0RXF1YXRpb24ucmkpO1xuICAgICAgICBjMi5yai5jb3B5KGNvbnRhY3RFcXVhdGlvbi5yaik7XG5cbiAgICAgICAgLy8gQ29uc3RydWN0IHRhbmdlbnRzXG4gICAgICAgIGNvbnRhY3RFcXVhdGlvbi5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcblxuICAgICAgICAvLyBTZXQgc3Bvb2sgcGFyYW1zXG4gICAgICAgIGMxLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG4gICAgICAgIGMyLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCB3b3JsZC5kdCk7XG5cbiAgICAgICAgYzEuZW5hYmxlZCA9IGMyLmVuYWJsZWQgPSBjb250YWN0RXF1YXRpb24uZW5hYmxlZDtcblxuICAgICAgICBvdXRBcnJheS5wdXNoKGMxLCBjMik7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxudmFyIGF2ZXJhZ2VOb3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIGF2ZXJhZ2VDb250YWN0UG9pbnRBID0gbmV3IFZlYzMoKTtcbnZhciBhdmVyYWdlQ29udGFjdFBvaW50QiA9IG5ldyBWZWMzKCk7XG5cbi8vIFRha2UgdGhlIGF2ZXJhZ2UgTiBsYXRlc3QgY29udGFjdCBwb2ludCBvbiB0aGUgcGxhbmUuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZSA9IGZ1bmN0aW9uKG51bUNvbnRhY3RzKXtcbiAgICAvLyBUaGUgbGFzdCBjb250YWN0RXF1YXRpb25cbiAgICB2YXIgYyA9IHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDFdO1xuXG4gICAgLy8gQ3JlYXRlIHRoZSByZXN1bHQ6IHR3byBcImF2ZXJhZ2VcIiBmcmljdGlvbiBlcXVhdGlvbnNcbiAgICBpZiAoIXRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChjLCB0aGlzLmZyaWN0aW9uUmVzdWx0KSB8fCBudW1Db250YWN0cyA9PT0gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGYxID0gdGhpcy5mcmljdGlvblJlc3VsdFt0aGlzLmZyaWN0aW9uUmVzdWx0Lmxlbmd0aCAtIDJdO1xuICAgIHZhciBmMiA9IHRoaXMuZnJpY3Rpb25SZXN1bHRbdGhpcy5mcmljdGlvblJlc3VsdC5sZW5ndGggLSAxXTtcblxuICAgIGF2ZXJhZ2VOb3JtYWwuc2V0WmVybygpO1xuICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnNldFplcm8oKTtcbiAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi5zZXRaZXJvKCk7XG5cbiAgICB2YXIgYm9keUEgPSBjLmJpO1xuICAgIHZhciBib2R5QiA9IGMuYmo7XG4gICAgZm9yKHZhciBpPTA7IGkhPT1udW1Db250YWN0czsgaSsrKXtcbiAgICAgICAgYyA9IHRoaXMucmVzdWx0W3RoaXMucmVzdWx0Lmxlbmd0aCAtIDEgLSBpXTtcbiAgICAgICAgaWYoYy5ib2R5QSAhPT0gYm9keUEpe1xuICAgICAgICAgICAgYXZlcmFnZU5vcm1hbC52YWRkKGMubmksIGF2ZXJhZ2VOb3JtYWwpOyAvLyB2ZWMyLmFkZChlcS50LCBlcS50LCBjLm5vcm1hbEEpO1xuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEEudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50QSk7IC8vIHZlYzIuYWRkKGVxLmNvbnRhY3RQb2ludEEsIGVxLmNvbnRhY3RQb2ludEEsIGMuY29udGFjdFBvaW50QSk7XG4gICAgICAgICAgICBhdmVyYWdlQ29udGFjdFBvaW50Qi52YWRkKGMucmosIGF2ZXJhZ2VDb250YWN0UG9pbnRCKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF2ZXJhZ2VOb3JtYWwudnN1YihjLm5pLCBhdmVyYWdlTm9ybWFsKTsgLy8gdmVjMi5zdWIoZXEudCwgZXEudCwgYy5ub3JtYWxBKTtcbiAgICAgICAgICAgIGF2ZXJhZ2VDb250YWN0UG9pbnRBLnZhZGQoYy5yaiwgYXZlcmFnZUNvbnRhY3RQb2ludEEpOyAvLyB2ZWMyLmFkZChlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBjLmNvbnRhY3RQb2ludEEpO1xuICAgICAgICAgICAgYXZlcmFnZUNvbnRhY3RQb2ludEIudmFkZChjLnJpLCBhdmVyYWdlQ29udGFjdFBvaW50Qik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaW52TnVtQ29udGFjdHMgPSAxIC8gbnVtQ29udGFjdHM7XG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEEuc2NhbGUoaW52TnVtQ29udGFjdHMsIGYxLnJpKTsgLy8gdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRBLCBlcS5jb250YWN0UG9pbnRBLCBpbnZOdW1Db250YWN0cyk7XG4gICAgYXZlcmFnZUNvbnRhY3RQb2ludEIuc2NhbGUoaW52TnVtQ29udGFjdHMsIGYxLnJqKTsgLy8gdmVjMi5zY2FsZShlcS5jb250YWN0UG9pbnRCLCBlcS5jb250YWN0UG9pbnRCLCBpbnZOdW1Db250YWN0cyk7XG4gICAgZjIucmkuY29weShmMS5yaSk7IC8vIFNob3VsZCBiZSB0aGUgc2FtZVxuICAgIGYyLnJqLmNvcHkoZjEucmopO1xuICAgIGF2ZXJhZ2VOb3JtYWwubm9ybWFsaXplKCk7XG4gICAgYXZlcmFnZU5vcm1hbC50YW5nZW50cyhmMS50LCBmMi50KTtcbiAgICAvLyByZXR1cm4gZXE7XG59O1xuXG5cbnZhciB0bXBWZWMxID0gbmV3IFZlYzMoKTtcbnZhciB0bXBWZWMyID0gbmV3IFZlYzMoKTtcbnZhciB0bXBRdWF0MSA9IG5ldyBRdWF0ZXJuaW9uKCk7XG52YXIgdG1wUXVhdDIgPSBuZXcgUXVhdGVybmlvbigpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGFsbCBjb250YWN0cyBiZXR3ZWVuIGEgbGlzdCBvZiBib2R5IHBhaXJzXG4gKiBAbWV0aG9kIGdldENvbnRhY3RzXG4gKiBAcGFyYW0ge2FycmF5fSBwMSBBcnJheSBvZiBib2R5IGluZGljZXNcbiAqIEBwYXJhbSB7YXJyYXl9IHAyIEFycmF5IG9mIGJvZHkgaW5kaWNlc1xuICogQHBhcmFtIHtXb3JsZH0gd29ybGRcbiAqIEBwYXJhbSB7YXJyYXl9IHJlc3VsdCBBcnJheSB0byBzdG9yZSBnZW5lcmF0ZWQgY29udGFjdHNcbiAqIEBwYXJhbSB7YXJyYXl9IG9sZGNvbnRhY3RzIE9wdGlvbmFsLiBBcnJheSBvZiByZXVzYWJsZSBjb250YWN0IG9iamVjdHNcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlLmdldENvbnRhY3RzID0gZnVuY3Rpb24ocDEsIHAyLCB3b3JsZCwgcmVzdWx0LCBvbGRjb250YWN0cywgZnJpY3Rpb25SZXN1bHQsIGZyaWN0aW9uUG9vbCl7XG4gICAgLy8gU2F2ZSBvbGQgY29udGFjdCBvYmplY3RzXG4gICAgdGhpcy5jb250YWN0UG9pbnRQb29sID0gb2xkY29udGFjdHM7XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9uUG9vbCA9IGZyaWN0aW9uUG9vbDtcbiAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB0aGlzLmZyaWN0aW9uUmVzdWx0ID0gZnJpY3Rpb25SZXN1bHQ7XG5cbiAgICB2YXIgcWkgPSB0bXBRdWF0MTtcbiAgICB2YXIgcWogPSB0bXBRdWF0MjtcbiAgICB2YXIgeGkgPSB0bXBWZWMxO1xuICAgIHZhciB4aiA9IHRtcFZlYzI7XG5cbiAgICBmb3IodmFyIGs9MCwgTj1wMS5sZW5ndGg7IGshPT1OOyBrKyspe1xuXG4gICAgICAgIC8vIEdldCBjdXJyZW50IGNvbGxpc2lvbiBib2RpZXNcbiAgICAgICAgdmFyIGJpID0gcDFba10sXG4gICAgICAgICAgICBiaiA9IHAyW2tdO1xuXG4gICAgICAgIC8vIEdldCBjb250YWN0IG1hdGVyaWFsXG4gICAgICAgIHZhciBib2R5Q29udGFjdE1hdGVyaWFsID0gbnVsbDtcbiAgICAgICAgaWYoYmkubWF0ZXJpYWwgJiYgYmoubWF0ZXJpYWwpe1xuICAgICAgICAgICAgYm9keUNvbnRhY3RNYXRlcmlhbCA9IHdvcmxkLmdldENvbnRhY3RNYXRlcmlhbChiaS5tYXRlcmlhbCxiai5tYXRlcmlhbCkgfHwgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmkuc2hhcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBiaS5xdWF0ZXJuaW9uLm11bHQoYmkuc2hhcGVPcmllbnRhdGlvbnNbaV0sIHFpKTtcbiAgICAgICAgICAgIGJpLnF1YXRlcm5pb24udm11bHQoYmkuc2hhcGVPZmZzZXRzW2ldLCB4aSk7XG4gICAgICAgICAgICB4aS52YWRkKGJpLnBvc2l0aW9uLCB4aSk7XG4gICAgICAgICAgICB2YXIgc2kgPSBiaS5zaGFwZXNbaV07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmouc2hhcGVzLmxlbmd0aDsgaisrKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHdvcmxkIHRyYW5zZm9ybSBvZiBzaGFwZXNcbiAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLm11bHQoYmouc2hhcGVPcmllbnRhdGlvbnNbal0sIHFqKTtcbiAgICAgICAgICAgICAgICBiai5xdWF0ZXJuaW9uLnZtdWx0KGJqLnNoYXBlT2Zmc2V0c1tqXSwgeGopO1xuICAgICAgICAgICAgICAgIHhqLnZhZGQoYmoucG9zaXRpb24sIHhqKTtcbiAgICAgICAgICAgICAgICB2YXIgc2ogPSBiai5zaGFwZXNbal07XG5cbiAgICAgICAgICAgICAgICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBHZXQgY29sbGlzaW9uIG1hdGVyaWFsXG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlQ29udGFjdE1hdGVyaWFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZihzaS5tYXRlcmlhbCAmJiBzai5tYXRlcmlhbCl7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlQ29udGFjdE1hdGVyaWFsID0gd29ybGQuZ2V0Q29udGFjdE1hdGVyaWFsKHNpLm1hdGVyaWFsLHNqLm1hdGVyaWFsKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENvbnRhY3RNYXRlcmlhbCA9IHNoYXBlQ29udGFjdE1hdGVyaWFsIHx8IGJvZHlDb250YWN0TWF0ZXJpYWwgfHwgd29ybGQuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcblxuICAgICAgICAgICAgICAgIC8vIEdldCBjb250YWN0c1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlciA9IHRoaXNbc2kudHlwZSB8IHNqLnR5cGVdO1xuICAgICAgICAgICAgICAgIGlmKHJlc29sdmVyKXtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpLnR5cGUgPCBzai50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlci5jYWxsKHRoaXMsIHNpLCBzaiwgeGksIHhqLCBxaSwgcWosIGJpLCBiaiwgc2ksIHNqKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyLmNhbGwodGhpcywgc2osIHNpLCB4aiwgeGksIHFqLCBxaSwgYmosIGJpLCBzaSwgc2opO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIG51bVdhcm5pbmdzID0gMDtcbnZhciBtYXhXYXJuaW5ncyA9IDEwO1xuXG5mdW5jdGlvbiB3YXJuKG1zZyl7XG4gICAgaWYobnVtV2FybmluZ3MgPiBtYXhXYXJuaW5ncyl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBudW1XYXJuaW5ncysrO1xuXG4gICAgY29uc29sZS53YXJuKG1zZyk7XG59XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5CT1hdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5ib3hCb3ggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2oubWF0ZXJpYWw7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2ouY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgdGhpcy5jb252ZXhDb252ZXgoc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbix4aSx4aixxaSxxaixiaSxiaixzaSxzaik7XG59O1xuXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQk9YIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveENvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqKXtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcbiAgICB0aGlzLmNvbnZleENvbnZleChzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2oseGkseGoscWkscWosYmksYmosc2ksc2opO1xufTtcblxuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkJPWCB8IFNoYXBlLnR5cGVzLlBBUlRJQ0xFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuYm94UGFydGljbGUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLm1hdGVyaWFsID0gc2kubWF0ZXJpYWw7XG4gICAgc2kuY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLmNvbGxpc2lvblJlc3BvbnNlID0gc2kuY29sbGlzaW9uUmVzcG9uc2U7XG4gICAgdGhpcy5jb252ZXhQYXJ0aWNsZShzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24sc2oseGkseGoscWkscWosYmksYmosc2ksc2opO1xufTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZVNwaGVyZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVTcGhlcmUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgLy8gV2Ugd2lsbCBoYXZlIG9ubHkgb25lIGNvbnRhY3QgaW4gdGhpcyBjYXNlXG4gICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG5cbiAgICAvLyBDb250YWN0IG5vcm1hbFxuICAgIHhqLnZzdWIoeGksIHIubmkpO1xuICAgIHIubmkubm9ybWFsaXplKCk7XG5cbiAgICAvLyBDb250YWN0IHBvaW50IGxvY2F0aW9uc1xuICAgIHIucmkuY29weShyLm5pKTtcbiAgICByLnJqLmNvcHkoci5uaSk7XG4gICAgci5yaS5tdWx0KHNpLnJhZGl1cywgci5yaSk7XG4gICAgci5yai5tdWx0KC1zai5yYWRpdXMsIHIucmopO1xuXG4gICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgci5yai52YWRkKHhqLCByLnJqKTtcbiAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgdGhpcy5yZXN1bHQucHVzaChyKTtcblxuICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbn07XG5cbi8qKlxuICogQG1ldGhvZCBwbGFuZVRyaW1lc2hcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG52YXIgcGxhbmVUcmltZXNoX25vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVUcmltZXNoX3JlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUExBTkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUucGxhbmVUcmltZXNoID0gZnVuY3Rpb24oXG4gICAgcGxhbmVTaGFwZSxcbiAgICB0cmltZXNoU2hhcGUsXG4gICAgcGxhbmVQb3MsXG4gICAgdHJpbWVzaFBvcyxcbiAgICBwbGFuZVF1YXQsXG4gICAgdHJpbWVzaFF1YXQsXG4gICAgcGxhbmVCb2R5LFxuICAgIHRyaW1lc2hCb2R5XG4pe1xuICAgIC8vIE1ha2UgY29udGFjdHMhXG4gICAgdmFyIHYgPSBuZXcgVmVjMygpO1xuXG4gICAgdmFyIG5vcm1hbCA9IHBsYW5lVHJpbWVzaF9ub3JtYWw7XG4gICAgbm9ybWFsLnNldCgwLDAsMSk7XG4gICAgcGxhbmVRdWF0LnZtdWx0KG5vcm1hbCxub3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmVcblxuICAgIGZvcih2YXIgaT0wOyBpPHRyaW1lc2hTaGFwZS52ZXJ0aWNlcy5sZW5ndGggLyAzOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCB2ZXJ0ZXggZnJvbSB0cmltZXNoXG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgoaSwgdik7XG5cbiAgICAgICAgLy8gU2FmZSB1cFxuICAgICAgICB2YXIgdjIgPSBuZXcgVmVjMygpO1xuICAgICAgICB2Mi5jb3B5KHYpO1xuICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHYyLCB2KTtcblxuICAgICAgICAvLyBDaGVjayBwbGFuZSBzaWRlXG4gICAgICAgIHZhciByZWxwb3MgPSBwbGFuZVRyaW1lc2hfcmVscG9zO1xuICAgICAgICB2LnZzdWIocGxhbmVQb3MsIHJlbHBvcyk7XG4gICAgICAgIHZhciBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XG5cbiAgICAgICAgaWYoZG90IDw9IDAuMCl7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKHBsYW5lQm9keSx0cmltZXNoQm9keSxwbGFuZVNoYXBlLHRyaW1lc2hTaGFwZSk7XG5cbiAgICAgICAgICAgIHIubmkuY29weShub3JtYWwpOyAvLyBDb250YWN0IG5vcm1hbCBpcyB0aGUgcGxhbmUgbm9ybWFsXG5cbiAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkID0gcGxhbmVUcmltZXNoX3Byb2plY3RlZDtcbiAgICAgICAgICAgIG5vcm1hbC5zY2FsZShyZWxwb3MuZG90KG5vcm1hbCksIHByb2plY3RlZCk7XG4gICAgICAgICAgICB2LnZzdWIocHJvamVjdGVkLHByb2plY3RlZCk7XG5cbiAgICAgICAgICAgIC8vIHJpIGlzIHRoZSBwcm9qZWN0ZWQgd29ybGQgcG9zaXRpb24gbWludXMgcGxhbmUgcG9zaXRpb25cbiAgICAgICAgICAgIHIucmkuY29weShwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgci5yaS52c3ViKHBsYW5lQm9keS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgIHIucmouY29weSh2KTtcbiAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgIC8vIFN0b3JlIHJlc3VsdFxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVUcmltZXNoXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzcGhlcmVTaGFwZVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgdHJpbWVzaFNoYXBlXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICBzcGhlcmVQb3NcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHRyaW1lc2hQb3NcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHNwaGVyZVF1YXRcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHRyaW1lc2hRdWF0XG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBzcGhlcmVCb2R5XG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICB0cmltZXNoQm9keVxuICovXG52YXIgc3BoZXJlVHJpbWVzaF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfcmVscG9zID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3Byb2plY3RlZCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlVHJpbWVzaF92ID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3YyID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhBID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZXJ0ZXhCID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3IgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvclVuaXQgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3MgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZVRyaW1lc2hfdG1wID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZhID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZiID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX3ZjID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQiA9IG5ldyBBQUJCKCk7XG52YXIgc3BoZXJlVHJpbWVzaF90cmlhbmdsZXMgPSBbXTtcbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5TUEhFUkUgfCBTaGFwZS50eXBlcy5UUklNRVNIXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlVHJpbWVzaCA9IGZ1bmN0aW9uIChcbiAgICBzcGhlcmVTaGFwZSxcbiAgICB0cmltZXNoU2hhcGUsXG4gICAgc3BoZXJlUG9zLFxuICAgIHRyaW1lc2hQb3MsXG4gICAgc3BoZXJlUXVhdCxcbiAgICB0cmltZXNoUXVhdCxcbiAgICBzcGhlcmVCb2R5LFxuICAgIHRyaW1lc2hCb2R5XG4pIHtcblxuICAgIHZhciBlZGdlVmVydGV4QSA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlcnRleEE7XG4gICAgdmFyIGVkZ2VWZXJ0ZXhCID0gc3BoZXJlVHJpbWVzaF9lZGdlVmVydGV4QjtcbiAgICB2YXIgZWRnZVZlY3RvciA9IHNwaGVyZVRyaW1lc2hfZWRnZVZlY3RvcjtcbiAgICB2YXIgZWRnZVZlY3RvclVuaXQgPSBzcGhlcmVUcmltZXNoX2VkZ2VWZWN0b3JVbml0O1xuICAgIHZhciBsb2NhbFNwaGVyZVBvcyA9IHNwaGVyZVRyaW1lc2hfbG9jYWxTcGhlcmVQb3M7XG4gICAgdmFyIHRtcCA9IHNwaGVyZVRyaW1lc2hfdG1wO1xuICAgIHZhciBsb2NhbFNwaGVyZUFBQkIgPSBzcGhlcmVUcmltZXNoX2xvY2FsU3BoZXJlQUFCQjtcbiAgICB2YXIgdjIgPSBzcGhlcmVUcmltZXNoX3YyO1xuICAgIHZhciByZWxwb3MgPSBzcGhlcmVUcmltZXNoX3JlbHBvcztcbiAgICB2YXIgdHJpYW5nbGVzID0gc3BoZXJlVHJpbWVzaF90cmlhbmdsZXM7XG5cbiAgICAvLyBDb252ZXJ0IHNwaGVyZSBwb3NpdGlvbiB0byBsb2NhbCBpbiB0aGUgdHJpbWVzaFxuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgc3BoZXJlUG9zLCBsb2NhbFNwaGVyZVBvcyk7XG5cbiAgICAvLyBHZXQgdGhlIGFhYmIgb2YgdGhlIHNwaGVyZSBsb2NhbGx5IGluIHRoZSB0cmltZXNoXG4gICAgdmFyIHNwaGVyZVJhZGl1cyA9IHNwaGVyZVNoYXBlLnJhZGl1cztcbiAgICBsb2NhbFNwaGVyZUFBQkIubG93ZXJCb3VuZC5zZXQoXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnggLSBzcGhlcmVSYWRpdXMsXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnkgLSBzcGhlcmVSYWRpdXMsXG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnogLSBzcGhlcmVSYWRpdXNcbiAgICApO1xuICAgIGxvY2FsU3BoZXJlQUFCQi51cHBlckJvdW5kLnNldChcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueCArIHNwaGVyZVJhZGl1cyxcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueSArIHNwaGVyZVJhZGl1cyxcbiAgICAgICAgbG9jYWxTcGhlcmVQb3MueiArIHNwaGVyZVJhZGl1c1xuICAgICk7XG5cbiAgICB0cmltZXNoU2hhcGUuZ2V0VHJpYW5nbGVzSW5BQUJCKGxvY2FsU3BoZXJlQUFCQiwgdHJpYW5nbGVzKTtcbiAgICAvL2ZvciAodmFyIGkgPSAwOyBpIDwgdHJpbWVzaFNoYXBlLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB0cmlhbmdsZXMucHVzaChpKTsgLy8gQWxsXG5cbiAgICAvLyBWZXJ0aWNlc1xuICAgIHZhciB2ID0gc3BoZXJlVHJpbWVzaF92O1xuICAgIHZhciByYWRpdXNTcXVhcmVkID0gc3BoZXJlU2hhcGUucmFkaXVzICogc3BoZXJlU2hhcGUucmFkaXVzO1xuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCB2KTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgdmVydGV4IG92ZXJsYXAgaW4gc3BoZXJlXG4gICAgICAgICAgICB2LnZzdWIobG9jYWxTcGhlcmVQb3MsIHJlbHBvcyk7XG5cbiAgICAgICAgICAgIGlmKHJlbHBvcy5ub3JtMigpIDw9IHJhZGl1c1NxdWFyZWQpe1xuXG4gICAgICAgICAgICAgICAgLy8gU2FmZSB1cFxuICAgICAgICAgICAgICAgIHYyLmNvcHkodik7XG4gICAgICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKHRyaW1lc2hQb3MsIHRyaW1lc2hRdWF0LCB2Miwgdik7XG5cbiAgICAgICAgICAgICAgICB2LnZzdWIoc3BoZXJlUG9zLCByZWxwb3MpO1xuXG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihzcGhlcmVCb2R5LHRyaW1lc2hCb2R5LHNwaGVyZVNoYXBlLHRyaW1lc2hTaGFwZSk7XG4gICAgICAgICAgICAgICAgci5uaS5jb3B5KHJlbHBvcyk7XG4gICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcblxuICAgICAgICAgICAgICAgIC8vIHJpIGlzIHRoZSB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHRoZSBzcGhlcmUgc3VyZmFjZVxuICAgICAgICAgICAgICAgIHIucmkuY29weShyLm5pKTtcbiAgICAgICAgICAgICAgICByLnJpLnNjYWxlKHNwaGVyZVNoYXBlLnJhZGl1cywgci5yaSk7XG4gICAgICAgICAgICAgICAgci5yaS52YWRkKHNwaGVyZVBvcywgci5yaSk7XG4gICAgICAgICAgICAgICAgci5yaS52c3ViKHNwaGVyZUJvZHkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgci5yai5jb3B5KHYpO1xuICAgICAgICAgICAgICAgIHIucmoudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAvLyBTdG9yZSByZXN1bHRcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGFsbCBlZGdlc1xuICAgIGZvcih2YXIgaT0wOyBpPHRyaWFuZ2xlcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cbiAgICAgICAgICAgIHRyaW1lc2hTaGFwZS5nZXRWZXJ0ZXgodHJpbWVzaFNoYXBlLmluZGljZXNbdHJpYW5nbGVzW2ldICogMyArIGpdLCBlZGdlVmVydGV4QSk7XG4gICAgICAgICAgICB0cmltZXNoU2hhcGUuZ2V0VmVydGV4KHRyaW1lc2hTaGFwZS5pbmRpY2VzW3RyaWFuZ2xlc1tpXSAqIDMgKyAoKGorMSklMyldLCBlZGdlVmVydGV4Qik7XG4gICAgICAgICAgICBlZGdlVmVydGV4Qi52c3ViKGVkZ2VWZXJ0ZXhBLCBlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgLy8gUHJvamVjdCBzcGhlcmUgcG9zaXRpb24gdG8gdGhlIGVkZ2VcbiAgICAgICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIoZWRnZVZlcnRleEIsIHRtcCk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25BbG9uZ0VkZ2VCID0gdG1wLmRvdChlZGdlVmVjdG9yKTtcblxuICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbkFsb25nRWRnZUEgPSB0bXAuZG90KGVkZ2VWZWN0b3IpO1xuXG4gICAgICAgICAgICBpZihwb3NpdGlvbkFsb25nRWRnZUEgPiAwICYmIHBvc2l0aW9uQWxvbmdFZGdlQiA8IDApe1xuXG4gICAgICAgICAgICAgICAgLy8gTm93IGNoZWNrIHRoZSBvcnRob2dvbmFsIGRpc3RhbmNlIGZyb20gZWRnZSB0byBzcGhlcmUgY2VudGVyXG4gICAgICAgICAgICAgICAgbG9jYWxTcGhlcmVQb3MudnN1YihlZGdlVmVydGV4QSwgdG1wKTtcblxuICAgICAgICAgICAgICAgIGVkZ2VWZWN0b3JVbml0LmNvcHkoZWRnZVZlY3Rvcik7XG4gICAgICAgICAgICAgICAgZWRnZVZlY3RvclVuaXQubm9ybWFsaXplKCk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BbG9uZ0VkZ2VBID0gdG1wLmRvdChlZGdlVmVjdG9yVW5pdCk7XG5cbiAgICAgICAgICAgICAgICBlZGdlVmVjdG9yVW5pdC5zY2FsZShwb3NpdGlvbkFsb25nRWRnZUEsIHRtcCk7XG4gICAgICAgICAgICAgICAgdG1wLnZhZGQoZWRnZVZlcnRleEEsIHRtcCk7XG5cbiAgICAgICAgICAgICAgICAvLyB0bXAgaXMgbm93IHRoZSBzcGhlcmUgY2VudGVyIHBvc2l0aW9uIHByb2plY3RlZCB0byB0aGUgZWRnZSwgZGVmaW5lZCBsb2NhbGx5IGluIHRoZSB0cmltZXNoIGZyYW1lXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XG4gICAgICAgICAgICAgICAgaWYoZGlzdCA8IHNwaGVyZVNoYXBlLnJhZGl1cyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRtcC52c3ViKGxvY2FsU3BoZXJlUG9zLCByLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgci5uaS5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgci5uaS5zY2FsZShzcGhlcmVTaGFwZS5yYWRpdXMsIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZSh0cmltZXNoUG9zLCB0cmltZXNoUXVhdCwgdG1wLCB0bXApO1xuICAgICAgICAgICAgICAgICAgICB0bXAudnN1Yih0cmltZXNoQm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5uaSwgci5uaSk7XG4gICAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybS52ZWN0b3JUb1dvcmxkRnJhbWUodHJpbWVzaFF1YXQsIHIucmksIHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmlhbmdsZSBmYWNlc1xuICAgIHZhciB2YSA9IHNwaGVyZVRyaW1lc2hfdmE7XG4gICAgdmFyIHZiID0gc3BoZXJlVHJpbWVzaF92YjtcbiAgICB2YXIgdmMgPSBzcGhlcmVUcmltZXNoX3ZjO1xuICAgIHZhciBub3JtYWwgPSBzcGhlcmVUcmltZXNoX25vcm1hbDtcbiAgICBmb3IodmFyIGk9MCwgTiA9IHRyaWFuZ2xlcy5sZW5ndGg7IGkgIT09IE47IGkrKyl7XG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXRUcmlhbmdsZVZlcnRpY2VzKHRyaWFuZ2xlc1tpXSwgdmEsIHZiLCB2Yyk7XG4gICAgICAgIHRyaW1lc2hTaGFwZS5nZXROb3JtYWwodHJpYW5nbGVzW2ldLCBub3JtYWwpO1xuICAgICAgICBsb2NhbFNwaGVyZVBvcy52c3ViKHZhLCB0bXApO1xuICAgICAgICB2YXIgZGlzdCA9IHRtcC5kb3Qobm9ybWFsKTtcbiAgICAgICAgbm9ybWFsLnNjYWxlKGRpc3QsIHRtcCk7XG4gICAgICAgIGxvY2FsU3BoZXJlUG9zLnZzdWIodG1wLCB0bXApO1xuXG4gICAgICAgIC8vIHRtcCBpcyBub3cgdGhlIHNwaGVyZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIHRyaWFuZ2xlIHBsYW5lXG4gICAgICAgIGRpc3QgPSB0bXAuZGlzdGFuY2VUbyhsb2NhbFNwaGVyZVBvcyk7XG4gICAgICAgIGlmKFJheS5wb2ludEluVHJpYW5nbGUodG1wLCB2YSwgdmIsIHZjKSAmJiBkaXN0IDwgc3BoZXJlU2hhcGUucmFkaXVzKXtcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oc3BoZXJlQm9keSwgdHJpbWVzaEJvZHksIHNwaGVyZVNoYXBlLCB0cmltZXNoU2hhcGUpO1xuXG4gICAgICAgICAgICB0bXAudnN1Yihsb2NhbFNwaGVyZVBvcywgci5uaSk7XG4gICAgICAgICAgICByLm5pLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgci5uaS5zY2FsZShzcGhlcmVTaGFwZS5yYWRpdXMsIHIucmkpO1xuXG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUodHJpbWVzaFBvcywgdHJpbWVzaFF1YXQsIHRtcCwgdG1wKTtcbiAgICAgICAgICAgIHRtcC52c3ViKHRyaW1lc2hCb2R5LnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgVHJhbnNmb3JtLnZlY3RvclRvV29ybGRGcmFtZSh0cmltZXNoUXVhdCwgci5uaSwgci5uaSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm0udmVjdG9yVG9Xb3JsZEZyYW1lKHRyaW1lc2hRdWF0LCByLnJpLCByLnJpKTtcblxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRyaWFuZ2xlcy5sZW5ndGggPSAwO1xufTtcblxudmFyIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVfdG9fc3BoZXJlX29ydGhvID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHNwaGVyZVBsYW5lXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlNQSEVSRSB8IFNoYXBlLnR5cGVzLlBMQU5FXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlUGxhbmUgPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiail7XG4gICAgLy8gV2Ugd2lsbCBoYXZlIG9uZSBjb250YWN0IGluIHRoaXMgY2FzZVxuICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2opO1xuXG4gICAgLy8gQ29udGFjdCBub3JtYWxcbiAgICByLm5pLnNldCgwLDAsMSk7XG4gICAgcWoudm11bHQoci5uaSwgci5uaSk7XG4gICAgci5uaS5uZWdhdGUoci5uaSk7IC8vIGJvZHkgaSBpcyB0aGUgc3BoZXJlLCBmbGlwIG5vcm1hbFxuICAgIHIubmkubm9ybWFsaXplKCk7IC8vIE5lZWRlZD9cblxuICAgIC8vIFZlY3RvciBmcm9tIHNwaGVyZSBjZW50ZXIgdG8gY29udGFjdCBwb2ludFxuICAgIHIubmkubXVsdChzaS5yYWRpdXMsIHIucmkpO1xuXG4gICAgLy8gUHJvamVjdCBkb3duIHNwaGVyZSBvbiBwbGFuZVxuICAgIHhpLnZzdWIoeGosIHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSk7XG4gICAgci5uaS5tdWx0KHIubmkuZG90KHBvaW50X29uX3BsYW5lX3RvX3NwaGVyZSksIHBsYW5lX3RvX3NwaGVyZV9vcnRobyk7XG4gICAgcG9pbnRfb25fcGxhbmVfdG9fc3BoZXJlLnZzdWIocGxhbmVfdG9fc3BoZXJlX29ydGhvLHIucmopOyAvLyBUaGUgc3BoZXJlIHBvc2l0aW9uIHByb2plY3RlZCB0byBwbGFuZVxuXG4gICAgaWYoLXBvaW50X29uX3BsYW5lX3RvX3NwaGVyZS5kb3Qoci5uaSkgPD0gc2kucmFkaXVzKXtcblxuICAgICAgICAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5XG4gICAgICAgIHZhciByaSA9IHIucmk7XG4gICAgICAgIHZhciByaiA9IHIucmo7XG4gICAgICAgIHJpLnZhZGQoeGksIHJpKTtcbiAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICByai52YWRkKHhqLCByaik7XG4gICAgICAgIHJqLnZzdWIoYmoucG9zaXRpb24sIHJqKTtcblxuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxufTtcblxuLy8gU2VlIGh0dHA6Ly9idWxsZXRwaHlzaWNzLmNvbS9CdWxsZXQvQnVsbGV0RnVsbC9TcGhlcmVUcmlhbmdsZURldGVjdG9yXzhjcHBfc291cmNlLmh0bWxcbnZhciBwb2ludEluUG9seWdvbl9lZGdlID0gbmV3IFZlYzMoKTtcbnZhciBwb2ludEluUG9seWdvbl9lZGdlX3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBwb2ludEluUG9seWdvbl92dHAgPSBuZXcgVmVjMygpO1xuZnVuY3Rpb24gcG9pbnRJblBvbHlnb24odmVydHMsIG5vcm1hbCwgcCl7XG4gICAgdmFyIHBvc2l0aXZlUmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgTiA9IHZlcnRzLmxlbmd0aDtcbiAgICBmb3IodmFyIGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciB2ID0gdmVydHNbaV07XG5cbiAgICAgICAgLy8gR2V0IGVkZ2UgdG8gdGhlIG5leHQgdmVydGV4XG4gICAgICAgIHZhciBlZGdlID0gcG9pbnRJblBvbHlnb25fZWRnZTtcbiAgICAgICAgdmVydHNbKGkrMSkgJSAoTildLnZzdWIodixlZGdlKTtcblxuICAgICAgICAvLyBHZXQgY3Jvc3MgcHJvZHVjdCBiZXR3ZWVuIHBvbHlnb24gbm9ybWFsIGFuZCB0aGUgZWRnZVxuICAgICAgICB2YXIgZWRnZV94X25vcm1hbCA9IHBvaW50SW5Qb2x5Z29uX2VkZ2VfeF9ub3JtYWw7XG4gICAgICAgIC8vdmFyIGVkZ2VfeF9ub3JtYWwgPSBuZXcgVmVjMygpO1xuICAgICAgICBlZGdlLmNyb3NzKG5vcm1hbCxlZGdlX3hfbm9ybWFsKTtcblxuICAgICAgICAvLyBHZXQgdmVjdG9yIGJldHdlZW4gcG9pbnQgYW5kIGN1cnJlbnQgdmVydGV4XG4gICAgICAgIHZhciB2ZXJ0ZXhfdG9fcCA9IHBvaW50SW5Qb2x5Z29uX3Z0cDtcbiAgICAgICAgcC52c3ViKHYsdmVydGV4X3RvX3ApO1xuXG4gICAgICAgIC8vIFRoaXMgZG90IHByb2R1Y3QgZGV0ZXJtaW5lcyB3aGljaCBzaWRlIG9mIHRoZSBlZGdlIHRoZSBwb2ludCBpc1xuICAgICAgICB2YXIgciA9IGVkZ2VfeF9ub3JtYWwuZG90KHZlcnRleF90b19wKTtcblxuICAgICAgICAvLyBJZiBhbGwgc3VjaCBkb3QgcHJvZHVjdHMgaGF2ZSBzYW1lIHNpZ24sIHdlIGFyZSBpbnNpZGUgdGhlIHBvbHlnb24uXG4gICAgICAgIGlmKHBvc2l0aXZlUmVzdWx0PT09bnVsbCB8fCAocj4wICYmIHBvc2l0aXZlUmVzdWx0PT09dHJ1ZSkgfHwgKHI8PTAgJiYgcG9zaXRpdmVSZXN1bHQ9PT1mYWxzZSkpe1xuICAgICAgICAgICAgaWYocG9zaXRpdmVSZXN1bHQ9PT1udWxsKXtcbiAgICAgICAgICAgICAgICBwb3NpdGl2ZVJlc3VsdCA9IHI+MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBFbmNvdW50ZXJlZCBzb21lIG90aGVyIHNpZ24uIEV4aXQuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBnb3QgaGVyZSwgYWxsIGRvdCBwcm9kdWN0cyB3ZXJlIG9mIHRoZSBzYW1lIHNpZ24uXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBib3hfdG9fc3BoZXJlID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVCb3hfbnMgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9uczEgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9uczIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9zaWRlcyA9IFtuZXcgVmVjMygpLG5ldyBWZWMzKCksbmV3IFZlYzMoKSxuZXcgVmVjMygpLG5ldyBWZWMzKCksbmV3IFZlYzMoKV07XG52YXIgc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9zaWRlX25zID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVCb3hfc2lkZV9uczEgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUJveF9zaWRlX25zMiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVCb3hcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQk9YXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlQm94ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmope1xuICAgIHZhciB2M3Bvb2wgPSB0aGlzLnYzcG9vbDtcblxuICAgIC8vIHdlIHJlZmVyIHRvIHRoZSBib3ggYXMgYm9keSBqXG4gICAgdmFyIHNpZGVzID0gc3BoZXJlQm94X3NpZGVzO1xuICAgIHhpLnZzdWIoeGosYm94X3RvX3NwaGVyZSk7XG4gICAgc2ouZ2V0U2lkZU5vcm1hbHMoc2lkZXMscWopO1xuICAgIHZhciBSID0gICAgIHNpLnJhZGl1cztcbiAgICB2YXIgcGVuZXRyYXRpbmdfc2lkZXMgPSBbXTtcblxuICAgIC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG5cbiAgICAvLyBTdG9yZSB0aGUgcmVzdWx0aW5nIHNpZGUgcGVuZXRyYXRpb24gaW5mb1xuICAgIHZhciBzaWRlX25zID0gc3BoZXJlQm94X3NpZGVfbnM7XG4gICAgdmFyIHNpZGVfbnMxID0gc3BoZXJlQm94X3NpZGVfbnMxO1xuICAgIHZhciBzaWRlX25zMiA9IHNwaGVyZUJveF9zaWRlX25zMjtcbiAgICB2YXIgc2lkZV9oID0gbnVsbDtcbiAgICB2YXIgc2lkZV9wZW5ldHJhdGlvbnMgPSAwO1xuICAgIHZhciBzaWRlX2RvdDEgPSAwO1xuICAgIHZhciBzaWRlX2RvdDIgPSAwO1xuICAgIHZhciBzaWRlX2Rpc3RhbmNlID0gbnVsbDtcbiAgICBmb3IodmFyIGlkeD0wLG5zaWRlcz1zaWRlcy5sZW5ndGg7IGlkeCE9PW5zaWRlcyAmJiBmb3VuZD09PWZhbHNlOyBpZHgrKyl7XG4gICAgICAgIC8vIEdldCB0aGUgcGxhbmUgc2lkZSBub3JtYWwgKG5zKVxuICAgICAgICB2YXIgbnMgPSBzcGhlcmVCb3hfbnM7XG4gICAgICAgIG5zLmNvcHkoc2lkZXNbaWR4XSk7XG5cbiAgICAgICAgdmFyIGggPSBucy5ub3JtKCk7XG4gICAgICAgIG5zLm5vcm1hbGl6ZSgpO1xuXG4gICAgICAgIC8vIFRoZSBub3JtYWwvZGlzdGFuY2UgZG90IHByb2R1Y3QgdGVsbHMgd2hpY2ggc2lkZSBvZiB0aGUgcGxhbmUgd2UgYXJlXG4gICAgICAgIHZhciBkb3QgPSBib3hfdG9fc3BoZXJlLmRvdChucyk7XG5cbiAgICAgICAgaWYoZG90PGgrUiAmJiBkb3Q+MCl7XG4gICAgICAgICAgICAvLyBJbnRlcnNlY3RzIHBsYW5lLiBOb3cgY2hlY2sgdGhlIG90aGVyIHR3byBkaW1lbnNpb25zXG4gICAgICAgICAgICB2YXIgbnMxID0gc3BoZXJlQm94X25zMTtcbiAgICAgICAgICAgIHZhciBuczIgPSBzcGhlcmVCb3hfbnMyO1xuICAgICAgICAgICAgbnMxLmNvcHkoc2lkZXNbKGlkeCsxKSUzXSk7XG4gICAgICAgICAgICBuczIuY29weShzaWRlc1soaWR4KzIpJTNdKTtcbiAgICAgICAgICAgIHZhciBoMSA9IG5zMS5ub3JtKCk7XG4gICAgICAgICAgICB2YXIgaDIgPSBuczIubm9ybSgpO1xuICAgICAgICAgICAgbnMxLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgbnMyLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgdmFyIGRvdDEgPSBib3hfdG9fc3BoZXJlLmRvdChuczEpO1xuICAgICAgICAgICAgdmFyIGRvdDIgPSBib3hfdG9fc3BoZXJlLmRvdChuczIpO1xuICAgICAgICAgICAgaWYoZG90MTxoMSAmJiBkb3QxPi1oMSAmJiBkb3QyPGgyICYmIGRvdDI+LWgyKXtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdCA9IE1hdGguYWJzKGRvdC1oLVIpO1xuICAgICAgICAgICAgICAgIGlmKHNpZGVfZGlzdGFuY2U9PT1udWxsIHx8IGRpc3QgPCBzaWRlX2Rpc3RhbmNlKXtcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9kaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfZG90MSA9IGRvdDE7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfZG90MiA9IGRvdDI7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfaCA9IGg7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfbnMuY29weShucyk7XG4gICAgICAgICAgICAgICAgICAgIHNpZGVfbnMxLmNvcHkobnMxKTtcbiAgICAgICAgICAgICAgICAgICAgc2lkZV9uczIuY29weShuczIpO1xuICAgICAgICAgICAgICAgICAgICBzaWRlX3BlbmV0cmF0aW9ucysrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihzaWRlX3BlbmV0cmF0aW9ucyl7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG4gICAgICAgIHNpZGVfbnMubXVsdCgtUixyLnJpKTsgLy8gU3BoZXJlIHJcbiAgICAgICAgci5uaS5jb3B5KHNpZGVfbnMpO1xuICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTsgLy8gTm9ybWFsIHNob3VsZCBiZSBvdXQgb2Ygc3BoZXJlXG4gICAgICAgIHNpZGVfbnMubXVsdChzaWRlX2gsc2lkZV9ucyk7XG4gICAgICAgIHNpZGVfbnMxLm11bHQoc2lkZV9kb3QxLHNpZGVfbnMxKTtcbiAgICAgICAgc2lkZV9ucy52YWRkKHNpZGVfbnMxLHNpZGVfbnMpO1xuICAgICAgICBzaWRlX25zMi5tdWx0KHNpZGVfZG90MixzaWRlX25zMik7XG4gICAgICAgIHNpZGVfbnMudmFkZChzaWRlX25zMixyLnJqKTtcblxuICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICByLnJqLnZzdWIoYmoucG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBjb3JuZXJzXG4gICAgdmFyIHJqID0gdjNwb29sLmdldCgpO1xuICAgIHZhciBzcGhlcmVfdG9fY29ybmVyID0gc3BoZXJlQm94X3NwaGVyZV90b19jb3JuZXI7XG4gICAgZm9yKHZhciBqPTA7IGohPT0yICYmICFmb3VuZDsgaisrKXtcbiAgICAgICAgZm9yKHZhciBrPTA7IGshPT0yICYmICFmb3VuZDsgaysrKXtcbiAgICAgICAgICAgIGZvcih2YXIgbD0wOyBsIT09MiAmJiAhZm91bmQ7IGwrKyl7XG4gICAgICAgICAgICAgICAgcmouc2V0KDAsMCwwKTtcbiAgICAgICAgICAgICAgICBpZihqKXtcbiAgICAgICAgICAgICAgICAgICAgcmoudmFkZChzaWRlc1swXSxyaik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmoudnN1YihzaWRlc1swXSxyaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGspe1xuICAgICAgICAgICAgICAgICAgICByai52YWRkKHNpZGVzWzFdLHJqKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByai52c3ViKHNpZGVzWzFdLHJqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYobCl7XG4gICAgICAgICAgICAgICAgICAgIHJqLnZhZGQoc2lkZXNbMl0scmopO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJqLnZzdWIoc2lkZXNbMl0scmopO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxuICAgICAgICAgICAgICAgIHhqLnZhZGQocmosc3BoZXJlX3RvX2Nvcm5lcik7XG4gICAgICAgICAgICAgICAgc3BoZXJlX3RvX2Nvcm5lci52c3ViKHhpLHNwaGVyZV90b19jb3JuZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYoc3BoZXJlX3RvX2Nvcm5lci5ub3JtMigpIDwgUipSKXtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqKTtcbiAgICAgICAgICAgICAgICAgICAgci5yaS5jb3B5KHNwaGVyZV90b19jb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICByLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByLm5pLmNvcHkoci5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmkubXVsdChSLHIucmkpO1xuICAgICAgICAgICAgICAgICAgICByLnJqLmNvcHkocmopO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgICAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgICAgIHIucmoudnN1Yihiai5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2M3Bvb2wucmVsZWFzZShyaik7XG4gICAgcmogPSBudWxsO1xuXG4gICAgLy8gQ2hlY2sgZWRnZXNcbiAgICB2YXIgZWRnZVRhbmdlbnQgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIGVkZ2VDZW50ZXIgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIHIgPSB2M3Bvb2wuZ2V0KCk7IC8vIHIgPSBlZGdlIGNlbnRlciB0byBzcGhlcmUgY2VudGVyXG4gICAgdmFyIG9ydGhvZ29uYWwgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIGRpc3QgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgdmFyIE5zaWRlcyA9IHNpZGVzLmxlbmd0aDtcbiAgICBmb3IodmFyIGo9MDsgaiE9PU5zaWRlcyAmJiAhZm91bmQ7IGorKyl7XG4gICAgICAgIGZvcih2YXIgaz0wOyBrIT09TnNpZGVzICYmICFmb3VuZDsgaysrKXtcbiAgICAgICAgICAgIGlmKGolMyAhPT0gayUzKXtcbiAgICAgICAgICAgICAgICAvLyBHZXQgZWRnZSB0YW5nZW50XG4gICAgICAgICAgICAgICAgc2lkZXNba10uY3Jvc3Moc2lkZXNbal0sZWRnZVRhbmdlbnQpO1xuICAgICAgICAgICAgICAgIGVkZ2VUYW5nZW50Lm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgIHNpZGVzW2pdLnZhZGQoc2lkZXNba10sIGVkZ2VDZW50ZXIpO1xuICAgICAgICAgICAgICAgIHIuY29weSh4aSk7XG4gICAgICAgICAgICAgICAgci52c3ViKGVkZ2VDZW50ZXIscik7XG4gICAgICAgICAgICAgICAgci52c3ViKHhqLHIpO1xuICAgICAgICAgICAgICAgIHZhciBvcnRob25vcm0gPSByLmRvdChlZGdlVGFuZ2VudCk7IC8vIGRpc3RhbmNlIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICBlZGdlVGFuZ2VudC5tdWx0KG9ydGhvbm9ybSxvcnRob2dvbmFsKTsgLy8gVmVjdG9yIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIGNlbnRlciBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb25cblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRoaXJkIHNpZGUgb3J0aG9nb25hbCB0byB0aGlzIG9uZVxuICAgICAgICAgICAgICAgIHZhciBsID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZShsPT09aiUzIHx8IGw9PT1rJTMpe1xuICAgICAgICAgICAgICAgICAgICBsKys7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gdmVjIGZyb20gZWRnZSBjZW50ZXIgdG8gc3BoZXJlIHByb2plY3RlZCB0byB0aGUgcGxhbmUgb3J0aG9nb25hbCB0byB0aGUgZWRnZSB0YW5nZW50XG4gICAgICAgICAgICAgICAgZGlzdC5jb3B5KHhpKTtcbiAgICAgICAgICAgICAgICBkaXN0LnZzdWIob3J0aG9nb25hbCxkaXN0KTtcbiAgICAgICAgICAgICAgICBkaXN0LnZzdWIoZWRnZUNlbnRlcixkaXN0KTtcbiAgICAgICAgICAgICAgICBkaXN0LnZzdWIoeGosZGlzdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBEaXN0YW5jZXMgaW4gdGFuZ2VudCBkaXJlY3Rpb24gYW5kIGRpc3RhbmNlIGluIHRoZSBwbGFuZSBvcnRob2dvbmFsIHRvIGl0XG4gICAgICAgICAgICAgICAgdmFyIHRkaXN0ID0gTWF0aC5hYnMob3J0aG9ub3JtKTtcbiAgICAgICAgICAgICAgICB2YXIgbmRpc3QgPSBkaXN0Lm5vcm0oKTtcblxuICAgICAgICAgICAgICAgIGlmKHRkaXN0IDwgc2lkZXNbbF0ubm9ybSgpICYmIG5kaXN0PFIpe1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXMgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2VDZW50ZXIudmFkZChvcnRob2dvbmFsLHJlcy5yaik7IC8vIGJveCByalxuICAgICAgICAgICAgICAgICAgICByZXMucmouY29weShyZXMucmopO1xuICAgICAgICAgICAgICAgICAgICBkaXN0Lm5lZ2F0ZShyZXMubmkpO1xuICAgICAgICAgICAgICAgICAgICByZXMubmkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLmNvcHkocmVzLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGoscmVzLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZzdWIoeGkscmVzLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXMucmkubXVsdChSLHJlcy5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSByZWxhdGl2ZSB0byBib2RpZXNcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJpLnZhZGQoeGksIHJlcy5yaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5yaS52c3ViKGJpLnBvc2l0aW9uLCByZXMucmkpO1xuICAgICAgICAgICAgICAgICAgICByZXMucmoudmFkZCh4aiwgcmVzLnJqKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLnJqLnZzdWIoYmoucG9zaXRpb24sIHJlcy5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyZXMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QocmVzLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdjNwb29sLnJlbGVhc2UoZWRnZVRhbmdlbnQsZWRnZUNlbnRlcixyLG9ydGhvZ29uYWwsZGlzdCk7XG59O1xuXG52YXIgY29udmV4X3RvX3NwaGVyZSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X2VkZ2UgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9lZGdlVW5pdCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3NwaGVyZVRvQ29ybmVyID0gbmV3IFZlYzMoKTtcbnZhciBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXIgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF93b3JsZE5vcm1hbCA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3dvcmxkUG9pbnQgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF93b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUgPSBuZXcgVmVjMygpO1xudmFyIHNwaGVyZUNvbnZleF9wZW5ldHJhdGlvblZlYyA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlQ29udmV4X3NwaGVyZVRvV29ybGRQb2ludCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVDb252ZXhcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnNwaGVyZUNvbnZleCA9IGZ1bmN0aW9uKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqKXtcbiAgICB2YXIgdjNwb29sID0gdGhpcy52M3Bvb2w7XG4gICAgeGkudnN1Yih4aixjb252ZXhfdG9fc3BoZXJlKTtcbiAgICB2YXIgbm9ybWFscyA9IHNqLmZhY2VOb3JtYWxzO1xuICAgIHZhciBmYWNlcyA9IHNqLmZhY2VzO1xuICAgIHZhciB2ZXJ0cyA9IHNqLnZlcnRpY2VzO1xuICAgIHZhciBSID0gICAgIHNpLnJhZGl1cztcbiAgICB2YXIgcGVuZXRyYXRpbmdfc2lkZXMgPSBbXTtcblxuICAgIC8vIGlmKGNvbnZleF90b19zcGhlcmUubm9ybTIoKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgIC8vICAgICByZXR1cm47XG4gICAgLy8gfVxuXG4gICAgLy8gQ2hlY2sgY29ybmVyc1xuICAgIGZvcih2YXIgaT0wOyBpIT09dmVydHMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgdiA9IHZlcnRzW2ldO1xuXG4gICAgICAgIC8vIFdvcmxkIHBvc2l0aW9uIG9mIGNvcm5lclxuICAgICAgICB2YXIgd29ybGRDb3JuZXIgPSBzcGhlcmVDb252ZXhfd29ybGRDb3JuZXI7XG4gICAgICAgIHFqLnZtdWx0KHYsd29ybGRDb3JuZXIpO1xuICAgICAgICB4ai52YWRkKHdvcmxkQ29ybmVyLHdvcmxkQ29ybmVyKTtcbiAgICAgICAgdmFyIHNwaGVyZV90b19jb3JuZXIgPSBzcGhlcmVDb252ZXhfc3BoZXJlVG9Db3JuZXI7XG4gICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGksIHNwaGVyZV90b19jb3JuZXIpO1xuICAgICAgICBpZihzcGhlcmVfdG9fY29ybmVyLm5vcm0yKCkgPCBSICogUil7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqKTtcbiAgICAgICAgICAgIHIucmkuY29weShzcGhlcmVfdG9fY29ybmVyKTtcbiAgICAgICAgICAgIHIucmkubm9ybWFsaXplKCk7XG4gICAgICAgICAgICByLm5pLmNvcHkoci5yaSk7XG4gICAgICAgICAgICByLnJpLm11bHQoUixyLnJpKTtcbiAgICAgICAgICAgIHdvcmxkQ29ybmVyLnZzdWIoeGosci5yaik7XG5cbiAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgIHIucmkudmFkZCh4aSwgci5yaSk7XG4gICAgICAgICAgICByLnJpLnZzdWIoYmkucG9zaXRpb24sIHIucmkpO1xuXG4gICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIHNpZGUgKHBsYW5lKSBpbnRlcnNlY3Rpb25zXG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgZm9yKHZhciBpPTAsIG5mYWNlcz1mYWNlcy5sZW5ndGg7IGkhPT1uZmFjZXMgJiYgZm91bmQ9PT1mYWxzZTsgaSsrKXtcbiAgICAgICAgdmFyIG5vcm1hbCA9IG5vcm1hbHNbaV07XG4gICAgICAgIHZhciBmYWNlID0gZmFjZXNbaV07XG5cbiAgICAgICAgLy8gR2V0IHdvcmxkLXRyYW5zZm9ybWVkIG5vcm1hbCBvZiB0aGUgZmFjZVxuICAgICAgICB2YXIgd29ybGROb3JtYWwgPSBzcGhlcmVDb252ZXhfd29ybGROb3JtYWw7XG4gICAgICAgIHFqLnZtdWx0KG5vcm1hbCx3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgLy8gR2V0IGEgd29ybGQgdmVydGV4IGZyb20gdGhlIGZhY2VcbiAgICAgICAgdmFyIHdvcmxkUG9pbnQgPSBzcGhlcmVDb252ZXhfd29ybGRQb2ludDtcbiAgICAgICAgcWoudm11bHQodmVydHNbZmFjZVswXV0sd29ybGRQb2ludCk7XG4gICAgICAgIHdvcmxkUG9pbnQudmFkZCh4aix3b3JsZFBvaW50KTtcblxuICAgICAgICAvLyBHZXQgYSBwb2ludCBvbiB0aGUgc3BoZXJlLCBjbG9zZXN0IHRvIHRoZSBmYWNlIG5vcm1hbFxuICAgICAgICB2YXIgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lID0gc3BoZXJlQ29udmV4X3dvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZTtcbiAgICAgICAgd29ybGROb3JtYWwubXVsdCgtUiwgd29ybGRTcGhlcmVQb2ludENsb3Nlc3RUb1BsYW5lKTtcbiAgICAgICAgeGkudmFkZCh3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUsIHdvcmxkU3BoZXJlUG9pbnRDbG9zZXN0VG9QbGFuZSk7XG5cbiAgICAgICAgLy8gVmVjdG9yIGZyb20gYSBmYWNlIHBvaW50IHRvIHRoZSBjbG9zZXN0IHBvaW50IG9uIHRoZSBzcGhlcmVcbiAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjID0gc3BoZXJlQ29udmV4X3BlbmV0cmF0aW9uVmVjO1xuICAgICAgICB3b3JsZFNwaGVyZVBvaW50Q2xvc2VzdFRvUGxhbmUudnN1Yih3b3JsZFBvaW50LHBlbmV0cmF0aW9uVmVjKTtcblxuICAgICAgICAvLyBUaGUgcGVuZXRyYXRpb24uIE5lZ2F0aXZlIHZhbHVlIG1lYW5zIG92ZXJsYXAuXG4gICAgICAgIHZhciBwZW5ldHJhdGlvbiA9IHBlbmV0cmF0aW9uVmVjLmRvdCh3b3JsZE5vcm1hbCk7XG5cbiAgICAgICAgdmFyIHdvcmxkUG9pbnRUb1NwaGVyZSA9IHNwaGVyZUNvbnZleF9zcGhlcmVUb1dvcmxkUG9pbnQ7XG4gICAgICAgIHhpLnZzdWIod29ybGRQb2ludCwgd29ybGRQb2ludFRvU3BoZXJlKTtcblxuICAgICAgICBpZihwZW5ldHJhdGlvbiA8IDAgJiYgd29ybGRQb2ludFRvU3BoZXJlLmRvdCh3b3JsZE5vcm1hbCk+MCl7XG4gICAgICAgICAgICAvLyBJbnRlcnNlY3RzIHBsYW5lLiBOb3cgY2hlY2sgaWYgdGhlIHNwaGVyZSBpcyBpbnNpZGUgdGhlIGZhY2UgcG9seWdvblxuICAgICAgICAgICAgdmFyIGZhY2VWZXJ0cyA9IFtdOyAvLyBGYWNlIHZlcnRpY2VzLCBpbiB3b3JsZCBjb29yZHNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOdmVydHM9ZmFjZS5sZW5ndGg7IGohPT1OdmVydHM7IGorKyl7XG4gICAgICAgICAgICAgICAgdmFyIHdvcmxkVmVydGV4ID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2Vbal1dLCB3b3JsZFZlcnRleCk7XG4gICAgICAgICAgICAgICAgeGoudmFkZCh3b3JsZFZlcnRleCx3b3JsZFZlcnRleCk7XG4gICAgICAgICAgICAgICAgZmFjZVZlcnRzLnB1c2god29ybGRWZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihwb2ludEluUG9seWdvbihmYWNlVmVydHMsd29ybGROb3JtYWwseGkpKXsgLy8gSXMgdGhlIHNwaGVyZSBjZW50ZXIgaW4gdGhlIGZhY2UgcG9seWdvbj9cbiAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG5cbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCByLnJpKTsgLy8gQ29udGFjdCBvZmZzZXQsIGZyb20gc3BoZXJlIGNlbnRlciB0byBjb250YWN0XG4gICAgICAgICAgICAgICAgd29ybGROb3JtYWwubmVnYXRlKHIubmkpOyAvLyBOb3JtYWwgcG9pbnRpbmcgb3V0IG9mIHNwaGVyZVxuXG4gICAgICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uVmVjMiA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1wZW5ldHJhdGlvbiwgcGVuZXRyYXRpb25WZWMyKTtcbiAgICAgICAgICAgICAgICB2YXIgcGVuZXRyYXRpb25TcGhlcmVQb2ludCA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICB3b3JsZE5vcm1hbC5tdWx0KC1SLCBwZW5ldHJhdGlvblNwaGVyZVBvaW50KTtcblxuICAgICAgICAgICAgICAgIC8veGkudnN1Yih4aikudmFkZChwZW5ldHJhdGlvblNwaGVyZVBvaW50KS52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopO1xuICAgICAgICAgICAgICAgIHhpLnZzdWIoeGosci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQsci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52YWRkKHBlbmV0cmF0aW9uVmVjMiAsIHIucmopO1xuXG4gICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgIHIucmoudmFkZCh4aiwgci5yaik7XG4gICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICByLnJpLnZhZGQoeGksIHIucmkpO1xuICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwZW5ldHJhdGlvblZlYzIpO1xuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHBlbmV0cmF0aW9uU3BoZXJlUG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQucHVzaChyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIHdvcmxkIHZlcnRpY2VzXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqPTAsIE5mYWNldmVydHM9ZmFjZVZlcnRzLmxlbmd0aDsgaiE9PU5mYWNldmVydHM7IGorKyl7XG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBXZSBvbmx5IGV4cGVjdCAqb25lKiBmYWNlIGNvbnRhY3RcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRWRnZT9cbiAgICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgaiE9PWZhY2UubGVuZ3RoOyBqKyspe1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0d28gd29ybGQgdHJhbnNmb3JtZWQgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgICAgdmFyIHYxID0gdjNwb29sLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdjIgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHFqLnZtdWx0KHZlcnRzW2ZhY2VbKGorMSklZmFjZS5sZW5ndGhdXSwgdjEpO1xuICAgICAgICAgICAgICAgICAgICBxai52bXVsdCh2ZXJ0c1tmYWNlWyhqKzIpJWZhY2UubGVuZ3RoXV0sIHYyKTtcbiAgICAgICAgICAgICAgICAgICAgeGoudmFkZCh2MSwgdjEpO1xuICAgICAgICAgICAgICAgICAgICB4ai52YWRkKHYyLCB2Mik7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGVkZ2UgdmVjdG9yXG4gICAgICAgICAgICAgICAgICAgIHZhciBlZGdlID0gc3BoZXJlQ29udmV4X2VkZ2U7XG4gICAgICAgICAgICAgICAgICAgIHYyLnZzdWIodjEsZWRnZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IHRoZSBzYW1lIHZlY3RvciwgYnV0IG5vcm1hbGl6ZWRcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkZ2VVbml0ID0gc3BoZXJlQ29udmV4X2VkZ2VVbml0O1xuICAgICAgICAgICAgICAgICAgICBlZGdlLnVuaXQoZWRnZVVuaXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIHAgaXMgeGkgcHJvamVjdGVkIG9udG8gdGhlIGVkZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB2M3Bvb2wuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2MV90b194aSA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgeGkudnN1Yih2MSwgdjFfdG9feGkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG90ID0gdjFfdG9feGkuZG90KGVkZ2VVbml0KTtcbiAgICAgICAgICAgICAgICAgICAgZWRnZVVuaXQubXVsdChkb3QsIHApO1xuICAgICAgICAgICAgICAgICAgICBwLnZhZGQodjEsIHApO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXB1dGUgYSB2ZWN0b3IgZnJvbSBwIHRvIHRoZSBjZW50ZXIgb2YgdGhlIHNwaGVyZVxuICAgICAgICAgICAgICAgICAgICB2YXIgeGlfdG9fcCA9IHYzcG9vbC5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgcC52c3ViKHhpLCB4aV90b19wKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBDb2xsaXNpb24gaWYgdGhlIGVkZ2Utc3BoZXJlIGRpc3RhbmNlIGlzIGxlc3MgdGhhbiB0aGUgcmFkaXVzXG4gICAgICAgICAgICAgICAgICAgIC8vIEFORCBpZiBwIGlzIGluIGJldHdlZW4gdjEgYW5kIHYyXG4gICAgICAgICAgICAgICAgICAgIGlmKGRvdCA+IDAgJiYgZG90KmRvdDxlZGdlLm5vcm0yKCkgJiYgeGlfdG9fcC5ub3JtMigpIDwgUipSKXsgLy8gQ29sbGlzaW9uIGlmIHRoZSBlZGdlLXNwaGVyZSBkaXN0YW5jZSBpcyBsZXNzIHRoYW4gdGhlIHJhZGl1c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRWRnZSBjb250YWN0IVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSB0aGlzLmNyZWF0ZUNvbnRhY3RFcXVhdGlvbihiaSxiaixzaSxzaik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwLnZzdWIoeGosci5yaik7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHAudnN1Yih4aSxyLm5pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubm9ybWFsaXplKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHIubmkubXVsdChSLHIucmkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJvZHkuXG4gICAgICAgICAgICAgICAgICAgICAgICByLnJqLnZhZGQoeGosIHIucmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgci5yai52c3ViKGJqLnBvc2l0aW9uLCByLnJqKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgICAgICAgICAgci5yaS52YWRkKHhpLCByLnJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHIucmkudnN1YihiaS5wb3NpdGlvbiwgci5yaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZSh2MV90b194aSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxKTtcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UodjIpO1xuICAgICAgICAgICAgICAgICAgICB2M3Bvb2wucmVsZWFzZShwKTtcbiAgICAgICAgICAgICAgICAgICAgdjNwb29sLnJlbGVhc2UoeGlfdG9fcCk7XG4gICAgICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKHYxX3RvX3hpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlbGVhc2Ugd29ybGQgdmVydGljZXNcbiAgICAgICAgICAgIGZvcih2YXIgaj0wLCBOZmFjZXZlcnRzPWZhY2VWZXJ0cy5sZW5ndGg7IGohPT1OZmFjZXZlcnRzOyBqKyspe1xuICAgICAgICAgICAgICAgIHYzcG9vbC5yZWxlYXNlKGZhY2VWZXJ0c1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgcGxhbmVCb3hfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBwbGFuZV90b19jb3JuZXIgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgcGxhbmVCb3hcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgIHJlc3VsdFxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2lcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNqXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4aVxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGpcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFpXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxalxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmlcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJqXG4gKi9cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5QTEFORSB8IFNoYXBlLnR5cGVzLkJPWF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQm94ID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmope1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5tYXRlcmlhbCA9IHNqLm1hdGVyaWFsO1xuICAgIHNqLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbi5jb2xsaXNpb25SZXNwb25zZSA9IHNqLmNvbGxpc2lvblJlc3BvbnNlO1xuICAgIHRoaXMucGxhbmVDb252ZXgoc2ksc2ouY29udmV4UG9seWhlZHJvblJlcHJlc2VudGF0aW9uLHhpLHhqLHFpLHFqLGJpLGJqKTtcbn07XG5cbnZhciBwbGFuZUNvbnZleF92ID0gbmV3IFZlYzMoKTtcbnZhciBwbGFuZUNvbnZleF9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIHBsYW5lQ29udmV4X3JlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgcGxhbmVDb252ZXhfcHJvamVjdGVkID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIHBsYW5lQ29udmV4XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTl0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLnBsYW5lQ29udmV4ID0gZnVuY3Rpb24oXG4gICAgcGxhbmVTaGFwZSxcbiAgICBjb252ZXhTaGFwZSxcbiAgICBwbGFuZVBvc2l0aW9uLFxuICAgIGNvbnZleFBvc2l0aW9uLFxuICAgIHBsYW5lUXVhdCxcbiAgICBjb252ZXhRdWF0LFxuICAgIHBsYW5lQm9keSxcbiAgICBjb252ZXhCb2R5XG4pe1xuICAgIC8vIFNpbXBseSByZXR1cm4gdGhlIHBvaW50cyBiZWhpbmQgdGhlIHBsYW5lLlxuICAgIHZhciB3b3JsZFZlcnRleCA9IHBsYW5lQ29udmV4X3YsXG4gICAgICAgIHdvcmxkTm9ybWFsID0gcGxhbmVDb252ZXhfbm9ybWFsO1xuICAgIHdvcmxkTm9ybWFsLnNldCgwLDAsMSk7XG4gICAgcGxhbmVRdWF0LnZtdWx0KHdvcmxkTm9ybWFsLHdvcmxkTm9ybWFsKTsgLy8gVHVybiBub3JtYWwgYWNjb3JkaW5nIHRvIHBsYW5lIG9yaWVudGF0aW9uXG5cbiAgICB2YXIgbnVtQ29udGFjdHMgPSAwO1xuICAgIHZhciByZWxwb3MgPSBwbGFuZUNvbnZleF9yZWxwb3M7XG4gICAgZm9yKHZhciBpID0gMDsgaSAhPT0gY29udmV4U2hhcGUudmVydGljZXMubGVuZ3RoOyBpKyspe1xuXG4gICAgICAgIC8vIEdldCB3b3JsZCBjb252ZXggdmVydGV4XG4gICAgICAgIHdvcmxkVmVydGV4LmNvcHkoY29udmV4U2hhcGUudmVydGljZXNbaV0pO1xuICAgICAgICBjb252ZXhRdWF0LnZtdWx0KHdvcmxkVmVydGV4LCB3b3JsZFZlcnRleCk7XG4gICAgICAgIGNvbnZleFBvc2l0aW9uLnZhZGQod29ybGRWZXJ0ZXgsIHdvcmxkVmVydGV4KTtcbiAgICAgICAgd29ybGRWZXJ0ZXgudnN1YihwbGFuZVBvc2l0aW9uLCByZWxwb3MpO1xuXG4gICAgICAgIHZhciBkb3QgPSB3b3JsZE5vcm1hbC5kb3QocmVscG9zKTtcbiAgICAgICAgaWYoZG90IDw9IDAuMCl7XG5cbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24ocGxhbmVCb2R5LCBjb252ZXhCb2R5LCBwbGFuZVNoYXBlLCBjb252ZXhTaGFwZSk7XG5cbiAgICAgICAgICAgIC8vIEdldCB2ZXJ0ZXggcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgICAgICB2YXIgcHJvamVjdGVkID0gcGxhbmVDb252ZXhfcHJvamVjdGVkO1xuICAgICAgICAgICAgd29ybGROb3JtYWwubXVsdCh3b3JsZE5vcm1hbC5kb3QocmVscG9zKSxwcm9qZWN0ZWQpO1xuICAgICAgICAgICAgd29ybGRWZXJ0ZXgudnN1Yihwcm9qZWN0ZWQsIHByb2plY3RlZCk7XG4gICAgICAgICAgICBwcm9qZWN0ZWQudnN1YihwbGFuZVBvc2l0aW9uLCByLnJpKTsgLy8gRnJvbSBwbGFuZSB0byB2ZXJ0ZXggcHJvamVjdGVkIG9uIHBsYW5lXG5cbiAgICAgICAgICAgIHIubmkuY29weSh3b3JsZE5vcm1hbCk7IC8vIENvbnRhY3Qgbm9ybWFsIGlzIHRoZSBwbGFuZSBub3JtYWwgb3V0IGZyb20gcGxhbmVcblxuICAgICAgICAgICAgLy8gcmogaXMgbm93IGp1c3QgdGhlIHZlY3RvciBmcm9tIHRoZSBjb252ZXggY2VudGVyIHRvIHRoZSB2ZXJ0ZXhcbiAgICAgICAgICAgIHdvcmxkVmVydGV4LnZzdWIoY29udmV4UG9zaXRpb24sIHIucmopO1xuXG4gICAgICAgICAgICAvLyBNYWtlIGl0IHJlbGF0aXZlIHRvIHRoZSBib2R5XG4gICAgICAgICAgICByLnJpLnZhZGQocGxhbmVQb3NpdGlvbiwgci5yaSk7XG4gICAgICAgICAgICByLnJpLnZzdWIocGxhbmVCb2R5LnBvc2l0aW9uLCByLnJpKTtcbiAgICAgICAgICAgIHIucmoudmFkZChjb252ZXhQb3NpdGlvbiwgci5yaik7XG4gICAgICAgICAgICByLnJqLnZzdWIoY29udmV4Qm9keS5wb3NpdGlvbiwgci5yaik7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICBudW1Db250YWN0cysrO1xuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24gJiYgbnVtQ29udGFjdHMpe1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRnJvbUF2ZXJhZ2UobnVtQ29udGFjdHMpO1xuICAgIH1cbn07XG5cbnZhciBjb252ZXhDb252ZXhfc2VwQXhpcyA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4Q29udmV4X3EgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgY29udmV4Q29udmV4XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST05dID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhDb252ZXggPSBmdW5jdGlvbihzaSxzaix4aSx4aixxaSxxaixiaSxiaixyc2kscnNqLGZhY2VMaXN0QSxmYWNlTGlzdEIpe1xuICAgIHZhciBzZXBBeGlzID0gY29udmV4Q29udmV4X3NlcEF4aXM7XG5cbiAgICBpZih4aS5kaXN0YW5jZVRvKHhqKSA+IHNpLmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc2ouYm91bmRpbmdTcGhlcmVSYWRpdXMpe1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYoc2kuZmluZFNlcGFyYXRpbmdBeGlzKHNqLHhpLHFpLHhqLHFqLHNlcEF4aXMsZmFjZUxpc3RBLGZhY2VMaXN0Qikpe1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIHZhciBxID0gY29udmV4Q29udmV4X3E7XG4gICAgICAgIHNpLmNsaXBBZ2FpbnN0SHVsbCh4aSxxaSxzaix4aixxaixzZXBBeGlzLC0xMDAsMTAwLHJlcyk7XG4gICAgICAgIHZhciBudW1Db250YWN0cyA9IDA7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogIT09IHJlcy5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgICB2YXIgciA9IHRoaXMuY3JlYXRlQ29udGFjdEVxdWF0aW9uKGJpLGJqLHNpLHNqLHJzaSxyc2opLFxuICAgICAgICAgICAgICAgIHJpID0gci5yaSxcbiAgICAgICAgICAgICAgICByaiA9IHIucmo7XG4gICAgICAgICAgICBzZXBBeGlzLm5lZ2F0ZShyLm5pKTtcbiAgICAgICAgICAgIHJlc1tqXS5ub3JtYWwubmVnYXRlKHEpO1xuICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XG4gICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7XG4gICAgICAgICAgICByai5jb3B5KHJlc1tqXS5wb2ludCk7XG5cbiAgICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmVcbiAgICAgICAgICAgIHJpLnZzdWIoeGkscmkpO1xuICAgICAgICAgICAgcmoudnN1Yih4aixyaik7XG5cbiAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4gICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4gICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4gICAgICAgICAgICByai52YWRkKHhqLCByaik7XG4gICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG5cbiAgICAgICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgICAgICBudW1Db250YWN0cysrO1xuICAgICAgICAgICAgaWYoIXRoaXMuZW5hYmxlRnJpY3Rpb25SZWR1Y3Rpb24pe1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmVuYWJsZUZyaWN0aW9uUmVkdWN0aW9uICYmIG51bUNvbnRhY3RzKXtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25Gcm9tQXZlcmFnZShudW1Db250YWN0cyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogQG1ldGhvZCBjb252ZXhUcmltZXNoXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG4vLyBOYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLlRSSU1FU0hdID1cbi8vIE5hcnJvd3BoYXNlLnByb3RvdHlwZS5jb252ZXhUcmltZXNoID0gZnVuY3Rpb24oc2ksc2oseGkseGoscWkscWosYmksYmoscnNpLHJzaixmYWNlTGlzdEEsZmFjZUxpc3RCKXtcbi8vICAgICB2YXIgc2VwQXhpcyA9IGNvbnZleENvbnZleF9zZXBBeGlzO1xuXG4vLyAgICAgaWYoeGkuZGlzdGFuY2VUbyh4aikgPiBzaS5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIHNqLmJvdW5kaW5nU3BoZXJlUmFkaXVzKXtcbi8vICAgICAgICAgcmV0dXJuO1xuLy8gICAgIH1cblxuLy8gICAgIC8vIENvbnN0cnVjdCBhIHRlbXAgaHVsbCBmb3IgZWFjaCB0cmlhbmdsZVxuLy8gICAgIHZhciBodWxsQiA9IG5ldyBDb252ZXhQb2x5aGVkcm9uKCk7XG5cbi8vICAgICBodWxsQi5mYWNlcyA9IFtbMCwxLDJdXTtcbi8vICAgICB2YXIgdmEgPSBuZXcgVmVjMygpO1xuLy8gICAgIHZhciB2YiA9IG5ldyBWZWMzKCk7XG4vLyAgICAgdmFyIHZjID0gbmV3IFZlYzMoKTtcbi8vICAgICBodWxsQi52ZXJ0aWNlcyA9IFtcbi8vICAgICAgICAgdmEsXG4vLyAgICAgICAgIHZiLFxuLy8gICAgICAgICB2Y1xuLy8gICAgIF07XG5cbi8vICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNqLmluZGljZXMubGVuZ3RoIC8gMzsgaSsrKSB7XG5cbi8vICAgICAgICAgdmFyIHRyaWFuZ2xlTm9ybWFsID0gbmV3IFZlYzMoKTtcbi8vICAgICAgICAgc2ouZ2V0Tm9ybWFsKGksIHRyaWFuZ2xlTm9ybWFsKTtcbi8vICAgICAgICAgaHVsbEIuZmFjZU5vcm1hbHMgPSBbdHJpYW5nbGVOb3JtYWxdO1xuXG4vLyAgICAgICAgIHNqLmdldFRyaWFuZ2xlVmVydGljZXMoaSwgdmEsIHZiLCB2Yyk7XG5cbi8vICAgICAgICAgdmFyIGQgPSBzaS50ZXN0U2VwQXhpcyh0cmlhbmdsZU5vcm1hbCwgaHVsbEIsIHhpLCBxaSwgeGosIHFqKTtcbi8vICAgICAgICAgaWYoIWQpe1xuLy8gICAgICAgICAgICAgdHJpYW5nbGVOb3JtYWwuc2NhbGUoLTEsIHRyaWFuZ2xlTm9ybWFsKTtcbi8vICAgICAgICAgICAgIGQgPSBzaS50ZXN0U2VwQXhpcyh0cmlhbmdsZU5vcm1hbCwgaHVsbEIsIHhpLCBxaSwgeGosIHFqKTtcblxuLy8gICAgICAgICAgICAgaWYoIWQpe1xuLy8gICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuLy8gICAgICAgICAgICAgfVxuLy8gICAgICAgICB9XG5cbi8vICAgICAgICAgdmFyIHJlcyA9IFtdO1xuLy8gICAgICAgICB2YXIgcSA9IGNvbnZleENvbnZleF9xO1xuLy8gICAgICAgICBzaS5jbGlwQWdhaW5zdEh1bGwoeGkscWksaHVsbEIseGoscWosdHJpYW5nbGVOb3JtYWwsLTEwMCwxMDAscmVzKTtcbi8vICAgICAgICAgZm9yKHZhciBqID0gMDsgaiAhPT0gcmVzLmxlbmd0aDsgaisrKXtcbi8vICAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2oscnNpLHJzaiksXG4vLyAgICAgICAgICAgICAgICAgcmkgPSByLnJpLFxuLy8gICAgICAgICAgICAgICAgIHJqID0gci5yajtcbi8vICAgICAgICAgICAgIHIubmkuY29weSh0cmlhbmdsZU5vcm1hbCk7XG4vLyAgICAgICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTtcbi8vICAgICAgICAgICAgIHJlc1tqXS5ub3JtYWwubmVnYXRlKHEpO1xuLy8gICAgICAgICAgICAgcS5tdWx0KHJlc1tqXS5kZXB0aCwgcSk7XG4vLyAgICAgICAgICAgICByZXNbal0ucG9pbnQudmFkZChxLCByaSk7XG4vLyAgICAgICAgICAgICByai5jb3B5KHJlc1tqXS5wb2ludCk7XG5cbi8vICAgICAgICAgICAgIC8vIENvbnRhY3QgcG9pbnRzIGFyZSBpbiB3b3JsZCBjb29yZGluYXRlcy4gVHJhbnNmb3JtIGJhY2sgdG8gcmVsYXRpdmVcbi8vICAgICAgICAgICAgIHJpLnZzdWIoeGkscmkpO1xuLy8gICAgICAgICAgICAgcmoudnN1Yih4aixyaik7XG5cbi8vICAgICAgICAgICAgIC8vIE1ha2UgcmVsYXRpdmUgdG8gYm9kaWVzXG4vLyAgICAgICAgICAgICByaS52YWRkKHhpLCByaSk7XG4vLyAgICAgICAgICAgICByaS52c3ViKGJpLnBvc2l0aW9uLCByaSk7XG4vLyAgICAgICAgICAgICByai52YWRkKHhqLCByaik7XG4vLyAgICAgICAgICAgICByai52c3ViKGJqLnBvc2l0aW9uLCByaik7XG5cbi8vICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHIpO1xuLy8gICAgICAgICB9XG4vLyAgICAgfVxuLy8gfTtcblxudmFyIHBhcnRpY2xlUGxhbmVfbm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBwYXJ0aWNsZVBsYW5lX3JlbHBvcyA9IG5ldyBWZWMzKCk7XG52YXIgcGFydGljbGVQbGFuZV9wcm9qZWN0ZWQgPSBuZXcgVmVjMygpO1xuXG4vKipcbiAqIEBtZXRob2QgcGFydGljbGVQbGFuZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBMQU5FIHwgU2hhcGUudHlwZXMuUEFSVElDTEVdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5wbGFuZVBhcnRpY2xlID0gZnVuY3Rpb24oc2osc2kseGoseGkscWoscWksYmosYmkpe1xuICAgIHZhciBub3JtYWwgPSBwYXJ0aWNsZVBsYW5lX25vcm1hbDtcbiAgICBub3JtYWwuc2V0KDAsMCwxKTtcbiAgICBiai5xdWF0ZXJuaW9uLnZtdWx0KG5vcm1hbCxub3JtYWwpOyAvLyBUdXJuIG5vcm1hbCBhY2NvcmRpbmcgdG8gcGxhbmUgb3JpZW50YXRpb25cbiAgICB2YXIgcmVscG9zID0gcGFydGljbGVQbGFuZV9yZWxwb3M7XG4gICAgeGkudnN1Yihiai5wb3NpdGlvbixyZWxwb3MpO1xuICAgIHZhciBkb3QgPSBub3JtYWwuZG90KHJlbHBvcyk7XG4gICAgaWYoZG90IDw9IDAuMCl7XG4gICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2opO1xuICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWwgaXMgdGhlIHBsYW5lIG5vcm1hbFxuICAgICAgICByLm5pLm5lZ2F0ZShyLm5pKTtcbiAgICAgICAgci5yaS5zZXQoMCwwLDApOyAvLyBDZW50ZXIgb2YgcGFydGljbGVcblxuICAgICAgICAvLyBHZXQgcGFydGljbGUgcG9zaXRpb24gcHJvamVjdGVkIG9uIHBsYW5lXG4gICAgICAgIHZhciBwcm9qZWN0ZWQgPSBwYXJ0aWNsZVBsYW5lX3Byb2plY3RlZDtcbiAgICAgICAgbm9ybWFsLm11bHQobm9ybWFsLmRvdCh4aSkscHJvamVjdGVkKTtcbiAgICAgICAgeGkudnN1Yihwcm9qZWN0ZWQscHJvamVjdGVkKTtcbiAgICAgICAgLy9wcm9qZWN0ZWQudmFkZChiai5wb3NpdGlvbixwcm9qZWN0ZWQpO1xuXG4gICAgICAgIC8vIHJqIGlzIG5vdyB0aGUgcHJvamVjdGVkIHdvcmxkIHBvc2l0aW9uIG1pbnVzIHBsYW5lIHBvc2l0aW9uXG4gICAgICAgIHIucmouY29weShwcm9qZWN0ZWQpO1xuICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB0aGlzLmNyZWF0ZUZyaWN0aW9uRXF1YXRpb25zRnJvbUNvbnRhY3QociwgdGhpcy5mcmljdGlvblJlc3VsdCk7XG4gICAgfVxufTtcblxudmFyIHBhcnRpY2xlU3BoZXJlX25vcm1hbCA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBwYXJ0aWNsZVNwaGVyZVxuICogQHBhcmFtICB7QXJyYXl9ICAgICAgcmVzdWx0XG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzaVxuICogQHBhcmFtICB7U2hhcGV9ICAgICAgc2pcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhpXG4gKiBAcGFyYW0gIHtWZWMzfSAgICAgICB4alxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWlcbiAqIEBwYXJhbSAge1F1YXRlcm5pb259IHFqXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBiaVxuICogQHBhcmFtICB7Qm9keX0gICAgICAgYmpcbiAqL1xuTmFycm93cGhhc2UucHJvdG90eXBlW1NoYXBlLnR5cGVzLlBBUlRJQ0xFIHwgU2hhcGUudHlwZXMuU1BIRVJFXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuc3BoZXJlUGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSl7XG4gICAgLy8gVGhlIG5vcm1hbCBpcyB0aGUgdW5pdCB2ZWN0b3IgZnJvbSBzcGhlcmUgY2VudGVyIHRvIHBhcnRpY2xlIGNlbnRlclxuICAgIHZhciBub3JtYWwgPSBwYXJ0aWNsZVNwaGVyZV9ub3JtYWw7XG4gICAgbm9ybWFsLnNldCgwLDAsMSk7XG4gICAgeGkudnN1Yih4aixub3JtYWwpO1xuICAgIHZhciBsZW5ndGhTcXVhcmVkID0gbm9ybWFsLm5vcm0yKCk7XG5cbiAgICBpZihsZW5ndGhTcXVhcmVkIDw9IHNqLnJhZGl1cyAqIHNqLnJhZGl1cyl7XG4gICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2opO1xuICAgICAgICBub3JtYWwubm9ybWFsaXplKCk7XG4gICAgICAgIHIucmouY29weShub3JtYWwpO1xuICAgICAgICByLnJqLm11bHQoc2oucmFkaXVzLHIucmopO1xuICAgICAgICByLm5pLmNvcHkobm9ybWFsKTsgLy8gQ29udGFjdCBub3JtYWxcbiAgICAgICAgci5uaS5uZWdhdGUoci5uaSk7XG4gICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXG4gICAgICAgIHRoaXMucmVzdWx0LnB1c2gocik7XG4gICAgICAgIHRoaXMuY3JlYXRlRnJpY3Rpb25FcXVhdGlvbnNGcm9tQ29udGFjdChyLCB0aGlzLmZyaWN0aW9uUmVzdWx0KTtcbiAgICB9XG59O1xuXG4vLyBXSVBcbnZhciBjcWogPSBuZXcgUXVhdGVybmlvbigpO1xudmFyIGNvbnZleFBhcnRpY2xlX2xvY2FsID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhQYXJ0aWNsZV9ub3JtYWwgPSBuZXcgVmVjMygpO1xudmFyIGNvbnZleFBhcnRpY2xlX3BlbmV0cmF0ZWRGYWNlTm9ybWFsID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhQYXJ0aWNsZV92ZXJ0ZXhUb1BhcnRpY2xlID0gbmV3IFZlYzMoKTtcbnZhciBjb252ZXhQYXJ0aWNsZV93b3JsZFBlbmV0cmF0aW9uVmVjID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBAbWV0aG9kIGNvbnZleFBhcnRpY2xlXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgICByZXN1bHRcbiAqIEBwYXJhbSAge1NoYXBlfSAgICAgIHNpXG4gKiBAcGFyYW0gIHtTaGFwZX0gICAgICBzalxuICogQHBhcmFtICB7VmVjM30gICAgICAgeGlcbiAqIEBwYXJhbSAge1ZlYzN9ICAgICAgIHhqXG4gKiBAcGFyYW0gIHtRdWF0ZXJuaW9ufSBxaVxuICogQHBhcmFtICB7UXVhdGVybmlvbn0gcWpcbiAqIEBwYXJhbSAge0JvZHl9ICAgICAgIGJpXG4gKiBAcGFyYW0gIHtCb2R5fSAgICAgICBialxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuUEFSVElDTEUgfCBTaGFwZS50eXBlcy5DT05WRVhQT0xZSEVEUk9OXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4UGFydGljbGUgPSBmdW5jdGlvbihzaixzaSx4aix4aSxxaixxaSxiaixiaSl7XG4gICAgdmFyIHBlbmV0cmF0ZWRGYWNlSW5kZXggPSAtMTtcbiAgICB2YXIgcGVuZXRyYXRlZEZhY2VOb3JtYWwgPSBjb252ZXhQYXJ0aWNsZV9wZW5ldHJhdGVkRmFjZU5vcm1hbDtcbiAgICB2YXIgd29ybGRQZW5ldHJhdGlvblZlYyA9IGNvbnZleFBhcnRpY2xlX3dvcmxkUGVuZXRyYXRpb25WZWM7XG4gICAgdmFyIG1pblBlbmV0cmF0aW9uID0gbnVsbDtcbiAgICB2YXIgbnVtRGV0ZWN0ZWRGYWNlcyA9IDA7XG5cbiAgICAvLyBDb252ZXJ0IHBhcnRpY2xlIHBvc2l0aW9uIHhpIHRvIGxvY2FsIGNvb3JkcyBpbiB0aGUgY29udmV4XG4gICAgdmFyIGxvY2FsID0gY29udmV4UGFydGljbGVfbG9jYWw7XG4gICAgbG9jYWwuY29weSh4aSk7XG4gICAgbG9jYWwudnN1Yih4aixsb2NhbCk7IC8vIENvbnZlcnQgcG9zaXRpb24gdG8gcmVsYXRpdmUgdGhlIGNvbnZleCBvcmlnaW5cbiAgICBxai5jb25qdWdhdGUoY3FqKTtcbiAgICBjcWoudm11bHQobG9jYWwsbG9jYWwpO1xuXG4gICAgaWYoc2oucG9pbnRJc0luc2lkZShsb2NhbCkpe1xuXG4gICAgICAgIGlmKHNqLndvcmxkVmVydGljZXNOZWVkc1VwZGF0ZSl7XG4gICAgICAgICAgICBzai5jb21wdXRlV29ybGRWZXJ0aWNlcyh4aixxaik7XG4gICAgICAgIH1cbiAgICAgICAgaWYoc2oud29ybGRGYWNlTm9ybWFsc05lZWRzVXBkYXRlKXtcbiAgICAgICAgICAgIHNqLmNvbXB1dGVXb3JsZEZhY2VOb3JtYWxzKHFqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBlYWNoIHdvcmxkIHBvbHlnb24gaW4gdGhlIHBvbHloZWRyYVxuICAgICAgICBmb3IodmFyIGk9MCxuZmFjZXM9c2ouZmFjZXMubGVuZ3RoOyBpIT09bmZhY2VzOyBpKyspe1xuXG4gICAgICAgICAgICAvLyBDb25zdHJ1Y3Qgd29ybGQgZmFjZSB2ZXJ0aWNlc1xuICAgICAgICAgICAgdmFyIHZlcnRzID0gWyBzai53b3JsZFZlcnRpY2VzWyBzai5mYWNlc1tpXVswXSBdIF07XG4gICAgICAgICAgICB2YXIgbm9ybWFsID0gc2oud29ybGRGYWNlTm9ybWFsc1tpXTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgaG93IG11Y2ggdGhlIHBhcnRpY2xlIHBlbmV0cmF0ZXMgdGhlIHBvbHlnb24gcGxhbmUuXG4gICAgICAgICAgICB4aS52c3ViKHZlcnRzWzBdLGNvbnZleFBhcnRpY2xlX3ZlcnRleFRvUGFydGljbGUpO1xuICAgICAgICAgICAgdmFyIHBlbmV0cmF0aW9uID0gLW5vcm1hbC5kb3QoY29udmV4UGFydGljbGVfdmVydGV4VG9QYXJ0aWNsZSk7XG4gICAgICAgICAgICBpZihtaW5QZW5ldHJhdGlvbj09PW51bGwgfHwgTWF0aC5hYnMocGVuZXRyYXRpb24pPE1hdGguYWJzKG1pblBlbmV0cmF0aW9uKSl7XG4gICAgICAgICAgICAgICAgbWluUGVuZXRyYXRpb24gPSBwZW5ldHJhdGlvbjtcbiAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZUluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5jb3B5KG5vcm1hbCk7XG4gICAgICAgICAgICAgICAgbnVtRGV0ZWN0ZWRGYWNlcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYocGVuZXRyYXRlZEZhY2VJbmRleCE9PS0xKXtcbiAgICAgICAgICAgIC8vIFNldHVwIGNvbnRhY3RcbiAgICAgICAgICAgIHZhciByID0gdGhpcy5jcmVhdGVDb250YWN0RXF1YXRpb24oYmksYmosc2ksc2opO1xuICAgICAgICAgICAgcGVuZXRyYXRlZEZhY2VOb3JtYWwubXVsdChtaW5QZW5ldHJhdGlvbiwgd29ybGRQZW5ldHJhdGlvblZlYyk7XG5cbiAgICAgICAgICAgIC8vIHJqIGlzIHRoZSBwYXJ0aWNsZSBwb3NpdGlvbiBwcm9qZWN0ZWQgdG8gdGhlIGZhY2VcbiAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudmFkZCh4aSx3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIHdvcmxkUGVuZXRyYXRpb25WZWMudnN1Yih4aix3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIHIucmouY29weSh3b3JsZFBlbmV0cmF0aW9uVmVjKTtcbiAgICAgICAgICAgIC8vdmFyIHByb2plY3RlZFRvRmFjZSA9IHhpLnZzdWIoeGopLnZhZGQod29ybGRQZW5ldHJhdGlvblZlYyk7XG4gICAgICAgICAgICAvL3Byb2plY3RlZFRvRmFjZS5jb3B5KHIucmopO1xuXG4gICAgICAgICAgICAvL3FqLnZtdWx0KHIucmosci5yaik7XG4gICAgICAgICAgICBwZW5ldHJhdGVkRmFjZU5vcm1hbC5uZWdhdGUoIHIubmkgKTsgLy8gQ29udGFjdCBub3JtYWxcbiAgICAgICAgICAgIHIucmkuc2V0KDAsMCwwKTsgLy8gQ2VudGVyIG9mIHBhcnRpY2xlXG5cbiAgICAgICAgICAgIHZhciByaSA9IHIucmksXG4gICAgICAgICAgICAgICAgcmogPSByLnJqO1xuXG4gICAgICAgICAgICAvLyBNYWtlIHJlbGF0aXZlIHRvIGJvZGllc1xuICAgICAgICAgICAgcmkudmFkZCh4aSwgcmkpO1xuICAgICAgICAgICAgcmkudnN1YihiaS5wb3NpdGlvbiwgcmkpO1xuICAgICAgICAgICAgcmoudmFkZCh4aiwgcmopO1xuICAgICAgICAgICAgcmoudnN1Yihiai5wb3NpdGlvbiwgcmopO1xuXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVGcmljdGlvbkVxdWF0aW9uc0Zyb21Db250YWN0KHIsIHRoaXMuZnJpY3Rpb25SZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUG9pbnQgZm91bmQgaW5zaWRlIGNvbnZleCwgYnV0IGRpZCBub3QgZmluZCBwZW5ldHJhdGluZyBmYWNlIVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk5hcnJvd3BoYXNlLnByb3RvdHlwZVtTaGFwZS50eXBlcy5CT1ggfCBTaGFwZS50eXBlcy5IRUlHSFRGSUVMRF0gPVxuTmFycm93cGhhc2UucHJvdG90eXBlLmJveEhlaWdodGZpZWxkID0gZnVuY3Rpb24gKHNpLHNqLHhpLHhqLHFpLHFqLGJpLGJqKXtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24ubWF0ZXJpYWwgPSBzaS5tYXRlcmlhbDtcbiAgICBzaS5jb252ZXhQb2x5aGVkcm9uUmVwcmVzZW50YXRpb24uY29sbGlzaW9uUmVzcG9uc2UgPSBzaS5jb2xsaXNpb25SZXNwb25zZTtcbiAgICB0aGlzLmNvbnZleEhlaWdodGZpZWxkKHNpLmNvbnZleFBvbHloZWRyb25SZXByZXNlbnRhdGlvbixzaix4aSx4aixxaSxxaixiaSxiaik7XG59O1xuXG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4SGVpZ2h0ZmllbGRfdG1wMiA9IG5ldyBWZWMzKCk7XG52YXIgY29udmV4SGVpZ2h0ZmllbGRfZmFjZUxpc3QgPSBbMF07XG5cbi8qKlxuICogQG1ldGhvZCBjb252ZXhIZWlnaHRmaWVsZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuQ09OVkVYUE9MWUhFRFJPTiB8IFNoYXBlLnR5cGVzLkhFSUdIVEZJRUxEXSA9XG5OYXJyb3dwaGFzZS5wcm90b3R5cGUuY29udmV4SGVpZ2h0ZmllbGQgPSBmdW5jdGlvbiAoXG4gICAgY29udmV4U2hhcGUsXG4gICAgaGZTaGFwZSxcbiAgICBjb252ZXhQb3MsXG4gICAgaGZQb3MsXG4gICAgY29udmV4UXVhdCxcbiAgICBoZlF1YXQsXG4gICAgY29udmV4Qm9keSxcbiAgICBoZkJvZHlcbil7XG4gICAgdmFyIGRhdGEgPSBoZlNoYXBlLmRhdGEsXG4gICAgICAgIHcgPSBoZlNoYXBlLmVsZW1lbnRTaXplLFxuICAgICAgICByYWRpdXMgPSBjb252ZXhTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cyxcbiAgICAgICAgd29ybGRQaWxsYXJPZmZzZXQgPSBjb252ZXhIZWlnaHRmaWVsZF90bXAyLFxuICAgICAgICBmYWNlTGlzdCA9IGNvbnZleEhlaWdodGZpZWxkX2ZhY2VMaXN0O1xuXG4gICAgLy8gR2V0IHNwaGVyZSBwb3NpdGlvbiB0byBoZWlnaHRmaWVsZCBsb2NhbCFcbiAgICB2YXIgbG9jYWxDb252ZXhQb3MgPSBjb252ZXhIZWlnaHRmaWVsZF90bXAxO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBjb252ZXhQb3MsIGxvY2FsQ29udmV4UG9zKTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsQ29udmV4UG9zLnggLSByYWRpdXMpIC8gdykgLSAxLFxuICAgICAgICBpTWF4WCA9IE1hdGguY2VpbCgobG9jYWxDb252ZXhQb3MueCArIHJhZGl1cykgLyB3KSArIDEsXG4gICAgICAgIGlNaW5ZID0gTWF0aC5mbG9vcigobG9jYWxDb252ZXhQb3MueSAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgIGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbENvbnZleFBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTtcblxuICAgIC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cbiAgICBpZihpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1pblkgPiBkYXRhWzBdLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGFtcCBpbmRleCB0byBlZGdlc1xuICAgIGlmKGlNaW5YIDwgMCl7IGlNaW5YID0gMDsgfVxuICAgIGlmKGlNYXhYIDwgMCl7IGlNYXhYID0gMDsgfVxuICAgIGlmKGlNaW5ZIDwgMCl7IGlNaW5ZID0gMDsgfVxuICAgIGlmKGlNYXhZIDwgMCl7IGlNYXhZID0gMDsgfVxuICAgIGlmKGlNaW5YID49IGRhdGEubGVuZ3RoKXsgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICBpZihpTWF4WCA+PSBkYXRhLmxlbmd0aCl7IGlNYXhYID0gZGF0YS5sZW5ndGggLSAxOyB9XG4gICAgaWYoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuICAgIGlmKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cblxuICAgIHZhciBtaW5NYXggPSBbXTtcbiAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XG4gICAgdmFyIG1pbiA9IG1pbk1heFswXTtcbiAgICB2YXIgbWF4ID0gbWluTWF4WzFdO1xuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgY2FudCB0b3VjaCB0aGUgYm91bmRpbmcgaGVpZ2h0IGJveFxuICAgIGlmKGxvY2FsQ29udmV4UG9zLnogLSByYWRpdXMgPiBtYXggfHwgbG9jYWxDb252ZXhQb3MueiArIHJhZGl1cyA8IG1pbil7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IodmFyIGkgPSBpTWluWDsgaSA8IGlNYXhYOyBpKyspe1xuICAgICAgICBmb3IodmFyIGogPSBpTWluWTsgaiA8IGlNYXhZOyBqKyspe1xuXG4gICAgICAgICAgICAvLyBMb3dlciB0cmlhbmdsZVxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCBmYWxzZSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm0ucG9pbnRUb1dvcmxkRnJhbWUoaGZQb3MsIGhmUXVhdCwgaGZTaGFwZS5waWxsYXJPZmZzZXQsIHdvcmxkUGlsbGFyT2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChjb252ZXhQb3MuZGlzdGFuY2VUbyh3b3JsZFBpbGxhck9mZnNldCkgPCBoZlNoYXBlLnBpbGxhckNvbnZleC5ib3VuZGluZ1NwaGVyZVJhZGl1cyArIGNvbnZleFNoYXBlLmJvdW5kaW5nU3BoZXJlUmFkaXVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb252ZXhDb252ZXgoY29udmV4U2hhcGUsIGhmU2hhcGUucGlsbGFyQ29udmV4LCBjb252ZXhQb3MsIHdvcmxkUGlsbGFyT2Zmc2V0LCBjb252ZXhRdWF0LCBoZlF1YXQsIGNvbnZleEJvZHksIGhmQm9keSwgbnVsbCwgbnVsbCwgZmFjZUxpc3QsIG51bGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcHBlciB0cmlhbmdsZVxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGNvbnZleFBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgY29udmV4U2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnZleENvbnZleChjb252ZXhTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIGNvbnZleFBvcywgd29ybGRQaWxsYXJPZmZzZXQsIGNvbnZleFF1YXQsIGhmUXVhdCwgY29udmV4Qm9keSwgaGZCb2R5LCBudWxsLCBudWxsLCBmYWNlTGlzdCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMSA9IG5ldyBWZWMzKCk7XG52YXIgc3BoZXJlSGVpZ2h0ZmllbGRfdG1wMiA9IG5ldyBWZWMzKCk7XG5cbi8qKlxuICogQG1ldGhvZCBzcGhlcmVIZWlnaHRmaWVsZFxuICovXG5OYXJyb3dwaGFzZS5wcm90b3R5cGVbU2hhcGUudHlwZXMuU1BIRVJFIHwgU2hhcGUudHlwZXMuSEVJR0hURklFTERdID1cbk5hcnJvd3BoYXNlLnByb3RvdHlwZS5zcGhlcmVIZWlnaHRmaWVsZCA9IGZ1bmN0aW9uIChcbiAgICBzcGhlcmVTaGFwZSxcbiAgICBoZlNoYXBlLFxuICAgIHNwaGVyZVBvcyxcbiAgICBoZlBvcyxcbiAgICBzcGhlcmVRdWF0LFxuICAgIGhmUXVhdCxcbiAgICBzcGhlcmVCb2R5LFxuICAgIGhmQm9keVxuKXtcbiAgICB2YXIgZGF0YSA9IGhmU2hhcGUuZGF0YSxcbiAgICAgICAgcmFkaXVzID0gc3BoZXJlU2hhcGUucmFkaXVzLFxuICAgICAgICB3ID0gaGZTaGFwZS5lbGVtZW50U2l6ZSxcbiAgICAgICAgd29ybGRQaWxsYXJPZmZzZXQgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAyO1xuXG4gICAgLy8gR2V0IHNwaGVyZSBwb3NpdGlvbiB0byBoZWlnaHRmaWVsZCBsb2NhbCFcbiAgICB2YXIgbG9jYWxTcGhlcmVQb3MgPSBzcGhlcmVIZWlnaHRmaWVsZF90bXAxO1xuICAgIFRyYW5zZm9ybS5wb2ludFRvTG9jYWxGcmFtZShoZlBvcywgaGZRdWF0LCBzcGhlcmVQb3MsIGxvY2FsU3BoZXJlUG9zKTtcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRhdGEgcG9pbnRzIHRvIHRlc3QgYWdhaW5zdFxuICAgIHZhciBpTWluWCA9IE1hdGguZmxvb3IoKGxvY2FsU3BoZXJlUG9zLnggLSByYWRpdXMpIC8gdykgLSAxLFxuICAgICAgICBpTWF4WCA9IE1hdGguY2VpbCgobG9jYWxTcGhlcmVQb3MueCArIHJhZGl1cykgLyB3KSArIDEsXG4gICAgICAgIGlNaW5ZID0gTWF0aC5mbG9vcigobG9jYWxTcGhlcmVQb3MueSAtIHJhZGl1cykgLyB3KSAtIDEsXG4gICAgICAgIGlNYXhZID0gTWF0aC5jZWlsKChsb2NhbFNwaGVyZVBvcy55ICsgcmFkaXVzKSAvIHcpICsgMTtcblxuICAgIC8vIEJhaWwgb3V0IGlmIHdlIGFyZSBvdXQgb2YgdGhlIHRlcnJhaW5cbiAgICBpZihpTWF4WCA8IDAgfHwgaU1heFkgPCAwIHx8IGlNaW5YID4gZGF0YS5sZW5ndGggfHwgaU1heFkgPiBkYXRhWzBdLmxlbmd0aCl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDbGFtcCBpbmRleCB0byBlZGdlc1xuICAgIGlmKGlNaW5YIDwgMCl7IGlNaW5YID0gMDsgfVxuICAgIGlmKGlNYXhYIDwgMCl7IGlNYXhYID0gMDsgfVxuICAgIGlmKGlNaW5ZIDwgMCl7IGlNaW5ZID0gMDsgfVxuICAgIGlmKGlNYXhZIDwgMCl7IGlNYXhZID0gMDsgfVxuICAgIGlmKGlNaW5YID49IGRhdGEubGVuZ3RoKXsgaU1pblggPSBkYXRhLmxlbmd0aCAtIDE7IH1cbiAgICBpZihpTWF4WCA+PSBkYXRhLmxlbmd0aCl7IGlNYXhYID0gZGF0YS5sZW5ndGggLSAxOyB9XG4gICAgaWYoaU1heFkgPj0gZGF0YVswXS5sZW5ndGgpeyBpTWF4WSA9IGRhdGFbMF0ubGVuZ3RoIC0gMTsgfVxuICAgIGlmKGlNaW5ZID49IGRhdGFbMF0ubGVuZ3RoKXsgaU1pblkgPSBkYXRhWzBdLmxlbmd0aCAtIDE7IH1cblxuICAgIHZhciBtaW5NYXggPSBbXTtcbiAgICBoZlNoYXBlLmdldFJlY3RNaW5NYXgoaU1pblgsIGlNaW5ZLCBpTWF4WCwgaU1heFksIG1pbk1heCk7XG4gICAgdmFyIG1pbiA9IG1pbk1heFswXTtcbiAgICB2YXIgbWF4ID0gbWluTWF4WzFdO1xuXG4gICAgLy8gQmFpbCBvdXQgaWYgd2UncmUgY2FudCB0b3VjaCB0aGUgYm91bmRpbmcgaGVpZ2h0IGJveFxuICAgIGlmKGxvY2FsU3BoZXJlUG9zLnogLSByYWRpdXMgPiBtYXggfHwgbG9jYWxTcGhlcmVQb3MueiArIHJhZGl1cyA8IG1pbil7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHQ7XG4gICAgZm9yKHZhciBpID0gaU1pblg7IGkgPCBpTWF4WDsgaSsrKXtcbiAgICAgICAgZm9yKHZhciBqID0gaU1pblk7IGogPCBpTWF4WTsgaisrKXtcblxuICAgICAgICAgICAgdmFyIG51bUNvbnRhY3RzQmVmb3JlID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgICAgICAgLy8gTG93ZXIgdHJpYW5nbGVcbiAgICAgICAgICAgIGhmU2hhcGUuZ2V0Q29udmV4VHJpYW5nbGVQaWxsYXIoaSwgaiwgZmFsc2UpO1xuICAgICAgICAgICAgVHJhbnNmb3JtLnBvaW50VG9Xb3JsZEZyYW1lKGhmUG9zLCBoZlF1YXQsIGhmU2hhcGUucGlsbGFyT2Zmc2V0LCB3b3JsZFBpbGxhck9mZnNldCk7XG4gICAgICAgICAgICBpZiAoc3BoZXJlUG9zLmRpc3RhbmNlVG8od29ybGRQaWxsYXJPZmZzZXQpIDwgaGZTaGFwZS5waWxsYXJDb252ZXguYm91bmRpbmdTcGhlcmVSYWRpdXMgKyBzcGhlcmVTaGFwZS5ib3VuZGluZ1NwaGVyZVJhZGl1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3BoZXJlQ29udmV4KHNwaGVyZVNoYXBlLCBoZlNoYXBlLnBpbGxhckNvbnZleCwgc3BoZXJlUG9zLCB3b3JsZFBpbGxhck9mZnNldCwgc3BoZXJlUXVhdCwgaGZRdWF0LCBzcGhlcmVCb2R5LCBoZkJvZHkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVcHBlciB0cmlhbmdsZVxuICAgICAgICAgICAgaGZTaGFwZS5nZXRDb252ZXhUcmlhbmdsZVBpbGxhcihpLCBqLCB0cnVlKTtcbiAgICAgICAgICAgIFRyYW5zZm9ybS5wb2ludFRvV29ybGRGcmFtZShoZlBvcywgaGZRdWF0LCBoZlNoYXBlLnBpbGxhck9mZnNldCwgd29ybGRQaWxsYXJPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHNwaGVyZVBvcy5kaXN0YW5jZVRvKHdvcmxkUGlsbGFyT2Zmc2V0KSA8IGhmU2hhcGUucGlsbGFyQ29udmV4LmJvdW5kaW5nU3BoZXJlUmFkaXVzICsgc3BoZXJlU2hhcGUuYm91bmRpbmdTcGhlcmVSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNwaGVyZUNvbnZleChzcGhlcmVTaGFwZSwgaGZTaGFwZS5waWxsYXJDb252ZXgsIHNwaGVyZVBvcywgd29ybGRQaWxsYXJPZmZzZXQsIHNwaGVyZVF1YXQsIGhmUXVhdCwgc3BoZXJlQm9keSwgaGZCb2R5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG51bUNvbnRhY3RzID0gcmVzdWx0Lmxlbmd0aCAtIG51bUNvbnRhY3RzQmVmb3JlO1xuXG4gICAgICAgICAgICBpZihudW1Db250YWN0cyA+IDIpe1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAvLyBTa2lwIGFsbCBidXQgMVxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBudW1Db250YWN0cyAtIDE7IGsrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG59LHtcIi4uL2NvbGxpc2lvbi9BQUJCXCI6MyxcIi4uL2NvbGxpc2lvbi9SYXlcIjo5LFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjE5LFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMSxcIi4uL21hdGgvUXVhdGVybmlvblwiOjI4LFwiLi4vbWF0aC9UcmFuc2Zvcm1cIjoyOSxcIi4uL21hdGgvVmVjM1wiOjMwLFwiLi4vc2hhcGVzL0NvbnZleFBvbHloZWRyb25cIjozOCxcIi4uL3NoYXBlcy9TaGFwZVwiOjQzLFwiLi4vc29sdmVyL1NvbHZlclwiOjQ3LFwiLi4vdXRpbHMvVmVjM1Bvb2xcIjo1NH1dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIGdsb2JhbCBwZXJmb3JtYW5jZSAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdvcmxkO1xuXG52YXIgU2hhcGUgPSBfZGVyZXFfKCcuLi9zaGFwZXMvU2hhcGUnKTtcbnZhciBWZWMzID0gX2RlcmVxXygnLi4vbWF0aC9WZWMzJyk7XG52YXIgUXVhdGVybmlvbiA9IF9kZXJlcV8oJy4uL21hdGgvUXVhdGVybmlvbicpO1xudmFyIEdTU29sdmVyID0gX2RlcmVxXygnLi4vc29sdmVyL0dTU29sdmVyJyk7XG52YXIgVmVjM1Bvb2wgPSBfZGVyZXFfKCcuLi91dGlscy9WZWMzUG9vbCcpO1xudmFyIENvbnRhY3RFcXVhdGlvbiA9IF9kZXJlcV8oJy4uL2VxdWF0aW9ucy9Db250YWN0RXF1YXRpb24nKTtcbnZhciBGcmljdGlvbkVxdWF0aW9uID0gX2RlcmVxXygnLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb24nKTtcbnZhciBOYXJyb3dwaGFzZSA9IF9kZXJlcV8oJy4vTmFycm93cGhhc2UnKTtcbnZhciBFdmVudFRhcmdldCA9IF9kZXJlcV8oJy4uL3V0aWxzL0V2ZW50VGFyZ2V0Jyk7XG52YXIgQXJyYXlDb2xsaXNpb25NYXRyaXggPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQXJyYXlDb2xsaXNpb25NYXRyaXgnKTtcbnZhciBNYXRlcmlhbCA9IF9kZXJlcV8oJy4uL21hdGVyaWFsL01hdGVyaWFsJyk7XG52YXIgQ29udGFjdE1hdGVyaWFsID0gX2RlcmVxXygnLi4vbWF0ZXJpYWwvQ29udGFjdE1hdGVyaWFsJyk7XG52YXIgQm9keSA9IF9kZXJlcV8oJy4uL29iamVjdHMvQm9keScpO1xudmFyIFR1cGxlRGljdGlvbmFyeSA9IF9kZXJlcV8oJy4uL3V0aWxzL1R1cGxlRGljdGlvbmFyeScpO1xudmFyIFJheWNhc3RSZXN1bHQgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdCcpO1xudmFyIEFBQkIgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vQUFCQicpO1xudmFyIFJheSA9IF9kZXJlcV8oJy4uL2NvbGxpc2lvbi9SYXknKTtcbnZhciBOYWl2ZUJyb2FkcGhhc2UgPSBfZGVyZXFfKCcuLi9jb2xsaXNpb24vTmFpdmVCcm9hZHBoYXNlJyk7XG5cbi8qKlxuICogVGhlIHBoeXNpY3Mgd29ybGRcbiAqIEBjbGFzcyBXb3JsZFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudFRhcmdldFxuICovXG5mdW5jdGlvbiBXb3JsZCgpe1xuICAgIEV2ZW50VGFyZ2V0LmFwcGx5KHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQ3VycmVudGx5IC8gbGFzdCB1c2VkIHRpbWVzdGVwLiBJcyBzZXQgdG8gLTEgaWYgbm90IGF2YWlsYWJsZS4gVGhpcyB2YWx1ZSBpcyB1cGRhdGVkIGJlZm9yZSBlYWNoIGludGVybmFsIHN0ZXAsIHdoaWNoIG1lYW5zIHRoYXQgaXQgaXMgXCJmcmVzaFwiIGluc2lkZSBldmVudCBjYWxsYmFja3MuXG4gICAgICogQHByb3BlcnR5IHtOdW1iZXJ9IGR0XG4gICAgICovXG4gICAgdGhpcy5kdCA9IC0xO1xuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYm9kaWVzIGdvIHRvIHNsZWVwIHdoZW4gdGhleSd2ZSBiZWVuIGluYWN0aXZlXG4gICAgICogQHByb3BlcnR5IGFsbG93U2xlZXBcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmFsbG93U2xlZXAgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEFsbCB0aGUgY3VycmVudCBjb250YWN0cyAoaW5zdGFuY2VzIG9mIENvbnRhY3RFcXVhdGlvbikgaW4gdGhlIHdvcmxkLlxuICAgICAqIEBwcm9wZXJ0eSBjb250YWN0c1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RzID0gW107XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogSG93IG9mdGVuIHRvIG5vcm1hbGl6ZSBxdWF0ZXJuaW9ucy4gU2V0IHRvIDAgZm9yIGV2ZXJ5IHN0ZXAsIDEgZm9yIGV2ZXJ5IHNlY29uZCBldGMuLiBBIGxhcmdlciB2YWx1ZSBpbmNyZWFzZXMgcGVyZm9ybWFuY2UuIElmIGJvZGllcyB0ZW5kIHRvIGV4cGxvZGUsIHNldCB0byBhIHNtYWxsZXIgdmFsdWUgKHplcm8gdG8gYmUgc3VyZSBub3RoaW5nIGNhbiBnbyB3cm9uZykuXG4gICAgICogQHByb3BlcnR5IHF1YXROb3JtYWxpemVTa2lwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnF1YXROb3JtYWxpemVTa2lwID0gMDtcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIHVzZSBmYXN0IHF1YXRlcm5pb24gbm9ybWFsaXphdGlvbi4gSXQgaXMgb2Z0ZW4gZW5vdWdoIGFjY3VyYXRlIHRvIHVzZS4gSWYgYm9kaWVzIHRlbmQgdG8gZXhwbG9kZSwgc2V0IHRvIGZhbHNlLlxuICAgICAqIEBwcm9wZXJ0eSBxdWF0Tm9ybWFsaXplRmFzdFxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBzZWUgUXVhdGVybmlvbi5ub3JtYWxpemVGYXN0XG4gICAgICogQHNlZSBRdWF0ZXJuaW9uLm5vcm1hbGl6ZVxuICAgICAqL1xuICAgIHRoaXMucXVhdE5vcm1hbGl6ZUZhc3QgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB3YWxsLWNsb2NrIHRpbWUgc2luY2Ugc2ltdWxhdGlvbiBzdGFydFxuICAgICAqIEBwcm9wZXJ0eSB0aW1lXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnRpbWUgPSAwLjA7XG5cbiAgICAvKipcbiAgICAgKiBOdW1iZXIgb2YgdGltZXN0ZXBzIHRha2VuIHNpbmNlIHN0YXJ0XG4gICAgICogQHByb3BlcnR5IHN0ZXBudW1iZXJcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuc3RlcG51bWJlciA9IDA7XG5cbiAgICAvLy8gRGVmYXVsdCBhbmQgbGFzdCB0aW1lc3RlcCBzaXplc1xuICAgIHRoaXMuZGVmYXVsdF9kdCA9IDEvNjA7XG5cbiAgICB0aGlzLm5leHRJZCA9IDA7XG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGdyYXZpdHlcbiAgICAgKiBAdHlwZSB7VmVjM31cbiAgICAgKi9cbiAgICB0aGlzLmdyYXZpdHkgPSBuZXcgVmVjMygpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGJyb2FkcGhhc2VcbiAgICAgKiBAdHlwZSB7QnJvYWRwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLmJyb2FkcGhhc2UgPSBuZXcgTmFpdmVCcm9hZHBoYXNlKCk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgYm9kaWVzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuYm9kaWVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgc29sdmVyXG4gICAgICogQHR5cGUge1NvbHZlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNvbHZlciA9IG5ldyBHU1NvbHZlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnN0cmFpbnRzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuY29uc3RyYWludHMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBuYXJyb3dwaGFzZVxuICAgICAqIEB0eXBlIHtOYXJyb3dwaGFzZX1cbiAgICAgKi9cbiAgICB0aGlzLm5hcnJvd3BoYXNlID0gbmV3IE5hcnJvd3BoYXNlKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtBcnJheUNvbGxpc2lvbk1hdHJpeH0gY29sbGlzaW9uTWF0cml4XG5cdCAqIEB0eXBlIHtBcnJheUNvbGxpc2lvbk1hdHJpeH1cblx0ICovXG5cdHRoaXMuY29sbGlzaW9uTWF0cml4ID0gbmV3IEFycmF5Q29sbGlzaW9uTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBDb2xsaXNpb25NYXRyaXggZnJvbSB0aGUgcHJldmlvdXMgc3RlcC5cbiAgICAgKiBAcHJvcGVydHkge0FycmF5Q29sbGlzaW9uTWF0cml4fSBjb2xsaXNpb25NYXRyaXhQcmV2aW91c1xuXHQgKiBAdHlwZSB7QXJyYXlDb2xsaXNpb25NYXRyaXh9XG5cdCAqL1xuXHR0aGlzLmNvbGxpc2lvbk1hdHJpeFByZXZpb3VzID0gbmV3IEFycmF5Q29sbGlzaW9uTWF0cml4KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbGwgYWRkZWQgbWF0ZXJpYWxzXG4gICAgICogQHByb3BlcnR5IG1hdGVyaWFsc1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLm1hdGVyaWFscyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IGNvbnRhY3RtYXRlcmlhbHNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGxvb2sgdXAgYSBDb250YWN0TWF0ZXJpYWwgZ2l2ZW4gdHdvIGluc3RhbmNlcyBvZiBNYXRlcmlhbC5cbiAgICAgKiBAcHJvcGVydHkge1R1cGxlRGljdGlvbmFyeX0gY29udGFjdE1hdGVyaWFsVGFibGVcbiAgICAgKi9cbiAgICB0aGlzLmNvbnRhY3RNYXRlcmlhbFRhYmxlID0gbmV3IFR1cGxlRGljdGlvbmFyeSgpO1xuXG4gICAgdGhpcy5kZWZhdWx0TWF0ZXJpYWwgPSBuZXcgTWF0ZXJpYWwoXCJkZWZhdWx0XCIpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBjb250YWN0IG1hdGVyaWFsIGlzIHVzZWQgaWYgbm8gc3VpdGFibGUgY29udGFjdG1hdGVyaWFsIGlzIGZvdW5kIGZvciBhIGNvbnRhY3QuXG4gICAgICogQHByb3BlcnR5IGRlZmF1bHRDb250YWN0TWF0ZXJpYWxcbiAgICAgKiBAdHlwZSB7Q29udGFjdE1hdGVyaWFsfVxuICAgICAqL1xuICAgIHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbCA9IG5ldyBDb250YWN0TWF0ZXJpYWwodGhpcy5kZWZhdWx0TWF0ZXJpYWwsIHRoaXMuZGVmYXVsdE1hdGVyaWFsLCB7IGZyaWN0aW9uOiAwLjMsIHJlc3RpdHV0aW9uOiAwLjAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgZG9Qcm9maWxpbmdcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmRvUHJvZmlsaW5nID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkgcHJvZmlsZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5wcm9maWxlID0ge1xuICAgICAgICBzb2x2ZTowLFxuICAgICAgICBtYWtlQ29udGFjdENvbnN0cmFpbnRzOjAsXG4gICAgICAgIGJyb2FkcGhhc2U6MCxcbiAgICAgICAgaW50ZWdyYXRlOjAsXG4gICAgICAgIG5hcnJvd3BoYXNlOjAsXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSBzdWJzeXN0ZW1zXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuc3Vic3lzdGVtcyA9IFtdO1xuXG4gICAgdGhpcy5hZGRCb2R5RXZlbnQgPSB7XG4gICAgICAgIHR5cGU6XCJhZGRCb2R5XCIsXG4gICAgICAgIGJvZHkgOiBudWxsLFxuICAgIH07XG5cbiAgICB0aGlzLnJlbW92ZUJvZHlFdmVudCA9IHtcbiAgICAgICAgdHlwZTpcInJlbW92ZUJvZHlcIixcbiAgICAgICAgYm9keSA6IG51bGwsXG4gICAgfTtcbn1cbldvcmxkLnByb3RvdHlwZSA9IG5ldyBFdmVudFRhcmdldCgpO1xuXG4vLyBUZW1wIHN0dWZmXG52YXIgdG1wQUFCQjEgPSBuZXcgQUFCQigpO1xudmFyIHRtcEFycmF5MSA9IFtdO1xudmFyIHRtcFJheSA9IG5ldyBSYXkoKTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbnRhY3QgbWF0ZXJpYWwgYmV0d2VlbiBtYXRlcmlhbHMgbTEgYW5kIG0yXG4gKiBAbWV0aG9kIGdldENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtNYXRlcmlhbH0gbTFcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG0yXG4gKiBAcmV0dXJuIHtDb250YWN0TWF0ZXJpYWx9IFRoZSBjb250YWN0IG1hdGVyaWFsIGlmIGl0IHdhcyBmb3VuZC5cbiAqL1xuV29ybGQucHJvdG90eXBlLmdldENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKG0xLG0yKXtcbiAgICByZXR1cm4gdGhpcy5jb250YWN0TWF0ZXJpYWxUYWJsZS5nZXQobTEuaWQsbTIuaWQpOyAvL3RoaXMuY29udGFjdG1hdGVyaWFsc1t0aGlzLm1hdHMyY21hdFtpK2oqdGhpcy5tYXRlcmlhbHMubGVuZ3RoXV07XG59O1xuXG4vKipcbiAqIEdldCBudW1iZXIgb2Ygb2JqZWN0cyBpbiB0aGUgd29ybGQuXG4gKiBAbWV0aG9kIG51bU9iamVjdHNcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBkZXByZWNhdGVkXG4gKi9cbldvcmxkLnByb3RvdHlwZS5udW1PYmplY3RzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5ib2RpZXMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBTdG9yZSBvbGQgY29sbGlzaW9uIHN0YXRlIGluZm9cbiAqIEBtZXRob2QgY29sbGlzaW9uTWF0cml4VGlja1xuICovXG5Xb3JsZC5wcm90b3R5cGUuY29sbGlzaW9uTWF0cml4VGljayA9IGZ1bmN0aW9uKCl7XG5cdHZhciB0ZW1wID0gdGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cztcblx0dGhpcy5jb2xsaXNpb25NYXRyaXhQcmV2aW91cyA9IHRoaXMuY29sbGlzaW9uTWF0cml4O1xuXHR0aGlzLmNvbGxpc2lvbk1hdHJpeCA9IHRlbXA7XG5cdHRoaXMuY29sbGlzaW9uTWF0cml4LnJlc2V0KCk7XG59O1xuXG4vKipcbiAqIEFkZCBhIHJpZ2lkIGJvZHkgdG8gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtIHtCb2R5fSBib2R5XG4gKiBAdG9kbyBJZiB0aGUgc2ltdWxhdGlvbiBoYXMgbm90IHlldCBzdGFydGVkLCB3aHkgcmVjcmV0ZSBhbmQgY29weSBhcnJheXMgZm9yIGVhY2ggYm9keT8gQWNjdW11bGF0ZSBpbiBkeW5hbWljIGFycmF5cyBpbiB0aGlzIGNhc2UuXG4gKiBAdG9kbyBBZGRpbmcgYW4gYXJyYXkgb2YgYm9kaWVzIHNob3VsZCBiZSBwb3NzaWJsZS4gVGhpcyB3b3VsZCBzYXZlIHNvbWUgbG9vcHMgdG9vXG4gKiBAZGVwcmVjYXRlZCBVc2UgLmFkZEJvZHkgaW5zdGVhZFxuICovXG5Xb3JsZC5wcm90b3R5cGUuYWRkID0gV29ybGQucHJvdG90eXBlLmFkZEJvZHkgPSBmdW5jdGlvbihib2R5KXtcbiAgICBpZih0aGlzLmJvZGllcy5pbmRleE9mKGJvZHkpICE9PSAtMSl7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYm9keS5pbmRleCA9IHRoaXMuYm9kaWVzLmxlbmd0aDtcbiAgICB0aGlzLmJvZGllcy5wdXNoKGJvZHkpO1xuICAgIGJvZHkud29ybGQgPSB0aGlzO1xuICAgIGJvZHkuaW5pdFBvc2l0aW9uLmNvcHkoYm9keS5wb3NpdGlvbik7XG4gICAgYm9keS5pbml0VmVsb2NpdHkuY29weShib2R5LnZlbG9jaXR5KTtcbiAgICBib2R5LnRpbWVMYXN0U2xlZXB5ID0gdGhpcy50aW1lO1xuICAgIGlmKGJvZHkgaW5zdGFuY2VvZiBCb2R5KXtcbiAgICAgICAgYm9keS5pbml0QW5ndWxhclZlbG9jaXR5LmNvcHkoYm9keS5hbmd1bGFyVmVsb2NpdHkpO1xuICAgICAgICBib2R5LmluaXRRdWF0ZXJuaW9uLmNvcHkoYm9keS5xdWF0ZXJuaW9uKTtcbiAgICB9XG5cdHRoaXMuY29sbGlzaW9uTWF0cml4LnNldE51bU9iamVjdHModGhpcy5ib2RpZXMubGVuZ3RoKTtcbiAgICB0aGlzLmFkZEJvZHlFdmVudC5ib2R5ID0gYm9keTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQodGhpcy5hZGRCb2R5RXZlbnQpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCBhZGRDb25zdHJhaW50XG4gKiBAcGFyYW0ge0NvbnN0cmFpbnR9IGNcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnN0cmFpbnQgPSBmdW5jdGlvbihjKXtcbiAgICB0aGlzLmNvbnN0cmFpbnRzLnB1c2goYyk7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBjb25zdHJhaW50XG4gKiBAbWV0aG9kIHJlbW92ZUNvbnN0cmFpbnRcbiAqIEBwYXJhbSB7Q29uc3RyYWludH0gY1xuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uKGMpe1xuICAgIHZhciBpZHggPSB0aGlzLmNvbnN0cmFpbnRzLmluZGV4T2YoYyk7XG4gICAgaWYoaWR4IT09LTEpe1xuICAgICAgICB0aGlzLmNvbnN0cmFpbnRzLnNwbGljZShpZHgsMSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSYXljYXN0IHRlc3RcbiAqIEBtZXRob2QgcmF5VGVzdFxuICogQHBhcmFtIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0ge1ZlYzN9IHRvXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFJheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQGRlcHJlY2F0ZWQgVXNlIC5yYXljYXN0QWxsLCAucmF5Y2FzdENsb3Nlc3Qgb3IgLnJheWNhc3RBbnkgaW5zdGVhZC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheVRlc3QgPSBmdW5jdGlvbihmcm9tLCB0bywgcmVzdWx0KXtcbiAgICBpZihyZXN1bHQgaW5zdGFuY2VvZiBSYXljYXN0UmVzdWx0KXtcbiAgICAgICAgLy8gRG8gcmF5Y2FzdGNsb3Nlc3RcbiAgICAgICAgdGhpcy5yYXljYXN0Q2xvc2VzdChmcm9tLCB0bywge1xuICAgICAgICAgICAgc2tpcEJhY2tmYWNlczogdHJ1ZVxuICAgICAgICB9LCByZXN1bHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvIHJheWNhc3RBbGxcbiAgICAgICAgdGhpcy5yYXljYXN0QWxsKGZyb20sIHRvLCB7XG4gICAgICAgICAgICBza2lwQmFja2ZhY2VzOiB0cnVlXG4gICAgICAgIH0sIHJlc3VsdCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSYXkgY2FzdCBhZ2FpbnN0IGFsbCBib2RpZXMuIFRoZSBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIGhpdCB3aXRoIGEgUmF5Y2FzdFJlc3VsdCBhcyBzaW5nbGUgYXJndW1lbnQuXG4gKiBAbWV0aG9kIHJheWNhc3RBbGxcbiAqIEBwYXJhbSAge1ZlYzN9IGZyb21cbiAqIEBwYXJhbSAge1ZlYzN9IHRvXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyTWFzaz0tMV1cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMuY29sbGlzaW9uRmlsdGVyR3JvdXA9LTFdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5za2lwQmFja2ZhY2VzPWZhbHNlXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuY2hlY2tDb2xsaXNpb25SZXNwb25zZT10cnVlXVxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFueSBib2R5IHdhcyBoaXQuXG4gKi9cbldvcmxkLnByb3RvdHlwZS5yYXljYXN0QWxsID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIGNhbGxiYWNrKXtcbiAgICBvcHRpb25zLm1vZGUgPSBSYXkuQUxMO1xuICAgIG9wdGlvbnMuZnJvbSA9IGZyb207XG4gICAgb3B0aW9ucy50byA9IHRvO1xuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICByZXR1cm4gdG1wUmF5LmludGVyc2VjdFdvcmxkKHRoaXMsIG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBSYXkgY2FzdCwgYW5kIHN0b3AgYXQgdGhlIGZpcnN0IHJlc3VsdC4gTm90ZSB0aGF0IHRoZSBvcmRlciBpcyByYW5kb20gLSBidXQgdGhlIG1ldGhvZCBpcyBmYXN0LlxuICogQG1ldGhvZCByYXljYXN0QW55XG4gKiBAcGFyYW0gIHtWZWMzfSBmcm9tXG4gKiBAcGFyYW0gIHtWZWMzfSB0b1xuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlck1hc2s9LTFdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLmNvbGxpc2lvbkZpbHRlckdyb3VwPS0xXVxuICogQHBhcmFtICB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcEJhY2tmYWNlcz1mYWxzZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLmNoZWNrQ29sbGlzaW9uUmVzcG9uc2U9dHJ1ZV1cbiAqIEBwYXJhbSAge1JheWNhc3RSZXN1bHR9IHJlc3VsdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbnkgYm9keSB3YXMgaGl0LlxuICovXG5Xb3JsZC5wcm90b3R5cGUucmF5Y2FzdEFueSA9IGZ1bmN0aW9uKGZyb20sIHRvLCBvcHRpb25zLCByZXN1bHQpe1xuICAgIG9wdGlvbnMubW9kZSA9IFJheS5BTlk7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmF5IGNhc3QsIGFuZCByZXR1cm4gaW5mb3JtYXRpb24gb2YgdGhlIGNsb3Nlc3QgaGl0LlxuICogQG1ldGhvZCByYXljYXN0Q2xvc2VzdFxuICogQHBhcmFtICB7VmVjM30gZnJvbVxuICogQHBhcmFtICB7VmVjM30gdG9cbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJNYXNrPS0xXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5jb2xsaXNpb25GaWx0ZXJHcm91cD0tMV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFtvcHRpb25zLnNraXBCYWNrZmFjZXM9ZmFsc2VdXG4gKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5jaGVja0NvbGxpc2lvblJlc3BvbnNlPXRydWVdXG4gKiBAcGFyYW0gIHtSYXljYXN0UmVzdWx0fSByZXN1bHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW55IGJvZHkgd2FzIGhpdC5cbiAqL1xuV29ybGQucHJvdG90eXBlLnJheWNhc3RDbG9zZXN0ID0gZnVuY3Rpb24oZnJvbSwgdG8sIG9wdGlvbnMsIHJlc3VsdCl7XG4gICAgb3B0aW9ucy5tb2RlID0gUmF5LkNMT1NFU1Q7XG4gICAgb3B0aW9ucy5mcm9tID0gZnJvbTtcbiAgICBvcHRpb25zLnRvID0gdG87XG4gICAgb3B0aW9ucy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgcmV0dXJuIHRtcFJheS5pbnRlcnNlY3RXb3JsZCh0aGlzLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGEgcmlnaWQgYm9keSBmcm9tIHRoZSBzaW11bGF0aW9uLlxuICogQG1ldGhvZCByZW1vdmVcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICogQGRlcHJlY2F0ZWQgVXNlIC5yZW1vdmVCb2R5IGluc3RlYWRcbiAqL1xuV29ybGQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGJvZHkpe1xuICAgIGJvZHkud29ybGQgPSBudWxsO1xuICAgIHZhciBuID0gdGhpcy5ib2RpZXMubGVuZ3RoLTEsXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYm9kaWVzLFxuICAgICAgICBpZHggPSBib2RpZXMuaW5kZXhPZihib2R5KTtcbiAgICBpZihpZHggIT09IC0xKXtcbiAgICAgICAgYm9kaWVzLnNwbGljZShpZHgsIDEpOyAvLyBUb2RvOiBzaG91bGQgdXNlIGEgZ2FyYmFnZSBmcmVlIG1ldGhvZFxuXG4gICAgICAgIC8vIFJlY29tcHV0ZSBpbmRleFxuICAgICAgICBmb3IodmFyIGk9MDsgaSE9PWJvZGllcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uaW5kZXggPSBpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb2xsaXNpb25NYXRyaXguc2V0TnVtT2JqZWN0cyhuKTtcbiAgICAgICAgdGhpcy5yZW1vdmVCb2R5RXZlbnQuYm9keSA9IGJvZHk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLnJlbW92ZUJvZHlFdmVudCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgYSByaWdpZCBib2R5IGZyb20gdGhlIHNpbXVsYXRpb24uXG4gKiBAbWV0aG9kIHJlbW92ZUJvZHlcbiAqIEBwYXJhbSB7Qm9keX0gYm9keVxuICovXG5Xb3JsZC5wcm90b3R5cGUucmVtb3ZlQm9keSA9IFdvcmxkLnByb3RvdHlwZS5yZW1vdmU7XG5cbi8qKlxuICogQWRkcyBhIG1hdGVyaWFsIHRvIHRoZSBXb3JsZC5cbiAqIEBtZXRob2QgYWRkTWF0ZXJpYWxcbiAqIEBwYXJhbSB7TWF0ZXJpYWx9IG1cbiAqIEB0b2RvIE5lY2Vzc2FyeT9cbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZE1hdGVyaWFsID0gZnVuY3Rpb24obSl7XG4gICAgdGhpcy5tYXRlcmlhbHMucHVzaChtKTtcbn07XG5cbi8qKlxuICogQWRkcyBhIGNvbnRhY3QgbWF0ZXJpYWwgdG8gdGhlIFdvcmxkXG4gKiBAbWV0aG9kIGFkZENvbnRhY3RNYXRlcmlhbFxuICogQHBhcmFtIHtDb250YWN0TWF0ZXJpYWx9IGNtYXRcbiAqL1xuV29ybGQucHJvdG90eXBlLmFkZENvbnRhY3RNYXRlcmlhbCA9IGZ1bmN0aW9uKGNtYXQpIHtcblxuICAgIC8vIEFkZCBjb250YWN0IG1hdGVyaWFsXG4gICAgdGhpcy5jb250YWN0bWF0ZXJpYWxzLnB1c2goY21hdCk7XG5cbiAgICAvLyBBZGQgY3VycmVudCBjb250YWN0IG1hdGVyaWFsIHRvIHRoZSBtYXRlcmlhbCB0YWJsZVxuICAgIHRoaXMuY29udGFjdE1hdGVyaWFsVGFibGUuc2V0KGNtYXQubWF0ZXJpYWxzWzBdLmlkLGNtYXQubWF0ZXJpYWxzWzFdLmlkLGNtYXQpO1xufTtcblxuLy8gcGVyZm9ybWFuY2Uubm93KClcbmlmKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcpe1xuICAgIHBlcmZvcm1hbmNlID0ge307XG59XG5pZighcGVyZm9ybWFuY2Uubm93KXtcbiAgICB2YXIgbm93T2Zmc2V0ID0gRGF0ZS5ub3coKTtcbiAgICBpZiAocGVyZm9ybWFuY2UudGltaW5nICYmIHBlcmZvcm1hbmNlLnRpbWluZy5uYXZpZ2F0aW9uU3RhcnQpe1xuICAgICAgICBub3dPZmZzZXQgPSBwZXJmb3JtYW5jZS50aW1pbmcubmF2aWdhdGlvblN0YXJ0O1xuICAgIH1cbiAgICBwZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIG5vd09mZnNldDtcbiAgICB9O1xufVxuXG52YXIgc3RlcF90bXAxID0gbmV3IFZlYzMoKTtcblxuLyoqXG4gKiBTdGVwIHRoZSBwaHlzaWNzIHdvcmxkIGZvcndhcmQgaW4gdGltZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIG1vZGVzLiBUaGUgc2ltcGxlIG1vZGUgaXMgZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvbi4gSW4gdGhpcyBjYXNlIHlvdSBvbmx5IHVzZSB0aGUgZmlyc3QgYXJndW1lbnQuIFRoZSBzZWNvbmQgY2FzZSB1c2VzIGludGVycG9sYXRpb24uIEluIHRoYXQgeW91IGFsc28gcHJvdmlkZSB0aGUgdGltZSBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgdXNlZCwgYXMgd2VsbCBhcyB0aGUgbWF4aW11bSBmaXhlZCB0aW1lc3RlcHMgdG8gdGFrZS5cbiAqXG4gKiBAbWV0aG9kIHN0ZXBcbiAqIEBwYXJhbSB7TnVtYmVyfSBkdCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGZpeGVkIHRpbWUgc3RlcCBzaXplIHRvIHVzZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZVNpbmNlTGFzdENhbGxlZF0gICAgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgZnVuY3Rpb24gd2FzIGxhc3QgY2FsbGVkLlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTdWJTdGVwcz0xMF0gICAgICAgICBNYXhpbXVtIG51bWJlciBvZiBmaXhlZCBzdGVwcyB0byB0YWtlIHBlciBmdW5jdGlvbiBjYWxsLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgICAgLy8gZml4ZWQgdGltZXN0ZXBwaW5nIHdpdGhvdXQgaW50ZXJwb2xhdGlvblxuICogICAgIHdvcmxkLnN0ZXAoMS82MCk7XG4gKlxuICogQHNlZSBodHRwOi8vYnVsbGV0cGh5c2ljcy5vcmcvbWVkaWF3aWtpLTEuNS44L2luZGV4LnBocC9TdGVwcGluZ19UaGVfV29ybGRcbiAqL1xuV29ybGQucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbihkdCwgdGltZVNpbmNlTGFzdENhbGxlZCwgbWF4U3ViU3RlcHMpe1xuICAgIG1heFN1YlN0ZXBzID0gbWF4U3ViU3RlcHMgfHwgMTA7XG4gICAgdGltZVNpbmNlTGFzdENhbGxlZCA9IHRpbWVTaW5jZUxhc3RDYWxsZWQgfHwgMDtcblxuICAgIGlmKHRpbWVTaW5jZUxhc3RDYWxsZWQgPT09IDApeyAvLyBGaXhlZCwgc2ltcGxlIHN0ZXBwaW5nXG5cbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuXG4gICAgICAgIC8vIEluY3JlbWVudCB0aW1lXG4gICAgICAgIHRoaXMudGltZSArPSBkdDtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIGZpeGVkIHN0ZXBzIHdlIHNob3VsZCBoYXZlIHRha2VuIHNpbmNlIHRoZSBsYXN0IHN0ZXBcbiAgICAgICAgdmFyIGludGVybmFsU3RlcHMgPSBNYXRoLmZsb29yKCh0aGlzLnRpbWUgKyB0aW1lU2luY2VMYXN0Q2FsbGVkKSAvIGR0KSAtIE1hdGguZmxvb3IodGhpcy50aW1lIC8gZHQpO1xuICAgICAgICBpbnRlcm5hbFN0ZXBzID0gTWF0aC5taW4oaW50ZXJuYWxTdGVwcyxtYXhTdWJTdGVwcyk7XG5cbiAgICAgICAgLy8gRG8gc29tZSBmaXhlZCBzdGVwcyB0byBjYXRjaCB1cFxuICAgICAgICB2YXIgdDAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkhPT1pbnRlcm5hbFN0ZXBzOyBpKyspe1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbFN0ZXAoZHQpO1xuICAgICAgICAgICAgaWYocGVyZm9ybWFuY2Uubm93KCkgLSB0MCA+IGR0ICogMTAwMCl7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIHNsb3dlciB0aGFuIHJlYWwtdGltZS4gQmV0dGVyIGJhaWwgb3V0LlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5jcmVtZW50IGludGVybmFsIGNsb2NrXG4gICAgICAgIHRoaXMudGltZSArPSB0aW1lU2luY2VMYXN0Q2FsbGVkO1xuXG4gICAgICAgIC8vIENvbXB1dGUgXCJMZWZ0IG92ZXJcIiB0aW1lIHN0ZXBcbiAgICAgICAgdmFyIGggPSB0aGlzLnRpbWUgJSBkdDtcbiAgICAgICAgdmFyIGhfZGl2X2R0ID0gaCAvIGR0O1xuICAgICAgICB2YXIgaW50ZXJwdmVsbyA9IHN0ZXBfdG1wMTtcbiAgICAgICAgdmFyIGJvZGllcyA9IHRoaXMuYm9kaWVzO1xuXG4gICAgICAgIGZvcih2YXIgaj0wOyBqICE9PSBib2RpZXMubGVuZ3RoOyBqKyspe1xuICAgICAgICAgICAgdmFyIGIgPSBib2RpZXNbal07XG4gICAgICAgICAgICBpZihiLnR5cGUgIT09IEJvZHkuU1RBVElDICYmIGIuc2xlZXBTdGF0ZSAhPT0gQm9keS5TTEVFUElORyl7XG5cbiAgICAgICAgICAgICAgICAvLyBJbnRlcnBvbGF0ZVxuICAgICAgICAgICAgICAgIGIucG9zaXRpb24udnN1YihiLnByZXZpb3VzUG9zaXRpb24sIGludGVycHZlbG8pO1xuICAgICAgICAgICAgICAgIGludGVycHZlbG8uc2NhbGUoaF9kaXZfZHQsIGludGVycHZlbG8pO1xuICAgICAgICAgICAgICAgIGIucG9zaXRpb24udmFkZChpbnRlcnB2ZWxvLCBiLmludGVycG9sYXRlZFBvc2l0aW9uKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGludGVycG9sYXRlIHF1YXRlcm5pb25cbiAgICAgICAgICAgICAgICAvLyBiLmludGVycG9sYXRlZEFuZ2xlID0gYi5hbmdsZSArIChiLmFuZ2xlIC0gYi5wcmV2aW91c0FuZ2xlKSAqIGhfZGl2X2R0O1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gRm9yIHN0YXRpYyBib2RpZXMsIGp1c3QgY29weS4gV2hvIGVsc2Ugd2lsbCBkbyBpdD9cbiAgICAgICAgICAgICAgICBiLmludGVycG9sYXRlZFBvc2l0aW9uLmNvcHkoYi5wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgYi5pbnRlcnBvbGF0ZWRRdWF0ZXJuaW9uLmNvcHkoYi5xdWF0ZXJuaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU3RlcCB0aGUgc2ltdWxhdGlvblxuICogQG1ldGhvZCBzdGVwXG4gKiBAcGFyYW0ge051bWJlcn0gZHRcbiAqL1xudmFyIFdvcmxkX3N0ZXBfcG9zdFN0ZXBFdmVudCA9IHt0eXBlOlwicG9zdFN0ZXBcIn0sIC8vIFJldXNhYmxlIGV2ZW50IG9iamVjdHMgdG8gc2F2ZSBtZW1vcnlcbiAgICBXb3JsZF9zdGVwX3ByZVN0ZXBFdmVudCA9IHt0eXBlOlwicHJlU3RlcFwifSxcbiAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudCA9IHt0eXBlOlwiY29sbGlkZVwiLCBib2R5Om51bGwsIGNvbnRhY3Q6bnVsbCB9LFxuICAgIFdvcmxkX3N0ZXBfb2xkQ29udGFjdHMgPSBbXSwgLy8gUG9vbHMgZm9yIHVudXNlZCBvYmplY3RzXG4gICAgV29ybGRfc3RlcF9mcmljdGlvbkVxdWF0aW9uUG9vbCA9IFtdLFxuICAgIFdvcmxkX3N0ZXBfcDEgPSBbXSwgLy8gUmV1c2FibGUgYXJyYXlzIGZvciBjb2xsaXNpb24gcGFpcnNcbiAgICBXb3JsZF9zdGVwX3AyID0gW10sXG4gICAgV29ybGRfc3RlcF9ndmVjID0gbmV3IFZlYzMoKSwgLy8gVGVtcG9yYXJ5IHZlY3RvcnMgYW5kIHF1YXRzXG4gICAgV29ybGRfc3RlcF92aSA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF92aiA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF93aSA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF93aiA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF90MSA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF90MiA9IG5ldyBWZWMzKCksXG4gICAgV29ybGRfc3RlcF9yaXhuID0gbmV3IFZlYzMoKSxcbiAgICBXb3JsZF9zdGVwX3JqeG4gPSBuZXcgVmVjMygpLFxuICAgIFdvcmxkX3N0ZXBfc3RlcF9xID0gbmV3IFF1YXRlcm5pb24oKSxcbiAgICBXb3JsZF9zdGVwX3N0ZXBfdyA9IG5ldyBRdWF0ZXJuaW9uKCksXG4gICAgV29ybGRfc3RlcF9zdGVwX3dxID0gbmV3IFF1YXRlcm5pb24oKSxcbiAgICBpbnZJX3RhdV9kdCA9IG5ldyBWZWMzKCk7XG5Xb3JsZC5wcm90b3R5cGUuaW50ZXJuYWxTdGVwID0gZnVuY3Rpb24oZHQpe1xuICAgIHRoaXMuZHQgPSBkdDtcblxuICAgIHZhciB3b3JsZCA9IHRoaXMsXG4gICAgICAgIHRoYXQgPSB0aGlzLFxuICAgICAgICBjb250YWN0cyA9IHRoaXMuY29udGFjdHMsXG4gICAgICAgIHAxID0gV29ybGRfc3RlcF9wMSxcbiAgICAgICAgcDIgPSBXb3JsZF9zdGVwX3AyLFxuICAgICAgICBOID0gdGhpcy5udW1PYmplY3RzKCksXG4gICAgICAgIGJvZGllcyA9IHRoaXMuYm9kaWVzLFxuICAgICAgICBzb2x2ZXIgPSB0aGlzLnNvbHZlcixcbiAgICAgICAgZ3Jhdml0eSA9IHRoaXMuZ3Jhdml0eSxcbiAgICAgICAgZG9Qcm9maWxpbmcgPSB0aGlzLmRvUHJvZmlsaW5nLFxuICAgICAgICBwcm9maWxlID0gdGhpcy5wcm9maWxlLFxuICAgICAgICBEWU5BTUlDID0gQm9keS5EWU5BTUlDLFxuICAgICAgICBwcm9maWxpbmdTdGFydCxcbiAgICAgICAgY29uc3RyYWludHMgPSB0aGlzLmNvbnN0cmFpbnRzLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbCA9IFdvcmxkX3N0ZXBfZnJpY3Rpb25FcXVhdGlvblBvb2wsXG4gICAgICAgIGdub3JtID0gZ3Jhdml0eS5ub3JtKCksXG4gICAgICAgIGd4ID0gZ3Jhdml0eS54LFxuICAgICAgICBneSA9IGdyYXZpdHkueSxcbiAgICAgICAgZ3ogPSBncmF2aXR5LnosXG4gICAgICAgIGk9MDtcblxuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgZ3Jhdml0eSB0byBhbGwgb2JqZWN0c1xuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJpLnR5cGUgJiBEWU5BTUlDKXsgLy8gT25seSBmb3IgZHluYW1pYyBib2RpZXNcbiAgICAgICAgICAgIHZhciBmID0gYmkuZm9yY2UsIG0gPSBiaS5tYXNzO1xuICAgICAgICAgICAgZi54ICs9IG0qZ3g7XG4gICAgICAgICAgICBmLnkgKz0gbSpneTtcbiAgICAgICAgICAgIGYueiArPSBtKmd6O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHN1YnN5c3RlbXNcbiAgICBmb3IodmFyIGk9MCwgTnN1YnN5c3RlbXM9dGhpcy5zdWJzeXN0ZW1zLmxlbmd0aDsgaSE9PU5zdWJzeXN0ZW1zOyBpKyspe1xuICAgICAgICB0aGlzLnN1YnN5c3RlbXNbaV0udXBkYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gQ29sbGlzaW9uIGRldGVjdGlvblxuICAgIGlmKGRvUHJvZmlsaW5nKXsgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgfVxuICAgIHAxLmxlbmd0aCA9IDA7IC8vIENsZWFuIHVwIHBhaXIgYXJyYXlzIGZyb20gbGFzdCBzdGVwXG4gICAgcDIubGVuZ3RoID0gMDtcbiAgICB0aGlzLmJyb2FkcGhhc2UuY29sbGlzaW9uUGFpcnModGhpcyxwMSxwMik7XG4gICAgaWYoZG9Qcm9maWxpbmcpeyBwcm9maWxlLmJyb2FkcGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0OyB9XG5cbiAgICAvLyBSZW1vdmUgY29uc3RyYWluZWQgcGFpcnMgd2l0aCBjb2xsaWRlQ29ubmVjdGVkID09IGZhbHNlXG4gICAgdmFyIE5jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzLmxlbmd0aDtcbiAgICBmb3IoaT0wOyBpIT09TmNvbnN0cmFpbnRzOyBpKyspe1xuICAgICAgICB2YXIgYyA9IGNvbnN0cmFpbnRzW2ldO1xuICAgICAgICBpZighYy5jb2xsaWRlQ29ubmVjdGVkKXtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IHAxLmxlbmd0aC0xOyBqPj0wOyBqLT0xKXtcbiAgICAgICAgICAgICAgICBpZiggKGMuYm9keUEgPT09IHAxW2pdICYmIGMuYm9keUIgPT09IHAyW2pdKSB8fFxuICAgICAgICAgICAgICAgICAgICAoYy5ib2R5QiA9PT0gcDFbal0gJiYgYy5ib2R5QSA9PT0gcDJbal0pKXtcbiAgICAgICAgICAgICAgICAgICAgcDEuc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgICAgICBwMi5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb2xsaXNpb25NYXRyaXhUaWNrKCk7XG5cbiAgICAvLyBHZW5lcmF0ZSBjb250YWN0c1xuICAgIGlmKGRvUHJvZmlsaW5nKXsgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTsgfVxuICAgIHZhciBvbGRjb250YWN0cyA9IFdvcmxkX3N0ZXBfb2xkQ29udGFjdHM7XG4gICAgdmFyIE5vbGRDb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcblxuICAgIGZvcihpPTA7IGkhPT1Ob2xkQ29udGFjdHM7IGkrKyl7XG4gICAgICAgIG9sZGNvbnRhY3RzLnB1c2goY29udGFjdHNbaV0pO1xuICAgIH1cbiAgICBjb250YWN0cy5sZW5ndGggPSAwO1xuXG4gICAgLy8gVHJhbnNmZXIgRnJpY3Rpb25FcXVhdGlvbiBmcm9tIGN1cnJlbnQgbGlzdCB0byB0aGUgcG9vbCBmb3IgcmV1c2VcbiAgICB2YXIgTm9sZEZyaWN0aW9uRXF1YXRpb25zID0gdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5vbGRGcmljdGlvbkVxdWF0aW9uczsgaSsrKXtcbiAgICAgICAgZnJpY3Rpb25FcXVhdGlvblBvb2wucHVzaCh0aGlzLmZyaWN0aW9uRXF1YXRpb25zW2ldKTtcbiAgICB9XG4gICAgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGggPSAwO1xuXG4gICAgdGhpcy5uYXJyb3dwaGFzZS5nZXRDb250YWN0cyhcbiAgICAgICAgcDEsXG4gICAgICAgIHAyLFxuICAgICAgICB0aGlzLFxuICAgICAgICBjb250YWN0cyxcbiAgICAgICAgb2xkY29udGFjdHMsIC8vIFRvIGJlIHJldXNlZFxuICAgICAgICB0aGlzLmZyaWN0aW9uRXF1YXRpb25zLFxuICAgICAgICBmcmljdGlvbkVxdWF0aW9uUG9vbFxuICAgICk7XG5cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGUubmFycm93cGhhc2UgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHByb2ZpbGluZ1N0YXJ0O1xuICAgIH1cblxuICAgIC8vIExvb3Agb3ZlciBhbGwgY29sbGlzaW9uc1xuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGZyaWN0aW9uIGVxc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcmljdGlvbkVxdWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzb2x2ZXIuYWRkRXF1YXRpb24odGhpcy5mcmljdGlvbkVxdWF0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIG5jb250YWN0cyA9IGNvbnRhY3RzLmxlbmd0aDtcbiAgICBmb3IodmFyIGs9MDsgayE9PW5jb250YWN0czsgaysrKXtcblxuICAgICAgICAvLyBDdXJyZW50IGNvbnRhY3RcbiAgICAgICAgdmFyIGMgPSBjb250YWN0c1trXTtcblxuICAgICAgICAvLyBHZXQgY3VycmVudCBjb2xsaXNpb24gaW5kZWNlc1xuICAgICAgICB2YXIgYmkgPSBjLmJpLFxuICAgICAgICAgICAgYmogPSBjLmJqLFxuICAgICAgICAgICAgc2kgPSBjLnNpLFxuICAgICAgICAgICAgc2ogPSBjLnNqO1xuXG4gICAgICAgIC8vIEdldCBjb2xsaXNpb24gcHJvcGVydGllc1xuICAgICAgICB2YXIgY207XG4gICAgICAgIGlmKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgIGNtID0gdGhpcy5nZXRDb250YWN0TWF0ZXJpYWwoYmkubWF0ZXJpYWwsYmoubWF0ZXJpYWwpIHx8IHRoaXMuZGVmYXVsdENvbnRhY3RNYXRlcmlhbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNtID0gdGhpcy5kZWZhdWx0Q29udGFjdE1hdGVyaWFsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYy5lbmFibGVkID0gYmkuY29sbGlzaW9uUmVzcG9uc2UgJiYgYmouY29sbGlzaW9uUmVzcG9uc2UgJiYgc2kuY29sbGlzaW9uUmVzcG9uc2UgJiYgc2ouY29sbGlzaW9uUmVzcG9uc2U7XG5cbiAgICAgICAgdmFyIG11ID0gY20uZnJpY3Rpb247XG4gICAgICAgIC8vIGMucmVzdGl0dXRpb24gPSBjbS5yZXN0aXR1dGlvbjtcblxuICAgICAgICAvLyBJZiBmcmljdGlvbiBvciByZXN0aXR1dGlvbiB3ZXJlIHNwZWNpZmllZCBpbiB0aGUgbWF0ZXJpYWwsIHVzZSB0aGVtXG4gICAgICAgIGlmKGJpLm1hdGVyaWFsICYmIGJqLm1hdGVyaWFsKXtcbiAgICAgICAgICAgIGlmKGJpLm1hdGVyaWFsLmZyaWN0aW9uID49IDAgJiYgYmoubWF0ZXJpYWwuZnJpY3Rpb24gPj0gMCl7XG4gICAgICAgICAgICAgICAgbXUgPSBiaS5tYXRlcmlhbC5mcmljdGlvbiAqIGJqLm1hdGVyaWFsLmZyaWN0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZihiaS5tYXRlcmlhbC5yZXN0aXR1dGlvbiA+PSAwICYmIGJqLm1hdGVyaWFsLnJlc3RpdHV0aW9uID49IDApe1xuICAgICAgICAgICAgICAgIGMucmVzdGl0dXRpb24gPSBiaS5tYXRlcmlhbC5yZXN0aXR1dGlvbiAqIGJqLm1hdGVyaWFsLnJlc3RpdHV0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblx0XHQvLyBjLnNldFNwb29rUGFyYW1zKFxuICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uU3RpZmZuZXNzLFxuICAvLyAgICAgICAgICAgY20uY29udGFjdEVxdWF0aW9uUmVsYXhhdGlvbixcbiAgLy8gICAgICAgICAgIGR0XG4gIC8vICAgICAgICk7XG5cblx0XHRzb2x2ZXIuYWRkRXF1YXRpb24oYyk7XG5cblx0XHQvLyAvLyBBZGQgZnJpY3Rpb24gY29uc3RyYWludCBlcXVhdGlvblxuXHRcdC8vIGlmKG11ID4gMCl7XG5cblx0XHQvLyBcdC8vIENyZWF0ZSAyIHRhbmdlbnQgZXF1YXRpb25zXG5cdFx0Ly8gXHR2YXIgbXVnID0gbXUgKiBnbm9ybTtcblx0XHQvLyBcdHZhciByZWR1Y2VkTWFzcyA9IChiaS5pbnZNYXNzICsgYmouaW52TWFzcyk7XG5cdFx0Ly8gXHRpZihyZWR1Y2VkTWFzcyA+IDApe1xuXHRcdC8vIFx0XHRyZWR1Y2VkTWFzcyA9IDEvcmVkdWNlZE1hc3M7XG5cdFx0Ly8gXHR9XG5cdFx0Ly8gXHR2YXIgcG9vbCA9IGZyaWN0aW9uRXF1YXRpb25Qb29sO1xuXHRcdC8vIFx0dmFyIGMxID0gcG9vbC5sZW5ndGggPyBwb29sLnBvcCgpIDogbmV3IEZyaWN0aW9uRXF1YXRpb24oYmksYmosbXVnKnJlZHVjZWRNYXNzKTtcblx0XHQvLyBcdHZhciBjMiA9IHBvb2wubGVuZ3RoID8gcG9vbC5wb3AoKSA6IG5ldyBGcmljdGlvbkVxdWF0aW9uKGJpLGJqLG11ZypyZWR1Y2VkTWFzcyk7XG5cdFx0Ly8gXHR0aGlzLmZyaWN0aW9uRXF1YXRpb25zLnB1c2goYzEsIGMyKTtcblxuXHRcdC8vIFx0YzEuYmkgPSBjMi5iaSA9IGJpO1xuXHRcdC8vIFx0YzEuYmogPSBjMi5iaiA9IGJqO1xuXHRcdC8vIFx0YzEubWluRm9yY2UgPSBjMi5taW5Gb3JjZSA9IC1tdWcqcmVkdWNlZE1hc3M7XG5cdFx0Ly8gXHRjMS5tYXhGb3JjZSA9IGMyLm1heEZvcmNlID0gbXVnKnJlZHVjZWRNYXNzO1xuXG5cdFx0Ly8gXHQvLyBDb3B5IG92ZXIgdGhlIHJlbGF0aXZlIHZlY3RvcnNcblx0XHQvLyBcdGMxLnJpLmNvcHkoYy5yaSk7XG5cdFx0Ly8gXHRjMS5yai5jb3B5KGMucmopO1xuXHRcdC8vIFx0YzIucmkuY29weShjLnJpKTtcblx0XHQvLyBcdGMyLnJqLmNvcHkoYy5yaik7XG5cblx0XHQvLyBcdC8vIENvbnN0cnVjdCB0YW5nZW50c1xuXHRcdC8vIFx0Yy5uaS50YW5nZW50cyhjMS50LCBjMi50KTtcblxuICAvLyAgICAgICAgICAgLy8gU2V0IHNwb29rIHBhcmFtc1xuICAvLyAgICAgICAgICAgYzEuc2V0U3Bvb2tQYXJhbXMoY20uZnJpY3Rpb25FcXVhdGlvblN0aWZmbmVzcywgY20uZnJpY3Rpb25FcXVhdGlvblJlbGF4YXRpb24sIGR0KTtcbiAgLy8gICAgICAgICAgIGMyLnNldFNwb29rUGFyYW1zKGNtLmZyaWN0aW9uRXF1YXRpb25TdGlmZm5lc3MsIGNtLmZyaWN0aW9uRXF1YXRpb25SZWxheGF0aW9uLCBkdCk7XG5cbiAgLy8gICAgICAgICAgIGMxLmVuYWJsZWQgPSBjMi5lbmFibGVkID0gYy5lbmFibGVkO1xuXG5cdFx0Ly8gXHQvLyBBZGQgZXF1YXRpb25zIHRvIHNvbHZlclxuXHRcdC8vIFx0c29sdmVyLmFkZEVxdWF0aW9uKGMxKTtcblx0XHQvLyBcdHNvbHZlci5hZGRFcXVhdGlvbihjMik7XG5cdFx0Ly8gfVxuXG4gICAgICAgIGlmKCBiaS5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICBiaS50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgIGJpLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICBiai5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgYmoudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgKXtcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRCID0gYmoudmVsb2NpdHkubm9ybTIoKSArIGJqLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQiA9IE1hdGgucG93KGJqLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEIgPj0gc3BlZWRMaW1pdFNxdWFyZWRCKjIpe1xuICAgICAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBiai5hbGxvd1NsZWVwICYmXG4gICAgICAgICAgICBiai50eXBlID09PSBCb2R5LkRZTkFNSUMgJiZcbiAgICAgICAgICAgIGJqLnNsZWVwU3RhdGUgID09PSBCb2R5LlNMRUVQSU5HICYmXG4gICAgICAgICAgICBiaS5zbGVlcFN0YXRlICA9PT0gQm9keS5BV0FLRSAmJlxuICAgICAgICAgICAgYmkudHlwZSAhPT0gQm9keS5TVEFUSUNcbiAgICAgICAgKXtcbiAgICAgICAgICAgIHZhciBzcGVlZFNxdWFyZWRBID0gYmkudmVsb2NpdHkubm9ybTIoKSArIGJpLmFuZ3VsYXJWZWxvY2l0eS5ub3JtMigpO1xuICAgICAgICAgICAgdmFyIHNwZWVkTGltaXRTcXVhcmVkQSA9IE1hdGgucG93KGJpLnNsZWVwU3BlZWRMaW1pdCwyKTtcbiAgICAgICAgICAgIGlmKHNwZWVkU3F1YXJlZEEgPj0gc3BlZWRMaW1pdFNxdWFyZWRBKjIpe1xuICAgICAgICAgICAgICAgIGJqLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IHRoYXQgaSBhbmQgaiBhcmUgaW4gY29udGFjdC4gU2V0IGNvbGxpc2lvbiBtYXRyaXggc3RhdGVcblx0XHR0aGlzLmNvbGxpc2lvbk1hdHJpeC5zZXQoYmksIGJqLCB0cnVlKTtcblxuICAgICAgICBpZiAoIXRoaXMuY29sbGlzaW9uTWF0cml4UHJldmlvdXMuZ2V0KGJpLCBiaikpIHtcbiAgICAgICAgICAgIC8vIEZpcnN0IGNvbnRhY3QhXG4gICAgICAgICAgICAvLyBXZSByZXVzZSB0aGUgY29sbGlkZUV2ZW50IG9iamVjdCwgb3RoZXJ3aXNlIHdlIHdpbGwgZW5kIHVwIGNyZWF0aW5nIG5ldyBvYmplY3RzIGZvciBlYWNoIG5ldyBjb250YWN0LCBldmVuIGlmIHRoZXJlJ3Mgbm8gZXZlbnQgbGlzdGVuZXIgYXR0YWNoZWQuXG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5ib2R5ID0gYmo7XG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5jb250YWN0ID0gYztcbiAgICAgICAgICAgIGJpLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9jb2xsaWRlRXZlbnQpO1xuXG4gICAgICAgICAgICBXb3JsZF9zdGVwX2NvbGxpZGVFdmVudC5ib2R5ID0gYmk7XG4gICAgICAgICAgICBiai5kaXNwYXRjaEV2ZW50KFdvcmxkX3N0ZXBfY29sbGlkZUV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZihkb1Byb2ZpbGluZyl7XG4gICAgICAgIHByb2ZpbGUubWFrZUNvbnRhY3RDb25zdHJhaW50cyA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgICAgIHByb2ZpbGluZ1N0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuXG4gICAgLy8gV2FrZSB1cCBib2RpZXNcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS5fd2FrZVVwQWZ0ZXJOYXJyb3dwaGFzZSl7XG4gICAgICAgICAgICBiaS53YWtlVXAoKTtcbiAgICAgICAgICAgIGJpLl93YWtlVXBBZnRlck5hcnJvd3BoYXNlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgdXNlci1hZGRlZCBjb25zdHJhaW50c1xuICAgIHZhciBOY29uc3RyYWludHMgPSBjb25zdHJhaW50cy5sZW5ndGg7XG4gICAgZm9yKGk9MDsgaSE9PU5jb25zdHJhaW50czsgaSsrKXtcbiAgICAgICAgdmFyIGMgPSBjb25zdHJhaW50c1tpXTtcbiAgICAgICAgYy51cGRhdGUoKTtcbiAgICAgICAgZm9yKHZhciBqPTAsIE5lcT1jLmVxdWF0aW9ucy5sZW5ndGg7IGohPT1OZXE7IGorKyl7XG4gICAgICAgICAgICB2YXIgZXEgPSBjLmVxdWF0aW9uc1tqXTtcbiAgICAgICAgICAgIHNvbHZlci5hZGRFcXVhdGlvbihlcSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb2x2ZSB0aGUgY29uc3RyYWluZWQgc3lzdGVtXG4gICAgc29sdmVyLnNvbHZlKGR0LHRoaXMpO1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICBwcm9maWxlLnNvbHZlID0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcm9maWxpbmdTdGFydDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgYWxsIGNvbnRhY3RzIGZyb20gc29sdmVyXG4gICAgc29sdmVyLnJlbW92ZUFsbEVxdWF0aW9ucygpO1xuXG4gICAgLy8gQXBwbHkgZGFtcGluZywgc2VlIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9idWxsZXQvaXNzdWVzL2RldGFpbD9pZD03NCBmb3IgZGV0YWlsc1xuICAgIHZhciBwb3cgPSBNYXRoLnBvdztcbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGJpID0gYm9kaWVzW2ldO1xuICAgICAgICBpZihiaS50eXBlICYgRFlOQU1JQyl7IC8vIE9ubHkgZm9yIGR5bmFtaWMgYm9kaWVzXG4gICAgICAgICAgICB2YXIgbGQgPSBwb3coMS4wIC0gYmkubGluZWFyRGFtcGluZyxkdCk7XG4gICAgICAgICAgICB2YXIgdiA9IGJpLnZlbG9jaXR5O1xuICAgICAgICAgICAgdi5tdWx0KGxkLHYpO1xuICAgICAgICAgICAgdmFyIGF2ID0gYmkuYW5ndWxhclZlbG9jaXR5O1xuICAgICAgICAgICAgaWYoYXYpe1xuICAgICAgICAgICAgICAgIHZhciBhZCA9IHBvdygxLjAgLSBiaS5hbmd1bGFyRGFtcGluZyxkdCk7XG4gICAgICAgICAgICAgICAgYXYubXVsdChhZCxhdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wcmVTdGVwRXZlbnQpO1xuXG4gICAgLy8gSW52b2tlIHByZS1zdGVwIGNhbGxiYWNrc1xuICAgIGZvcihpPTA7IGkhPT1OOyBpKyspe1xuICAgICAgICB2YXIgYmkgPSBib2RpZXNbaV07XG4gICAgICAgIGlmKGJpLnByZVN0ZXApe1xuICAgICAgICAgICAgYmkucHJlU3RlcC5jYWxsKGJpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIExlYXAgZnJvZ1xuICAgIC8vIHZuZXcgPSB2ICsgaCpmL21cbiAgICAvLyB4bmV3ID0geCArIGgqdm5ld1xuICAgIGlmKGRvUHJvZmlsaW5nKXtcbiAgICAgICAgcHJvZmlsaW5nU3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgdmFyIHEgPSBXb3JsZF9zdGVwX3N0ZXBfcTtcbiAgICB2YXIgdyA9IFdvcmxkX3N0ZXBfc3RlcF93O1xuICAgIHZhciB3cSA9IFdvcmxkX3N0ZXBfc3RlcF93cTtcbiAgICB2YXIgc3RlcG51bWJlciA9IHRoaXMuc3RlcG51bWJlcjtcbiAgICB2YXIgRFlOQU1JQ19PUl9LSU5FTUFUSUMgPSBCb2R5LkRZTkFNSUMgfCBCb2R5LktJTkVNQVRJQztcbiAgICB2YXIgcXVhdE5vcm1hbGl6ZSA9IHN0ZXBudW1iZXIgJSAodGhpcy5xdWF0Tm9ybWFsaXplU2tpcCsxKSA9PT0gMDtcbiAgICB2YXIgcXVhdE5vcm1hbGl6ZUZhc3QgPSB0aGlzLnF1YXROb3JtYWxpemVGYXN0O1xuICAgIHZhciBoYWxmX2R0ID0gZHQgKiAwLjU7XG4gICAgdmFyIFBMQU5FID0gU2hhcGUudHlwZXMuUExBTkUsXG4gICAgICAgIENPTlZFWCA9IFNoYXBlLnR5cGVzLkNPTlZFWFBPTFlIRURST047XG5cbiAgICBmb3IoaT0wOyBpIT09TjsgaSsrKXtcbiAgICAgICAgdmFyIGIgPSBib2RpZXNbaV0sXG4gICAgICAgICAgICBmb3JjZSA9IGIuZm9yY2UsXG4gICAgICAgICAgICB0YXUgPSBiLnRvcnF1ZTtcbiAgICAgICAgaWYoKGIudHlwZSAmIERZTkFNSUNfT1JfS0lORU1BVElDKSAmJiBiLnNsZWVwU3RhdGUgIT09IEJvZHkuU0xFRVBJTkcpeyAvLyBPbmx5IGZvciBkeW5hbWljXG4gICAgICAgICAgICB2YXIgdmVsbyA9IGIudmVsb2NpdHksXG4gICAgICAgICAgICAgICAgYW5ndWxhclZlbG8gPSBiLmFuZ3VsYXJWZWxvY2l0eSxcbiAgICAgICAgICAgICAgICBwb3MgPSBiLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHF1YXQgPSBiLnF1YXRlcm5pb24sXG4gICAgICAgICAgICAgICAgaW52TWFzcyA9IGIuaW52TWFzcyxcbiAgICAgICAgICAgICAgICBpbnZJbmVydGlhID0gYi5pbnZJbmVydGlhV29ybGQ7XG5cbiAgICAgICAgICAgIHZlbG8ueCArPSBmb3JjZS54ICogaW52TWFzcyAqIGR0O1xuICAgICAgICAgICAgdmVsby55ICs9IGZvcmNlLnkgKiBpbnZNYXNzICogZHQ7XG4gICAgICAgICAgICB2ZWxvLnogKz0gZm9yY2UueiAqIGludk1hc3MgKiBkdDtcblxuICAgICAgICAgICAgaWYoYi5hbmd1bGFyVmVsb2NpdHkpe1xuICAgICAgICAgICAgICAgIGludkluZXJ0aWEudm11bHQodGF1LGludklfdGF1X2R0KTtcbiAgICAgICAgICAgICAgICBpbnZJX3RhdV9kdC5tdWx0KGR0LGludklfdGF1X2R0KTtcbiAgICAgICAgICAgICAgICBpbnZJX3RhdV9kdC52YWRkKGFuZ3VsYXJWZWxvLGFuZ3VsYXJWZWxvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIG5ldyB2ZWxvY2l0eSAgLSBsZWFwIGZyb2dcbiAgICAgICAgICAgIHBvcy54ICs9IHZlbG8ueCAqIGR0O1xuICAgICAgICAgICAgcG9zLnkgKz0gdmVsby55ICogZHQ7XG4gICAgICAgICAgICBwb3MueiArPSB2ZWxvLnogKiBkdDtcblxuICAgICAgICAgICAgaWYoYi5hbmd1bGFyVmVsb2NpdHkpe1xuICAgICAgICAgICAgICAgIHcuc2V0KGFuZ3VsYXJWZWxvLngsIGFuZ3VsYXJWZWxvLnksIGFuZ3VsYXJWZWxvLnosIDApO1xuICAgICAgICAgICAgICAgIHcubXVsdChxdWF0LHdxKTtcbiAgICAgICAgICAgICAgICBxdWF0LnggKz0gaGFsZl9kdCAqIHdxLng7XG4gICAgICAgICAgICAgICAgcXVhdC55ICs9IGhhbGZfZHQgKiB3cS55O1xuICAgICAgICAgICAgICAgIHF1YXQueiArPSBoYWxmX2R0ICogd3EuejtcbiAgICAgICAgICAgICAgICBxdWF0LncgKz0gaGFsZl9kdCAqIHdxLnc7XG4gICAgICAgICAgICAgICAgaWYocXVhdE5vcm1hbGl6ZSl7XG4gICAgICAgICAgICAgICAgICAgIGlmKHF1YXROb3JtYWxpemVGYXN0KXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1YXQubm9ybWFsaXplRmFzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcXVhdC5ub3JtYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoYi5hYWJiKXtcbiAgICAgICAgICAgICAgICBiLmFhYmJOZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB3b3JsZCBpbmVydGlhXG4gICAgICAgICAgICBpZihiLnVwZGF0ZUluZXJ0aWFXb3JsZCl7XG4gICAgICAgICAgICAgICAgYi51cGRhdGVJbmVydGlhV29ybGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNsZWFyRm9yY2VzKCk7XG5cbiAgICB0aGlzLmJyb2FkcGhhc2UuZGlydHkgPSB0cnVlO1xuXG4gICAgaWYoZG9Qcm9maWxpbmcpe1xuICAgICAgICBwcm9maWxlLmludGVncmF0ZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gcHJvZmlsaW5nU3RhcnQ7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHdvcmxkIHRpbWVcbiAgICB0aGlzLnRpbWUgKz0gZHQ7XG4gICAgdGhpcy5zdGVwbnVtYmVyICs9IDE7XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoV29ybGRfc3RlcF9wb3N0U3RlcEV2ZW50KTtcblxuICAgIC8vIEludm9rZSBwb3N0LXN0ZXAgY2FsbGJhY2tzXG4gICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgIHZhciBiaSA9IGJvZGllc1tpXTtcbiAgICAgICAgdmFyIHBvc3RTdGVwID0gYmkucG9zdFN0ZXA7XG4gICAgICAgIGlmKHBvc3RTdGVwKXtcbiAgICAgICAgICAgIHBvc3RTdGVwLmNhbGwoYmkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2xlZXBpbmcgdXBkYXRlXG4gICAgaWYodGhpcy5hbGxvd1NsZWVwKXtcbiAgICAgICAgZm9yKGk9MDsgaSE9PU47IGkrKyl7XG4gICAgICAgICAgICBib2RpZXNbaV0uc2xlZXBUaWNrKHRoaXMudGltZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFNldHMgYWxsIGJvZHkgZm9yY2VzIGluIHRoZSB3b3JsZCB0byB6ZXJvLlxuICogQG1ldGhvZCBjbGVhckZvcmNlc1xuICovXG5Xb3JsZC5wcm90b3R5cGUuY2xlYXJGb3JjZXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBib2RpZXMgPSB0aGlzLmJvZGllcztcbiAgICB2YXIgTiA9IGJvZGllcy5sZW5ndGg7XG4gICAgZm9yKHZhciBpPTA7IGkgIT09IE47IGkrKyl7XG4gICAgICAgIHZhciBiID0gYm9kaWVzW2ldLFxuICAgICAgICAgICAgZm9yY2UgPSBiLmZvcmNlLFxuICAgICAgICAgICAgdGF1ID0gYi50b3JxdWU7XG5cbiAgICAgICAgYi5mb3JjZS5zZXQoMCwwLDApO1xuICAgICAgICBiLnRvcnF1ZS5zZXQoMCwwLDApO1xuICAgIH1cbn07XG5cbn0se1wiLi4vY29sbGlzaW9uL0FBQkJcIjozLFwiLi4vY29sbGlzaW9uL0FycmF5Q29sbGlzaW9uTWF0cml4XCI6NCxcIi4uL2NvbGxpc2lvbi9OYWl2ZUJyb2FkcGhhc2VcIjo3LFwiLi4vY29sbGlzaW9uL1JheVwiOjksXCIuLi9jb2xsaXNpb24vUmF5Y2FzdFJlc3VsdFwiOjEwLFwiLi4vZXF1YXRpb25zL0NvbnRhY3RFcXVhdGlvblwiOjE5LFwiLi4vZXF1YXRpb25zL0ZyaWN0aW9uRXF1YXRpb25cIjoyMSxcIi4uL21hdGVyaWFsL0NvbnRhY3RNYXRlcmlhbFwiOjI0LFwiLi4vbWF0ZXJpYWwvTWF0ZXJpYWxcIjoyNSxcIi4uL21hdGgvUXVhdGVybmlvblwiOjI4LFwiLi4vbWF0aC9WZWMzXCI6MzAsXCIuLi9vYmplY3RzL0JvZHlcIjozMSxcIi4uL3NoYXBlcy9TaGFwZVwiOjQzLFwiLi4vc29sdmVyL0dTU29sdmVyXCI6NDYsXCIuLi91dGlscy9FdmVudFRhcmdldFwiOjQ5LFwiLi4vdXRpbHMvVHVwbGVEaWN0aW9uYXJ5XCI6NTIsXCIuLi91dGlscy9WZWMzUG9vbFwiOjU0LFwiLi9OYXJyb3dwaGFzZVwiOjU1fV19LHt9LFsyXSlcbigyKVxufSk7IiwibW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgcGFyc2U6IGZ1bmN0aW9uIChjbWQpIHtcclxuICAgIGxldCB3b3JkcyA9IGNtZC5zcGxpdChcIiBcIilcclxuICAgIGxldCBhcmdzID0gW11cclxuICAgIGZvciAobGV0IHdvcmQgb2Ygd29yZHMpIHtcclxuICAgICAgaWYgKHdvcmQpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgYXJncy5wdXNoKEpTT04ucGFyc2Uod29yZCkpXHJcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgIGlmICh3b3JkICE9PSBcIj1cIilcclxuICAgICAgICAgICAgYXJncy5wdXNoKHdvcmQpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJnc1xyXG4gIH0sXHJcbiAgc3RyaW5naWZ5UGFyYW06IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpLnJlcGxhY2VBbGwoXCIgXCIsIFwiXFxcXHUwMDIwXCIpLnJlcGxhY2VBbGwoXCJcXFwiX1wiLCBcIlxcXCJcIilcclxuICB9XHJcbn0iXX0=
